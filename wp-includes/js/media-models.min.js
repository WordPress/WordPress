!function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{enumerable:!0,get:d})},b.r=function(a){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},b.t=function(a,c){if(1&c&&(a=b(a)),8&c)return a;if(4&c&&"object"==typeof a&&a&&a.__esModule)return a;var d=Object.create(null);if(b.r(d),Object.defineProperty(d,"default",{enumerable:!0,value:a}),2&c&&"string"!=typeof a)for(var e in a)b.d(d,e,function(b){return a[b]}.bind(null,e));return d},b.n=function(a){var c=a&&a.__esModule?function(){return a["default"]}:function(){return a};return b.d(c,"a",c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p="",b(b.s=2)}({"./src/js/_enqueues/wp/media/models.js":function(module,exports,__webpack_require__){eval("/**\n * @output wp-includes/js/media-models.js\n */\n\nvar $ = jQuery,\n\tAttachment, Attachments, l10n, media;\n\n/** @namespace wp */\nwindow.wp = window.wp || {};\n\n/**\n * Create and return a media frame.\n *\n * Handles the default media experience.\n *\n * @alias wp.media\n * @memberOf wp\n * @namespace\n *\n * @param  {object} attributes The properties passed to the main media controller.\n * @return {wp.media.view.MediaFrame} A media workflow.\n */\nmedia = wp.media = function( attributes ) {\n\tvar MediaFrame = media.view.MediaFrame,\n\t\tframe;\n\n\tif ( ! MediaFrame ) {\n\t\treturn;\n\t}\n\n\tattributes = _.defaults( attributes || {}, {\n\t\tframe: 'select'\n\t});\n\n\tif ( 'select' === attributes.frame && MediaFrame.Select ) {\n\t\tframe = new MediaFrame.Select( attributes );\n\t} else if ( 'post' === attributes.frame && MediaFrame.Post ) {\n\t\tframe = new MediaFrame.Post( attributes );\n\t} else if ( 'manage' === attributes.frame && MediaFrame.Manage ) {\n\t\tframe = new MediaFrame.Manage( attributes );\n\t} else if ( 'image' === attributes.frame && MediaFrame.ImageDetails ) {\n\t\tframe = new MediaFrame.ImageDetails( attributes );\n\t} else if ( 'audio' === attributes.frame && MediaFrame.AudioDetails ) {\n\t\tframe = new MediaFrame.AudioDetails( attributes );\n\t} else if ( 'video' === attributes.frame && MediaFrame.VideoDetails ) {\n\t\tframe = new MediaFrame.VideoDetails( attributes );\n\t} else if ( 'edit-attachments' === attributes.frame && MediaFrame.EditAttachments ) {\n\t\tframe = new MediaFrame.EditAttachments( attributes );\n\t}\n\n\tdelete attributes.frame;\n\n\tmedia.frame = frame;\n\n\treturn frame;\n};\n\n/** @namespace wp.media.model */\n/** @namespace wp.media.view */\n/** @namespace wp.media.controller */\n/** @namespace wp.media.frames */\n_.extend( media, { model: {}, view: {}, controller: {}, frames: {} });\n\n// Link any localized strings.\nl10n = media.model.l10n = window._wpMediaModelsL10n || {};\n\n// Link any settings.\nmedia.model.settings = l10n.settings || {};\ndelete l10n.settings;\n\nAttachment = media.model.Attachment = __webpack_require__( /*! ../../../media/models/attachment.js */ \"./src/js/media/models/attachment.js\" );\nAttachments = media.model.Attachments = __webpack_require__( /*! ../../../media/models/attachments.js */ \"./src/js/media/models/attachments.js\" );\n\nmedia.model.Query = __webpack_require__( /*! ../../../media/models/query.js */ \"./src/js/media/models/query.js\" );\nmedia.model.PostImage = __webpack_require__( /*! ../../../media/models/post-image.js */ \"./src/js/media/models/post-image.js\" );\nmedia.model.Selection = __webpack_require__( /*! ../../../media/models/selection.js */ \"./src/js/media/models/selection.js\" );\n\n/**\n * ========================================================================\n * UTILITIES\n * ========================================================================\n */\n\n/**\n * A basic equality comparator for Backbone models.\n *\n * Used to order models within a collection - @see wp.media.model.Attachments.comparator().\n *\n * @param  {mixed}  a  The primary parameter to compare.\n * @param  {mixed}  b  The primary parameter to compare.\n * @param  {string} ac The fallback parameter to compare, a's cid.\n * @param  {string} bc The fallback parameter to compare, b's cid.\n * @return {number}    -1: a should come before b.\n *                      0: a and b are of the same rank.\n *                      1: b should come before a.\n */\nmedia.compare = function( a, b, ac, bc ) {\n\tif ( _.isEqual( a, b ) ) {\n\t\treturn ac === bc ? 0 : (ac > bc ? -1 : 1);\n\t} else {\n\t\treturn a > b ? -1 : 1;\n\t}\n};\n\n_.extend( media, /** @lends wp.media */{\n\t/**\n\t * media.template( id )\n\t *\n\t * Fetch a JavaScript template for an id, and return a templating function for it.\n\t *\n\t * See wp.template() in `wp-includes/js/wp-util.js`.\n\t *\n\t * @borrows wp.template as template\n\t */\n\ttemplate: wp.template,\n\n\t/**\n\t * media.post( [action], [data] )\n\t *\n\t * Sends a POST request to WordPress.\n\t * See wp.ajax.post() in `wp-includes/js/wp-util.js`.\n\t *\n\t * @borrows wp.ajax.post as post\n\t */\n\tpost: wp.ajax.post,\n\n\t/**\n\t * media.ajax( [action], [options] )\n\t *\n\t * Sends an XHR request to WordPress.\n\t * See wp.ajax.send() in `wp-includes/js/wp-util.js`.\n\t *\n\t * @borrows wp.ajax.send as ajax\n\t */\n\tajax: wp.ajax.send,\n\n\t/**\n\t * Scales a set of dimensions to fit within bounding dimensions.\n\t *\n\t * @param {Object} dimensions\n\t * @returns {Object}\n\t */\n\tfit: function( dimensions ) {\n\t\tvar width     = dimensions.width,\n\t\t\theight    = dimensions.height,\n\t\t\tmaxWidth  = dimensions.maxWidth,\n\t\t\tmaxHeight = dimensions.maxHeight,\n\t\t\tconstraint;\n\n\t\t// Compare ratios between the two values to determine which\n\t\t// max to constrain by. If a max value doesn't exist, then the\n\t\t// opposite side is the constraint.\n\t\tif ( ! _.isUndefined( maxWidth ) && ! _.isUndefined( maxHeight ) ) {\n\t\t\tconstraint = ( width / height > maxWidth / maxHeight ) ? 'width' : 'height';\n\t\t} else if ( _.isUndefined( maxHeight ) ) {\n\t\t\tconstraint = 'width';\n\t\t} else if (  _.isUndefined( maxWidth ) && height > maxHeight ) {\n\t\t\tconstraint = 'height';\n\t\t}\n\n\t\t// If the value of the constrained side is larger than the max,\n\t\t// then scale the values. Otherwise return the originals; they fit.\n\t\tif ( 'width' === constraint && width > maxWidth ) {\n\t\t\treturn {\n\t\t\t\twidth : maxWidth,\n\t\t\t\theight: Math.round( maxWidth * height / width )\n\t\t\t};\n\t\t} else if ( 'height' === constraint && height > maxHeight ) {\n\t\t\treturn {\n\t\t\t\twidth : Math.round( maxHeight * width / height ),\n\t\t\t\theight: maxHeight\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\twidth : width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t}\n\t},\n\t/**\n\t * Truncates a string by injecting an ellipsis into the middle.\n\t * Useful for filenames.\n\t *\n\t * @param {String} string\n\t * @param {Number} [length=30]\n\t * @param {String} [replacement=&hellip;]\n\t * @returns {String} The string, unless length is greater than string.length.\n\t */\n\ttruncate: function( string, length, replacement ) {\n\t\tlength = length || 30;\n\t\treplacement = replacement || '&hellip;';\n\n\t\tif ( string.length <= length ) {\n\t\t\treturn string;\n\t\t}\n\n\t\treturn string.substr( 0, length / 2 ) + replacement + string.substr( -1 * length / 2 );\n\t}\n});\n\n/**\n * ========================================================================\n * MODELS\n * ========================================================================\n */\n/**\n * wp.media.attachment\n *\n * @static\n * @param {String} id A string used to identify a model.\n * @returns {wp.media.model.Attachment}\n */\nmedia.attachment = function( id ) {\n\treturn Attachment.get( id );\n};\n\n/**\n * A collection of all attachments that have been fetched from the server.\n *\n * @static\n * @member {wp.media.model.Attachments}\n */\nAttachments.all = new Attachments();\n\n/**\n * wp.media.query\n *\n * Shorthand for creating a new Attachments Query.\n *\n * @param {object} [props]\n * @returns {wp.media.model.Attachments}\n */\nmedia.query = function( props ) {\n\treturn new Attachments( null, {\n\t\tprops: _.extend( _.defaults( props || {}, { orderby: 'date' } ), { query: true } )\n\t});\n};\n\n// Clean up. Prevents mobile browsers caching\n$(window).on('unload', function(){\n\twindow.wp = null;\n});\n\n\n//# sourceURL=webpack:///./src/js/_enqueues/wp/media/models.js?")},"./src/js/media/models/attachment.js":function(module,exports){eval("var $ = Backbone.$,\n\tAttachment;\n\n/**\n * wp.media.model.Attachment\n *\n * @memberOf wp.media.model\n *\n * @class\n * @augments Backbone.Model\n */\nAttachment = Backbone.Model.extend(/** @lends wp.media.model.Attachment.prototype */{\n\t/**\n\t * Triggered when attachment details change\n\t * Overrides Backbone.Model.sync\n\t *\n\t * @param {string} method\n\t * @param {wp.media.model.Attachment} model\n\t * @param {Object} [options={}]\n\t *\n\t * @returns {Promise}\n\t */\n\tsync: function( method, model, options ) {\n\t\t// If the attachment does not yet have an `id`, return an instantly\n\t\t// rejected promise. Otherwise, all of our requests will fail.\n\t\tif ( _.isUndefined( this.id ) ) {\n\t\t\treturn $.Deferred().rejectWith( this ).promise();\n\t\t}\n\n\t\t// Overload the `read` request so Attachment.fetch() functions correctly.\n\t\tif ( 'read' === method ) {\n\t\t\toptions = options || {};\n\t\t\toptions.context = this;\n\t\t\toptions.data = _.extend( options.data || {}, {\n\t\t\t\taction: 'get-attachment',\n\t\t\t\tid: this.id\n\t\t\t});\n\t\t\treturn wp.media.ajax( options );\n\n\t\t// Overload the `update` request so properties can be saved.\n\t\t} else if ( 'update' === method ) {\n\t\t\t// If we do not have the necessary nonce, fail immeditately.\n\t\t\tif ( ! this.get('nonces') || ! this.get('nonces').update ) {\n\t\t\t\treturn $.Deferred().rejectWith( this ).promise();\n\t\t\t}\n\n\t\t\toptions = options || {};\n\t\t\toptions.context = this;\n\n\t\t\t// Set the action and ID.\n\t\t\toptions.data = _.extend( options.data || {}, {\n\t\t\t\taction:  'save-attachment',\n\t\t\t\tid:      this.id,\n\t\t\t\tnonce:   this.get('nonces').update,\n\t\t\t\tpost_id: wp.media.model.settings.post.id\n\t\t\t});\n\n\t\t\t// Record the values of the changed attributes.\n\t\t\tif ( model.hasChanged() ) {\n\t\t\t\toptions.data.changes = {};\n\n\t\t\t\t_.each( model.changed, function( value, key ) {\n\t\t\t\t\toptions.data.changes[ key ] = this.get( key );\n\t\t\t\t}, this );\n\t\t\t}\n\n\t\t\treturn wp.media.ajax( options );\n\n\t\t// Overload the `delete` request so attachments can be removed.\n\t\t// This will permanently delete an attachment.\n\t\t} else if ( 'delete' === method ) {\n\t\t\toptions = options || {};\n\n\t\t\tif ( ! options.wait ) {\n\t\t\t\tthis.destroyed = true;\n\t\t\t}\n\n\t\t\toptions.context = this;\n\t\t\toptions.data = _.extend( options.data || {}, {\n\t\t\t\taction:   'delete-post',\n\t\t\t\tid:       this.id,\n\t\t\t\t_wpnonce: this.get('nonces')['delete']\n\t\t\t});\n\n\t\t\treturn wp.media.ajax( options ).done( function() {\n\t\t\t\tthis.destroyed = true;\n\t\t\t}).fail( function() {\n\t\t\t\tthis.destroyed = false;\n\t\t\t});\n\n\t\t// Otherwise, fall back to `Backbone.sync()`.\n\t\t} else {\n\t\t\t/**\n\t\t\t * Call `sync` directly on Backbone.Model\n\t\t\t */\n\t\t\treturn Backbone.Model.prototype.sync.apply( this, arguments );\n\t\t}\n\t},\n\t/**\n\t * Convert date strings into Date objects.\n\t *\n\t * @param {Object} resp The raw response object, typically returned by fetch()\n\t * @returns {Object} The modified response object, which is the attributes hash\n\t *    to be set on the model.\n\t */\n\tparse: function( resp ) {\n\t\tif ( ! resp ) {\n\t\t\treturn resp;\n\t\t}\n\n\t\tresp.date = new Date( resp.date );\n\t\tresp.modified = new Date( resp.modified );\n\t\treturn resp;\n\t},\n\t/**\n\t * @param {Object} data The properties to be saved.\n\t * @param {Object} options Sync options. e.g. patch, wait, success, error.\n\t *\n\t * @this Backbone.Model\n\t *\n\t * @returns {Promise}\n\t */\n\tsaveCompat: function( data, options ) {\n\t\tvar model = this;\n\n\t\t// If we do not have the necessary nonce, fail immeditately.\n\t\tif ( ! this.get('nonces') || ! this.get('nonces').update ) {\n\t\t\treturn $.Deferred().rejectWith( this ).promise();\n\t\t}\n\n\t\treturn wp.media.post( 'save-attachment-compat', _.defaults({\n\t\t\tid:      this.id,\n\t\t\tnonce:   this.get('nonces').update,\n\t\t\tpost_id: wp.media.model.settings.post.id\n\t\t}, data ) ).done( function( resp, status, xhr ) {\n\t\t\tmodel.set( model.parse( resp, xhr ), options );\n\t\t});\n\t}\n},/** @lends wp.media.model.Attachment */{\n\t/**\n\t * Create a new model on the static 'all' attachments collection and return it.\n\t *\n\t * @static\n\t *\n\t * @param {Object} attrs\n\t * @returns {wp.media.model.Attachment}\n\t */\n\tcreate: function( attrs ) {\n\t\tvar Attachments = wp.media.model.Attachments;\n\t\treturn Attachments.all.push( attrs );\n\t},\n\t/**\n\t * Create a new model on the static 'all' attachments collection and return it.\n\t *\n\t * If this function has already been called for the id,\n\t * it returns the specified attachment.\n\t *\n\t * @static\n\t * @param {string} id A string used to identify a model.\n\t * @param {Backbone.Model|undefined} attachment\n\t * @returns {wp.media.model.Attachment}\n\t */\n\tget: _.memoize( function( id, attachment ) {\n\t\tvar Attachments = wp.media.model.Attachments;\n\t\treturn Attachments.all.push( attachment || { id: id } );\n\t})\n});\n\nmodule.exports = Attachment;\n\n\n//# sourceURL=webpack:///./src/js/media/models/attachment.js?")},"./src/js/media/models/attachments.js":function(module,exports){eval("/**\n * wp.media.model.Attachments\n *\n * A collection of attachments.\n *\n * This collection has no persistence with the server without supplying\n * 'options.props.query = true', which will mirror the collection\n * to an Attachments Query collection - @see wp.media.model.Attachments.mirror().\n *\n * @memberOf wp.media.model\n *\n * @class\n * @augments Backbone.Collection\n *\n * @param {array}  [models]                Models to initialize with the collection.\n * @param {object} [options]               Options hash for the collection.\n * @param {string} [options.props]         Options hash for the initial query properties.\n * @param {string} [options.props.order]   Initial order (ASC or DESC) for the collection.\n * @param {string} [options.props.orderby] Initial attribute key to order the collection by.\n * @param {string} [options.props.query]   Whether the collection is linked to an attachments query.\n * @param {string} [options.observe]\n * @param {string} [options.filters]\n *\n */\nvar Attachments = Backbone.Collection.extend(/** @lends wp.media.model.Attachments.prototype */{\n\t/**\n\t * @type {wp.media.model.Attachment}\n\t */\n\tmodel: wp.media.model.Attachment,\n\t/**\n\t * @param {Array} [models=[]] Array of models used to populate the collection.\n\t * @param {Object} [options={}]\n\t */\n\tinitialize: function( models, options ) {\n\t\toptions = options || {};\n\n\t\tthis.props   = new Backbone.Model();\n\t\tthis.filters = options.filters || {};\n\n\t\t// Bind default `change` events to the `props` model.\n\t\tthis.props.on( 'change', this._changeFilteredProps, this );\n\n\t\tthis.props.on( 'change:order',   this._changeOrder,   this );\n\t\tthis.props.on( 'change:orderby', this._changeOrderby, this );\n\t\tthis.props.on( 'change:query',   this._changeQuery,   this );\n\n\t\tthis.props.set( _.defaults( options.props || {} ) );\n\n\t\tif ( options.observe ) {\n\t\t\tthis.observe( options.observe );\n\t\t}\n\t},\n\t/**\n\t * Sort the collection when the order attribute changes.\n\t *\n\t * @access private\n\t */\n\t_changeOrder: function() {\n\t\tif ( this.comparator ) {\n\t\t\tthis.sort();\n\t\t}\n\t},\n\t/**\n\t * Set the default comparator only when the `orderby` property is set.\n\t *\n\t * @access private\n\t *\n\t * @param {Backbone.Model} model\n\t * @param {string} orderby\n\t */\n\t_changeOrderby: function( model, orderby ) {\n\t\t// If a different comparator is defined, bail.\n\t\tif ( this.comparator && this.comparator !== Attachments.comparator ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( orderby && 'post__in' !== orderby ) {\n\t\t\tthis.comparator = Attachments.comparator;\n\t\t} else {\n\t\t\tdelete this.comparator;\n\t\t}\n\t},\n\t/**\n\t * If the `query` property is set to true, query the server using\n\t * the `props` values, and sync the results to this collection.\n\t *\n\t * @access private\n\t *\n\t * @param {Backbone.Model} model\n\t * @param {Boolean} query\n\t */\n\t_changeQuery: function( model, query ) {\n\t\tif ( query ) {\n\t\t\tthis.props.on( 'change', this._requery, this );\n\t\t\tthis._requery();\n\t\t} else {\n\t\t\tthis.props.off( 'change', this._requery, this );\n\t\t}\n\t},\n\t/**\n\t * @access private\n\t *\n\t * @param {Backbone.Model} model\n\t */\n\t_changeFilteredProps: function( model ) {\n\t\t// If this is a query, updating the collection will be handled by\n\t\t// `this._requery()`.\n\t\tif ( this.props.get('query') ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar changed = _.chain( model.changed ).map( function( t, prop ) {\n\t\t\tvar filter = Attachments.filters[ prop ],\n\t\t\t\tterm = model.get( prop );\n\n\t\t\tif ( ! filter ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( term && ! this.filters[ prop ] ) {\n\t\t\t\tthis.filters[ prop ] = filter;\n\t\t\t} else if ( ! term && this.filters[ prop ] === filter ) {\n\t\t\t\tdelete this.filters[ prop ];\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Record the change.\n\t\t\treturn true;\n\t\t}, this ).any().value();\n\n\t\tif ( ! changed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If no `Attachments` model is provided to source the searches\n\t\t// from, then automatically generate a source from the existing\n\t\t// models.\n\t\tif ( ! this._source ) {\n\t\t\tthis._source = new Attachments( this.models );\n\t\t}\n\n\t\tthis.reset( this._source.filter( this.validator, this ) );\n\t},\n\n\tvalidateDestroyed: false,\n\t/**\n\t * Checks whether an attachment is valid.\n\t *\n\t * @param {wp.media.model.Attachment} attachment\n\t * @returns {Boolean}\n\t */\n\tvalidator: function( attachment ) {\n\n\t\t// Filter out contextually created attachments (e.g. headers, logos, etc.).\n\t\tif (\n\t\t\t! _.isUndefined( attachment.attributes.context ) &&\n\t\t\t'' !== attachment.attributes.context\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! this.validateDestroyed && attachment.destroyed ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn _.all( this.filters, function( filter ) {\n\t\t\treturn !! filter.call( this, attachment );\n\t\t}, this );\n\t},\n\t/**\n\t * Add or remove an attachment to the collection depending on its validity.\n\t *\n\t * @param {wp.media.model.Attachment} attachment\n\t * @param {Object} options\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\tvalidate: function( attachment, options ) {\n\t\tvar valid = this.validator( attachment ),\n\t\t\thasAttachment = !! this.get( attachment.cid );\n\n\t\tif ( ! valid && hasAttachment ) {\n\t\t\tthis.remove( attachment, options );\n\t\t} else if ( valid && ! hasAttachment ) {\n\t\t\tthis.add( attachment, options );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Add or remove all attachments from another collection depending on each one's validity.\n\t *\n\t * @param {wp.media.model.Attachments} attachments\n\t * @param {object} [options={}]\n\t *\n\t * @fires wp.media.model.Attachments#reset\n\t *\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\tvalidateAll: function( attachments, options ) {\n\t\toptions = options || {};\n\n\t\t_.each( attachments.models, function( attachment ) {\n\t\t\tthis.validate( attachment, { silent: true });\n\t\t}, this );\n\n\t\tif ( ! options.silent ) {\n\t\t\tthis.trigger( 'reset', this, options );\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * Start observing another attachments collection change events\n\t * and replicate them on this collection.\n\t *\n\t * @param {wp.media.model.Attachments} The attachments collection to observe.\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining.\n\t */\n\tobserve: function( attachments ) {\n\t\tthis.observers = this.observers || [];\n\t\tthis.observers.push( attachments );\n\n\t\tattachments.on( 'add change remove', this._validateHandler, this );\n\t\tattachments.on( 'reset', this._validateAllHandler, this );\n\t\tthis.validateAll( attachments );\n\t\treturn this;\n\t},\n\t/**\n\t * Stop replicating collection change events from another attachments collection.\n\t *\n\t * @param {wp.media.model.Attachments} The attachments collection to stop observing.\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\tunobserve: function( attachments ) {\n\t\tif ( attachments ) {\n\t\t\tattachments.off( null, null, this );\n\t\t\tthis.observers = _.without( this.observers, attachments );\n\n\t\t} else {\n\t\t\t_.each( this.observers, function( attachments ) {\n\t\t\t\tattachments.off( null, null, this );\n\t\t\t}, this );\n\t\t\tdelete this.observers;\n\t\t}\n\n\t\treturn this;\n\t},\n\t/**\n\t * @access private\n\t *\n\t * @param {wp.media.model.Attachments} attachment\n\t * @param {wp.media.model.Attachments} attachments\n\t * @param {Object} options\n\t *\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\t_validateHandler: function( attachment, attachments, options ) {\n\t\t// If we're not mirroring this `attachments` collection,\n\t\t// only retain the `silent` option.\n\t\toptions = attachments === this.mirroring ? options : {\n\t\t\tsilent: options && options.silent\n\t\t};\n\n\t\treturn this.validate( attachment, options );\n\t},\n\t/**\n\t * @access private\n\t *\n\t * @param {wp.media.model.Attachments} attachments\n\t * @param {Object} options\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\t_validateAllHandler: function( attachments, options ) {\n\t\treturn this.validateAll( attachments, options );\n\t},\n\t/**\n\t * Start mirroring another attachments collection, clearing out any models already\n\t * in the collection.\n\t *\n\t * @param {wp.media.model.Attachments} The attachments collection to mirror.\n\t * @returns {wp.media.model.Attachments} Returns itself to allow chaining\n\t */\n\tmirror: function( attachments ) {\n\t\tif ( this.mirroring && this.mirroring === attachments ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.unmirror();\n\t\tthis.mirroring = attachments;\n\n\t\t// Clear the collection silently. A `reset` event will be fired\n\t\t// when `observe()` calls `validateAll()`.\n\t\tthis.reset( [], { silent: true } );\n\t\tthis.observe( attachments );\n\n\t\treturn this;\n\t},\n\t/**\n\t * Stop mirroring another attachments collection.\n\t */\n\tunmirror: function() {\n\t\tif ( ! this.mirroring ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.unobserve( this.mirroring );\n\t\tdelete this.mirroring;\n\t},\n\t/**\n\t * Retrieve more attachments from the server for the collection.\n\t *\n\t * Only works if the collection is mirroring a Query Attachments collection,\n\t * and forwards to its `more` method. This collection class doesn't have\n\t * server persistence by itself.\n\t *\n\t * @param {object} options\n\t * @returns {Promise}\n\t */\n\tmore: function( options ) {\n\t\tvar deferred = jQuery.Deferred(),\n\t\t\tmirroring = this.mirroring,\n\t\t\tattachments = this;\n\n\t\tif ( ! mirroring || ! mirroring.more ) {\n\t\t\treturn deferred.resolveWith( this ).promise();\n\t\t}\n\t\t// If we're mirroring another collection, forward `more` to\n\t\t// the mirrored collection. Account for a race condition by\n\t\t// checking if we're still mirroring that collection when\n\t\t// the request resolves.\n\t\tmirroring.more( options ).done( function() {\n\t\t\tif ( this === attachments.mirroring ) {\n\t\t\t\tdeferred.resolveWith( this );\n\t\t\t}\n\t\t});\n\n\t\treturn deferred.promise();\n\t},\n\t/**\n\t * Whether there are more attachments that haven't been sync'd from the server\n\t * that match the collection's query.\n\t *\n\t * Only works if the collection is mirroring a Query Attachments collection,\n\t * and forwards to its `hasMore` method. This collection class doesn't have\n\t * server persistence by itself.\n\t *\n\t * @returns {boolean}\n\t */\n\thasMore: function() {\n\t\treturn this.mirroring ? this.mirroring.hasMore() : false;\n\t},\n\t/**\n\t * A custom AJAX-response parser.\n\t *\n\t * See trac ticket #24753\n\t *\n\t * @param {Object|Array} resp The raw response Object/Array.\n\t * @param {Object} xhr\n\t * @returns {Array} The array of model attributes to be added to the collection\n\t */\n\tparse: function( resp, xhr ) {\n\t\tif ( ! _.isArray( resp ) ) {\n\t\t\tresp = [resp];\n\t\t}\n\n\t\treturn _.map( resp, function( attrs ) {\n\t\t\tvar id, attachment, newAttributes;\n\n\t\t\tif ( attrs instanceof Backbone.Model ) {\n\t\t\t\tid = attrs.get( 'id' );\n\t\t\t\tattrs = attrs.attributes;\n\t\t\t} else {\n\t\t\t\tid = attrs.id;\n\t\t\t}\n\n\t\t\tattachment = wp.media.model.Attachment.get( id );\n\t\t\tnewAttributes = attachment.parse( attrs, xhr );\n\n\t\t\tif ( ! _.isEqual( attachment.attributes, newAttributes ) ) {\n\t\t\t\tattachment.set( newAttributes );\n\t\t\t}\n\n\t\t\treturn attachment;\n\t\t});\n\t},\n\t/**\n\t * If the collection is a query, create and mirror an Attachments Query collection.\n\t *\n\t * @access private\n\t */\n\t_requery: function( refresh ) {\n\t\tvar props;\n\t\tif ( this.props.get('query') ) {\n\t\t\tprops = this.props.toJSON();\n\t\t\tprops.cache = ( true !== refresh );\n\t\t\tthis.mirror( wp.media.model.Query.get( props ) );\n\t\t}\n\t},\n\t/**\n\t * If this collection is sorted by `menuOrder`, recalculates and saves\n\t * the menu order to the database.\n\t *\n\t * @returns {undefined|Promise}\n\t */\n\tsaveMenuOrder: function() {\n\t\tif ( 'menuOrder' !== this.props.get('orderby') ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Removes any uploading attachments, updates each attachment's\n\t\t// menu order, and returns an object with an { id: menuOrder }\n\t\t// mapping to pass to the request.\n\t\tvar attachments = this.chain().filter( function( attachment ) {\n\t\t\treturn ! _.isUndefined( attachment.id );\n\t\t}).map( function( attachment, index ) {\n\t\t\t// Indices start at 1.\n\t\t\tindex = index + 1;\n\t\t\tattachment.set( 'menuOrder', index );\n\t\t\treturn [ attachment.id, index ];\n\t\t}).object().value();\n\n\t\tif ( _.isEmpty( attachments ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn wp.media.post( 'save-attachment-order', {\n\t\t\tnonce:       wp.media.model.settings.post.nonce,\n\t\t\tpost_id:     wp.media.model.settings.post.id,\n\t\t\tattachments: attachments\n\t\t});\n\t}\n},/** @lends wp.media.model.Attachments */{\n\t/**\n\t * A function to compare two attachment models in an attachments collection.\n\t *\n\t * Used as the default comparator for instances of wp.media.model.Attachments\n\t * and its subclasses. @see wp.media.model.Attachments._changeOrderby().\n\t *\n\t * @param {Backbone.Model} a\n\t * @param {Backbone.Model} b\n\t * @param {Object} options\n\t * @returns {Number} -1 if the first model should come before the second,\n\t *    0 if they are of the same rank and\n\t *    1 if the first model should come after.\n\t */\n\tcomparator: function( a, b, options ) {\n\t\tvar key   = this.props.get('orderby'),\n\t\t\torder = this.props.get('order') || 'DESC',\n\t\t\tac    = a.cid,\n\t\t\tbc    = b.cid;\n\n\t\ta = a.get( key );\n\t\tb = b.get( key );\n\n\t\tif ( 'date' === key || 'modified' === key ) {\n\t\t\ta = a || new Date();\n\t\t\tb = b || new Date();\n\t\t}\n\n\t\t// If `options.ties` is set, don't enforce the `cid` tiebreaker.\n\t\tif ( options && options.ties ) {\n\t\t\tac = bc = null;\n\t\t}\n\n\t\treturn ( 'DESC' === order ) ? wp.media.compare( a, b, ac, bc ) : wp.media.compare( b, a, bc, ac );\n\t},\n\t/** @namespace wp.media.model.Attachments.filters */\n\tfilters: {\n\t\t/**\n\t\t * @static\n\t\t * Note that this client-side searching is *not* equivalent\n\t\t * to our server-side searching.\n\t\t *\n\t\t * @param {wp.media.model.Attachment} attachment\n\t\t *\n\t\t * @this wp.media.model.Attachments\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsearch: function( attachment ) {\n\t\t\tif ( ! this.props.get('search') ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn _.any(['title','filename','description','caption','name'], function( key ) {\n\t\t\t\tvar value = attachment.get( key );\n\t\t\t\treturn value && -1 !== value.search( this.props.get('search') );\n\t\t\t}, this );\n\t\t},\n\t\t/**\n\t\t * @static\n\t\t * @param {wp.media.model.Attachment} attachment\n\t\t *\n\t\t * @this wp.media.model.Attachments\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\ttype: function( attachment ) {\n\t\t\tvar type = this.props.get('type'), atts = attachment.toJSON(), mime, found;\n\n\t\t\tif ( ! type || ( _.isArray( type ) && ! type.length ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tmime = atts.mime || ( atts.file && atts.file.type ) || '';\n\n\t\t\tif ( _.isArray( type ) ) {\n\t\t\t\tfound = _.find( type, function (t) {\n\t\t\t\t\treturn -1 !== mime.indexOf( t );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tfound = -1 !== mime.indexOf( type );\n\t\t\t}\n\n\t\t\treturn found;\n\t\t},\n\t\t/**\n\t\t * @static\n\t\t * @param {wp.media.model.Attachment} attachment\n\t\t *\n\t\t * @this wp.media.model.Attachments\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\tuploadedTo: function( attachment ) {\n\t\t\tvar uploadedTo = this.props.get('uploadedTo');\n\t\t\tif ( _.isUndefined( uploadedTo ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn uploadedTo === attachment.get('uploadedTo');\n\t\t},\n\t\t/**\n\t\t * @static\n\t\t * @param {wp.media.model.Attachment} attachment\n\t\t *\n\t\t * @this wp.media.model.Attachments\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\tstatus: function( attachment ) {\n\t\t\tvar status = this.props.get('status');\n\t\t\tif ( _.isUndefined( status ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn status === attachment.get('status');\n\t\t}\n\t}\n});\n\nmodule.exports = Attachments;\n\n\n//# sourceURL=webpack:///./src/js/media/models/attachments.js?")},"./src/js/media/models/post-image.js":function(module,exports){eval("/**\n * wp.media.model.PostImage\n *\n * An instance of an image that's been embedded into a post.\n *\n * Used in the embedded image attachment display settings modal - @see wp.media.view.MediaFrame.ImageDetails.\n *\n * @memberOf wp.media.model\n *\n * @class\n * @augments Backbone.Model\n *\n * @param {int} [attributes]               Initial model attributes.\n * @param {int} [attributes.attachment_id] ID of the attachment.\n **/\nvar PostImage = Backbone.Model.extend(/** @lends wp.media.model.PostImage.prototype */{\n\n\tinitialize: function( attributes ) {\n\t\tvar Attachment = wp.media.model.Attachment;\n\t\tthis.attachment = false;\n\n\t\tif ( attributes.attachment_id ) {\n\t\t\tthis.attachment = Attachment.get( attributes.attachment_id );\n\t\t\tif ( this.attachment.get( 'url' ) ) {\n\t\t\t\tthis.dfd = jQuery.Deferred();\n\t\t\t\tthis.dfd.resolve();\n\t\t\t} else {\n\t\t\t\tthis.dfd = this.attachment.fetch();\n\t\t\t}\n\t\t\tthis.bindAttachmentListeners();\n\t\t}\n\n\t\t// keep url in sync with changes to the type of link\n\t\tthis.on( 'change:link', this.updateLinkUrl, this );\n\t\tthis.on( 'change:size', this.updateSize, this );\n\n\t\tthis.setLinkTypeFromUrl();\n\t\tthis.setAspectRatio();\n\n\t\tthis.set( 'originalUrl', attributes.url );\n\t},\n\n\tbindAttachmentListeners: function() {\n\t\tthis.listenTo( this.attachment, 'sync', this.setLinkTypeFromUrl );\n\t\tthis.listenTo( this.attachment, 'sync', this.setAspectRatio );\n\t\tthis.listenTo( this.attachment, 'change', this.updateSize );\n\t},\n\n\tchangeAttachment: function( attachment, props ) {\n\t\tthis.stopListening( this.attachment );\n\t\tthis.attachment = attachment;\n\t\tthis.bindAttachmentListeners();\n\n\t\tthis.set( 'attachment_id', this.attachment.get( 'id' ) );\n\t\tthis.set( 'caption', this.attachment.get( 'caption' ) );\n\t\tthis.set( 'alt', this.attachment.get( 'alt' ) );\n\t\tthis.set( 'size', props.get( 'size' ) );\n\t\tthis.set( 'align', props.get( 'align' ) );\n\t\tthis.set( 'link', props.get( 'link' ) );\n\t\tthis.updateLinkUrl();\n\t\tthis.updateSize();\n\t},\n\n\tsetLinkTypeFromUrl: function() {\n\t\tvar linkUrl = this.get( 'linkUrl' ),\n\t\t\ttype;\n\n\t\tif ( ! linkUrl ) {\n\t\t\tthis.set( 'link', 'none' );\n\t\t\treturn;\n\t\t}\n\n\t\t// default to custom if there is a linkUrl\n\t\ttype = 'custom';\n\n\t\tif ( this.attachment ) {\n\t\t\tif ( this.attachment.get( 'url' ) === linkUrl ) {\n\t\t\t\ttype = 'file';\n\t\t\t} else if ( this.attachment.get( 'link' ) === linkUrl ) {\n\t\t\t\ttype = 'post';\n\t\t\t}\n\t\t} else {\n\t\t\tif ( this.get( 'url' ) === linkUrl ) {\n\t\t\t\ttype = 'file';\n\t\t\t}\n\t\t}\n\n\t\tthis.set( 'link', type );\n\t},\n\n\tupdateLinkUrl: function() {\n\t\tvar link = this.get( 'link' ),\n\t\t\turl;\n\n\t\tswitch( link ) {\n\t\t\tcase 'file':\n\t\t\t\tif ( this.attachment ) {\n\t\t\t\t\turl = this.attachment.get( 'url' );\n\t\t\t\t} else {\n\t\t\t\t\turl = this.get( 'url' );\n\t\t\t\t}\n\t\t\t\tthis.set( 'linkUrl', url );\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\tthis.set( 'linkUrl', this.attachment.get( 'link' ) );\n\t\t\t\tbreak;\n\t\t\tcase 'none':\n\t\t\t\tthis.set( 'linkUrl', '' );\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\tupdateSize: function() {\n\t\tvar size;\n\n\t\tif ( ! this.attachment ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.get( 'size' ) === 'custom' ) {\n\t\t\tthis.set( 'width', this.get( 'customWidth' ) );\n\t\t\tthis.set( 'height', this.get( 'customHeight' ) );\n\t\t\tthis.set( 'url', this.get( 'originalUrl' ) );\n\t\t\treturn;\n\t\t}\n\n\t\tsize = this.attachment.get( 'sizes' )[ this.get( 'size' ) ];\n\n\t\tif ( ! size ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.set( 'url', size.url );\n\t\tthis.set( 'width', size.width );\n\t\tthis.set( 'height', size.height );\n\t},\n\n\tsetAspectRatio: function() {\n\t\tvar full;\n\n\t\tif ( this.attachment && this.attachment.get( 'sizes' ) ) {\n\t\t\tfull = this.attachment.get( 'sizes' ).full;\n\n\t\t\tif ( full ) {\n\t\t\t\tthis.set( 'aspectRatio', full.width / full.height );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.set( 'aspectRatio', this.get( 'customWidth' ) / this.get( 'customHeight' ) );\n\t}\n});\n\nmodule.exports = PostImage;\n\n\n//# sourceURL=webpack:///./src/js/media/models/post-image.js?");
},"./src/js/media/models/query.js":function(module,exports){eval("var Attachments = wp.media.model.Attachments,\n\tQuery;\n\n/**\n * wp.media.model.Query\n *\n * A collection of attachments that match the supplied query arguments.\n *\n * Note: Do NOT change this.args after the query has been initialized.\n *       Things will break.\n *\n * @memberOf wp.media.model\n *\n * @class\n * @augments wp.media.model.Attachments\n * @augments Backbone.Collection\n *\n * @param {array}  [models]                      Models to initialize with the collection.\n * @param {object} [options]                     Options hash.\n * @param {object} [options.args]                Attachments query arguments.\n * @param {object} [options.args.posts_per_page]\n */\nQuery = Attachments.extend(/** @lends wp.media.model.Query.prototype */{\n\t/**\n\t * @param {array}  [models=[]]  Array of initial models to populate the collection.\n\t * @param {object} [options={}]\n\t */\n\tinitialize: function( models, options ) {\n\t\tvar allowed;\n\n\t\toptions = options || {};\n\t\tAttachments.prototype.initialize.apply( this, arguments );\n\n\t\tthis.args     = options.args;\n\t\tthis._hasMore = true;\n\t\tthis.created  = new Date();\n\n\t\tthis.filters.order = function( attachment ) {\n\t\t\tvar orderby = this.props.get('orderby'),\n\t\t\t\torder = this.props.get('order');\n\n\t\t\tif ( ! this.comparator ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// We want any items that can be placed before the last\n\t\t\t// item in the set. If we add any items after the last\n\t\t\t// item, then we can't guarantee the set is complete.\n\t\t\tif ( this.length ) {\n\t\t\t\treturn 1 !== this.comparator( attachment, this.last(), { ties: true });\n\n\t\t\t// Handle the case where there are no items yet and\n\t\t\t// we're sorting for recent items. In that case, we want\n\t\t\t// changes that occurred after we created the query.\n\t\t\t} else if ( 'DESC' === order && ( 'date' === orderby || 'modified' === orderby ) ) {\n\t\t\t\treturn attachment.get( orderby ) >= this.created;\n\n\t\t\t// If we're sorting by menu order and we have no items,\n\t\t\t// accept any items that have the default menu order (0).\n\t\t\t} else if ( 'ASC' === order && 'menuOrder' === orderby ) {\n\t\t\t\treturn attachment.get( orderby ) === 0;\n\t\t\t}\n\n\t\t\t// Otherwise, we don't want any items yet.\n\t\t\treturn false;\n\t\t};\n\n\t\t// Observe the central `wp.Uploader.queue` collection to watch for\n\t\t// new matches for the query.\n\t\t//\n\t\t// Only observe when a limited number of query args are set. There\n\t\t// are no filters for other properties, so observing will result in\n\t\t// false positives in those queries.\n\t\tallowed = [ 's', 'order', 'orderby', 'posts_per_page', 'post_mime_type', 'post_parent', 'author' ];\n\t\tif ( wp.Uploader && _( this.args ).chain().keys().difference( allowed ).isEmpty().value() ) {\n\t\t\tthis.observe( wp.Uploader.queue );\n\t\t}\n\t},\n\t/**\n\t * Whether there are more attachments that haven't been sync'd from the server\n\t * that match the collection's query.\n\t *\n\t * @returns {boolean}\n\t */\n\thasMore: function() {\n\t\treturn this._hasMore;\n\t},\n\t/**\n\t * Fetch more attachments from the server for the collection.\n\t *\n\t * @param   {object}  [options={}]\n\t * @returns {Promise}\n\t */\n\tmore: function( options ) {\n\t\tvar query = this;\n\n\t\t// If there is already a request pending, return early with the Deferred object.\n\t\tif ( this._more && 'pending' === this._more.state() ) {\n\t\t\treturn this._more;\n\t\t}\n\n\t\tif ( ! this.hasMore() ) {\n\t\t\treturn jQuery.Deferred().resolveWith( this ).promise();\n\t\t}\n\n\t\toptions = options || {};\n\t\toptions.remove = false;\n\n\t\treturn this._more = this.fetch( options ).done( function( resp ) {\n\t\t\tif ( _.isEmpty( resp ) || -1 === this.args.posts_per_page || resp.length < this.args.posts_per_page ) {\n\t\t\t\tquery._hasMore = false;\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Overrides Backbone.Collection.sync\n\t * Overrides wp.media.model.Attachments.sync\n\t *\n\t * @param {String} method\n\t * @param {Backbone.Model} model\n\t * @param {Object} [options={}]\n\t * @returns {Promise}\n\t */\n\tsync: function( method, model, options ) {\n\t\tvar args, fallback;\n\n\t\t// Overload the read method so Attachment.fetch() functions correctly.\n\t\tif ( 'read' === method ) {\n\t\t\toptions = options || {};\n\t\t\toptions.context = this;\n\t\t\toptions.data = _.extend( options.data || {}, {\n\t\t\t\taction:  'query-attachments',\n\t\t\t\tpost_id: wp.media.model.settings.post.id\n\t\t\t});\n\n\t\t\t// Clone the args so manipulation is non-destructive.\n\t\t\targs = _.clone( this.args );\n\n\t\t\t// Determine which page to query.\n\t\t\tif ( -1 !== args.posts_per_page ) {\n\t\t\t\targs.paged = Math.round( this.length / args.posts_per_page ) + 1;\n\t\t\t}\n\n\t\t\toptions.data.query = args;\n\t\t\treturn wp.media.ajax( options );\n\n\t\t// Otherwise, fall back to Backbone.sync()\n\t\t} else {\n\t\t\t/**\n\t\t\t * Call wp.media.model.Attachments.sync or Backbone.sync\n\t\t\t */\n\t\t\tfallback = Attachments.prototype.sync ? Attachments.prototype : Backbone;\n\t\t\treturn fallback.sync.apply( this, arguments );\n\t\t}\n\t}\n}, /** @lends wp.media.model.Query */{\n\t/**\n\t * @readonly\n\t */\n\tdefaultProps: {\n\t\torderby: 'date',\n\t\torder:   'DESC'\n\t},\n\t/**\n\t * @readonly\n\t */\n\tdefaultArgs: {\n\t\tposts_per_page: 40\n\t},\n\t/**\n\t * @readonly\n\t */\n\torderby: {\n\t\tallowed:  [ 'name', 'author', 'date', 'title', 'modified', 'uploadedTo', 'id', 'post__in', 'menuOrder' ],\n\t\t/**\n\t\t * A map of JavaScript orderby values to their WP_Query equivalents.\n\t\t * @type {Object}\n\t\t */\n\t\tvaluemap: {\n\t\t\t'id':         'ID',\n\t\t\t'uploadedTo': 'parent',\n\t\t\t'menuOrder':  'menu_order ID'\n\t\t}\n\t},\n\t/**\n\t * A map of JavaScript query properties to their WP_Query equivalents.\n\t *\n\t * @readonly\n\t */\n\tpropmap: {\n\t\t'search':\t\t's',\n\t\t'type':\t\t\t'post_mime_type',\n\t\t'perPage':\t\t'posts_per_page',\n\t\t'menuOrder':\t'menu_order',\n\t\t'uploadedTo':\t'post_parent',\n\t\t'status':\t\t'post_status',\n\t\t'include':\t\t'post__in',\n\t\t'exclude':\t\t'post__not_in',\n\t\t'author':\t\t'author'\n\t},\n\t/**\n\t * Creates and returns an Attachments Query collection given the properties.\n\t *\n\t * Caches query objects and reuses where possible.\n\t *\n\t * @static\n\t * @method\n\t *\n\t * @param {object} [props]\n\t * @param {Object} [props.cache=true]   Whether to use the query cache or not.\n\t * @param {Object} [props.order]\n\t * @param {Object} [props.orderby]\n\t * @param {Object} [props.include]\n\t * @param {Object} [props.exclude]\n\t * @param {Object} [props.s]\n\t * @param {Object} [props.post_mime_type]\n\t * @param {Object} [props.posts_per_page]\n\t * @param {Object} [props.menu_order]\n\t * @param {Object} [props.post_parent]\n\t * @param {Object} [props.post_status]\n\t * @param {Object} [props.author]\n\t * @param {Object} [options]\n\t *\n\t * @returns {wp.media.model.Query} A new Attachments Query collection.\n\t */\n\tget: (function(){\n\t\t/**\n\t\t * @static\n\t\t * @type Array\n\t\t */\n\t\tvar queries = [];\n\n\t\t/**\n\t\t * @returns {Query}\n\t\t */\n\t\treturn function( props, options ) {\n\t\t\tvar args     = {},\n\t\t\t\torderby  = Query.orderby,\n\t\t\t\tdefaults = Query.defaultProps,\n\t\t\t\tquery,\n\t\t\t\tcache    = !! props.cache || _.isUndefined( props.cache );\n\n\t\t\t// Remove the `query` property. This isn't linked to a query,\n\t\t\t// this *is* the query.\n\t\t\tdelete props.query;\n\t\t\tdelete props.cache;\n\n\t\t\t// Fill default args.\n\t\t\t_.defaults( props, defaults );\n\n\t\t\t// Normalize the order.\n\t\t\tprops.order = props.order.toUpperCase();\n\t\t\tif ( 'DESC' !== props.order && 'ASC' !== props.order ) {\n\t\t\t\tprops.order = defaults.order.toUpperCase();\n\t\t\t}\n\n\t\t\t// Ensure we have a valid orderby value.\n\t\t\tif ( ! _.contains( orderby.allowed, props.orderby ) ) {\n\t\t\t\tprops.orderby = defaults.orderby;\n\t\t\t}\n\n\t\t\t_.each( [ 'include', 'exclude' ], function( prop ) {\n\t\t\t\tif ( props[ prop ] && ! _.isArray( props[ prop ] ) ) {\n\t\t\t\t\tprops[ prop ] = [ props[ prop ] ];\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Generate the query `args` object.\n\t\t\t// Correct any differing property names.\n\t\t\t_.each( props, function( value, prop ) {\n\t\t\t\tif ( _.isNull( value ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\targs[ Query.propmap[ prop ] || prop ] = value;\n\t\t\t});\n\n\t\t\t// Fill any other default query args.\n\t\t\t_.defaults( args, Query.defaultArgs );\n\n\t\t\t// `props.orderby` does not always map directly to `args.orderby`.\n\t\t\t// Substitute exceptions specified in orderby.keymap.\n\t\t\targs.orderby = orderby.valuemap[ props.orderby ] || props.orderby;\n\n\t\t\t// Search the query cache for a matching query.\n\t\t\tif ( cache ) {\n\t\t\t\tquery = _.find( queries, function( query ) {\n\t\t\t\t\treturn _.isEqual( query.args, args );\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tqueries = [];\n\t\t\t}\n\n\t\t\t// Otherwise, create a new query and add it to the cache.\n\t\t\tif ( ! query ) {\n\t\t\t\tquery = new Query( [], _.extend( options || {}, {\n\t\t\t\t\tprops: props,\n\t\t\t\t\targs:  args\n\t\t\t\t} ) );\n\t\t\t\tqueries.push( query );\n\t\t\t}\n\n\t\t\treturn query;\n\t\t};\n\t}())\n});\n\nmodule.exports = Query;\n\n\n//# sourceURL=webpack:///./src/js/media/models/query.js?")},"./src/js/media/models/selection.js":function(module,exports){eval("var Attachments = wp.media.model.Attachments,\n\tSelection;\n\n/**\n * wp.media.model.Selection\n *\n * A selection of attachments.\n *\n * @memberOf wp.media.model\n *\n * @class\n * @augments wp.media.model.Attachments\n * @augments Backbone.Collection\n */\nSelection = Attachments.extend(/** @lends wp.media.model.Selection.prototype */{\n\t/**\n\t * Refresh the `single` model whenever the selection changes.\n\t * Binds `single` instead of using the context argument to ensure\n\t * it receives no parameters.\n\t *\n\t * @param {Array} [models=[]] Array of models used to populate the collection.\n\t * @param {Object} [options={}]\n\t */\n\tinitialize: function( models, options ) {\n\t\t/**\n\t\t * call 'initialize' directly on the parent class\n\t\t */\n\t\tAttachments.prototype.initialize.apply( this, arguments );\n\t\tthis.multiple = options && options.multiple;\n\n\t\tthis.on( 'add remove reset', _.bind( this.single, this, false ) );\n\t},\n\n\t/**\n\t * If the workflow does not support multi-select, clear out the selection\n\t * before adding a new attachment to it.\n\t *\n\t * @param {Array} models\n\t * @param {Object} options\n\t * @returns {wp.media.model.Attachment[]}\n\t */\n\tadd: function( models, options ) {\n\t\tif ( ! this.multiple ) {\n\t\t\tthis.remove( this.models );\n\t\t}\n\t\t/**\n\t\t * call 'add' directly on the parent class\n\t\t */\n\t\treturn Attachments.prototype.add.call( this, models, options );\n\t},\n\n\t/**\n\t * Fired when toggling (clicking on) an attachment in the modal.\n\t *\n\t * @param {undefined|boolean|wp.media.model.Attachment} model\n\t *\n\t * @fires wp.media.model.Selection#selection:single\n\t * @fires wp.media.model.Selection#selection:unsingle\n\t *\n\t * @returns {Backbone.Model}\n\t */\n\tsingle: function( model ) {\n\t\tvar previous = this._single;\n\n\t\t// If a `model` is provided, use it as the single model.\n\t\tif ( model ) {\n\t\t\tthis._single = model;\n\t\t}\n\t\t// If the single model isn't in the selection, remove it.\n\t\tif ( this._single && ! this.get( this._single.cid ) ) {\n\t\t\tdelete this._single;\n\t\t}\n\n\t\tthis._single = this._single || this.last();\n\n\t\t// If single has changed, fire an event.\n\t\tif ( this._single !== previous ) {\n\t\t\tif ( previous ) {\n\t\t\t\tprevious.trigger( 'selection:unsingle', previous, this );\n\n\t\t\t\t// If the model was already removed, trigger the collection\n\t\t\t\t// event manually.\n\t\t\t\tif ( ! this.get( previous.cid ) ) {\n\t\t\t\t\tthis.trigger( 'selection:unsingle', previous, this );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this._single ) {\n\t\t\t\tthis._single.trigger( 'selection:single', this._single, this );\n\t\t\t}\n\t\t}\n\n\t\t// Return the single model, or the last model as a fallback.\n\t\treturn this._single;\n\t}\n});\n\nmodule.exports = Selection;\n\n\n//# sourceURL=webpack:///./src/js/media/models/selection.js?")},2:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/js/_enqueues/wp/media/models.js */"./src/js/_enqueues/wp/media/models.js");\n\n\n//# sourceURL=webpack:///multi_./src/js/_enqueues/wp/media/models.js?')}});