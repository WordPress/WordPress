{
  "version": 3,
  "sources": ["package-external:@wordpress/data", "package-external:@wordpress/i18n", "../../../node_modules/ajv/lib/compile/codegen/code.ts", "../../../node_modules/ajv/lib/compile/codegen/scope.ts", "../../../node_modules/ajv/lib/compile/codegen/index.ts", "../../../node_modules/ajv/lib/compile/util.ts", "../../../node_modules/ajv/lib/compile/names.ts", "../../../node_modules/ajv/lib/compile/errors.ts", "../../../node_modules/ajv/lib/compile/validate/boolSchema.ts", "../../../node_modules/ajv/lib/compile/rules.ts", "../../../node_modules/ajv/lib/compile/validate/applicability.ts", "../../../node_modules/ajv/lib/compile/validate/dataType.ts", "../../../node_modules/ajv/lib/compile/validate/defaults.ts", "../../../node_modules/ajv/lib/vocabularies/code.ts", "../../../node_modules/ajv/lib/compile/validate/keyword.ts", "../../../node_modules/ajv/lib/compile/validate/subschema.ts", "../../../node_modules/fast-deep-equal/index.js", "../../../node_modules/ajv/node_modules/json-schema-traverse/index.js", "../../../node_modules/ajv/lib/compile/resolve.ts", "../../../node_modules/ajv/lib/compile/validate/index.ts", "../../../node_modules/ajv/lib/runtime/validation_error.ts", "../../../node_modules/ajv/lib/compile/ref_error.ts", "../../../node_modules/ajv/lib/compile/index.ts", "../../../node_modules/ajv/dist/refs/data.json", "../../../node_modules/fast-uri/lib/scopedChars.js", "../../../node_modules/fast-uri/lib/utils.js", "../../../node_modules/fast-uri/lib/schemes.js", "../../../node_modules/fast-uri/index.js", "../../../node_modules/ajv/lib/runtime/uri.ts", "../../../node_modules/ajv/lib/core.ts", "../../../node_modules/ajv/lib/vocabularies/core/ref.ts", "../../../node_modules/ajv-draft-04/src/vocabulary/core.ts", "../../../node_modules/ajv-draft-04/src/vocabulary/validation/limitNumber.ts", "../../../node_modules/ajv-draft-04/src/vocabulary/validation/limitNumberExclusive.ts", "../../../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts", "../../../node_modules/ajv/lib/runtime/ucs2length.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitLength.ts", "../../../node_modules/ajv/lib/vocabularies/validation/pattern.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts", "../../../node_modules/ajv/lib/vocabularies/validation/required.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitItems.ts", "../../../node_modules/ajv/lib/runtime/equal.ts", "../../../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts", "../../../node_modules/ajv/lib/vocabularies/validation/const.ts", "../../../node_modules/ajv/lib/vocabularies/validation/enum.ts", "../../../node_modules/ajv-draft-04/src/vocabulary/validation/index.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/items.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/items2020.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/contains.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/properties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/not.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/allOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/if.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/index.ts", "../../../node_modules/ajv/lib/vocabularies/format/format.ts", "../../../node_modules/ajv/lib/vocabularies/format/index.ts", "../../../node_modules/ajv-draft-04/src/vocabulary/draft4.ts", "../../../node_modules/ajv/lib/vocabularies/discriminator/types.ts", "../../../node_modules/ajv/lib/vocabularies/discriminator/index.ts", "../../../node_modules/ajv-draft-04/dist/refs/json-schema-draft-04.json", "../../../node_modules/ajv-draft-04/src/index.ts", "../../../packages/abilities/node_modules/ajv-formats/src/formats.ts", "../../../node_modules/ajv/lib/vocabularies/core/id.ts", "../../../node_modules/ajv/lib/vocabularies/core/index.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts", "../../../node_modules/ajv/lib/vocabularies/validation/index.ts", "../../../node_modules/ajv/lib/vocabularies/metadata.ts", "../../../node_modules/ajv/lib/vocabularies/draft7.ts", "../../../node_modules/ajv/dist/refs/json-schema-draft-07.json", "../../../node_modules/ajv/lib/ajv.ts", "../../../packages/abilities/node_modules/ajv-formats/src/limit.ts", "../../../packages/abilities/node_modules/ajv-formats/src/index.ts", "../../../packages/abilities/src/api.ts", "../../../packages/abilities/src/store/index.ts", "../../../packages/abilities/src/store/reducer.ts", "../../../packages/abilities/src/store/constants.ts", "../../../packages/abilities/src/store/actions.ts", "../../../packages/abilities/src/store/selectors.ts", "../../../packages/abilities/src/validation.ts"],
  "sourcesContent": ["module.exports = window.wp.data;", "module.exports = window.wp.i18n;", "// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n", "import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n", "import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n", "import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n", "import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n", "import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n", "import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n", "import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n", "import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n", "import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n", "import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n", "import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n", "import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n", "import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n", "import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n", "import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n", "import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n", "import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n", "{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n", "'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n", "'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n", "'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n", "'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme)\n    uriTokens.push(':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?')\n    uriTokens.push(components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#')\n    uriTokens.push(components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.userinfo !== undefined) {\n        parsed.userinfo = unescape(parsed.userinfo)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n", "import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n", "export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n", "import type {Vocabulary} from \"ajv/dist/core\"\nimport refKeyword from \"ajv/dist/vocabularies/core/ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"id\",\n  \"$defs\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  refKeyword,\n]\n\nexport default core\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordCxt,\n  KeywordErrorDefinition,\n} from \"ajv/dist/core\"\nimport type {KeywordErrorCxt} from \"ajv/dist/types\"\nimport {_, str, Code} from \"ajv/dist/core\"\nimport {operators} from \"ajv/dist/compile/codegen\"\n\nconst ops = operators\n\nexport type LimitKwd = \"maximum\" | \"minimum\"\n\nexport type ExclusiveLimitKwd = \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\ninterface KwdOp {\n  okStr: Comparison\n  ok: Code\n  fail: Code\n}\n\ninterface KwdDef {\n  exclusive: ExclusiveLimitKwd\n  ops: [KwdOp, KwdOp]\n}\n\nconst KWDs: {[K in LimitKwd]: KwdDef} = {\n  maximum: {\n    exclusive: \"exclusiveMaximum\",\n    ops: [\n      {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n      {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n    ],\n  },\n  minimum: {\n    exclusive: \"exclusiveMinimum\",\n    ops: [\n      {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n      {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n    ],\n  },\n}\n\nexport type LimitNumberError = ErrorObject<\n  LimitKwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => str`must be ${kwdOp(cxt).okStr} ${cxt.schemaCode}`,\n  params: (cxt) => _`{comparison: ${kwdOp(cxt).okStr}, limit: ${cxt.schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${kwdOp(cxt).fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nfunction kwdOp(cxt: KeywordErrorCxt): KwdOp {\n  const keyword = cxt.keyword as LimitKwd\n  const opsIdx = cxt.parentSchema?.[KWDs[keyword].exclusive] ? 1 : 0\n  return KWDs[keyword].ops[opsIdx]\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  // ErrorObject,\n  KeywordCxt,\n  // KeywordErrorDefinition,\n} from \"ajv/dist/core\"\nimport {LimitKwd, ExclusiveLimitKwd} from \"./limitNumber\"\n\nconst KWDs: {[K in ExclusiveLimitKwd]: LimitKwd} = {\n  exclusiveMaximum: \"maximum\",\n  exclusiveMinimum: \"minimum\",\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"boolean\",\n  code({keyword, parentSchema}: KeywordCxt) {\n    const limitKwd = KWDs[keyword as ExclusiveLimitKwd]\n    if (parentSchema[limitKwd] === undefined) {\n      throw new Error(`${keyword} can only be used with ${limitKwd}`)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n", "// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n", "import type {ErrorObject, Vocabulary} from \"ajv/dist/core\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport limitNumberExclusive from \"./limitNumberExclusive\"\nimport multipleOf, {MultipleOfError} from \"ajv/dist/vocabularies/validation/multipleOf\"\nimport limitLength from \"ajv/dist/vocabularies/validation/limitLength\"\nimport pattern, {PatternError} from \"ajv/dist/vocabularies/validation/pattern\"\nimport limitProperties from \"ajv/dist/vocabularies/validation/limitProperties\"\nimport required, {RequiredError} from \"ajv/dist/vocabularies/validation/required\"\nimport limitItems from \"ajv/dist/vocabularies/validation/limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"ajv/dist/vocabularies/validation/uniqueItems\"\nimport constKeyword, {ConstError} from \"ajv/dist/vocabularies/validation/const\"\nimport enumKeyword, {EnumError} from \"ajv/dist/vocabularies/validation/enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  limitNumberExclusive,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n", "import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n", "import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n", "import type {Vocabulary} from \"ajv/dist/core\"\nimport coreVocabulary from \"./core\"\nimport validationDraft4 from \"./validation\"\nimport getApplicatorVocabulary from \"ajv/dist/vocabularies/applicator\"\nimport formatVocabulary from \"ajv/dist/vocabularies/format\"\n\nconst metadataVocabulary: Vocabulary = [\"title\", \"description\", \"default\"]\n\nconst draft4Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationDraft4,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n]\n\nexport default draft4Vocabularies\n", "import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n", "{\n  \"id\": \"http://json-schema.org/draft-04/schema#\",\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"description\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"positiveInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"positiveIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/positiveInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    }\n  },\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": {},\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"exclusiveMinimum\": true\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/positiveInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/positiveIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\n      \"anyOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#\"}],\n      \"default\": {}\n    },\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": {}\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/positiveInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/positiveIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"maxProperties\": {\"$ref\": \"#/definitions/positiveInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/positiveIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\n      \"anyOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#\"}],\n      \"default\": {}\n    },\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"enum\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"dependencies\": {\n    \"exclusiveMaximum\": [\"maximum\"],\n    \"exclusiveMinimum\": [\"minimum\"]\n  },\n  \"default\": {}\n}\n", "import type {AnySchemaObject, Options} from \"ajv/dist/core\"\nimport AjvCore from \"ajv/dist/core\"\nimport draft4Vocabularies from \"./vocabulary/draft4\"\nimport discriminator from \"ajv/dist/vocabularies/discriminator\"\nimport * as draft4MetaSchema from \"./refs/json-schema-draft-04.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-04/schema\"\n\nclass Ajv extends AjvCore {\n  constructor(opts: Options = {}) {\n    super({\n      ...opts,\n      schemaId: \"id\",\n    })\n  }\n\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft4Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft4MetaSchema, META_SUPPORT_DATA)\n      : draft4MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"ajv/dist/types\"\n\nexport {\n  Plugin,\n  Options,\n  CodeOptions,\n  InstanceOptions,\n  Logger,\n  ErrorsTextOptions,\n} from \"ajv/dist/core\"\nexport {SchemaCxt, SchemaObjCxt} from \"ajv/dist/core\"\nexport {KeywordCxt} from \"ajv/dist/core\"\nexport {DefinedError} from \"ajv/dist/core\"\nexport {JSONType} from \"ajv/dist/core\"\nexport {JSONSchemaType} from \"ajv/dist/core\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"ajv/dist/core\"\n", "import type {Format, FormatDefinition} from \"ajv\"\nimport type {FormatValidator, FormatCompare} from \"ajv/dist/types\"\n\nexport type FormatMode = \"fast\" | \"full\"\n\nexport type FormatName =\n  | \"date\"\n  | \"time\"\n  | \"date-time\"\n  | \"iso-time\"\n  | \"iso-date-time\"\n  | \"duration\"\n  | \"uri\"\n  | \"uri-reference\"\n  | \"uri-template\"\n  | \"url\"\n  | \"email\"\n  | \"hostname\"\n  | \"ipv4\"\n  | \"ipv6\"\n  | \"regex\"\n  | \"uuid\"\n  | \"json-pointer\"\n  | \"json-pointer-uri-fragment\"\n  | \"relative-json-pointer\"\n  | \"byte\"\n  | \"int32\"\n  | \"int64\"\n  | \"float\"\n  | \"double\"\n  | \"password\"\n  | \"binary\"\n\nexport type DefinedFormats = {\n  [key in FormatName]: Format\n}\n\nfunction fmtDef(\n  validate: RegExp | FormatValidator<string>,\n  compare: FormatCompare<string>\n): FormatDefinition<string> {\n  return {validate, compare}\n}\n\nexport const fullFormats: DefinedFormats = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: fmtDef(date, compareDate),\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: fmtDef(getTime(true), compareTime),\n  \"date-time\": fmtDef(getDateTime(true), compareDateTime),\n  \"iso-time\": fmtDef(getTime(), compareIsoTime),\n  \"iso-date-time\": fmtDef(getDateTime(), compareIsoDateTime),\n  // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n  duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n  uri,\n  \"uri-reference\":\n    /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  \"uri-template\":\n    /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  email:\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname:\n    /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n  regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n  \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n  // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n  // byte: https://github.com/miguelmota/is-base64\n  byte,\n  // signed 32 bit integer\n  int32: {type: \"number\", validate: validateInt32},\n  // signed 64 bit integer\n  int64: {type: \"number\", validate: validateInt64},\n  // C-type float\n  float: {type: \"number\", validate: validateNumber},\n  // C-type double\n  double: {type: \"number\", validate: validateNumber},\n  // hint to the UI to hide input strings\n  password: true,\n  // unchecked string payload\n  binary: true,\n}\n\nexport const fastFormats: DefinedFormats = {\n  ...fullFormats,\n  date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n  time: fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareTime\n  ),\n  \"date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareDateTime\n  ),\n  \"iso-time\": fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareIsoTime\n  ),\n  \"iso-date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareIsoDateTime\n  ),\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n  email:\n    /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n}\n\nexport const formatNames = Object.keys(fullFormats) as FormatName[]\n\nfunction isLeapYear(year: number): boolean {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  const matches: string[] | null = DATE.exec(str)\n  if (!matches) return false\n  const year: number = +matches[1]\n  const month: number = +matches[2]\n  const day: number = +matches[3]\n  return (\n    month >= 1 &&\n    month <= 12 &&\n    day >= 1 &&\n    day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n  )\n}\n\nfunction compareDate(d1: string, d2: string): number | undefined {\n  if (!(d1 && d2)) return undefined\n  if (d1 > d2) return 1\n  if (d1 < d2) return -1\n  return 0\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n  return function time(str: string): boolean {\n    const matches: string[] | null = TIME.exec(str)\n    if (!matches) return false\n    const hr: number = +matches[1]\n    const min: number = +matches[2]\n    const sec: number = +matches[3]\n    const tz: string | undefined = matches[4]\n    const tzSign: number = matches[5] === \"-\" ? -1 : 1\n    const tzH: number = +(matches[6] || 0)\n    const tzM: number = +(matches[7] || 0)\n    if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n    if (hr <= 23 && min <= 59 && sec < 60) return true\n    // leap second\n    const utcMin = min - tzM * tzSign\n    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61\n  }\n}\n\nfunction compareTime(s1: string, s2: string): number | undefined {\n  if (!(s1 && s2)) return undefined\n  const t1 = new Date(\"2020-01-01T\" + s1).valueOf()\n  const t2 = new Date(\"2020-01-01T\" + s2).valueOf()\n  if (!(t1 && t2)) return undefined\n  return t1 - t2\n}\n\nfunction compareIsoTime(t1: string, t2: string): number | undefined {\n  if (!(t1 && t2)) return undefined\n  const a1 = TIME.exec(t1)\n  const a2 = TIME.exec(t2)\n  if (!(a1 && a2)) return undefined\n  t1 = a1[1] + a1[2] + a1[3]\n  t2 = a2[1] + a2[2] + a2[3]\n  if (t1 > t2) return 1\n  if (t1 < t2) return -1\n  return 0\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n  const time = getTime(strictTimeZone)\n\n  return function date_time(str: string): boolean {\n    // http://tools.ietf.org/html/rfc3339#section-5.6\n    const dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n  }\n}\n\nfunction compareDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const d1 = new Date(dt1).valueOf()\n  const d2 = new Date(dt2).valueOf()\n  if (!(d1 && d2)) return undefined\n  return d1 - d2\n}\n\nfunction compareIsoDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)\n  const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)\n  const res = compareDate(d1, d2)\n  if (res === undefined) return undefined\n  return res || compareTime(t1, t2)\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n  /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n  BYTE.lastIndex = 0\n  return BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n  // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n  return Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n  return true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n  if (Z_ANCHOR.test(str)) return false\n  try {\n    new RegExp(str)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n", "import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n", "import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n", "import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n", "import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n", "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n", "import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n", "import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n", "import {\n  DefinedFormats,\n  FormatMode,\n  FormatName,\n  formatNames,\n  fastFormats,\n  fullFormats,\n} from \"./formats\"\nimport formatLimit from \"./limit\"\nimport type Ajv from \"ajv\"\nimport type {Plugin, Format} from \"ajv\"\nimport {_, Name} from \"ajv/dist/compile/codegen\"\n\nexport {FormatMode, FormatName} from \"./formats\"\nexport {LimitFormatError} from \"./limit\"\nexport interface FormatOptions {\n  mode?: FormatMode\n  formats?: FormatName[]\n  keywords?: boolean\n}\n\nexport type FormatsPluginOptions = FormatName[] | FormatOptions\n\nexport interface FormatsPlugin extends Plugin<FormatsPluginOptions> {\n  get: (format: FormatName, mode?: FormatMode) => Format\n}\n\nconst fullName = new Name(\"fullFormats\")\nconst fastName = new Name(\"fastFormats\")\n\nconst formatsPlugin: FormatsPlugin = (\n  ajv: Ajv,\n  opts: FormatsPluginOptions = {keywords: true}\n): Ajv => {\n  if (Array.isArray(opts)) {\n    addFormats(ajv, opts, fullFormats, fullName)\n    return ajv\n  }\n  const [formats, exportName] =\n    opts.mode === \"fast\" ? [fastFormats, fastName] : [fullFormats, fullName]\n  const list = opts.formats || formatNames\n  addFormats(ajv, list, formats, exportName)\n  if (opts.keywords) formatLimit(ajv)\n  return ajv\n}\n\nformatsPlugin.get = (name: FormatName, mode: FormatMode = \"full\"): Format => {\n  const formats = mode === \"fast\" ? fastFormats : fullFormats\n  const f = formats[name]\n  if (!f) throw new Error(`Unknown format \"${name}\"`)\n  return f\n}\n\nfunction addFormats(ajv: Ajv, list: FormatName[], fs: DefinedFormats, exportName: Name): void {\n  ajv.opts.code.formats ??= _`require(\"ajv-formats/dist/formats\").${exportName}`\n  for (const f of list) ajv.addFormat(f, fs[f])\n}\n\nmodule.exports = exports = formatsPlugin\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default formatsPlugin\n", "/**\n * WordPress dependencies\n */\nimport { dispatch, select } from '@wordpress/data';\nimport { sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport { store } from './store';\nimport type {\n\tAbility,\n\tAbilityCategory,\n\tAbilityCategoryArgs,\n\tAbilitiesQueryArgs,\n\tAbilityInput,\n\tAbilityOutput,\n} from './types';\nimport { validateValueFromSchema } from './validation';\n\n/**\n * Get all available abilities with optional filtering.\n *\n * @param args Optional query arguments to filter. Defaults to empty object.\n * @return Array of abilities.\n */\nexport function getAbilities( args: AbilitiesQueryArgs = {} ): Ability[] {\n\treturn select( store ).getAbilities( args );\n}\n\n/**\n * Get a specific ability by name.\n *\n * @param name The ability name.\n * @return The ability or undefined if not found.\n */\nexport function getAbility( name: string ): Ability | undefined {\n\treturn select( store ).getAbility( name );\n}\n\n/**\n * Get all available ability categories.\n *\n * @return Array of categories.\n */\nexport function getAbilityCategories(): AbilityCategory[] {\n\treturn select( store ).getAbilityCategories();\n}\n\n/**\n * Get a specific ability category by slug.\n *\n * @param slug The category slug.\n * @return The category or undefined if not found.\n */\nexport function getAbilityCategory(\n\tslug: string\n): AbilityCategory | undefined {\n\treturn select( store ).getAbilityCategory( slug );\n}\n\n/**\n * Register a client-side ability.\n *\n * Client abilities are executed locally in the browser and must include\n * a callback function. The ability will be validated by the store action,\n * and an error will be thrown if validation fails.\n *\n * The category must already be registered before registering abilities.\n *\n * @param  ability The ability definition including callback.\n * @throws {Error} If the ability fails validation.\n *\n * @example\n * ```js\n * registerAbility({\n *   name: 'my-plugin/navigate',\n *   label: 'Navigate to URL',\n *   description: 'Navigates to a URL within WordPress admin',\n *   category: 'navigation',\n *   input_schema: {\n *     type: 'object',\n *     properties: {\n *       url: { type: 'string' }\n *     },\n *     required: ['url']\n *   },\n *   callback: async ({ url }) => {\n *     window.location.href = url;\n *     return { success: true };\n *   }\n * });\n * ```\n */\nexport function registerAbility( ability: Ability ): void {\n\tdispatch( store ).registerAbility( ability );\n}\n\n/**\n * Unregister an ability from the store.\n *\n * Remove a client-side ability from the store.\n * Note: This will return an error for server-side abilities.\n *\n * @param name The ability name to unregister.\n */\nexport function unregisterAbility( name: string ): void {\n\tdispatch( store ).unregisterAbility( name );\n}\n\n/**\n * Register a client-side ability category.\n *\n * Categories registered on the client are stored alongside server-side categories\n * in the same store and can be used when registering client side abilities.\n * This is useful when registering client-side abilities that introduce new\n * categories not defined by the server.\n *\n * @param  slug Category slug (lowercase alphanumeric with dashes only).\n * @param  args Category arguments (label, description, optional meta).\n * @throws {Error} If the category fails validation.\n *\n * @example\n * ```js\n * // Register a new category for block editor abilities\n * registerAbilityCategory('block-editor', {\n *   label: 'Block Editor',\n *   description: 'Abilities for interacting with the WordPress block editor'\n * });\n *\n * // Then register abilities using this category\n * registerAbility({\n *   name: 'my-plugin/insert-block',\n *   label: 'Insert Block',\n *   description: 'Inserts a block into the editor',\n *   category: 'block-editor',\n *   callback: async ({ blockType }) => {\n *     // Implementation\n *     return { success: true };\n *   }\n * });\n * ```\n */\nexport function registerAbilityCategory(\n\tslug: string,\n\targs: AbilityCategoryArgs\n): void {\n\tdispatch( store ).registerAbilityCategory( slug, args );\n}\n\n/**\n * Unregister an ability category.\n *\n * Removes a category from the store.\n *\n * @param slug The category slug to unregister.\n *\n * @example\n * ```js\n * unregisterAbilityCategory('block-editor');\n * ```\n */\nexport function unregisterAbilityCategory( slug: string ): void {\n\tdispatch( store ).unregisterAbilityCategory( slug );\n}\n\n/**\n * Execute an ability.\n *\n * Executes abilities with validation for client-side abilities only.\n * Server abilities bypass validation as it's handled on the server.\n *\n * @param name  The ability name.\n * @param input Optional input parameters for the ability.\n * @return Promise resolving to the ability execution result.\n * @throws Error if the ability is not found or execution fails.\n */\nexport async function executeAbility(\n\tname: string,\n\tinput?: AbilityInput\n): Promise< AbilityOutput > {\n\tconst ability = getAbility( name );\n\tif ( ! ability ) {\n\t\tthrow new Error( sprintf( 'Ability not found: %s', name ) );\n\t}\n\n\tif ( ! ability.callback ) {\n\t\tthrow new Error(\n\t\t\tsprintf(\n\t\t\t\t'Ability \"%s\" is missing callback. Please ensure the ability is properly registered.',\n\t\t\t\tability.name\n\t\t\t)\n\t\t);\n\t}\n\n\t// Check permission callback if defined\n\tif ( ability.permissionCallback ) {\n\t\tconst hasPermission = await ability.permissionCallback( input );\n\t\tif ( ! hasPermission ) {\n\t\t\tconst error = new Error(\n\t\t\t\tsprintf( 'Permission denied for ability: %s', ability.name )\n\t\t\t);\n\t\t\t( error as any ).code = 'ability_permission_denied';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Validate input\n\tif ( ability.input_schema ) {\n\t\tconst inputValidation = validateValueFromSchema(\n\t\t\tinput,\n\t\t\tability.input_schema,\n\t\t\t'input'\n\t\t);\n\t\tif ( inputValidation !== true ) {\n\t\t\tconst error = new Error(\n\t\t\t\tsprintf(\n\t\t\t\t\t'Ability \"%1$s\" has invalid input. Reason: %2$s',\n\t\t\t\t\tability.name,\n\t\t\t\t\tinputValidation\n\t\t\t\t)\n\t\t\t);\n\t\t\t( error as any ).code = 'ability_invalid_input';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t// Execute the ability\n\tlet result: AbilityOutput;\n\ttry {\n\t\tresult = await ability.callback( input );\n\t} catch ( error ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( `Error executing ability ${ ability.name }:`, error );\n\t\tthrow error;\n\t}\n\n\t// Validate output\n\tif ( ability.output_schema ) {\n\t\tconst outputValidation = validateValueFromSchema(\n\t\t\tresult,\n\t\t\tability.output_schema,\n\t\t\t'output'\n\t\t);\n\t\tif ( outputValidation !== true ) {\n\t\t\tconst error = new Error(\n\t\t\t\tsprintf(\n\t\t\t\t\t'Ability \"%1$s\" has invalid output. Reason: %2$s',\n\t\t\t\t\tability.name,\n\t\t\t\t\toutputValidation\n\t\t\t\t)\n\t\t\t);\n\t\t\t( error as any ).code = 'ability_invalid_output';\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as actions from './actions';\nimport * as selectors from './selectors';\nimport { STORE_NAME } from './constants';\n\n/**\n * The abilities store definition.\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tactions,\n\tselectors,\n} );\n\nregister( store );\n", "/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport type { Ability, AbilityCategory } from '../types';\nimport {\n\tREGISTER_ABILITY,\n\tUNREGISTER_ABILITY,\n\tREGISTER_ABILITY_CATEGORY,\n\tUNREGISTER_ABILITY_CATEGORY,\n} from './constants';\n\n/**\n * Valid keys for an Ability object.\n * Used to filter out non-standard properties from server responses.\n */\nconst ABILITY_KEYS = [\n\t'name',\n\t'label',\n\t'description',\n\t'category',\n\t'input_schema',\n\t'output_schema',\n\t'meta',\n\t'callback',\n\t'permissionCallback',\n] as const;\n\n/**\n * Valid keys for an AbilityCategory object.\n * Used to filter out non-standard properties from server responses.\n */\nconst CATEGORY_KEYS = [ 'slug', 'label', 'description', 'meta' ] as const;\n\n/**\n * Sanitizes an ability object to only include valid properties.\n * This ensures consistent shape regardless of source (server/client).\n *\n * @param ability Raw ability object that may contain extra properties.\n * @return Sanitized ability with only valid properties.\n */\nfunction sanitizeAbility( ability: any ): Ability {\n\treturn Object.keys( ability )\n\t\t.filter(\n\t\t\t( key ) =>\n\t\t\t\tABILITY_KEYS.includes( key as any ) &&\n\t\t\t\tability[ key ] !== undefined\n\t\t)\n\t\t.reduce(\n\t\t\t( obj, key ) => ( { ...obj, [ key ]: ability[ key ] } ),\n\t\t\t{} as Ability\n\t\t);\n}\n\n/**\n * Sanitizes a category object to only include valid properties.\n * This ensures consistent shape regardless of source.\n *\n * @param category Raw category object that may contain extra properties.\n * @return Sanitized category with only valid properties.\n */\nfunction sanitizeCategory( category: any ): AbilityCategory {\n\treturn Object.keys( category )\n\t\t.filter(\n\t\t\t( key ) =>\n\t\t\t\tCATEGORY_KEYS.includes( key as any ) &&\n\t\t\t\tcategory[ key ] !== undefined\n\t\t)\n\t\t.reduce(\n\t\t\t( obj, key ) => ( { ...obj, [ key ]: category[ key ] } ),\n\t\t\t{} as AbilityCategory\n\t\t);\n}\n\ninterface RegisterAbilityAction {\n\ttype: typeof REGISTER_ABILITY;\n\tability: Ability;\n}\n\ninterface UnregisterAbilityAction {\n\ttype: typeof UNREGISTER_ABILITY;\n\tname: string;\n}\n\ninterface RegisterAbilityCategoryAction {\n\ttype: typeof REGISTER_ABILITY_CATEGORY;\n\tcategory: AbilityCategory;\n}\n\ninterface UnregisterAbilityCategoryAction {\n\ttype: typeof UNREGISTER_ABILITY_CATEGORY;\n\tslug: string;\n}\n\ntype AbilitiesAction = RegisterAbilityAction | UnregisterAbilityAction;\n\ntype AbilitiesCategoryAction =\n\t| RegisterAbilityCategoryAction\n\t| UnregisterAbilityCategoryAction;\n\nconst DEFAULT_STATE: Record< string, Ability > = {};\n\n/**\n * Reducer managing the abilities by name.\n *\n * @param state  Current state.\n * @param action Dispatched action.\n * @return New state.\n */\nfunction abilitiesByName(\n\tstate: Record< string, Ability > = DEFAULT_STATE,\n\taction: AbilitiesAction\n): Record< string, Ability > {\n\tswitch ( action.type ) {\n\t\tcase REGISTER_ABILITY: {\n\t\t\tif ( ! action.ability ) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ action.ability.name ]: sanitizeAbility( action.ability ),\n\t\t\t};\n\t\t}\n\t\tcase UNREGISTER_ABILITY: {\n\t\t\tif ( ! state[ action.name ] ) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\tconst { [ action.name ]: _, ...newState } = state;\n\t\t\treturn newState;\n\t\t}\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\nconst DEFAULT_CATEGORIES_STATE: Record< string, AbilityCategory > = {};\n\n/**\n * Reducer managing the categories by slug.\n *\n * @param state  Current state.\n * @param action Dispatched action.\n * @return New state.\n */\nfunction categoriesBySlug(\n\tstate: Record< string, AbilityCategory > = DEFAULT_CATEGORIES_STATE,\n\taction: AbilitiesCategoryAction\n): Record< string, AbilityCategory > {\n\tswitch ( action.type ) {\n\t\tcase REGISTER_ABILITY_CATEGORY: {\n\t\t\tif ( ! action.category ) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t[ action.category.slug ]: sanitizeCategory( action.category ),\n\t\t\t};\n\t\t}\n\t\tcase UNREGISTER_ABILITY_CATEGORY: {\n\t\t\tif ( ! state[ action.slug ] ) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\tconst { [ action.slug ]: _, ...newState } = state;\n\t\t\treturn newState;\n\t\t}\n\t\tdefault:\n\t\t\treturn state;\n\t}\n}\n\nexport default combineReducers( {\n\tabilitiesByName,\n\tcategoriesBySlug,\n} );\n", "/**\n * Store constants\n */\nexport const STORE_NAME = 'core/abilities';\n\n// Validation patterns\nexport const ABILITY_NAME_PATTERN = /^[a-z0-9-]+\\/[a-z0-9-]+$/;\nexport const CATEGORY_SLUG_PATTERN = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\n// Action types\nexport const REGISTER_ABILITY = 'REGISTER_ABILITY';\nexport const UNREGISTER_ABILITY = 'UNREGISTER_ABILITY';\nexport const REGISTER_ABILITY_CATEGORY = 'REGISTER_ABILITY_CATEGORY';\nexport const UNREGISTER_ABILITY_CATEGORY = 'UNREGISTER_ABILITY_CATEGORY';\n", "/**\n * WordPress dependencies\n */\nimport { sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\nimport type { Ability, AbilityCategory, AbilityCategoryArgs } from '../types';\nimport {\n\tREGISTER_ABILITY,\n\tUNREGISTER_ABILITY,\n\tREGISTER_ABILITY_CATEGORY,\n\tUNREGISTER_ABILITY_CATEGORY,\n\tABILITY_NAME_PATTERN,\n\tCATEGORY_SLUG_PATTERN,\n} from './constants';\n\ntype AbilityAnnotations = NonNullable< Ability[ 'meta' ] >[ 'annotations' ];\n\n/**\n * Filters annotations to only include allowed keys with non-null values.\n *\n * @param sourceAnnotations The source annotations object to filter.\n * @param allowedKeys       Array of annotation keys to include.\n * @return Filtered annotations object.\n */\nfunction filterAnnotations< K extends keyof NonNullable< AbilityAnnotations > >(\n\tsourceAnnotations: Record< string, boolean > | undefined,\n\tallowedKeys: readonly K[]\n): NonNullable< AbilityAnnotations > {\n\tconst annotations: NonNullable< AbilityAnnotations > = {};\n\n\tif ( sourceAnnotations ) {\n\t\tfor ( const key of allowedKeys ) {\n\t\t\tif ( sourceAnnotations[ key ] !== undefined ) {\n\t\t\t\tannotations[ key ] = sourceAnnotations[ key ];\n\t\t\t}\n\t\t}\n\t}\n\treturn annotations;\n}\n\n/**\n * Registers an ability in the store.\n *\n * This action validates the ability before registration. If validation fails,\n * an error will be thrown.\n *\n * @param  ability The ability to register.\n * @return Action object or function.\n * @throws {Error} If validation fails.\n */\nexport function registerAbility( ability: Ability ) {\n\t// @ts-expect-error - registry types are not yet available\n\treturn ( { select, dispatch } ) => {\n\t\tif ( ! ability.name ) {\n\t\t\tthrow new Error( 'Ability name is required' );\n\t\t}\n\n\t\t// Validate name format matches server implementation\n\t\tif ( ! ABILITY_NAME_PATTERN.test( ability.name ) ) {\n\t\t\tthrow new Error(\n\t\t\t\t'Ability name must be a string containing a namespace prefix, i.e. \"my-plugin/my-ability\". It can only contain lowercase alphanumeric characters, dashes and the forward slash.'\n\t\t\t);\n\t\t}\n\n\t\tif ( ! ability.label ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf( 'Ability \"%s\" must have a label', ability.name )\n\t\t\t);\n\t\t}\n\n\t\tif ( ! ability.description ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf( 'Ability \"%s\" must have a description', ability.name )\n\t\t\t);\n\t\t}\n\n\t\tif ( ! ability.category ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf( 'Ability \"%s\" must have a category', ability.name )\n\t\t\t);\n\t\t}\n\n\t\t// Validate category format\n\t\tif ( ! CATEGORY_SLUG_PATTERN.test( ability.category ) ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf(\n\t\t\t\t\t'Ability \"%1$s\" has an invalid category. Category must be lowercase alphanumeric with dashes only. Got: \"%2$s\"',\n\t\t\t\t\tability.name,\n\t\t\t\t\tability.category\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Check that the category exists\n\t\tconst categories = select.getAbilityCategories();\n\t\tconst existingCategory = categories.find(\n\t\t\t( cat: AbilityCategory ) => cat.slug === ability.category\n\t\t);\n\t\tif ( ! existingCategory ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf(\n\t\t\t\t\t'Ability \"%1$s\" references non-existent category \"%2$s\". Please register the category first.',\n\t\t\t\t\tability.name,\n\t\t\t\t\tability.category\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Client-side abilities must have a callback\n\t\tif ( ability.callback && typeof ability.callback !== 'function' ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf(\n\t\t\t\t\t'Ability \"%s\" has an invalid callback. Callback must be a function',\n\t\t\t\t\tability.name\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Check if ability is already registered\n\t\tconst existingAbility = select.getAbility( ability.name );\n\t\tif ( existingAbility ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf( 'Ability \"%s\" is already registered', ability.name )\n\t\t\t);\n\t\t}\n\n\t\tconst annotations = filterAnnotations( ability.meta?.annotations, [\n\t\t\t'readonly',\n\t\t\t'destructive',\n\t\t\t'idempotent',\n\t\t\t'serverRegistered',\n\t\t\t'clientRegistered',\n\t\t] );\n\n\t\tif ( ! annotations.serverRegistered ) {\n\t\t\tannotations.clientRegistered = true;\n\t\t}\n\n\t\tconst meta = { annotations };\n\n\t\t// All validation passed, dispatch the registration action\n\t\tdispatch( {\n\t\t\ttype: REGISTER_ABILITY,\n\t\t\tability: {\n\t\t\t\t...ability,\n\t\t\t\tmeta,\n\t\t\t},\n\t\t} );\n\t};\n}\n\n/**\n * Returns an action object used to unregister a client-side ability.\n *\n * @param name The name of the ability to unregister.\n * @return Action object.\n */\nexport function unregisterAbility( name: string ) {\n\treturn {\n\t\ttype: UNREGISTER_ABILITY,\n\t\tname,\n\t};\n}\n\n/**\n * Registers a client-side ability category in the store.\n *\n * This action validates the category before registration. If validation fails,\n * an error will be thrown.\n *\n * @param  slug The unique category slug identifier.\n * @param  args Category arguments (label, description, optional meta).\n * @return Action object or function.\n * @throws {Error} If validation fails.\n */\nexport function registerAbilityCategory(\n\tslug: string,\n\targs: AbilityCategoryArgs\n) {\n\t// @ts-expect-error - registry types are not yet available\n\treturn ( { select, dispatch } ) => {\n\t\tif ( ! slug ) {\n\t\t\tthrow new Error( 'Category slug is required' );\n\t\t}\n\n\t\t// Validate slug format matches server implementation\n\t\tif ( ! CATEGORY_SLUG_PATTERN.test( slug ) ) {\n\t\t\tthrow new Error(\n\t\t\t\t'Category slug must contain only lowercase alphanumeric characters and dashes.'\n\t\t\t);\n\t\t}\n\n\t\t// Check for duplicates\n\t\tconst existingCategory = select.getAbilityCategory( slug );\n\t\tif ( existingCategory ) {\n\t\t\tthrow new Error(\n\t\t\t\tsprintf( 'Category \"%s\" is already registered.', slug )\n\t\t\t);\n\t\t}\n\n\t\t// Validate label presence and type (matches PHP empty() + is_string())\n\t\tif ( ! args.label || typeof args.label !== 'string' ) {\n\t\t\tthrow new Error(\n\t\t\t\t'The category properties must contain a `label` string.'\n\t\t\t);\n\t\t}\n\n\t\t// Validate description presence and type (matches PHP empty() + is_string())\n\t\tif ( ! args.description || typeof args.description !== 'string' ) {\n\t\t\tthrow new Error(\n\t\t\t\t'The category properties must contain a `description` string.'\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\targs.meta !== undefined &&\n\t\t\t( typeof args.meta !== 'object' || Array.isArray( args.meta ) )\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t'The category properties should provide a valid `meta` object.'\n\t\t\t);\n\t\t}\n\n\t\tconst annotations = filterAnnotations( args.meta?.annotations, [\n\t\t\t'serverRegistered',\n\t\t\t'clientRegistered',\n\t\t] );\n\n\t\tif ( ! annotations.serverRegistered ) {\n\t\t\tannotations.clientRegistered = true;\n\t\t}\n\n\t\tconst meta = { annotations };\n\t\tconst category: AbilityCategory = {\n\t\t\tslug,\n\t\t\tlabel: args.label,\n\t\t\tdescription: args.description,\n\t\t\tmeta,\n\t\t};\n\n\t\tdispatch( {\n\t\t\ttype: REGISTER_ABILITY_CATEGORY,\n\t\t\tcategory,\n\t\t} );\n\t};\n}\n\n/**\n * Returns an action object used to unregister a client-side ability category.\n *\n * @param slug The slug of the category to unregister.\n * @return Action object.\n */\nexport function unregisterAbilityCategory( slug: string ) {\n\treturn {\n\t\ttype: UNREGISTER_ABILITY_CATEGORY,\n\t\tslug,\n\t};\n}\n", "/**\n * WordPress dependencies\n */\nimport { createSelector } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport type { Ability, AbilityCategory, AbilitiesQueryArgs } from '../types';\nimport type { AbilitiesState } from './types';\n\n/**\n * Returns all registered abilities.\n * Optionally filters by query arguments.\n *\n * @param state Store state.\n * @param args  Optional query arguments to filter. Defaults to empty object.\n * @return Array of abilities.\n */\nexport const getAbilities = createSelector(\n\t(\n\t\tstate: AbilitiesState,\n\t\t{ category }: AbilitiesQueryArgs = {}\n\t): Ability[] => {\n\t\tconst abilities = Object.values( state.abilitiesByName );\n\t\tif ( category ) {\n\t\t\treturn abilities.filter(\n\t\t\t\t( ability ) => ability.category === category\n\t\t\t);\n\t\t}\n\t\treturn abilities;\n\t},\n\t( state: AbilitiesState, { category }: AbilitiesQueryArgs = {} ) => [\n\t\tstate.abilitiesByName,\n\t\tcategory,\n\t]\n);\n\n/**\n * Returns a specific ability by name.\n *\n * @param state Store state.\n * @param name  Ability name.\n * @return Ability object or undefined if not found.\n */\nexport function getAbility(\n\tstate: AbilitiesState,\n\tname: string\n): Ability | undefined {\n\treturn state.abilitiesByName[ name ];\n}\n\n/**\n * Returns all registered ability categories.\n *\n * @param state Store state.\n * @return Array of categories.\n */\nexport const getAbilityCategories = createSelector(\n\t( state: AbilitiesState ): AbilityCategory[] => {\n\t\treturn Object.values( state.categoriesBySlug );\n\t},\n\t( state: AbilitiesState ) => [ state.categoriesBySlug ]\n);\n\n/**\n * Returns a specific ability category by slug.\n *\n * @param state Store state.\n * @param slug  Category slug.\n * @return Category object or undefined if not found.\n */\nexport function getAbilityCategory(\n\tstate: AbilitiesState,\n\tslug: string\n): AbilityCategory | undefined {\n\treturn state.categoriesBySlug[ slug ];\n}\n", "/**\n * Schema validation for client-side ability input and output schemas using AJV and ajv-formats.\n *\n * This utility provides validation for JSON Schema draft-04.\n * Rules are configured to support the intersection of common rules between JSON Schema draft-04, WordPress (a subset of JSON Schema draft-04),\n * and various providers like OpenAI and Anthropic.\n *\n * @see https://developer.wordpress.org/rest-api/extending-the-rest-api/schema/#json-schema-basics\n */\n\n/**\n * External dependencies\n */\nimport Ajv from 'ajv-draft-04';\nimport addFormats from 'ajv-formats';\n\n/**\n * Internal dependencies\n */\nimport type { ValidationError } from './types';\n\nconst ajv = new Ajv( {\n\tcoerceTypes: false, // No type coercion - AI should send proper JSON\n\tuseDefaults: true,\n\tremoveAdditional: false, // Keep additional properties\n\tallErrors: true,\n\tverbose: true,\n\tallowUnionTypes: true, // Allow anyOf without explicit type\n} );\n\naddFormats( ajv, [ 'date-time', 'email', 'hostname', 'ipv4', 'ipv6', 'uuid' ] );\n\n/**\n * Formats AJV errors into a simple error message.\n * The Abilities API will wrap this with ability_invalid_input/output to match the server side format.\n *\n * @param ajvError The AJV validation error.\n * @param param    The base parameter name.\n * @return Simple error message string.\n */\nfunction formatAjvError( ajvError: any, param: string ): string {\n\t// Convert AJV's instancePath format (/0/prop) to an array like format to better match WordPress ([0][prop])\n\tconst instancePath = ajvError.instancePath\n\t\t? ajvError.instancePath.replace( /\\//g, '][' ).replace( /^\\]\\[/, '[' ) +\n\t\t  ']'\n\t\t: '';\n\tconst fullParam = param + instancePath;\n\n\tswitch ( ajvError.keyword ) {\n\t\tcase 'type':\n\t\t\treturn `${ fullParam } is not of type ${ ajvError.params.type }.`;\n\n\t\tcase 'required':\n\t\t\treturn `${ ajvError.params.missingProperty } is a required property of ${ fullParam }.`;\n\n\t\tcase 'additionalProperties':\n\t\t\treturn `${ ajvError.params.additionalProperty } is not a valid property of Object.`;\n\n\t\tcase 'enum':\n\t\t\tconst enumValues = ajvError.params.allowedValues\n\t\t\t\t.map( ( v: any ) =>\n\t\t\t\t\ttypeof v === 'string' ? v : JSON.stringify( v )\n\t\t\t\t)\n\t\t\t\t.join( ', ' );\n\t\t\treturn ajvError.params.allowedValues.length === 1\n\t\t\t\t? `${ fullParam } is not ${ enumValues }.`\n\t\t\t\t: `${ fullParam } is not one of ${ enumValues }.`;\n\n\t\tcase 'pattern':\n\t\t\treturn `${ fullParam } does not match pattern ${ ajvError.params.pattern }.`;\n\n\t\tcase 'format':\n\t\t\tconst format = ajvError.params.format;\n\t\t\tconst formatMessages: Record< string, string > = {\n\t\t\t\temail: 'Invalid email address.',\n\t\t\t\t'date-time': 'Invalid date.',\n\t\t\t\tuuid: `${ fullParam } is not a valid UUID.`,\n\t\t\t\tipv4: `${ fullParam } is not a valid IP address.`,\n\t\t\t\tipv6: `${ fullParam } is not a valid IP address.`,\n\t\t\t\thostname: `${ fullParam } is not a valid hostname.`,\n\t\t\t};\n\t\t\treturn formatMessages[ format ] || `Invalid ${ format }.`;\n\n\t\tcase 'minimum':\n\t\tcase 'exclusiveMinimum':\n\t\t\treturn ajvError.keyword === 'exclusiveMinimum'\n\t\t\t\t? `${ fullParam } must be greater than ${ ajvError.params.limit }`\n\t\t\t\t: `${ fullParam } must be greater than or equal to ${ ajvError.params.limit }`;\n\n\t\tcase 'maximum':\n\t\tcase 'exclusiveMaximum':\n\t\t\treturn ajvError.keyword === 'exclusiveMaximum'\n\t\t\t\t? `${ fullParam } must be less than ${ ajvError.params.limit }`\n\t\t\t\t: `${ fullParam } must be less than or equal to ${ ajvError.params.limit }`;\n\n\t\tcase 'multipleOf':\n\t\t\treturn `${ fullParam } must be a multiple of ${ ajvError.params.multipleOf }.`;\n\n\t\tcase 'anyOf':\n\t\tcase 'oneOf':\n\t\t\treturn `${ fullParam } is invalid (failed ${ ajvError.keyword } validation).`;\n\n\t\tcase 'minLength':\n\t\t\treturn `${ fullParam } must be at least ${\n\t\t\t\tajvError.params.limit\n\t\t\t} character${ ajvError.params.limit === 1 ? '' : 's' } long.`;\n\n\t\tcase 'maxLength':\n\t\t\treturn `${ fullParam } must be at most ${\n\t\t\t\tajvError.params.limit\n\t\t\t} character${ ajvError.params.limit === 1 ? '' : 's' } long.`;\n\n\t\tcase 'minItems':\n\t\t\treturn `${ fullParam } must contain at least ${\n\t\t\t\tajvError.params.limit\n\t\t\t} item${ ajvError.params.limit === 1 ? '' : 's' }.`;\n\n\t\tcase 'maxItems':\n\t\t\treturn `${ fullParam } must contain at most ${\n\t\t\t\tajvError.params.limit\n\t\t\t} item${ ajvError.params.limit === 1 ? '' : 's' }.`;\n\n\t\tcase 'uniqueItems':\n\t\t\treturn `${ fullParam } has duplicate items.`;\n\n\t\tcase 'minProperties':\n\t\t\treturn `${ fullParam } must contain at least ${\n\t\t\t\tajvError.params.limit\n\t\t\t} propert${ ajvError.params.limit === 1 ? 'y' : 'ies' }.`;\n\n\t\tcase 'maxProperties':\n\t\t\treturn `${ fullParam } must contain at most ${\n\t\t\t\tajvError.params.limit\n\t\t\t} propert${ ajvError.params.limit === 1 ? 'y' : 'ies' }.`;\n\n\t\tdefault:\n\t\t\t// Fallback for any unhandled validation keywords\n\t\t\treturn (\n\t\t\t\tajvError.message ||\n\t\t\t\t`${ fullParam } is invalid (failed ${ ajvError.keyword } validation).`\n\t\t\t);\n\t}\n}\n\n/**\n * Validates a value against a JSON Schema.\n *\n * @param value The value to validate.\n * @param args  The JSON Schema to validate against.\n * @param param Optional parameter name for error messages.\n * @return True if valid, error message string if invalid.\n */\nexport function validateValueFromSchema(\n\tvalue: any,\n\targs: Record< string, any >,\n\tparam = ''\n): true | ValidationError {\n\t// WordPress server expects schema to be an array/object\n\tif ( ! args || typeof args !== 'object' ) {\n\t\t// WordPress issues a _doing_it_wrong for invalid schema\n\t\t// Match this behavior with console.warn on client-side\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn( `Schema must be an object. Received ${ typeof args }.` );\n\t\t// Continue validation, treating as valid (matching server behavior)\n\t\treturn true;\n\t}\n\n\t// Type validation - WordPress REST API requires type to be set\n\tif ( ! args.type && ! args.anyOf && ! args.oneOf ) {\n\t\t// WordPress issues a _doing_it_wrong but continues\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(\n\t\t\t`The \"type\" schema keyword for ${ param || 'value' } is required.`\n\t\t);\n\t\treturn true;\n\t}\n\n\ttry {\n\t\tconst { default: defaultValue, ...schemaWithoutDefault } = args;\n\t\tconst validate = ajv.compile( schemaWithoutDefault );\n\t\tconst valid = validate( value === undefined ? defaultValue : value );\n\n\t\tif ( valid ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Return the first error as a simple message string\n\t\t// The API will wrap this with ability_invalid_input/output\n\t\tif ( validate.errors && validate.errors.length > 0 ) {\n\t\t\t// For anyOf/oneOf, look for the more specific error\n\t\t\tconst anyOfError = validate.errors.find(\n\t\t\t\t( e ) => e.keyword === 'anyOf' || e.keyword === 'oneOf'\n\t\t\t);\n\t\t\tif ( anyOfError ) {\n\t\t\t\treturn formatAjvError( anyOfError, param );\n\t\t\t}\n\t\t\treturn formatAjvError( validate.errors[ 0 ], param );\n\t\t}\n\n\t\treturn `${ param } is invalid.`;\n\t} catch ( error ) {\n\t\t// Handle schema compilation errors\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'Schema compilation error:', error );\n\t\treturn 'Invalid schema provided for validation.';\n\t}\n}\n"],
  "mappings": "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",
  "names": ["require_data", "__commonJSMin", "exports", "module", "require_i18n", "__commonJSMin", "exports", "module", "_CodeOrName", "exports", "Name", "s", "_Code", "code", "item", "_a", "c", "names", "_", "strs", "args", "i", "addCodeArg", "plus", "str", "expr", "safeStringify", "optimize", "arg", "interpolate", "res", "mergeExprItems", "a", "b", "strConcat", "c1", "c2", "x", "stringify", "getProperty", "key", "getEsmExportName", "regexpCode", "rx", "code_1", "ValueError", "name", "UsedValueState", "exports", "Scope", "prefixes", "parent", "nameOrPrefix", "prefix", "ng", "_b", "_a", "ValueScopeName", "nameStr", "value", "property", "itemIndex", "line", "ValueScope", "opts", "valueKey", "vs", "_name", "s", "keyOrRef", "scopeName", "values", "usedValues", "getCode", "valueCode", "code", "nameSet", "def", "code_1", "scope_1", "code_2", "exports", "scope_2", "Node", "_names", "_constants", "Def", "varKind", "name", "rhs", "es5", "_n", "names", "constants", "optimizeExpr", "Assign", "lhs", "sideEffects", "addExprNames", "AssignOp", "op", "Label", "label", "Break", "Throw", "error", "AnyCode", "code", "ParentNode", "nodes", "opts", "n", "i", "subtractNames", "addNames", "BlockNode", "Root", "Else", "If", "_If", "condition", "cond", "e", "ns", "not", "_a", "For", "ForLoop", "iteration", "ForRange", "from", "to", "ForIter", "loop", "iterable", "Func", "args", "async", "Return", "Try", "_b", "Catch", "Finally", "CodeGen", "extScope", "prefix", "prefixOrName", "value", "keyOrRef", "scopeName", "nameOrPrefix", "constant", "_constant", "c", "keyValues", "key", "thenBody", "elseBody", "node", "forBody", "arr", "obj", "tryBody", "catchCode", "finallyCode", "body", "nodeCount", "len", "toClose", "funcBody", "N1", "N2", "expr", "replaceName", "canOptimize", "items", "x", "par", "andCode", "mappend", "and", "orCode", "or", "y", "codegen_1", "code_1", "toHash", "arr", "hash", "item", "exports", "alwaysValidSchema", "it", "schema", "checkUnknownRules", "schemaHasRules", "opts", "self", "rules", "key", "checkStrictMode", "schemaHasRulesButRef", "RULES", "schemaRefOrVal", "topSchemaRef", "schemaPath", "keyword", "$data", "unescapeFragment", "str", "unescapeJsonPointer", "escapeFragment", "escapeJsonPointer", "eachItem", "xs", "f", "x", "makeMergeEvaluated", "mergeNames", "mergeToName", "mergeValues", "resultToName", "gen", "from", "to", "toName", "res", "setEvaluated", "evaluatedPropsToName", "items", "ps", "props", "p", "snippets", "useFunc", "Type", "getErrorPath", "dataProp", "dataPropType", "jsPropertySyntax", "isNumber", "msg", "mode", "codegen_1", "names", "exports", "codegen_1", "util_1", "names_1", "exports", "keyword", "schemaType", "reportError", "cxt", "error", "errorPaths", "overrideAllErrors", "it", "gen", "compositeRule", "allErrors", "errObj", "errorObjectCode", "addError", "returnErrors", "reportExtraError", "resetErrorsCount", "errsCount", "extendErrors", "schemaValue", "data", "err", "i", "errs", "validateName", "schemaEnv", "E", "createErrors", "errorObject", "keyValues", "errorInstancePath", "errorSchemaPath", "extraErrorProps", "errorPath", "instancePath", "instPath", "errSchemaPath", "schemaPath", "parentSchema", "schPath", "params", "message", "opts", "propertyName", "topSchemaRef", "errors_1", "codegen_1", "names_1", "boolError", "topBoolOrEmptySchema", "it", "gen", "schema", "validateName", "falseSchemaError", "exports", "boolOrEmptySchema", "valid", "overrideAllErrors", "data", "cxt", "_jsonTypes", "jsonTypes", "isJSONType", "x", "exports", "getRules", "groups", "schemaHasRulesForType", "schema", "self", "type", "group", "shouldUseGroup", "exports", "rule", "shouldUseRule", "_a", "kwd", "rules_1", "applicability_1", "errors_1", "codegen_1", "util_1", "DataType", "exports", "getSchemaTypes", "schema", "types", "getJSONTypes", "ts", "coerceAndCheckDataType", "it", "gen", "data", "opts", "coerceTo", "coerceToTypes", "checkTypes", "wrongType", "checkDataTypes", "coerceData", "reportTypeError", "COERCIBLE", "coerceTypes", "t", "dataType", "coerced", "coerceSpecificType", "assignParentData", "parentData", "parentDataProperty", "expr", "checkDataType", "strictNums", "correct", "EQ", "cond", "numCond", "_cond", "dataTypes", "notObj", "typeError", "schemaValue", "cxt", "getTypeErrorContext", "schemaCode", "codegen_1", "util_1", "assignDefaults", "it", "ty", "properties", "items", "key", "assignDefault", "sch", "i", "exports", "prop", "defaultValue", "gen", "compositeRule", "data", "opts", "childData", "condition", "codegen_1", "util_1", "names_1", "util_2", "checkReportMissingProp", "cxt", "prop", "gen", "data", "it", "noPropertyInData", "exports", "checkMissingProp", "opts", "properties", "missing", "reportMissingProp", "hasPropFunc", "isOwnProperty", "property", "propertyInData", "ownProperties", "cond", "allSchemaProperties", "schemaMap", "p", "schemaProperties", "callValidateCode", "schemaCode", "topSchemaRef", "schemaPath", "errorPath", "func", "context", "passSchema", "dataAndSchema", "valCxt", "args", "newRegExp", "usePattern", "pattern", "u", "regExp", "rx", "validateArray", "keyword", "valid", "validArr", "validateItems", "notValid", "len", "i", "validateUnion", "schema", "sch", "schValid", "_sch", "schCxt", "codegen_1", "names_1", "code_1", "errors_1", "macroKeywordCode", "cxt", "def", "gen", "keyword", "schema", "parentSchema", "it", "macroSchema", "schemaRef", "useKeyword", "valid", "exports", "funcKeywordCode", "$data", "checkAsyncKeyword", "validate", "validateRef", "validateKeyword", "_a", "assignValid", "modifyData", "reportErrs", "ruleErrs", "validateAsync", "validateSync", "addErrs", "e", "validateErrs", "_await", "passCxt", "passSchema", "errors", "data", "errs", "schemaEnv", "result", "validSchemaType", "schemaType", "allowUndefined", "st", "validateKeywordUsage", "opts", "self", "errSchemaPath", "deps", "kwd", "msg", "codegen_1", "util_1", "getSubschema", "it", "keyword", "schemaProp", "schema", "schemaPath", "errSchemaPath", "topSchemaRef", "sch", "exports", "extendSubschemaData", "subschema", "dataProp", "dpType", "data", "dataTypes", "propertyName", "gen", "errorPath", "dataPathArr", "opts", "nextData", "dataContextProps", "_nextData", "extendSubschemaMode", "jtdDiscriminator", "jtdMetadata", "compositeRule", "createErrors", "allErrors", "require_fast_deep_equal", "__commonJSMin", "exports", "module", "equal", "a", "b", "length", "i", "keys", "key", "require_json_schema_traverse", "__commonJSMin", "exports", "module", "traverse", "schema", "opts", "cb", "pre", "post", "_traverse", "jsonPtr", "rootSchema", "parentJsonPtr", "parentKeyword", "parentSchema", "keyIndex", "key", "sch", "i", "prop", "escapeJsonPtr", "str", "util_1", "equal", "traverse", "SIMPLE_INLINED", "inlineRef", "schema", "limit", "hasRef", "countKeys", "exports", "REF_KEYWORDS", "key", "sch", "count", "getFullPath", "resolver", "id", "normalize", "normalizeId", "p", "_getFullPath", "TRAILING_SLASH_HASH", "resolveUrl", "baseId", "ANCHOR", "getSchemaRefs", "schemaId", "uriResolver", "schId", "baseIds", "pathPrefix", "localRefs", "schemaRefs", "jsonPtr", "_", "parentJsonPtr", "fullPath", "innerBaseId", "addRef", "addAnchor", "ref", "_resolve", "ambiguos", "schOrRef", "checkAmbiguosRef", "anchor", "sch1", "sch2", "boolSchema_1", "dataType_1", "applicability_1", "dataType_2", "defaults_1", "keyword_1", "subschema_1", "codegen_1", "names_1", "resolve_1", "util_1", "errors_1", "validateFunctionCode", "it", "isSchemaObj", "checkKeywords", "schemaCxtHasRules", "topSchemaObjCode", "validateFunction", "exports", "gen", "validateName", "schema", "schemaEnv", "opts", "body", "funcSourceUrl", "destructureValCxtES5", "destructureValCxt", "commentKeyword", "checkNoDefault", "resetEvaluated", "typeAndKeywords", "returnResults", "schId", "subschemaCode", "valid", "subSchemaObjCode", "self", "key", "updateContext", "checkAsyncSchema", "errsCount", "checkRefsAndKeywords", "schemaKeywords", "types", "checkedTypes", "errSchemaPath", "msg", "schemaPath", "rootName", "ValidationError", "assignEvaluated", "evaluated", "props", "items", "typeErrors", "data", "allErrors", "RULES", "keywordCode", "checkStrictTypes", "group", "groupKeywords", "iterateKeywords", "useDefaults", "rule", "checkContextTypes", "checkMultipleTypes", "checkKeywordTypes", "t", "includesType", "strictTypesError", "narrowSchemaTypes", "ts", "rules", "keyword", "type", "hasApplicableType", "schTs", "kwdT", "withTypes", "KeywordCxt", "def", "getData", "condition", "successAction", "failAction", "schemaCode", "append", "errorParams", "errorPaths", "cond", "obj", "assign", "codeBlock", "$dataValid", "schemaType", "wrong$DataType", "invalid$DataSchema", "st", "validateSchemaRef", "appl", "subschema", "nextContext", "schemaCxt", "toName", "ruleType", "cxt", "JSON_POINTER", "RELATIVE_JSON_POINTER", "$data", "dataLevel", "dataNames", "dataPathArr", "jsonPointer", "matches", "up", "errorMsg", "expr", "segments", "segment", "pointerType", "ValidationError", "errors", "exports", "resolve_1", "MissingRefError", "resolver", "baseId", "ref", "msg", "exports", "codegen_1", "validation_error_1", "names_1", "resolve_1", "util_1", "validate_1", "SchemaEnv", "env", "schema", "_a", "exports", "compileSchema", "sch", "_sch", "getCompilingSchema", "rootId", "es5", "lines", "ownProperties", "gen", "_ValidationError", "validateName", "schemaCxt", "sourceCode", "validateCode", "validate", "props", "items", "e", "resolveRef", "root", "baseId", "ref", "schOrFunc", "resolve", "schemaId", "inlineOrCompile", "schEnv", "sameSchemaEnv", "s1", "s2", "resolveSchema", "p", "refPath", "getJsonPointer", "id", "schOrRef", "schId", "PREVENT_SCOPE_CHANGE", "parsedRef", "part", "partSchema", "$ref", "require_data", "__commonJSMin", "exports", "module", "require_scopedChars", "__commonJSMin", "exports", "module", "HEX", "require_utils", "__commonJSMin", "exports", "module", "HEX", "normalizeIPv4", "host", "findToken", "matches", "address", "stripLeadingZeros", "stringArrayToHexStripped", "input", "keepZero", "acc", "strip", "c", "getIPV6", "tokenCount", "output", "buffer", "isZone", "endipv6Encountered", "endIpv6", "consume", "hex", "i", "cursor", "normalizeIPv6", "opts", "ipv6", "newHost", "escapedHost", "str", "token", "out", "skip", "l", "ind", "RDS1", "RDS2", "RDS3", "RDS5", "removeDotSegments", "im", "normalizeComponentEncoding", "components", "esc", "func", "recomposeAuthority", "options", "uriTokens", "ipV4res", "ipV6res", "require_schemes", "__commonJSMin", "exports", "module", "UUID_REG", "URN_REG", "isSecure", "wsComponents", "httpParse", "components", "httpSerialize", "secure", "wsParse", "wsSerialize", "path", "query", "urnParse", "urnComponents", "options", "matches", "scheme", "urnScheme", "schemeHandler", "SCHEMES", "urnSerialize", "nid", "uriComponents", "nss", "urnuuidParse", "uuidComponents", "urnuuidSerialize", "http", "https", "ws", "wss", "urn", "urnuuid", "require_fast_uri", "__commonJSMin", "exports", "module", "normalizeIPv6", "normalizeIPv4", "removeDotSegments", "recomposeAuthority", "normalizeComponentEncoding", "SCHEMES", "normalize", "uri", "options", "serialize", "parse", "resolve", "baseURI", "relativeURI", "schemelessOptions", "resolved", "resolveComponents", "base", "relative", "skipNormalization", "target", "equal", "uriA", "uriB", "cmpts", "opts", "components", "uriTokens", "schemeHandler", "authority", "s", "hexLookUp", "v", "k", "nonSimpleDomain", "value", "code", "i", "len", "URI_PARSE", "parsed", "gotEncoding", "isIP", "matches", "ipv4result", "ipv6result", "e", "fastUri", "uri", "exports", "validate_1", "exports", "codegen_1", "validation_error_1", "ref_error_1", "rules_1", "compile_1", "codegen_2", "resolve_1", "dataType_1", "util_1", "$dataRefSchema", "uri_1", "defaultRegExp", "str", "flags", "META_IGNORE_OPTIONS", "EXT_SCOPE_NAMES", "removedOptions", "deprecatedOptions", "MAX_EXPRESSION", "requiredOptions", "o", "s", "_optz", "_a", "optimize", "regExp", "_c", "_b", "uriResolver", "_d", "_f", "_e", "_h", "_g", "_k", "_j", "_m", "_l", "_p", "_o", "_q", "_r", "_s", "_t", "_u", "_v", "_w", "_x", "_y", "_z", "_0", "Ajv", "opts", "es5", "lines", "getLogger", "formatOpt", "checkOptions", "getMetaSchemaOptions", "addInitialFormats", "addInitialKeywords", "addInitialSchemas", "$data", "meta", "schemaId", "_dataRefSchema", "schemaKeyRef", "data", "v", "valid", "schema", "_meta", "sch", "loadSchema", "runCompileAsync", "_schema", "loadMetaSchema", "_compileAsync", "$ref", "e", "checkLoaded", "loadMissingSchema", "ref", "missingRef", "_loadSchema", "p", "key", "_validateSchema", "id", "throwOrLogError", "$schema", "message", "keyRef", "getSchEnv", "root", "cacheKey", "definitions", "def", "kwdOrDef", "keyword", "checkKeyword", "kwd", "addRule", "keywordMetaschema", "definition", "k", "t", "rule", "RULES", "group", "i", "name", "format", "errors", "separator", "dataVar", "text", "msg", "metaSchema", "keywordsJsonPointers", "rules", "jsonPointer", "segments", "keywords", "seg", "schemaOrData", "schemas", "regex", "baseId", "validateSchema", "addSchema", "localRefs", "currentOpts", "checkOpts", "options", "log", "opt", "optsSchemas", "defs", "metaOpts", "noLogs", "logger", "KEYWORD_NAME", "dataType", "post", "ruleGroup", "addBeforeRule", "before", "_rule", "$dataRef", "ref_error_1", "code_1", "codegen_1", "names_1", "compile_1", "util_1", "def", "cxt", "gen", "$ref", "it", "baseId", "env", "validateName", "opts", "self", "root", "callRootRef", "schOrEnv", "callValidate", "inlineRefSchema", "callRef", "rootName", "sch", "v", "getValidate", "schName", "valid", "schCxt", "exports", "$async", "allErrors", "passCxt", "callAsyncRef", "callSyncRef", "addEvaluatedFrom", "e", "addErrorsFrom", "source", "errs", "schEvaluated", "_a", "props", "items", "ref_1", "core", "exports", "core_1", "codegen_1", "ops", "KWDs", "error", "cxt", "kwdOp", "def", "data", "schemaCode", "keyword", "opsIdx", "_a", "exports", "KWDs", "def", "keyword", "parentSchema", "limitKwd", "exports", "codegen_1", "error", "schemaCode", "def", "cxt", "gen", "data", "it", "prec", "res", "invalid", "exports", "ucs2length", "str", "len", "length", "pos", "value", "exports", "codegen_1", "util_1", "ucs2length_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "it", "op", "len", "exports", "code_1", "codegen_1", "error", "schemaCode", "def", "cxt", "data", "$data", "schema", "it", "u", "regExp", "exports", "codegen_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "op", "exports", "code_1", "codegen_1", "util_1", "error", "missingProperty", "def", "cxt", "gen", "schema", "schemaCode", "data", "$data", "it", "opts", "useLoop", "allErrorsMode", "exitOnErrorMode", "props", "definedProperties", "requiredKey", "schemaPath", "msg", "loopAllRequired", "prop", "missing", "valid", "loopUntilMissing", "exports", "codegen_1", "error", "keyword", "schemaCode", "comp", "def", "cxt", "data", "op", "exports", "equal", "exports", "dataType_1", "codegen_1", "util_1", "equal_1", "error", "i", "j", "def", "cxt", "gen", "data", "$data", "schema", "parentSchema", "schemaCode", "it", "valid", "itemTypes", "validateUniqueItems", "canOptimize", "loopN", "loopN2", "t", "item", "wrongType", "indices", "eql", "outer", "exports", "codegen_1", "util_1", "equal_1", "error", "schemaCode", "def", "cxt", "gen", "data", "$data", "schema", "exports", "codegen_1", "util_1", "equal_1", "error", "schemaCode", "def", "cxt", "gen", "data", "$data", "schema", "it", "useLoop", "eql", "getEql", "valid", "loopEnum", "vSchema", "_x", "i", "equalCode", "v", "sch", "exports", "limitNumber_1", "limitNumberExclusive_1", "multipleOf_1", "limitLength_1", "pattern_1", "limitProperties_1", "required_1", "limitItems_1", "uniqueItems_1", "const_1", "enum_1", "validation", "exports", "codegen_1", "util_1", "error", "len", "def", "cxt", "parentSchema", "it", "items", "validateAdditionalItems", "gen", "schema", "data", "keyword", "valid", "validateItems", "i", "exports", "codegen_1", "util_1", "code_1", "def", "cxt", "schema", "it", "validateTuple", "extraItems", "schArr", "gen", "parentSchema", "data", "keyword", "checkStrictTuple", "valid", "len", "sch", "i", "opts", "errSchemaPath", "l", "fullTuple", "msg", "exports", "items_1", "def", "cxt", "exports", "codegen_1", "util_1", "code_1", "additionalItems_1", "error", "len", "def", "cxt", "schema", "parentSchema", "it", "prefixItems", "exports", "codegen_1", "util_1", "error", "min", "max", "def", "cxt", "gen", "schema", "parentSchema", "data", "it", "minContains", "maxContains", "len", "cond", "valid", "validateItems", "validateItemsWithCount", "schValid", "count", "checkLimits", "_valid", "block", "i", "exports", "codegen_1", "util_1", "code_1", "exports", "property", "depsCount", "deps", "property_ies", "missingProperty", "def", "cxt", "propDeps", "schDeps", "splitDependencies", "validatePropertyDeps", "validateSchemaDeps", "schema", "propertyDeps", "schemaDeps", "key", "gen", "data", "it", "missing", "prop", "hasProperty", "depProp", "keyword", "valid", "schCxt", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "data", "it", "valid", "key", "exports", "code_1", "codegen_1", "names_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "parentSchema", "data", "errsCount", "it", "allErrors", "opts", "props", "patProps", "checkAdditionalProperties", "key", "additionalPropertyCode", "isAdditional", "definedProp", "propsSchema", "p", "deleteAdditional", "valid", "applyAdditionalSchema", "errors", "subschema", "exports", "validate_1", "code_1", "util_1", "additionalProperties_1", "def", "cxt", "gen", "schema", "parentSchema", "data", "it", "allProps", "prop", "properties", "p", "valid", "hasDefault", "applyPropertySchema", "exports", "code_1", "codegen_1", "util_1", "util_2", "def", "cxt", "gen", "schema", "data", "parentSchema", "it", "opts", "patterns", "alwaysValidPatterns", "p", "checkProperties", "valid", "props", "validatePatternProperties", "pat", "checkMatchingProperties", "validateProperties", "prop", "key", "alwaysValid", "exports", "util_1", "def", "cxt", "gen", "schema", "it", "valid", "exports", "code_1", "def", "exports", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "schema", "parentSchema", "it", "schArr", "valid", "passing", "schValid", "validateOneOf", "sch", "i", "schCxt", "exports", "util_1", "def", "cxt", "gen", "schema", "it", "valid", "sch", "schCxt", "exports", "codegen_1", "util_1", "error", "params", "def", "cxt", "gen", "parentSchema", "it", "hasThen", "hasSchema", "hasElse", "valid", "schValid", "validateIf", "ifClause", "validateClause", "schCxt", "keyword", "schema", "exports", "util_1", "def", "keyword", "parentSchema", "it", "exports", "additionalItems_1", "prefixItems_1", "items_1", "items2020_1", "contains_1", "dependencies_1", "propertyNames_1", "additionalProperties_1", "properties_1", "patternProperties_1", "not_1", "anyOf_1", "oneOf_1", "allOf_1", "if_1", "thenElse_1", "getApplicator", "draft2020", "applicator", "exports", "codegen_1", "error", "schemaCode", "def", "cxt", "ruleType", "gen", "data", "$data", "schema", "it", "opts", "errSchemaPath", "schemaEnv", "self", "validate$DataFormat", "validateFormat", "fmts", "fDef", "fType", "format", "unknownFmt", "invalidFmt", "callFormat", "validData", "formatDef", "unknownFormat", "fmtType", "fmtRef", "getFormat", "validCondition", "unknownMsg", "fmtDef", "code", "fmt", "exports", "format_1", "format", "exports", "core_1", "validation_1", "applicator_1", "format_1", "metadataVocabulary", "draft4Vocabularies", "exports", "DiscrError", "exports", "codegen_1", "types_1", "compile_1", "ref_error_1", "util_1", "error", "discrError", "tagName", "tag", "def", "cxt", "gen", "data", "schema", "parentSchema", "it", "oneOf", "valid", "validateMapping", "mapping", "getMapping", "tagValue", "applyTagSchema", "schemaProp", "_valid", "schCxt", "oneOfMapping", "topRequired", "hasRequired", "tagRequired", "i", "sch", "ref", "propSch", "_a", "addMappings", "required", "addMapping", "exports", "require_json_schema_draft_04", "__commonJSMin", "exports", "module", "core_1", "draft4_1", "discriminator_1", "draft4MetaSchema", "META_SUPPORT_DATA", "META_SCHEMA_ID", "Ajv", "opts", "v", "metaSchema", "module", "exports", "core_2", "core_3", "fmtDef", "validate", "compare", "exports", "date", "compareDate", "getTime", "compareTime", "getDateTime", "compareDateTime", "compareIsoTime", "compareIsoDateTime", "uri", "regex", "byte", "validateInt32", "validateInt64", "validateNumber", "isLeapYear", "year", "DATE", "DAYS", "str", "matches", "month", "day", "d1", "d2", "TIME", "strictTimeZone", "hr", "min", "sec", "tz", "tzSign", "tzH", "tzM", "utcMin", "utcHr", "s1", "s2", "t1", "t2", "a1", "a2", "DATE_TIME_SEPARATOR", "time", "dateTime", "dt1", "dt2", "res", "NOT_URI_FRAGMENT", "URI", "BYTE", "MIN_INT32", "MAX_INT32", "value", "Z_ANCHOR", "def", "exports", "id_1", "ref_1", "core", "exports", "codegen_1", "ops", "KWDs", "error", "keyword", "schemaCode", "def", "cxt", "data", "exports", "limitNumber_1", "multipleOf_1", "limitLength_1", "pattern_1", "limitProperties_1", "required_1", "limitItems_1", "uniqueItems_1", "const_1", "enum_1", "validation", "exports", "exports", "core_1", "validation_1", "applicator_1", "format_1", "metadata_1", "draft7Vocabularies", "exports", "require_json_schema_draft_07", "__commonJSMin", "exports", "module", "core_1", "draft7_1", "discriminator_1", "draft7MetaSchema", "META_SUPPORT_DATA", "META_SCHEMA_ID", "Ajv", "v", "metaSchema", "exports", "module", "validate_1", "codegen_1", "validation_error_1", "ref_error_1", "ajv_1", "codegen_1", "ops", "KWDs", "error", "keyword", "schemaCode", "exports", "cxt", "gen", "data", "it", "opts", "self", "fCxt", "validate$DataFormat", "validateFormat", "fmts", "fmt", "compareCode", "format", "fmtDef", "formatLimitPlugin", "ajv", "formats_1", "limit_1", "codegen_1", "fullName", "fastName", "formatsPlugin", "ajv", "opts", "addFormats", "formats", "exportName", "list", "name", "mode", "f", "fs", "_a", "_b", "module", "exports", "import_data", "import_i18n", "import_data", "import_data", "STORE_NAME", "ABILITY_NAME_PATTERN", "CATEGORY_SLUG_PATTERN", "REGISTER_ABILITY", "UNREGISTER_ABILITY", "REGISTER_ABILITY_CATEGORY", "UNREGISTER_ABILITY_CATEGORY", "ABILITY_KEYS", "CATEGORY_KEYS", "sanitizeAbility", "ability", "key", "obj", "sanitizeCategory", "category", "DEFAULT_STATE", "abilitiesByName", "state", "action", "REGISTER_ABILITY", "UNREGISTER_ABILITY", "_", "newState", "DEFAULT_CATEGORIES_STATE", "categoriesBySlug", "REGISTER_ABILITY_CATEGORY", "UNREGISTER_ABILITY_CATEGORY", "reducer_default", "import_i18n", "filterAnnotations", "sourceAnnotations", "allowedKeys", "annotations", "key", "registerAbility", "ability", "select", "dispatch", "ABILITY_NAME_PATTERN", "CATEGORY_SLUG_PATTERN", "cat", "REGISTER_ABILITY", "unregisterAbility", "name", "UNREGISTER_ABILITY", "registerAbilityCategory", "slug", "args", "meta", "category", "REGISTER_ABILITY_CATEGORY", "unregisterAbilityCategory", "UNREGISTER_ABILITY_CATEGORY", "import_data", "getAbilities", "state", "category", "abilities", "ability", "getAbility", "name", "getAbilityCategories", "getAbilityCategory", "slug", "store", "STORE_NAME", "reducer_default", "actions_exports", "selectors_exports", "import_ajv_draft_04", "import_ajv_formats", "ajv", "Ajv", "addFormats", "formatAjvError", "ajvError", "param", "instancePath", "fullParam", "enumValues", "v", "format", "validateValueFromSchema", "value", "args", "defaultValue", "schemaWithoutDefault", "validate", "anyOfError", "e", "error", "getAbilities", "args", "store", "getAbility", "name", "getAbilityCategories", "getAbilityCategory", "slug", "registerAbility", "ability", "unregisterAbility", "registerAbilityCategory", "unregisterAbilityCategory", "executeAbility", "input", "error", "inputValidation", "validateValueFromSchema", "result", "outputValidation"]
}
