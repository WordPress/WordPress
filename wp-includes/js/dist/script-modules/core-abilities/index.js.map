{
  "version": 3,
  "sources": ["package-external:@wordpress/api-fetch", "package-external:@wordpress/url", "../../../packages/core-abilities/src/index.ts"],
  "sourcesContent": ["module.exports = window.wp.apiFetch;", "module.exports = window.wp.url;", "/**\n * WordPress dependencies\n */\nimport { registerAbility, registerAbilityCategory } from '@wordpress/abilities';\nimport type {\n\tAbility,\n\tAbilityCategory,\n\tAbilityInput,\n\tAbilityOutput,\n} from '@wordpress/abilities';\nimport apiFetch from '@wordpress/api-fetch';\nimport { addQueryArgs } from '@wordpress/url';\n\n/**\n * API endpoint constants.\n */\nconst API_BASE = '/wp-abilities/v1';\nconst ABILITIES_ENDPOINT = `${ API_BASE }/abilities`;\nconst CATEGORIES_ENDPOINT = `${ API_BASE }/categories`;\n\n/**\n * Creates a serverCallback function for a WordPress REST API ability.\n *\n * @param ability The ability to create a callback for.\n * @return The serverCallback function.\n */\nfunction createServerCallback(\n\tability: Ability\n): ( input: AbilityInput ) => Promise< AbilityOutput > {\n\treturn async ( input: AbilityInput ) => {\n\t\t// Determine HTTP method based on ability annotations\n\t\tlet method = 'POST';\n\t\tif ( !! ability.meta?.annotations?.readonly ) {\n\t\t\tmethod = 'GET';\n\t\t} else if (\n\t\t\t!! ability.meta?.annotations?.destructive &&\n\t\t\t!! ability.meta?.annotations?.idempotent\n\t\t) {\n\t\t\tmethod = 'DELETE';\n\t\t}\n\n\t\tlet path = `${ ABILITIES_ENDPOINT }/${ ability.name }/run`;\n\t\tconst options: {\n\t\t\tmethod: string;\n\t\t\tdata?: { input: AbilityInput };\n\t\t} = {\n\t\t\tmethod,\n\t\t};\n\n\t\tif (\n\t\t\t[ 'GET', 'DELETE' ].includes( method ) &&\n\t\t\tinput !== null &&\n\t\t\tinput !== undefined\n\t\t) {\n\t\t\t// For GET and DELETE requests, pass the input as query parameters.\n\t\t\tpath = addQueryArgs( path, { input } );\n\t\t} else if (\n\t\t\tmethod === 'POST' &&\n\t\t\tinput !== null &&\n\t\t\tinput !== undefined\n\t\t) {\n\t\t\toptions.data = { input };\n\t\t}\n\n\t\t// Input and output validation happens on the server side for these abilities.\n\t\treturn apiFetch< AbilityOutput >( {\n\t\t\tpath,\n\t\t\t...options,\n\t\t} );\n\t};\n}\n\n/**\n * Fetches and registers all ability categories from WordPress.\n */\nasync function initializeCategories(): Promise< void > {\n\ttry {\n\t\tconst categories = await apiFetch< AbilityCategory[] >( {\n\t\t\tpath: addQueryArgs( CATEGORIES_ENDPOINT, {\n\t\t\t\tper_page: -1,\n\t\t\t\tcontext: 'edit',\n\t\t\t} ),\n\t\t} );\n\n\t\tif ( categories && Array.isArray( categories ) ) {\n\t\t\tfor ( const category of categories ) {\n\t\t\t\tregisterAbilityCategory( category.slug, {\n\t\t\t\t\tlabel: category.label,\n\t\t\t\t\tdescription: category.description,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tannotations: { serverRegistered: true },\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t} catch ( error ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'Failed to fetch ability categories:', error );\n\t}\n}\n\n/**\n * Fetches and registers all abilities from WordPress.\n */\nasync function initializeAbilities(): Promise< void > {\n\ttry {\n\t\tconst abilities = await apiFetch< Ability[] >( {\n\t\t\tpath: addQueryArgs( ABILITIES_ENDPOINT, {\n\t\t\t\tper_page: -1,\n\t\t\t\tcontext: 'edit',\n\t\t\t} ),\n\t\t} );\n\n\t\tif ( abilities && Array.isArray( abilities ) ) {\n\t\t\tfor ( const ability of abilities ) {\n\t\t\t\t// Register the ability with a callback\n\t\t\t\t// The abilities package filters annotations to allowed keys\n\t\t\t\tregisterAbility( {\n\t\t\t\t\t...ability,\n\t\t\t\t\tcallback: createServerCallback( ability ),\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tannotations: {\n\t\t\t\t\t\t\t...ability.meta?.annotations,\n\t\t\t\t\t\t\tserverRegistered: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t} catch ( error ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'Failed to fetch abilities:', error );\n\t}\n}\n\n/**\n * Initialize WordPress abilities integration.\n */\nasync function initialize(): Promise< void > {\n\t// Fetch and register categories, then abilities\n\tawait initializeCategories();\n\tawait initializeAbilities();\n}\n\n// Auto-initialize on import\ninitialize();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACA3B;AAAA;AAAA,WAAO,UAAU,OAAO,GAAG;AAAA;AAAA;;;ACU3B,uBAAqB;AACrB,iBAA6B;AAR7B,SAAS,iBAAiB,+BAA+B;AAazD,IAAM,WAAW;AACjB,IAAM,qBAAqB,GAAI,QAAS;AACxC,IAAM,sBAAsB,GAAI,QAAS;AAQzC,SAAS,qBACR,SACsD;AACtD,SAAO,OAAQ,UAAyB;AAEvC,QAAI,SAAS;AACb,QAAK,CAAC,CAAE,QAAQ,MAAM,aAAa,UAAW;AAC7C,eAAS;IACV,WACC,CAAC,CAAE,QAAQ,MAAM,aAAa,eAC9B,CAAC,CAAE,QAAQ,MAAM,aAAa,YAC7B;AACD,eAAS;IACV;AAEA,QAAI,OAAO,GAAI,kBAAmB,IAAK,QAAQ,IAAK;AACpD,UAAM,UAGF;MACH;IACD;AAEA,QACC,CAAE,OAAO,QAAS,EAAE,SAAU,MAAO,KACrC,UAAU,QACV,UAAU,QACT;AAED,iBAAO,yBAAc,MAAM,EAAE,MAAM,CAAE;IACtC,WACC,WAAW,UACX,UAAU,QACV,UAAU,QACT;AACD,cAAQ,OAAO,EAAE,MAAM;IACxB;AAGA,eAAO,iBAAAA,SAA2B;MACjC;MACA,GAAG;IACJ,CAAE;EACH;AACD;AAKA,eAAe,uBAAwC;AACtD,MAAI;AACH,UAAM,aAAa,UAAM,iBAAAA,SAA+B;MACvD,UAAM,yBAAc,qBAAqB;QACxC,UAAU;QACV,SAAS;MACV,CAAE;IACH,CAAE;AAEF,QAAK,cAAc,MAAM,QAAS,UAAW,GAAI;AAChD,iBAAY,YAAY,YAAa;AACpC,gCAAyB,SAAS,MAAM;UACvC,OAAO,SAAS;UAChB,aAAa,SAAS;UACtB,MAAM;YACL,aAAa,EAAE,kBAAkB,KAAK;UACvC;QACD,CAAE;MACH;IACD;EACD,SAAU,OAAQ;AAEjB,YAAQ,MAAO,uCAAuC,KAAM;EAC7D;AACD;AAKA,eAAe,sBAAuC;AACrD,MAAI;AACH,UAAM,YAAY,UAAM,iBAAAA,SAAuB;MAC9C,UAAM,yBAAc,oBAAoB;QACvC,UAAU;QACV,SAAS;MACV,CAAE;IACH,CAAE;AAEF,QAAK,aAAa,MAAM,QAAS,SAAU,GAAI;AAC9C,iBAAY,WAAW,WAAY;AAGlC,wBAAiB;UAChB,GAAG;UACH,UAAU,qBAAsB,OAAQ;UACxC,MAAM;YACL,aAAa;cACZ,GAAG,QAAQ,MAAM;cACjB,kBAAkB;YACnB;UACD;QACD,CAAE;MACH;IACD;EACD,SAAU,OAAQ;AAEjB,YAAQ,MAAO,8BAA8B,KAAM;EACpD;AACD;AAKA,eAAe,aAA8B;AAE5C,QAAM,qBAAqB;AAC3B,QAAM,oBAAoB;AAC3B;AAGA,WAAW;",
  "names": ["apiFetch"]
}
