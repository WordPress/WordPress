{
  "version": 3,
  "sources": ["../../../../packages/block-editor/src/utils/fit-text-frontend.js", "../../../../packages/block-editor/src/utils/fit-text-utils.js"],
  "sourcesContent": ["/**\n * Frontend fit text functionality.\n * Automatically detects and initializes fit text on blocks with the has-fit-text class.\n * Supports both initial page load and Interactivity API client-side navigation.\n */\n\n/**\n * WordPress dependencies\n */\nimport { store, getElement, getContext } from '@wordpress/interactivity';\n\n/**\n * Internal dependencies\n */\nimport { optimizeFitText } from './fit-text-utils';\n\n// Initialize via Interactivity API for client-side navigation\nstore( 'core/fit-text', {\n\tcallbacks: {\n\t\tinit() {\n\t\t\tconst context = getContext();\n\t\t\tconst { ref } = getElement();\n\n\t\t\tconst applyFontSize = ( fontSize ) => {\n\t\t\t\tif ( fontSize === 0 ) {\n\t\t\t\t\tref.style.fontSize = '';\n\t\t\t\t} else {\n\t\t\t\t\tref.style.fontSize = `${ fontSize }px`;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Initial fit text optimization.\n\t\t\tcontext.fontSize = optimizeFitText( ref, applyFontSize );\n\n\t\t\t// Starts ResizeObserver to handle dynamic resizing.\n\t\t\tif ( window.ResizeObserver && ref.parentElement ) {\n\t\t\t\tconst resizeObserver = new window.ResizeObserver( () => {\n\t\t\t\t\tcontext.fontSize = optimizeFitText( ref, applyFontSize );\n\t\t\t\t} );\n\t\t\t\tresizeObserver.observe( ref.parentElement );\n\t\t\t\tresizeObserver.observe( ref );\n\n\t\t\t\t// Return cleanup function to be called when element is removed.\n\t\t\t\treturn () => {\n\t\t\t\t\tif ( resizeObserver ) {\n\t\t\t\t\t\tresizeObserver.disconnect();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t},\n} );\n", "/**\n * Shared utility functions for fit text functionality.\n * Uses callback-based approach for maximum code reuse between editor and frontend.\n */\n\n/**\n * Find optimal font size using simple binary search between 0-2400px.\n *\n * @param {HTMLElement} textElement   The text element\n * @param {Function}    applyFontSize Function that receives font size in pixels\n * @return {number} Optimal font size\n */\nfunction findOptimalFontSize( textElement, applyFontSize ) {\n\tconst alreadyHasScrollableHeight =\n\t\ttextElement.scrollHeight > textElement.clientHeight;\n\tlet minSize = 0;\n\tlet maxSize = 2400;\n\tlet bestSize = minSize;\n\n\tconst computedStyle = window.getComputedStyle( textElement );\n\tconst paddingLeft = parseFloat( computedStyle.paddingLeft ) || 0;\n\tconst paddingRight = parseFloat( computedStyle.paddingRight ) || 0;\n\tconst range = document.createRange();\n\trange.selectNodeContents( textElement );\n\n\twhile ( minSize <= maxSize ) {\n\t\tconst midSize = Math.floor( ( minSize + maxSize ) / 2 );\n\t\tapplyFontSize( midSize );\n\n\t\t// When there is padding if the text overflows to the\n\t\t// padding area, it should be considered overflowing.\n\t\t// Use Range API to measure actual text content dimensions.\n\t\tconst rect = range.getBoundingClientRect();\n\t\tconst textWidth = rect.width;\n\n\t\t// Check if text fits within the element's width and is not\n\t\t// overflowing into the padding area.\n\t\tconst fitsWidth =\n\t\t\ttextElement.scrollWidth <= textElement.clientWidth &&\n\t\t\ttextWidth <= textElement.clientWidth - paddingLeft - paddingRight;\n\t\t// Check if text fits within the element's height.\n\t\tconst fitsHeight =\n\t\t\talreadyHasScrollableHeight ||\n\t\t\ttextElement.scrollHeight <= textElement.clientHeight;\n\n\t\tif ( fitsWidth && fitsHeight ) {\n\t\t\tbestSize = midSize;\n\t\t\tminSize = midSize + 1;\n\t\t} else {\n\t\t\tmaxSize = midSize - 1;\n\t\t}\n\t}\n\trange.detach();\n\n\treturn bestSize;\n}\n\n/**\n * Complete fit text optimization for a single text element.\n * Handles the full flow using callbacks for font size application.\n *\n * @param {HTMLElement} textElement   The text element (paragraph, heading, etc.)\n * @param {Function}    applyFontSize Function that receives font size in pixels (0 to clear, >0 to apply)\n */\nexport function optimizeFitText( textElement, applyFontSize ) {\n\tif ( ! textElement ) {\n\t\treturn;\n\t}\n\n\tapplyFontSize( 0 );\n\n\tconst optimalSize = findOptimalFontSize( textElement, applyFontSize );\n\n\tapplyFontSize( optimalSize );\n\treturn optimalSize;\n}\n"],
  "mappings": "AASA,OAAS,SAAAA,EAAO,cAAAC,EAAY,cAAAC,MAAkB,2BCG9C,SAASC,EAAqBC,EAAaC,EAAgB,CAC1D,IAAMC,EACLF,EAAY,aAAeA,EAAY,aACpCG,EAAU,EACVC,EAAU,KACVC,EAAWF,EAETG,EAAgB,OAAO,iBAAkBN,CAAY,EACrDO,EAAc,WAAYD,EAAc,WAAY,GAAK,EACzDE,EAAe,WAAYF,EAAc,YAAa,GAAK,EAC3DG,EAAQ,SAAS,YAAY,EAGnC,IAFAA,EAAM,mBAAoBT,CAAY,EAE9BG,GAAWC,GAAU,CAC5B,IAAMM,EAAU,KAAK,OAASP,EAAUC,GAAY,CAAE,EACtDH,EAAeS,CAAQ,EAMvB,IAAMC,EADOF,EAAM,sBAAsB,EAClB,MAIjBG,EACLZ,EAAY,aAAeA,EAAY,aACvCW,GAAaX,EAAY,YAAcO,EAAcC,EAEhDK,EACLX,GACAF,EAAY,cAAgBA,EAAY,aAEpCY,GAAaC,GACjBR,EAAWK,EACXP,EAAUO,EAAU,GAEpBN,EAAUM,EAAU,CAEtB,CACA,OAAAD,EAAM,OAAO,EAENJ,CACR,CASO,SAASS,EAAiBd,EAAaC,EAAgB,CAC7D,GAAK,CAAED,EACN,OAGDC,EAAe,CAAE,EAEjB,IAAMc,EAAchB,EAAqBC,EAAaC,CAAc,EAEpE,OAAAA,EAAec,CAAY,EACpBA,CACR,CD1DAC,EAAO,gBAAiB,CACvB,UAAW,CACV,MAAO,CACN,IAAMC,EAAUC,EAAW,EACrB,CAAE,IAAAC,CAAI,EAAIC,EAAW,EAErBC,EAAkBC,GAAc,CAChCA,IAAa,EACjBH,EAAI,MAAM,SAAW,GAErBA,EAAI,MAAM,SAAW,GAAIG,CAAS,IAEpC,EAMA,GAHAL,EAAQ,SAAWM,EAAiBJ,EAAKE,CAAc,EAGlD,OAAO,gBAAkBF,EAAI,cAAgB,CACjD,IAAMK,EAAiB,IAAI,OAAO,eAAgB,IAAM,CACvDP,EAAQ,SAAWM,EAAiBJ,EAAKE,CAAc,CACxD,CAAE,EACF,OAAAG,EAAe,QAASL,EAAI,aAAc,EAC1CK,EAAe,QAASL,CAAI,EAGrB,IAAM,CACPK,GACJA,EAAe,WAAW,CAE5B,CACD,CACD,CACD,CACD,CAAE",
  "names": ["store", "getElement", "getContext", "findOptimalFontSize", "textElement", "applyFontSize", "alreadyHasScrollableHeight", "minSize", "maxSize", "bestSize", "computedStyle", "paddingLeft", "paddingRight", "range", "midSize", "textWidth", "fitsWidth", "fitsHeight", "optimizeFitText", "optimalSize", "store", "context", "getContext", "ref", "getElement", "applyFontSize", "fontSize", "optimizeFitText", "resizeObserver"]
}
