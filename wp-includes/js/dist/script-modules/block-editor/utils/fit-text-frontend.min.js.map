{
  "version": 3,
  "sources": ["../../../../packages/block-editor/src/utils/fit-text-frontend.js", "../../../../packages/block-editor/src/utils/fit-text-utils.js"],
  "sourcesContent": ["/**\n * Frontend fit text functionality.\n * Automatically detects and initializes fit text on blocks with the has-fit-text class.\n * Supports both initial page load and Interactivity API client-side navigation.\n */\n\n/**\n * WordPress dependencies\n */\nimport { store, getElement, getContext } from '@wordpress/interactivity';\n\n/**\n * Internal dependencies\n */\nimport { optimizeFitText } from './fit-text-utils';\n\n// Initialize via Interactivity API for client-side navigation\nstore( 'core/fit-text', {\n\tcallbacks: {\n\t\tinit() {\n\t\t\tconst context = getContext();\n\t\t\tconst { ref } = getElement();\n\n\t\t\tconst applyFontSize = ( fontSize ) => {\n\t\t\t\tif ( fontSize === 0 ) {\n\t\t\t\t\tref.style.fontSize = '';\n\t\t\t\t} else {\n\t\t\t\t\tref.style.fontSize = `${ fontSize }px`;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Initial fit text optimization.\n\t\t\tcontext.fontSize = optimizeFitText( ref, applyFontSize );\n\n\t\t\t// Starts ResizeObserver to handle dynamic resizing.\n\t\t\tif ( window.ResizeObserver && ref.parentElement ) {\n\t\t\t\tconst resizeObserver = new window.ResizeObserver( () => {\n\t\t\t\t\tcontext.fontSize = optimizeFitText( ref, applyFontSize );\n\t\t\t\t} );\n\t\t\t\tresizeObserver.observe( ref.parentElement );\n\t\t\t\tresizeObserver.observe( ref );\n\n\t\t\t\t// Return cleanup function to be called when element is removed.\n\t\t\t\treturn () => {\n\t\t\t\t\tif ( resizeObserver ) {\n\t\t\t\t\t\tresizeObserver.disconnect();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t},\n} );\n", "/**\n * Shared utility functions for fit text functionality.\n * Uses callback-based approach for maximum code reuse between editor and frontend.\n */\n\n/**\n * Find optimal font size using simple binary search between 0-2400px.\n *\n * @param {HTMLElement} textElement   The text element\n * @param {Function}    applyFontSize Function that receives font size in pixels\n * @return {number} Optimal font size\n */\nfunction findOptimalFontSize( textElement, applyFontSize ) {\n\tconst alreadyHasScrollableHeight =\n\t\ttextElement.scrollHeight > textElement.clientHeight;\n\tlet minSize = 0;\n\tlet maxSize = 2400;\n\tlet bestSize = minSize;\n\n\tconst computedStyle = window.getComputedStyle( textElement );\n\tlet paddingLeft = parseFloat( computedStyle.paddingLeft ) || 0;\n\tlet paddingRight = parseFloat( computedStyle.paddingRight ) || 0;\n\tconst range = document.createRange();\n\trange.selectNodeContents( textElement );\n\n\tlet referenceElement = textElement;\n\tconst parentElement = textElement.parentElement;\n\tif ( parentElement ) {\n\t\tconst parentElementComputedStyle =\n\t\t\twindow.getComputedStyle( parentElement );\n\t\tif ( parentElementComputedStyle?.display === 'flex' ) {\n\t\t\treferenceElement = parentElement;\n\t\t\tpaddingLeft +=\n\t\t\t\tparseFloat( parentElementComputedStyle.paddingLeft ) || 0;\n\t\t\tpaddingRight +=\n\t\t\t\tparseFloat( parentElementComputedStyle.paddingRight ) || 0;\n\t\t}\n\t}\n\tlet maxclientHeight = referenceElement.clientHeight;\n\n\twhile ( minSize <= maxSize ) {\n\t\tconst midSize = Math.floor( ( minSize + maxSize ) / 2 );\n\t\tapplyFontSize( midSize );\n\n\t\t// When there is padding if the text overflows to the\n\t\t// padding area, it should be considered overflowing.\n\t\t// Use Range API to measure actual text content dimensions.\n\t\tconst rect = range.getBoundingClientRect();\n\t\tconst textWidth = rect.width;\n\n\t\t// Check if text fits within the element's width and is not\n\t\t// overflowing into the padding area.\n\t\tconst fitsWidth =\n\t\t\ttextElement.scrollWidth <= referenceElement.clientWidth &&\n\t\t\ttextWidth <=\n\t\t\t\treferenceElement.clientWidth - paddingLeft - paddingRight;\n\t\t// Check if text fits within the element's height.\n\t\tconst fitsHeight =\n\t\t\talreadyHasScrollableHeight ||\n\t\t\ttextElement.scrollHeight <= referenceElement.clientHeight ||\n\t\t\ttextElement.scrollHeight <= maxclientHeight;\n\n\t\t// When there are calculated line heights, text may jump in height\n\t\t// the available space may decrease while the font size decreases,\n\t\t// making text not fit.\n\t\t// We store a maximum reference height: the maximum reference element height that was observed\n\t\t// during the loop to avoid issues with such jumps.\n\t\tif ( referenceElement.clientHeight > maxclientHeight ) {\n\t\t\tmaxclientHeight = referenceElement.clientHeight;\n\t\t}\n\n\t\tif ( fitsWidth && fitsHeight ) {\n\t\t\tbestSize = midSize;\n\t\t\tminSize = midSize + 1;\n\t\t} else {\n\t\t\tmaxSize = midSize - 1;\n\t\t}\n\t}\n\trange.detach();\n\n\treturn bestSize;\n}\n\n/**\n * Complete fit text optimization for a single text element.\n * Handles the full flow using callbacks for font size application.\n *\n * @param {HTMLElement} textElement   The text element (paragraph, heading, etc.)\n * @param {Function}    applyFontSize Function that receives font size in pixels (0 to clear, >0 to apply)\n */\nexport function optimizeFitText( textElement, applyFontSize ) {\n\tif ( ! textElement ) {\n\t\treturn;\n\t}\n\n\tapplyFontSize( 0 );\n\n\tconst optimalSize = findOptimalFontSize( textElement, applyFontSize );\n\n\tapplyFontSize( optimalSize );\n\treturn optimalSize;\n}\n"],
  "mappings": "AASA,OAAS,SAAAA,EAAO,cAAAC,EAAY,cAAAC,MAAkB,2BCG9C,SAASC,EAAqBC,EAAaC,EAAgB,CAC1D,IAAMC,EACLF,EAAY,aAAeA,EAAY,aACpCG,EAAU,EACVC,EAAU,KACVC,EAAWF,EAETG,EAAgB,OAAO,iBAAkBN,CAAY,EACvDO,EAAc,WAAYD,EAAc,WAAY,GAAK,EACzDE,EAAe,WAAYF,EAAc,YAAa,GAAK,EACzDG,EAAQ,SAAS,YAAY,EACnCA,EAAM,mBAAoBT,CAAY,EAEtC,IAAIU,EAAmBV,EACjBW,EAAgBX,EAAY,cAClC,GAAKW,EAAgB,CACpB,IAAMC,EACL,OAAO,iBAAkBD,CAAc,EACnCC,GAA4B,UAAY,SAC5CF,EAAmBC,EACnBJ,GACC,WAAYK,EAA2B,WAAY,GAAK,EACzDJ,GACC,WAAYI,EAA2B,YAAa,GAAK,EAE5D,CACA,IAAIC,EAAkBH,EAAiB,aAEvC,KAAQP,GAAWC,GAAU,CAC5B,IAAMU,EAAU,KAAK,OAASX,EAAUC,GAAY,CAAE,EACtDH,EAAea,CAAQ,EAMvB,IAAMC,EADON,EAAM,sBAAsB,EAClB,MAIjBO,EACLhB,EAAY,aAAeU,EAAiB,aAC5CK,GACCL,EAAiB,YAAcH,EAAcC,EAEzCS,EACLf,GACAF,EAAY,cAAgBU,EAAiB,cAC7CV,EAAY,cAAgBa,EAOxBH,EAAiB,aAAeG,IACpCA,EAAkBH,EAAiB,cAG/BM,GAAaC,GACjBZ,EAAWS,EACXX,EAAUW,EAAU,GAEpBV,EAAUU,EAAU,CAEtB,CACA,OAAAL,EAAM,OAAO,EAENJ,CACR,CASO,SAASa,EAAiBlB,EAAaC,EAAgB,CAC7D,GAAK,CAAED,EACN,OAGDC,EAAe,CAAE,EAEjB,IAAMkB,EAAcpB,EAAqBC,EAAaC,CAAc,EAEpE,OAAAA,EAAekB,CAAY,EACpBA,CACR,CDpFAC,EAAO,gBAAiB,CACvB,UAAW,CACV,MAAO,CACN,IAAMC,EAAUC,EAAW,EACrB,CAAE,IAAAC,CAAI,EAAIC,EAAW,EAErBC,EAAkBC,GAAc,CAChCA,IAAa,EACjBH,EAAI,MAAM,SAAW,GAErBA,EAAI,MAAM,SAAW,GAAIG,CAAS,IAEpC,EAMA,GAHAL,EAAQ,SAAWM,EAAiBJ,EAAKE,CAAc,EAGlD,OAAO,gBAAkBF,EAAI,cAAgB,CACjD,IAAMK,EAAiB,IAAI,OAAO,eAAgB,IAAM,CACvDP,EAAQ,SAAWM,EAAiBJ,EAAKE,CAAc,CACxD,CAAE,EACF,OAAAG,EAAe,QAASL,EAAI,aAAc,EAC1CK,EAAe,QAASL,CAAI,EAGrB,IAAM,CACPK,GACJA,EAAe,WAAW,CAE5B,CACD,CACD,CACD,CACD,CAAE",
  "names": ["store", "getElement", "getContext", "findOptimalFontSize", "textElement", "applyFontSize", "alreadyHasScrollableHeight", "minSize", "maxSize", "bestSize", "computedStyle", "paddingLeft", "paddingRight", "range", "referenceElement", "parentElement", "parentElementComputedStyle", "maxclientHeight", "midSize", "textWidth", "fitsWidth", "fitsHeight", "optimizeFitText", "optimalSize", "store", "context", "getContext", "ref", "getElement", "applyFontSize", "fontSize", "optimizeFitText", "resizeObserver"]
}
