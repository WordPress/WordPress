{
  "version": 3,
  "sources": ["../../../../packages/block-library/src/tabs/view.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport {\n\tstore,\n\tgetContext,\n\tgetElement,\n\twithSyncEvent,\n} from '@wordpress/interactivity';\n\nfunction createReadOnlyProxy( obj ) {\n\tconst arrayMutationMethods = new Set( [\n\t\t'push',\n\t\t'pop',\n\t\t'shift',\n\t\t'unshift',\n\t\t'splice',\n\t\t'sort',\n\t\t'reverse',\n\t\t'copyWithin',\n\t\t'fill',\n\t] );\n\n\treturn new Proxy( obj, {\n\t\tget( target, prop ) {\n\t\t\t// If accessing an array mutation method, return a no-op function.\n\t\t\tif ( Array.isArray( target ) && arrayMutationMethods.has( prop ) ) {\n\t\t\t\treturn () => {};\n\t\t\t}\n\n\t\t\tconst value = target[ prop ];\n\t\t\tif ( typeof value === 'object' && value !== null ) {\n\t\t\t\treturn createReadOnlyProxy( value );\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tset() {\n\t\t\treturn false;\n\t\t},\n\t\tdeleteProperty() {\n\t\t\treturn false;\n\t\t},\n\t} );\n}\n\n// Private store for internal tabs functionality and security.\nconst { actions: privateActions, state: privateState } = store(\n\t'core/tabs/private',\n\t{\n\t\tstate: {\n\t\t\t/**\n\t\t\t * Gets a contextually aware list of tabs for the current tabs block.\n\t\t\t *\n\t\t\t * @type {Array}\n\t\t\t */\n\t\t\tget tabsList() {\n\t\t\t\tconst context = getContext();\n\t\t\t\tconst tabsId = context?.tabsId;\n\t\t\t\tconst tabsList = privateState[ tabsId ];\n\t\t\t\treturn tabsList;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Gets the index of the active tab element whether it\n\t\t\t * is a tab label or tab panel.\n\t\t\t *\n\t\t\t * @type {number|null}\n\t\t\t */\n\t\t\tget tabIndex() {\n\t\t\t\tconst { attributes } = getElement();\n\t\t\t\tconst tabId = attributes?.id?.replace( 'tab__', '' ) || null;\n\t\t\t\tif ( ! tabId ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst { tabsList } = privateState;\n\t\t\t\tconst tabIndex = tabsList.findIndex( ( t ) => t.id === tabId );\n\t\t\t\treturn tabIndex;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Whether the tab panel or tab label is the active tab.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tget isActiveTab() {\n\t\t\t\tconst { activeTabIndex } = getContext();\n\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\treturn activeTabIndex === tabIndex;\n\t\t\t},\n\t\t\t/**\n\t\t\t * The value of the tabindex attribute.\n\t\t\t *\n\t\t\t * @type {false|string}\n\t\t\t */\n\t\t\tget tabIndexAttribute() {\n\t\t\t\treturn privateState.isActiveTab ? -1 : 0;\n\t\t\t},\n\t\t},\n\t\tactions: {\n\t\t\t/**\n\t\t\t * Handles the keydown events for the tab label and tabs controller.\n\t\t\t *\n\t\t\t * @param {KeyboardEvent} event The keydown event.\n\t\t\t */\n\t\t\thandleTabKeyDown: withSyncEvent( ( event ) => {\n\t\t\t\t// If this is the enter key then lets get the tab index from context and set the active tab to that index.\n\t\t\t\tconst { isVertical } = getContext();\n\t\t\t\tif ( event.key === 'Enter' ) {\n\t\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\t\tprivateActions.setActiveTab( tabIndex );\n\t\t\t\t\t}\n\t\t\t\t} else if ( event.key === 'ArrowRight' && ! isVertical ) {\n\t\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\t\tprivateActions.setActiveTab( tabIndex + 1 );\n\t\t\t\t\t}\n\t\t\t\t} else if ( event.key === 'ArrowLeft' && ! isVertical ) {\n\t\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\t\tprivateActions.setActiveTab( tabIndex - 1 );\n\t\t\t\t\t}\n\t\t\t\t} else if ( event.key === 'ArrowDown' && isVertical ) {\n\t\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\t\tprivateActions.setActiveTab( tabIndex + 1 );\n\t\t\t\t\t}\n\t\t\t\t} else if ( event.key === 'ArrowUp' && isVertical ) {\n\t\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\t\tprivateActions.setActiveTab( tabIndex - 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ),\n\t\t\t/**\n\t\t\t * Handles the click event for the tab label.\n\t\t\t *\n\t\t\t * @param {MouseEvent} event The click event.\n\t\t\t */\n\t\t\thandleTabClick: withSyncEvent( ( event ) => {\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tconst { tabIndex } = privateState;\n\t\t\t\tif ( tabIndex !== null ) {\n\t\t\t\t\tprivateActions.setActiveTab( tabIndex );\n\t\t\t\t}\n\t\t\t} ),\n\t\t\t/**\n\t\t\t * Sets the active tab index (internal implementation).\n\t\t\t *\n\t\t\t * @param {number}  tabIndex    The index of the active tab.\n\t\t\t * @param {boolean} scrollToTab Whether to scroll to the tab element.\n\t\t\t */\n\t\t\tsetActiveTab: ( tabIndex, scrollToTab = false ) => {\n\t\t\t\tconst context = getContext();\n\t\t\t\tcontext.activeTabIndex = tabIndex;\n\t\t\t\tif ( scrollToTab ) {\n\t\t\t\t\tconst tabId = privateState.tabsList[ tabIndex ].id;\n\t\t\t\t\tconst tabElement = document.getElementById( tabId );\n\t\t\t\t\tif ( tabElement ) {\n\t\t\t\t\t\tsetTimeout( () => {\n\t\t\t\t\t\t\ttabElement.scrollIntoView( { behavior: 'smooth' } );\n\t\t\t\t\t\t}, 100 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tcallbacks: {\n\t\t\t/**\n\t\t\t * When the tabs are initialized, we need to check if there is a hash in the url and if so if it exists in the current tabsList, set the active tab to that index.\n\t\t\t *\n\t\t\t */\n\t\t\tonTabsInit: () => {\n\t\t\t\tconst { tabsList } = privateState;\n\t\t\t\tif ( tabsList.length === 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst { hash } = window.location;\n\t\t\t\tconst tabId = hash.replace( '#', '' );\n\t\t\t\tconst tabIndex = tabsList.findIndex( ( t ) => t.id === tabId );\n\t\t\t\t// Check if tabIndex is a positive number and if so we'll auto activate that tab.\n\t\t\t\tif ( tabIndex >= 0 ) {\n\t\t\t\t\tprivateActions.setActiveTab( tabIndex, true );\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tlock: true,\n\t}\n);\n\n// Public store for third-party extensibility.\nstore( 'core/tabs', {\n\tstate: {\n\t\t/**\n\t\t * Gets a contextually aware list of tabs for the current tabs block.\n\t\t * Public API for third-party access.\n\t\t *\n\t\t * @type {Array}\n\t\t */\n\t\tget tabsList() {\n\t\t\treturn createReadOnlyProxy( privateState.tabsList );\n\t\t},\n\t\t/**\n\t\t * Gets the index of the active tab element whether it\n\t\t * is a tab label or tab panel.\n\t\t *\n\t\t * @type {number|null}\n\t\t */\n\t\tget tabIndex() {\n\t\t\treturn privateState.tabIndex;\n\t\t},\n\t\t/**\n\t\t * Whether the tab panel or tab label is the active tab.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tget isActiveTab() {\n\t\t\treturn privateState.isActiveTab;\n\t\t},\n\t},\n\tactions: {\n\t\t/**\n\t\t * Sets the active tab index.\n\t\t * Public API for third-party programmatic tab activation.\n\t\t *\n\t\t * @param {number}  tabIndex    The index of the active tab.\n\t\t * @param {boolean} scrollToTab Whether to scroll to the tab element.\n\t\t */\n\t\tsetActiveTab: ( tabIndex, scrollToTab = false ) => {\n\t\t\tprivateActions.setActiveTab( tabIndex, scrollToTab );\n\t\t},\n\t},\n} );\n"],
  "mappings": "AAGA,OACC,SAAAA,EACA,cAAAC,EACA,cAAAC,EACA,iBAAAC,MACM,2BAEP,SAASC,EAAqBC,EAAM,CACnC,IAAMC,EAAuB,IAAI,IAAK,CACrC,OACA,MACA,QACA,UACA,SACA,OACA,UACA,aACA,MACD,CAAE,EAEF,OAAO,IAAI,MAAOD,EAAK,CACtB,IAAKE,EAAQC,EAAO,CAEnB,GAAK,MAAM,QAASD,CAAO,GAAKD,EAAqB,IAAKE,CAAK,EAC9D,MAAO,IAAM,CAAC,EAGf,IAAMC,EAAQF,EAAQC,CAAK,EAC3B,OAAK,OAAOC,GAAU,UAAYA,IAAU,KACpCL,EAAqBK,CAAM,EAE5BA,CACR,EACA,KAAM,CACL,MAAO,EACR,EACA,gBAAiB,CAChB,MAAO,EACR,CACD,CAAE,CACH,CAGA,GAAM,CAAE,QAASC,EAAgB,MAAOC,CAAa,EAAIX,EACxD,oBACA,CACC,MAAO,CAMN,IAAI,UAAW,CAEd,IAAMY,EADUX,EAAW,GACH,OAExB,OADiBU,EAAcC,CAAO,CAEvC,EAOA,IAAI,UAAW,CACd,GAAM,CAAE,WAAAC,CAAW,EAAIX,EAAW,EAC5BY,EAAQD,GAAY,IAAI,QAAS,QAAS,EAAG,GAAK,KACxD,GAAK,CAAEC,EACN,OAAO,KAER,GAAM,CAAE,SAAAC,CAAS,EAAIJ,EAErB,OADiBI,EAAS,UAAaC,GAAOA,EAAE,KAAOF,CAAM,CAE9D,EAMA,IAAI,aAAc,CACjB,GAAM,CAAE,eAAAG,CAAe,EAAIhB,EAAW,EAChC,CAAE,SAAAiB,CAAS,EAAIP,EACrB,OAAOM,IAAmBC,CAC3B,EAMA,IAAI,mBAAoB,CACvB,OAAOP,EAAa,YAAc,GAAK,CACxC,CACD,EACA,QAAS,CAMR,iBAAkBR,EAAiBgB,GAAW,CAE7C,GAAM,CAAE,WAAAC,CAAW,EAAInB,EAAW,EAClC,GAAKkB,EAAM,MAAQ,QAAU,CAC5B,GAAM,CAAE,SAAAD,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,CAAS,CAExC,SAAYC,EAAM,MAAQ,cAAgB,CAAEC,EAAa,CACxD,GAAM,CAAE,SAAAF,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,EAAW,CAAE,CAE5C,SAAYC,EAAM,MAAQ,aAAe,CAAEC,EAAa,CACvD,GAAM,CAAE,SAAAF,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,EAAW,CAAE,CAE5C,SAAYC,EAAM,MAAQ,aAAeC,EAAa,CACrD,GAAM,CAAE,SAAAF,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,EAAW,CAAE,CAE5C,SAAYC,EAAM,MAAQ,WAAaC,EAAa,CACnD,GAAM,CAAE,SAAAF,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,EAAW,CAAE,CAE5C,CACD,CAAE,EAMF,eAAgBf,EAAiBgB,GAAW,CAC3CA,EAAM,eAAe,EAErB,GAAM,CAAE,SAAAD,CAAS,EAAIP,EAChBO,IAAa,MACjBR,EAAe,aAAcQ,CAAS,CAExC,CAAE,EAOF,aAAc,CAAEA,EAAUG,EAAc,KAAW,CAClD,IAAMC,EAAUrB,EAAW,EAE3B,GADAqB,EAAQ,eAAiBJ,EACpBG,EAAc,CAClB,IAAMP,EAAQH,EAAa,SAAUO,CAAS,EAAE,GAC1CK,EAAa,SAAS,eAAgBT,CAAM,EAC7CS,GACJ,WAAY,IAAM,CACjBA,EAAW,eAAgB,CAAE,SAAU,QAAS,CAAE,CACnD,EAAG,GAAI,CAET,CACD,CACD,EACA,UAAW,CAKV,WAAY,IAAM,CACjB,GAAM,CAAE,SAAAR,CAAS,EAAIJ,EACrB,GAAKI,EAAS,SAAW,EACxB,OAED,GAAM,CAAE,KAAAS,CAAK,EAAI,OAAO,SAClBV,EAAQU,EAAK,QAAS,IAAK,EAAG,EAC9BN,EAAWH,EAAS,UAAaC,GAAOA,EAAE,KAAOF,CAAM,EAExDI,GAAY,GAChBR,EAAe,aAAcQ,EAAU,EAAK,CAE9C,CACD,CACD,EACA,CACC,KAAM,EACP,CACD,EAGAlB,EAAO,YAAa,CACnB,MAAO,CAON,IAAI,UAAW,CACd,OAAOI,EAAqBO,EAAa,QAAS,CACnD,EAOA,IAAI,UAAW,CACd,OAAOA,EAAa,QACrB,EAMA,IAAI,aAAc,CACjB,OAAOA,EAAa,WACrB,CACD,EACA,QAAS,CAQR,aAAc,CAAEO,EAAUG,EAAc,KAAW,CAClDX,EAAe,aAAcQ,EAAUG,CAAY,CACpD,CACD,CACD,CAAE",
  "names": ["store", "getContext", "getElement", "withSyncEvent", "createReadOnlyProxy", "obj", "arrayMutationMethods", "target", "prop", "value", "privateActions", "privateState", "tabsId", "attributes", "tabId", "tabsList", "t", "activeTabIndex", "tabIndex", "event", "isVertical", "scrollToTab", "context", "tabElement", "hash"]
}
