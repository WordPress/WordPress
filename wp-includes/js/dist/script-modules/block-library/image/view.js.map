{
  "version": 3,
  "sources": ["../../../../packages/block-library/src/image/view.js", "../../../../packages/block-library/src/image/constants.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport {\n\tstore,\n\tgetContext,\n\tgetElement,\n\tgetConfig,\n\twithSyncEvent,\n\twithScope,\n} from '@wordpress/interactivity';\n\n/**\n * Internal dependencies\n */\nimport { IMAGE_PRELOAD_DELAY } from './constants';\n\n/**\n * Tracks whether user is touching screen; used to differentiate behavior for\n * touch and mouse input.\n *\n * @type {boolean}\n */\nlet isTouching = false;\n\n/**\n * Tracks the last time the screen was touched; used to differentiate behavior\n * for touch and mouse input.\n *\n * @type {number}\n */\nlet lastTouchTime = 0;\n\nconst touchStartEvent = {\n\tstartX: 0,\n\tstartY: 0,\n\tstartTime: 0,\n};\n\nconst focusableSelectors = [\n\t'.wp-lightbox-close-button',\n\t'.wp-lightbox-navigation-button',\n];\n\n/**\n * Returns the appropriate src URL for an image.\n *\n * @param {string} uploadedSrc - Full size image src.\n * @return {string} The source URL.\n */\nfunction getImageSrc( { uploadedSrc } ) {\n\treturn (\n\t\tuploadedSrc ||\n\t\t'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n\t);\n}\n\n/**\n * Returns the appropriate srcset for an image.\n *\n * @param {string} lightboxSrcset - Image srcset.\n * @return {string} The srcset value.\n */\nfunction getImageSrcset( { lightboxSrcset } ) {\n\treturn lightboxSrcset || '';\n}\n\nconst { state, actions, callbacks } = store(\n\t'core/image',\n\t{\n\t\tstate: {\n\t\t\tselectedImageId: null,\n\t\t\tselectedGalleryId: null,\n\t\t\tpreloadTimers: new Map(),\n\t\t\tpreloadedImageIds: new Set(),\n\t\t\tget galleryImages() {\n\t\t\t\tif ( ! state.selectedGalleryId ) {\n\t\t\t\t\treturn [ state.selectedImageId ];\n\t\t\t\t}\n\n\t\t\t\t// Get all images in this gallery and sort by galleryOrder\n\t\t\t\treturn Object.entries( state.metadata )\n\t\t\t\t\t.filter(\n\t\t\t\t\t\t( [ , value ] ) =>\n\t\t\t\t\t\t\tvalue.galleryId === state.selectedGalleryId\n\t\t\t\t\t)\n\t\t\t\t\t.sort( ( [ , a ], [ , b ] ) => {\n\t\t\t\t\t\tconst orderA = a.order ?? 0;\n\t\t\t\t\t\tconst orderB = b.order ?? 0;\n\t\t\t\t\t\treturn orderA - orderB;\n\t\t\t\t\t} )\n\t\t\t\t\t.map( ( [ key ] ) => key );\n\t\t\t},\n\t\t\tget selectedImageIndex() {\n\t\t\t\treturn state.galleryImages.findIndex(\n\t\t\t\t\t( id ) => id === state.selectedImageId\n\t\t\t\t);\n\t\t\t},\n\t\t\tget selectedImage() {\n\t\t\t\treturn state.metadata[ state.selectedImageId ];\n\t\t\t},\n\t\t\tget hasNavigationIcon() {\n\t\t\t\tconst { navigationButtonType } = state.selectedImage;\n\t\t\t\treturn (\n\t\t\t\t\tnavigationButtonType === 'icon' ||\n\t\t\t\t\tnavigationButtonType === 'both'\n\t\t\t\t);\n\t\t\t},\n\t\t\tget hasNavigationText() {\n\t\t\t\tconst { navigationButtonType } = state.selectedImage;\n\t\t\t\treturn (\n\t\t\t\t\tnavigationButtonType === 'text' ||\n\t\t\t\t\tnavigationButtonType === 'both'\n\t\t\t\t);\n\t\t\t},\n\t\t\tget thisImage() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\treturn state.metadata[ imageId ];\n\t\t\t},\n\t\t\tget hasNavigation() {\n\t\t\t\treturn state.galleryImages.length > 1;\n\t\t\t},\n\t\t\tget hasNextImage() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.selectedImageIndex + 1 < state.galleryImages.length\n\t\t\t\t);\n\t\t\t},\n\t\t\tget hasPreviousImage() {\n\t\t\t\treturn state.selectedImageIndex - 1 >= 0;\n\t\t\t},\n\t\t\tget overlayOpened() {\n\t\t\t\treturn state.selectedImageId !== null;\n\t\t\t},\n\t\t\tget roleAttribute() {\n\t\t\t\treturn state.overlayOpened ? 'dialog' : null;\n\t\t\t},\n\t\t\tget ariaModal() {\n\t\t\t\treturn state.overlayOpened ? 'true' : null;\n\t\t\t},\n\t\t\tget ariaLabel() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.selectedImage.customAriaLabel ||\n\t\t\t\t\tgetConfig().defaultAriaLabel\n\t\t\t\t);\n\t\t\t},\n\t\t\tget closeButtonAriaLabel() {\n\t\t\t\treturn state.hasNavigationText\n\t\t\t\t\t? undefined\n\t\t\t\t\t: getConfig().closeButtonText;\n\t\t\t},\n\t\t\tget prevButtonAriaLabel() {\n\t\t\t\treturn state.hasNavigationText\n\t\t\t\t\t? undefined\n\t\t\t\t\t: getConfig().prevButtonText;\n\t\t\t},\n\t\t\tget nextButtonAriaLabel() {\n\t\t\t\treturn state.hasNavigationText\n\t\t\t\t\t? undefined\n\t\t\t\t\t: getConfig().nextButtonText;\n\t\t\t},\n\t\t\tget enlargedSrc() {\n\t\t\t\treturn getImageSrc( state.selectedImage );\n\t\t\t},\n\t\t\tget enlargedSrcset() {\n\t\t\t\treturn getImageSrcset( state.selectedImage );\n\t\t\t},\n\t\t\tget figureStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.selectedImage.figureStyles?.replace(\n\t\t\t\t\t\t/margin[^;]*;?/g,\n\t\t\t\t\t\t''\n\t\t\t\t\t) };`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget imgStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.selectedImage.imgStyles?.replace(\n\t\t\t\t\t\t/;$/,\n\t\t\t\t\t\t''\n\t\t\t\t\t) }; object-fit:cover;`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget isContentHidden() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayEnabled &&\n\t\t\t\t\tstate.selectedImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t\tget isContentVisible() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\t! state.overlayEnabled &&\n\t\t\t\t\tstate.selectedImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t},\n\t\tactions: {\n\t\t\tshowLightbox() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\t// Bails out if the image has not loaded yet.\n\t\t\t\tif ( ! state.metadata[ imageId ].imageRef?.complete ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores the positions of the scroll to fix it until the overlay is\n\t\t\t\t// closed.\n\t\t\t\tstate.scrollTopReset = document.documentElement.scrollTop;\n\t\t\t\tstate.scrollLeftReset = document.documentElement.scrollLeft;\n\n\t\t\t\t// Sets the selected image and gallery and enables the overlay.\n\t\t\t\tstate.selectedImageId = imageId;\n\t\t\t\tconst { galleryId } = getContext( 'core/gallery' ) || {};\n\t\t\t\tstate.selectedGalleryId = galleryId || null;\n\t\t\t\tstate.overlayEnabled = true;\n\n\t\t\t\t// Computes the styles of the overlay for the animation.\n\t\t\t\tcallbacks.setOverlayStyles();\n\t\t\t},\n\t\t\thideLightbox() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tstate.overlayEnabled = false;\n\n\t\t\t\t\t// Waits until the close animation has completed before allowing a\n\t\t\t\t\t// user to scroll again. The duration of this animation is defined in\n\t\t\t\t\t// the `styles.scss` file, but in any case we should wait a few\n\t\t\t\t\t// milliseconds longer than the duration, otherwise a user may scroll\n\t\t\t\t\t// too soon and cause the animation to look sloppy.\n\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\t// Delays before changing the focus. Otherwise the focus ring will\n\t\t\t\t\t\t// appear on Firefox before the image has finished animating, which\n\t\t\t\t\t\t// looks broken.\n\t\t\t\t\t\tstate.selectedImage.buttonRef.focus( {\n\t\t\t\t\t\t\tpreventScroll: true,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Resets the selected image and gallery ids.\n\t\t\t\t\t\tstate.selectedImageId = null;\n\t\t\t\t\t\tstate.selectedGalleryId = null;\n\t\t\t\t\t}, 450 );\n\t\t\t\t}\n\t\t\t},\n\t\t\tshowPreviousImage: withSyncEvent( ( event ) => {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tconst nextIndex = state.hasPreviousImage\n\t\t\t\t\t? state.selectedImageIndex - 1\n\t\t\t\t\t: state.galleryImages.length - 1;\n\t\t\t\tstate.selectedImageId = state.galleryImages[ nextIndex ];\n\t\t\t\tcallbacks.setOverlayStyles();\n\t\t\t} ),\n\t\t\tshowNextImage: withSyncEvent( ( event ) => {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tconst nextIndex = state.hasNextImage\n\t\t\t\t\t? state.selectedImageIndex + 1\n\t\t\t\t\t: 0;\n\t\t\t\tstate.selectedImageId = state.galleryImages[ nextIndex ];\n\t\t\t\tcallbacks.setOverlayStyles();\n\t\t\t} ),\n\t\t\thandleKeydown: withSyncEvent( ( event ) => {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tif ( event.key === 'Escape' ) {\n\t\t\t\t\t\tactions.hideLightbox();\n\t\t\t\t\t} else if ( event.key === 'ArrowLeft' ) {\n\t\t\t\t\t\tactions.showPreviousImage( event );\n\t\t\t\t\t} else if ( event.key === 'ArrowRight' ) {\n\t\t\t\t\t\tactions.showNextImage( event );\n\t\t\t\t\t} else if ( event.key === 'Tab' ) {\n\t\t\t\t\t\t// Traps focus within the overlay.\n\t\t\t\t\t\tconst focusableElements = Array.from(\n\t\t\t\t\t\t\tdocument.querySelectorAll( focusableSelectors )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst firstFocusableElement = focusableElements[ 0 ];\n\t\t\t\t\t\tconst lastFocusableElement =\n\t\t\t\t\t\t\tfocusableElements[ focusableElements.length - 1 ];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tevent.shiftKey &&\n\t\t\t\t\t\t\tevent.target === firstFocusableElement\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tlastFocusableElement.focus();\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t! event.shiftKey &&\n\t\t\t\t\t\t\tevent.target === lastFocusableElement\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tfirstFocusableElement.focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchMove: withSyncEvent( ( event ) => {\n\t\t\t\t// On mobile devices, prevents triggering the scroll event because\n\t\t\t\t// otherwise the page jumps around when it resets the scroll position.\n\t\t\t\t// This also means that closing the lightbox requires that a user\n\t\t\t\t// perform a simple tap. This may be changed in the future if there is a\n\t\t\t\t// better alternative to override or reset the scroll position during\n\t\t\t\t// swipe actions.\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchStart( event ) {\n\t\t\t\tisTouching = true;\n\t\t\t\tconst t = event.touches && event.touches[ 0 ];\n\t\t\t\tif ( t ) {\n\t\t\t\t\ttouchStartEvent.startX = t.clientX;\n\t\t\t\t\ttouchStartEvent.startY = t.clientY;\n\t\t\t\t\ttouchStartEvent.startTime = Date.now();\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleTouchEnd: withSyncEvent( ( event ) => {\n\t\t\t\tconst touchEndEvent =\n\t\t\t\t\t( event.changedTouches && event.changedTouches[ 0 ] ) ||\n\t\t\t\t\t( event.touches && event.touches[ 0 ] );\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tif ( touchEndEvent && state.overlayEnabled ) {\n\t\t\t\t\tconst deltaX =\n\t\t\t\t\t\ttouchEndEvent.clientX - touchStartEvent.startX;\n\t\t\t\t\tconst deltaY =\n\t\t\t\t\t\ttouchEndEvent.clientY - touchStartEvent.startY;\n\t\t\t\t\tconst absDeltaX = Math.abs( deltaX );\n\t\t\t\t\tconst absDeltaY = Math.abs( deltaY );\n\t\t\t\t\tconst elapsedMs = now - touchStartEvent.startTime;\n\t\t\t\t\tconst isHorizontalSwipe =\n\t\t\t\t\t\t// Swipe distance is greater than 50px\n\t\t\t\t\t\tabsDeltaX > 50 &&\n\t\t\t\t\t\t// Horizontal movement is much larger than the vertical movement\n\t\t\t\t\t\tabsDeltaX > absDeltaY * 1.5 &&\n\t\t\t\t\t\t// Fast action of less than 800ms\n\t\t\t\t\t\telapsedMs < 800;\n\n\t\t\t\t\tif ( isHorizontalSwipe ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tif ( deltaX < 0 ) {\n\t\t\t\t\t\t\tactions.showNextImage( event );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tactions.showPreviousImage( event );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlastTouchTime = now;\n\t\t\t\tisTouching = false;\n\t\t\t} ),\n\t\t\thandleScroll() {\n\t\t\t\t// Prevents scrolling behaviors that trigger content shift while the\n\t\t\t\t// lightbox is open. It would be better to accomplish through CSS alone,\n\t\t\t\t// but using overflow: hidden is currently the only way to do so and\n\t\t\t\t// that causes a layout to shift and prevents the zoom animation from\n\t\t\t\t// working in some cases because it's not possible to account for the\n\t\t\t\t// layout shift when doing the animation calculations. Instead, it uses\n\t\t\t\t// JavaScript to prevent and reset the scrolling behavior.\n\t\t\t\tif ( state.overlayOpened ) {\n\t\t\t\t\t// Avoids overriding the scroll behavior on mobile devices because\n\t\t\t\t\t// doing so breaks the pinch to zoom functionality, and users should\n\t\t\t\t\t// be able to zoom in further on the high-res image.\n\t\t\t\t\tif ( ! isTouching && Date.now() - lastTouchTime > 450 ) {\n\t\t\t\t\t\t// It doesn't rely on `event.preventDefault()` to prevent scrolling\n\t\t\t\t\t\t// because the scroll event can't be canceled, so it resets the\n\t\t\t\t\t\t// position instead.\n\t\t\t\t\t\twindow.scrollTo(\n\t\t\t\t\t\t\tstate.scrollLeftReset,\n\t\t\t\t\t\t\tstate.scrollTopReset\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpreloadImage() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\t// Bails if it has already been preloaded. This could help\n\t\t\t\t// prevent unnecessary preloading of the same image multiple times,\n\t\t\t\t// leading to duplicate link elements in the document head.\n\t\t\t\tif ( state.preloadedImageIds.has( imageId ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Link element to preload the image.\n\t\t\t\tconst imageMetadata = state.metadata[ imageId ];\n\t\t\t\tconst imageLink = document.createElement( 'link' );\n\t\t\t\timageLink.rel = 'preload';\n\t\t\t\timageLink.as = 'image';\n\t\t\t\timageLink.href = getImageSrc( imageMetadata );\n\n\t\t\t\t// Apply srcset if available for responsive preloading\n\t\t\t\tconst srcset = getImageSrcset( imageMetadata );\n\t\t\t\tif ( srcset ) {\n\t\t\t\t\timageLink.setAttribute( 'imagesrcset', srcset );\n\t\t\t\t\timageLink.setAttribute( 'imagesizes', '100vw' );\n\t\t\t\t}\n\n\t\t\t\tdocument.head.appendChild( imageLink );\n\t\t\t\tstate.preloadedImageIds.add( imageId );\n\t\t\t},\n\t\t\tpreloadImageWithDelay() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\tactions.cancelPreload();\n\n\t\t\t\t// Set a new timer to preload the image after a short delay.\n\t\t\t\tconst timerId = setTimeout(\n\t\t\t\t\twithScope( () => {\n\t\t\t\t\t\tactions.preloadImage();\n\t\t\t\t\t\tstate.preloadTimers.delete( imageId );\n\t\t\t\t\t} ),\n\t\t\t\t\tIMAGE_PRELOAD_DELAY\n\t\t\t\t);\n\t\t\t\tstate.preloadTimers.set( imageId, timerId );\n\t\t\t},\n\t\t\tcancelPreload() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tif ( state.preloadTimers.has( imageId ) ) {\n\t\t\t\t\tclearTimeout( state.preloadTimers.get( imageId ) );\n\t\t\t\t\tstate.preloadTimers.delete( imageId );\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tcallbacks: {\n\t\t\tsetOverlayStyles() {\n\t\t\t\tif ( ! state.overlayEnabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth: originalWidth,\n\t\t\t\t\toffsetHeight: originalHeight,\n\t\t\t\t} = state.selectedImage.imageRef;\n\t\t\t\tlet { x: screenPosX, y: screenPosY } =\n\t\t\t\t\tstate.selectedImage.imageRef.getBoundingClientRect();\n\n\t\t\t\t// Natural ratio of the image clicked to open the lightbox.\n\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t// Original ratio of the image clicked to open the lightbox.\n\t\t\t\tlet originalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// If it has object-fit: contain, recalculates the original sizes\n\t\t\t\t// and the screen position without the blank spaces.\n\t\t\t\tif ( state.selectedImage.scaleAttr === 'contain' ) {\n\t\t\t\t\tif ( naturalRatio > originalRatio ) {\n\t\t\t\t\t\tconst heightWithoutSpace = originalWidth / naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the top space.\n\t\t\t\t\t\tscreenPosY +=\n\t\t\t\t\t\t\t( originalHeight - heightWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalHeight = heightWithoutSpace;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst widthWithoutSpace = originalHeight * naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the left space.\n\t\t\t\t\t\tscreenPosX += ( originalWidth - widthWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalWidth = widthWithoutSpace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// Typically, it uses the image's full-sized dimensions. If those\n\t\t\t\t// dimensions have not been set (i.e. an external image with only one\n\t\t\t\t// size), the image's dimensions in the lightbox are the same\n\t\t\t\t// as those of the image in the content.\n\t\t\t\tlet imgMaxWidth = parseFloat(\n\t\t\t\t\tstate.selectedImage.targetWidth &&\n\t\t\t\t\t\tstate.selectedImage.targetWidth !== 'none'\n\t\t\t\t\t\t? state.selectedImage.targetWidth\n\t\t\t\t\t\t: naturalWidth\n\t\t\t\t);\n\t\t\t\tlet imgMaxHeight = parseFloat(\n\t\t\t\t\tstate.selectedImage.targetHeight &&\n\t\t\t\t\t\tstate.selectedImage.targetHeight !== 'none'\n\t\t\t\t\t\t? state.selectedImage.targetHeight\n\t\t\t\t\t\t: naturalHeight\n\t\t\t\t);\n\n\t\t\t\t// Ratio of the biggest image stored in the database.\n\t\t\t\tlet imgRatio = imgMaxWidth / imgMaxHeight;\n\t\t\t\tlet containerMaxWidth = imgMaxWidth;\n\t\t\t\tlet containerMaxHeight = imgMaxHeight;\n\t\t\t\tlet containerWidth = imgMaxWidth;\n\t\t\t\tlet containerHeight = imgMaxHeight;\n\n\t\t\t\t// Checks if the target image has a different ratio than the original\n\t\t\t\t// one (thumbnail). Recalculates the width and height.\n\t\t\t\tif ( naturalRatio.toFixed( 2 ) !== imgRatio.toFixed( 2 ) ) {\n\t\t\t\t\tif ( naturalRatio > imgRatio ) {\n\t\t\t\t\t\t// If the width is reached before the height, it keeps the maxWidth\n\t\t\t\t\t\t// and recalculates the height unless the difference between the\n\t\t\t\t\t\t// maxHeight and the reducedHeight is higher than the maxWidth,\n\t\t\t\t\t\t// where it keeps the reducedHeight and recalculate the width.\n\t\t\t\t\t\tconst reducedHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\tif ( imgMaxHeight - reducedHeight > imgMaxWidth ) {\n\t\t\t\t\t\t\timgMaxHeight = reducedHeight;\n\t\t\t\t\t\t\timgMaxWidth = reducedHeight * naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the height is reached before the width, it keeps the maxHeight\n\t\t\t\t\t\t// and recalculate the width unlesss the difference between the\n\t\t\t\t\t\t// maxWidth and the reducedWidth is higher than the maxHeight, where\n\t\t\t\t\t\t// it keeps the reducedWidth and recalculate the height.\n\t\t\t\t\t\tconst reducedWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\tif ( imgMaxWidth - reducedWidth > imgMaxHeight ) {\n\t\t\t\t\t\t\timgMaxWidth = reducedWidth;\n\t\t\t\t\t\t\timgMaxHeight = reducedWidth / naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainerWidth = imgMaxWidth;\n\t\t\t\t\tcontainerHeight = imgMaxHeight;\n\t\t\t\t\timgRatio = imgMaxWidth / imgMaxHeight;\n\n\t\t\t\t\t// Calculates the max size of the container.\n\t\t\t\t\tif ( originalRatio > imgRatio ) {\n\t\t\t\t\t\tcontainerMaxWidth = imgMaxWidth;\n\t\t\t\t\t\tcontainerMaxHeight = containerMaxWidth / originalRatio;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainerMaxHeight = imgMaxHeight;\n\t\t\t\t\t\tcontainerMaxWidth = containerMaxHeight * originalRatio;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the image has been pixelated on purpose, it keeps that size.\n\t\t\t\tif (\n\t\t\t\t\toriginalWidth > containerWidth ||\n\t\t\t\t\toriginalHeight > containerHeight\n\t\t\t\t) {\n\t\t\t\t\tcontainerWidth = originalWidth;\n\t\t\t\t\tcontainerHeight = originalHeight;\n\t\t\t\t}\n\n\t\t\t\t// Calculates the final lightbox image size and the scale factor.\n\t\t\t\t// MaxWidth is either the window container (accounting for padding) or\n\t\t\t\t// the image resolution.\n\n\t\t\t\t// 480px width or less\n\t\t\t\tlet horizontalPadding = 0;\n\t\t\t\tlet verticalPadding = 160;\n\t\t\t\t// Greater than 480px wide and less than or equal to 960px\n\t\t\t\tif ( 480 < window.innerWidth ) {\n\t\t\t\t\thorizontalPadding = 80;\n\t\t\t\t\tverticalPadding = 160;\n\t\t\t\t}\n\t\t\t\t// Greater than 960px wide\n\t\t\t\tif ( 960 < window.innerWidth ) {\n\t\t\t\t\thorizontalPadding = state.hasNavigation ? 320 : 80;\n\t\t\t\t\tverticalPadding = 80;\n\t\t\t\t}\n\n\t\t\t\tconst targetMaxWidth = Math.min(\n\t\t\t\t\twindow.innerWidth - horizontalPadding,\n\t\t\t\t\tcontainerWidth\n\t\t\t\t);\n\t\t\t\tconst targetMaxHeight = Math.min(\n\t\t\t\t\twindow.innerHeight - verticalPadding,\n\t\t\t\t\tcontainerHeight\n\t\t\t\t);\n\t\t\t\tconst targetContainerRatio = targetMaxWidth / targetMaxHeight;\n\n\t\t\t\tif ( originalRatio > targetContainerRatio ) {\n\t\t\t\t\t// If targetMaxWidth is reached before targetMaxHeight.\n\t\t\t\t\tcontainerWidth = targetMaxWidth;\n\t\t\t\t\tcontainerHeight = containerWidth / originalRatio;\n\t\t\t\t} else {\n\t\t\t\t\t// If targetMaxHeight is reached before targetMaxWidth.\n\t\t\t\t\tcontainerHeight = targetMaxHeight;\n\t\t\t\t\tcontainerWidth = containerHeight * originalRatio;\n\t\t\t\t}\n\n\t\t\t\tconst containerScale = originalWidth / containerWidth;\n\t\t\t\tconst lightboxImgWidth =\n\t\t\t\t\timgMaxWidth * ( containerWidth / containerMaxWidth );\n\t\t\t\tconst lightboxImgHeight =\n\t\t\t\t\timgMaxHeight * ( containerHeight / containerMaxHeight );\n\n\t\t\t\t// As of this writing, using the calculations above will render the\n\t\t\t\t// lightbox with a small, erroneous whitespace on the left side of the\n\t\t\t\t// image in iOS Safari, perhaps due to an inconsistency in how browsers\n\t\t\t\t// handle absolute positioning and CSS transformation. In any case,\n\t\t\t\t// adding 1 pixel to the container width and height solves the problem,\n\t\t\t\t// though this can be removed if the issue is fixed in the future.\n\t\t\t\tstate.overlayStyles = `\n\t\t\t\t\t--wp--lightbox-initial-top-position: ${ screenPosY }px;\n\t\t\t\t\t--wp--lightbox-initial-left-position: ${ screenPosX }px;\n\t\t\t\t\t--wp--lightbox-container-width: ${ containerWidth + 1 }px;\n\t\t\t\t\t--wp--lightbox-container-height: ${ containerHeight + 1 }px;\n\t\t\t\t\t--wp--lightbox-image-width: ${ lightboxImgWidth }px;\n\t\t\t\t\t--wp--lightbox-image-height: ${ lightboxImgHeight }px;\n\t\t\t\t\t--wp--lightbox-scale: ${ containerScale };\n\t\t\t\t\t--wp--lightbox-scrollbar-width: ${\n\t\t\t\t\t\twindow.innerWidth - document.documentElement.clientWidth\n\t\t\t\t\t}px;\n\t\t\t\t`;\n\t\t\t},\n\t\t\tsetButtonStyles() {\n\t\t\t\tconst { ref } = getElement();\n\n\t\t\t\t// This guard prevents errors in images with the `srcset`\n\t\t\t\t// attribute, which can dispatch `load` events even after DOM\n\t\t\t\t// removal. Preact doesn't automatically clean up `load` event\n\t\t\t\t// listeners on unmounted `img` elements (see\n\t\t\t\t// https://github.com/preactjs/preact/issues/3141).\n\t\t\t\tif ( ! ref ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\tstate.metadata[ imageId ].imageRef = ref;\n\t\t\t\tstate.metadata[ imageId ].currentSrc = ref.currentSrc;\n\n\t\t\t\tconst {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth,\n\t\t\t\t\toffsetHeight,\n\t\t\t\t} = ref;\n\n\t\t\t\t// If the image isn't loaded yet, it can't calculate where the button\n\t\t\t\t// should be.\n\t\t\t\tif ( naturalWidth === 0 || naturalHeight === 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst figure = ref.parentElement;\n\t\t\t\tconst figureWidth = ref.parentElement.clientWidth;\n\n\t\t\t\t// It needs special handling for the height because a caption will cause\n\t\t\t\t// the figure to be taller than the image, which means it needs to\n\t\t\t\t// account for that when calculating the placement of the button in the\n\t\t\t\t// top right corner of the image.\n\t\t\t\tlet figureHeight = ref.parentElement.clientHeight;\n\t\t\t\tconst caption = figure.querySelector( 'figcaption' );\n\t\t\t\tif ( caption ) {\n\t\t\t\t\tconst captionComputedStyle =\n\t\t\t\t\t\twindow.getComputedStyle( caption );\n\t\t\t\t\tif (\n\t\t\t\t\t\t! [ 'absolute', 'fixed' ].includes(\n\t\t\t\t\t\t\tcaptionComputedStyle.position\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfigureHeight =\n\t\t\t\t\t\t\tfigureHeight -\n\t\t\t\t\t\t\tcaption.offsetHeight -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginTop ) -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginBottom );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst buttonOffsetTop = figureHeight - offsetHeight;\n\t\t\t\tconst buttonOffsetRight = figureWidth - offsetWidth;\n\n\t\t\t\tlet buttonTop = buttonOffsetTop + 16;\n\t\t\t\tlet buttonRight = buttonOffsetRight + 16;\n\n\t\t\t\t// In the case of an image with object-fit: contain, the size of the\n\t\t\t\t// <img> element can be larger than the image itself, so it needs to\n\t\t\t\t// calculate where to place the button.\n\t\t\t\tif ( state.metadata[ imageId ].scaleAttr === 'contain' ) {\n\t\t\t\t\t// Natural ratio of the image.\n\t\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t\t// Offset ratio of the image.\n\t\t\t\t\tconst offsetRatio = offsetWidth / offsetHeight;\n\n\t\t\t\t\tif ( naturalRatio >= offsetRatio ) {\n\t\t\t\t\t\t// If it reaches the width first, it keeps the width and compute the\n\t\t\t\t\t\t// height.\n\t\t\t\t\t\tconst referenceHeight = offsetWidth / naturalRatio;\n\t\t\t\t\t\tbuttonTop =\n\t\t\t\t\t\t\t( offsetHeight - referenceHeight ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetTop +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t\tbuttonRight = buttonOffsetRight + 16;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If it reaches the height first, it keeps the height and compute\n\t\t\t\t\t\t// the width.\n\t\t\t\t\t\tconst referenceWidth = offsetHeight * naturalRatio;\n\t\t\t\t\t\tbuttonTop = buttonOffsetTop + 16;\n\t\t\t\t\t\tbuttonRight =\n\t\t\t\t\t\t\t( offsetWidth - referenceWidth ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetRight +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.metadata[ imageId ].buttonTop = buttonTop;\n\t\t\t\tstate.metadata[ imageId ].buttonRight = buttonRight;\n\t\t\t},\n\t\t\tsetOverlayFocus() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t// Moves the focus to the dialog when it opens.\n\t\t\t\t\tconst { ref } = getElement();\n\t\t\t\t\tref.focus();\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetInertElements() {\n\t\t\t\t// Makes all children of the document inert exempt .wp-lightbox-overlay.\n\t\t\t\tdocument\n\t\t\t\t\t.querySelectorAll( 'body > :not(.wp-lightbox-overlay)' )\n\t\t\t\t\t.forEach( ( el ) => {\n\t\t\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t\t\tel.setAttribute( 'inert', '' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tel.removeAttribute( 'inert' );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t},\n\t\t\tinitTriggerButton() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tconst { ref } = getElement();\n\t\t\t\tstate.metadata[ imageId ].buttonRef = ref;\n\t\t\t},\n\t\t},\n\t},\n\t{ lock: true }\n);\n", "export const MIN_SIZE = 20;\nexport const LINK_DESTINATION_NONE = 'none';\nexport const LINK_DESTINATION_MEDIA = 'media';\nexport const LINK_DESTINATION_ATTACHMENT = 'attachment';\nexport const LINK_DESTINATION_CUSTOM = 'custom';\nexport const NEW_TAB_REL = [ 'noreferrer', 'noopener' ];\nexport const ALLOWED_MEDIA_TYPES = [ 'image' ];\nexport const MEDIA_ID_NO_FEATURED_IMAGE_SET = 0;\nexport const SIZED_LAYOUTS = [ 'flex', 'grid' ];\nexport const DEFAULT_MEDIA_SIZE_SLUG = 'full';\n\n/**\n * Delay in milliseconds before preloading an image after hovering.\n * This prevents unnecessary preloading during quick scrolling or mouse movements.\n */\nexport const IMAGE_PRELOAD_DELAY = 200;\n"],
  "mappings": "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",
  "names": []
}
