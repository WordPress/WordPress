/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 197:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document


/***/ }),

/***/ 346:
/***/ ((module) => {

"use strict";


const DEFAULT_RAW = {
  after: '\n',
  beforeClose: '\n',
  beforeComment: '\n',
  beforeDecl: '\n',
  beforeOpen: ' ',
  beforeRule: '\n',
  colon: ': ',
  commentLeft: ' ',
  commentRight: ' ',
  emptyBody: '',
  indent: '    ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  document(node) {
    this.body(node)
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon)
  }
}

module.exports = Stringifier
Stringifier.default = Stringifier


/***/ }),

/***/ 356:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let pico = __webpack_require__(2775)

let terminalHighlight = __webpack_require__(9746)

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line
        this.column = column
      } else {
        this.line = line.line
        this.column = line.column
        this.endLine = column.line
        this.endColumn = column.column
      }
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported

    let aside = text => text
    let mark = text => text
    let highlight = text => text
    if (color) {
      let { bold, gray, red } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
      if (terminalHighlight) {
        highlight = text => terminalHighlight(text)
      }
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)
    let maxWidth = String(end).length

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          if (line.length > 160) {
            let padding = 20
            let subLineStart = Math.max(0, this.column - padding)
            let subLineEnd = Math.max(
              this.column + padding,
              this.endColumn + padding
            )
            let subLine = line.slice(subLineStart, subLineEnd)

            let spacing =
              aside(gutter.replace(/\d/g, ' ')) +
              line
                .slice(0, Math.min(this.column - 1, padding - 1))
                .replace(/[^\t]/g, ' ')

            return (
              mark('>') +
              aside(gutter) +
              highlight(subLine) +
              '\n ' +
              spacing +
              mark('^')
            )
          }

          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')

          return (
            mark('>') +
            aside(gutter) +
            highlight(line) +
            '\n ' +
            spacing +
            mark('^')
          )
        }

        return ' ' + aside(gutter) + highlight(line)
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError


/***/ }),

/***/ 448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)
let Document = __webpack_require__(271)
let MapGenerator = __webpack_require__(1670)
let parse = __webpack_require__(4295)
let Result = __webpack_require__(9055)
let Root = __webpack_require__(9434)
let stringify = __webpack_require__(633)
let { isClean, my } = __webpack_require__(1381)
let warnOnce = __webpack_require__(3122)

const TYPE_TO_CLASS_NAME = {
  atrule: 'AtRule',
  comment: 'Comment',
  decl: 'Declaration',
  document: 'Document',
  root: 'Root',
  rule: 'Rule'
}

const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
}

const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  get content() {
    return this.stringify().content
  }

  get css() {
    return this.stringify().css
  }

  get map() {
    return this.stringify().map
  }

  get messages() {
    return this.sync().messages
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    return this.sync().root
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }

  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, postcss, result: this.result }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (false) {}
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
    }
    return error
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  then(onFulfilled, onRejected) {
    if (false) {}
    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this.css
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  warnings() {
    return this.sync().warnings()
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)


/***/ }),

/***/ 461:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Load in dependencies
var computedStyle = __webpack_require__(6109);

/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */
function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10);

  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em';

    // Calculate the em based height
    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10);

    // Revert the lineHeight style
    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  }

  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3;
  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4;
  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54;
  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96;
  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  }

  // Continue our computation
  lnHeight = Math.round(lnHeight);

  // If the line-height is "normal", calculate by font-size
  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;
    var _node = document.createElement(nodeName);
    _node.innerHTML = '&nbsp;';

    // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4
    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    }

    // Set the font-size of the element
    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr;

    // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
    _node.style.padding = '0px';
    _node.style.border = '0px';

    // Append it to the body
    var body = document.body;
    body.appendChild(_node);

    // Assume the line height of the element is the height
    var height = _node.offsetHeight;
    lnHeight = height;

    // Remove our child from the DOM
    body.removeChild(_node);
  }

  // Return the calculated height
  return lnHeight;
}

// Export lineHeight
module.exports = lineHeight;


/***/ }),

/***/ 628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(4067);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Stringifier = __webpack_require__(346)

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify


/***/ }),

/***/ 683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Comment = __webpack_require__(6589)
let Declaration = __webpack_require__(1516)
let Node = __webpack_require__(7490)
let { isClean, my } = __webpack_require__(1381)

let AtRule, parse, Root, Rule

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markTreeDirty(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markTreeDirty(i)
    }
  }
}

class Container extends Node {
  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }

  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      }
    }
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  insertAfter(exist, add) {
    let existIndex = this.index(exist)
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertBefore(exist, add) {
    let existIndex = this.index(exist)
    let type = existIndex === 0 ? 'prepend' : false
    let nodes = this.normalize(
      add,
      this.proxyOf.nodes[existIndex],
      type
    ).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (typeof nodes === 'undefined') {
      nodes = []
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector || nodes.selectors) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markTreeDirty(i)

      if (!i.raws) i.raws = {}
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this.proxyOf
      return i
    })

    return processed
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

Container.registerRoot = dependant => {
  Root = dependant
}

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}
/* c8 ignore stop */


/***/ }),

/***/ 1087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */



var ExecutionEnvironment = __webpack_require__(8202);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;


/***/ }),

/***/ 1326:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ 1381:
/***/ ((module) => {

"use strict";


module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')


/***/ }),

/***/ 1443:
/***/ ((module) => {

module.exports = function postcssPrefixSelector(options) {
  const prefix = options.prefix;
  const prefixWithSpace = /\s+$/.test(prefix) ? prefix : `${prefix} `;
  const ignoreFiles = options.ignoreFiles ? [].concat(options.ignoreFiles) : [];
  const includeFiles = options.includeFiles
    ? [].concat(options.includeFiles)
    : [];

  return function (root) {
    if (
      ignoreFiles.length &&
      root.source.input.file &&
      isFileInArray(root.source.input.file, ignoreFiles)
    ) {
      return;
    }
    if (
      includeFiles.length &&
      root.source.input.file &&
      !isFileInArray(root.source.input.file, includeFiles)
    ) {
      return;
    }

    root.walkRules((rule) => {
      const keyframeRules = [
        'keyframes',
        '-webkit-keyframes',
        '-moz-keyframes',
        '-o-keyframes',
        '-ms-keyframes',
      ];

      if (rule.parent && keyframeRules.includes(rule.parent.name)) {
        return;
      }

      rule.selectors = rule.selectors.map((selector) => {
        if (options.exclude && excludeSelector(selector, options.exclude)) {
          return selector;
        }

        if (options.transform) {
          return options.transform(
            prefix,
            selector,
            prefixWithSpace + selector,
            root.source.input.file,
            rule
          );
        }

        return prefixWithSpace + selector;
      });
    });
  };
};

function isFileInArray(file, arr) {
  return arr.some((ruleOrString) => {
    if (ruleOrString instanceof RegExp) {
      return ruleOrString.test(file);
    }

    return file.includes(ruleOrString);
  });
}

function excludeSelector(selector, excludeArr) {
  return excludeArr.some((excludeRule) => {
    if (excludeRule instanceof RegExp) {
      return excludeRule.test(selector);
    }

    return selector === excludeRule;
  });
}


/***/ }),

/***/ 1516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(7490)

class Declaration extends Node {
  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }

  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }
}

module.exports = Declaration
Declaration.default = Declaration


/***/ }),

/***/ 1524:
/***/ ((module) => {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
  var code = value.charCodeAt(0);
  var nextCode;

  if (code === plus || code === minus) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    var nextNextCode = value.charCodeAt(2);

    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code === dot) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code >= 48 && code <= 57) {
    return true;
  }

  return false;
}

// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var code;
  var nextCode;
  var nextNextCode;

  if (length === 0 || !likeNumber(value)) {
    return false;
  }

  code = value.charCodeAt(pos);

  if (code === plus || code === minus) {
    pos++;
  }

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code < 48 || code > 57) {
      break;
    }

    pos += 1;
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);

  if (code === dot && nextCode >= 48 && nextCode <= 57) {
    pos += 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);
  nextNextCode = value.charCodeAt(pos + 2);

  if (
    (code === exp || code === EXP) &&
    ((nextCode >= 48 && nextCode <= 57) ||
      ((nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
  ) {
    pos += nextCode === plus || nextCode === minus ? 3 : 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  return {
    number: value.slice(0, pos),
    unit: value.slice(pos)
  };
};


/***/ }),

/***/ 1544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parse = __webpack_require__(8491);
var walk = __webpack_require__(3815);
var stringify = __webpack_require__(4725);

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = __webpack_require__(1524);

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;


/***/ }),

/***/ 1609:
/***/ ((module) => {

"use strict";
module.exports = window["React"];

/***/ }),

/***/ 1670:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { dirname, relative, resolve, sep } = __webpack_require__(197)
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(1866)
let { pathToFileURL } = __webpack_require__(2739)

let Input = __webpack_require__(5380)

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
    this.css = cssString
    this.originalCSS = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute

    this.memoizedFileURLs = new Map()
    this.memoizedPaths = new Map()
    this.memoizedURLs = new Map()
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = null
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.startsWith('# sourceMappingURL=')) {
          this.root.removeChild(i)
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '')
    }
  }

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    } else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      })
      return [result]
    }
  }

  generateMap() {
    if (this.root) {
      this.generateString()
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      })
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      })
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>'
      })
    }

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    } else {
      return [this.css, this.map]
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ''
    }

    let last, lines
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    } else if (this.opts.from) {
      return this.path(this.opts.from)
    } else {
      return 'to.css'
    }
  }

  path(file) {
    if (this.mapOpts.absolute) return file
    if (file.charCodeAt(0) === 60 /* `<` */) return file
    if (/^\w+:\/\//.test(file)) return file
    let cached = this.memoizedPaths.get(file)
    if (cached) return cached

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    let path = relative(from, file)
    this.memoizedPaths.set(file, path)

    return path
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            }
          }
        })
      } else {
        let input = new Input(this.originalCSS, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      }
    }

    return this.previousMaps
  }

  setSourcesContent() {
    let already = {}
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          }
        }
      })
    } else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    }
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path)
    if (cached) return cached

    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString()
      this.memoizedFileURLs.set(path, fileURL)

      return fileURL
    } else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    }
  }

  toUrl(path) {
    let cached = this.memoizedURLs.get(path)
    if (cached) return cached

    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    }

    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)
    this.memoizedURLs.set(path, url)

    return url
  }
}

module.exports = MapGenerator


/***/ }),

/***/ 1866:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 2213:
/***/ ((module) => {

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!(/Win64/.exec(uas));

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : (
          agent[5] ? parseFloat(agent[5]) : NaN);
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux   = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function() {
    return _populate() || (_ie_real_version > _ie);
  },


  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function() {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function() {
    return _populate() || _firefox;
  },


  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function() {
    return _populate() || _opera;
  },


  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function() {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome : function() {
    return _populate() || _chrome;
  },


  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function() {
    return _populate() || _windows;
  },


  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function() {
    return _populate() || _iphone;
  },

  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },

  nativeApp: function() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function() {
    return _populate() || _android;
  },

  ipad: function() {
    return _populate() || _ipad;
  }
};

module.exports = UserAgent_DEPRECATED;


/***/ }),

/***/ 2327:
/***/ ((module) => {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, content, escape, next, quote
  let currentToken, escaped, escapePos, n, prev

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    endOfFile,
    nextToken,
    position
  }
}


/***/ }),

/***/ 2739:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 2775:
/***/ ((module) => {

var x=String;
var create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};
module.exports=create();
module.exports.createColors = create;


/***/ }),

/***/ 3122:
/***/ ((module) => {

"use strict";
/* eslint-disable no-console */


let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}


/***/ }),

/***/ 3815:
/***/ ((module) => {

module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};


/***/ }),

/***/ 3937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let AtRule = __webpack_require__(1326)
let Comment = __webpack_require__(6589)
let Declaration = __webpack_require__(1516)
let Root = __webpack_require__(9434)
let Rule = __webpack_require__(4092)
let tokenizer = __webpack_require__(2327)

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let prev, token, type
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().startsWith('!') && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().startsWith('!')) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
        prev.source.end = this.getPosition(token[2])
        prev.source.end.offset += prev.raws.ownSemicolon.length
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      column: pos.col,
      line: pos.line,
      offset
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { raw, value }
    }
    node[prop] = value
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  unclosedBracket(bracket) {
    throw this.input.error(
      'Unclosed bracket',
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      'Unexpected }',
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      'Unknown word ' + tokens[0][1],
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      'At-rule without name',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }
}

module.exports = Parser


/***/ }),

/***/ 4067:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 4092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)
let list = __webpack_require__(7374)

class Rule extends Container {
  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }

  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)


/***/ }),

/***/ 4132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = true;
var TextareaAutosize_1 = __webpack_require__(4462);
exports.A = TextareaAutosize_1.TextareaAutosize;


/***/ }),

/***/ 4295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)
let Input = __webpack_require__(5380)
let Parser = __webpack_require__(3937)

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (false) {}
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)


/***/ }),

/***/ 4306:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else { var mod; }
})(this, function (module, exports) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			delete: function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function createEvent(name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = null;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				return;
			}

			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = '';
			ta.style.height = ta.scrollHeight + heightOffset + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that 
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight < styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map.delete(ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function autosize(el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function autosize(el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	exports.default = autosize;
	module.exports = exports['default'];
});

/***/ }),

/***/ 4462:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
exports.__esModule = true;
var React = __webpack_require__(1609);
var PropTypes = __webpack_require__(5826);
var autosize = __webpack_require__(4306);
var _getLineHeight = __webpack_require__(461);
var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */
var TextareaAutosizeClass = /** @class */ (function (_super) {
    __extends(TextareaAutosizeClass, _super);
    function TextareaAutosizeClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function (e) {
            if (_this.props.onResize) {
                _this.props.onResize(e);
            }
        };
        _this.updateLineHeight = function () {
            if (_this.textarea) {
                _this.setState({
                    lineHeight: getLineHeight(_this.textarea)
                });
            }
        };
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            _this.currentValue = e.currentTarget.value;
            onChange && onChange(e);
        };
        return _this;
    }
    TextareaAutosizeClass.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
            this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
            /*
              the defer is needed to:
                - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                - support StyledComponents (see #71)
            */
            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
        }
        else {
            this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
        }
    };
    TextareaAutosizeClass.prototype.componentWillUnmount = function () {
        if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
        }
    };
    TextareaAutosizeClass.prototype.render = function () {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return (React.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                _this.textarea = element;
                if (typeof _this.props.innerRef === 'function') {
                    _this.props.innerRef(element);
                }
                else if (_this.props.innerRef) {
                    _this.props.innerRef.current = element;
                }
            } }), children));
    };
    TextareaAutosizeClass.prototype.componentDidUpdate = function () {
        this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass.defaultProps = {
        rows: 1,
        async: false
    };
    TextareaAutosizeClass.propTypes = {
        rows: PropTypes.number,
        maxRows: PropTypes.number,
        onResize: PropTypes.func,
        innerRef: PropTypes.any,
        async: PropTypes.bool
    };
    return TextareaAutosizeClass;
}(React.Component));
exports.TextareaAutosize = React.forwardRef(function (props, ref) {
    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
});


/***/ }),

/***/ 4725:
/***/ ((module) => {

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;


/***/ }),

/***/ 5042:
/***/ ((module) => {

// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'

let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0
    while (i--) {
      // `| 0` is more compact and faster than `Math.floor()`.
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}

let nanoid = (size = 21) => {
  let id = ''
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size | 0
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}

module.exports = { nanoid, customAlphabet }


/***/ }),

/***/ 5215:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 5380:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { nanoid } = __webpack_require__(5042)
let { isAbsolute, resolve } = __webpack_require__(197)
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(1866)
let { fileURLToPath, pathToFileURL } = __webpack_require__(2739)

let CssSyntaxError = __webpack_require__(356)
let PreviousMap = __webpack_require__(5696)
let terminalHighlight = __webpack_require__(9746)

let lineToIndexCache = Symbol('lineToIndexCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

function getLineToIndex(input) {
  if (input[lineToIndexCache]) return input[lineToIndexCache]
  let lines = input.css.split('\n')
  let lineToIndex = new Array(lines.length)
  let prevIndex = 0

  for (let i = 0, l = lines.length; i < l; i++) {
    lineToIndex[i] = prevIndex
    prevIndex += lines[i].length + 1
  }

  input[lineToIndexCache] = lineToIndex
  return lineToIndex
}

class Input {
  get from() {
    return this.file || this.id
  }

  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    this.document = this.css
    if (opts.document) this.document = opts.document.toString()

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  error(message, line, column, opts = {}) {
    let endColumn, endLine, endOffset, offset, result

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        offset = start.offset
        let pos = this.fromOffset(offset)
        line = pos.line
        column = pos.col
      } else {
        line = start.line
        column = start.column
        offset = this.fromLineAndColumn(line, column)
      }
      if (typeof end.offset === 'number') {
        endOffset = end.offset
        let pos = this.fromOffset(endOffset)
        endLine = pos.line
        endColumn = pos.col
      } else {
        endLine = end.line
        endColumn = end.column
        endOffset = this.fromLineAndColumn(end.line, end.column)
      }
    } else if (!column) {
      offset = line
      let pos = this.fromOffset(offset)
      line = pos.line
      column = pos.col
    } else {
      offset = this.fromLineAndColumn(line, column)
    }

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { column: origin.column, line: origin.line },
        origin.endLine === undefined
          ? origin.column
          : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { column, line },
        endLine === undefined ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { column, endColumn, endLine, endOffset, line, offset, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  fromLineAndColumn(line, column) {
    let lineToIndex = getLineToIndex(this)
    let index = lineToIndex[line - 1]
    return index + column - 1
  }

  fromOffset(offset) {
    let lineToIndex = getLineToIndex(this)
    let lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    }
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ column, line })
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine })
    }

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}


/***/ }),

/***/ 5404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CSSValueParser = __webpack_require__(1544)

/**
 * @type {import('postcss').PluginCreator}
 */
module.exports = (opts) => {

  const DEFAULTS = {
    skipHostRelativeUrls: true,
  }
  const config = Object.assign(DEFAULTS, opts)

  return {
    postcssPlugin: 'rebaseUrl',

    Declaration(decl) {
      // The faster way to find Declaration node
      const parsedValue = CSSValueParser(decl.value)

      let valueChanged = false
      parsedValue.walk(node => {
        if (node.type !== 'function' || node.value !== 'url') {
          return
        }

        const urlVal = node.nodes[0].value

        // bases relative URLs with rootUrl
        const basedUrl = new URL(urlVal, opts.rootUrl)

        // skip host-relative, already normalized URLs (e.g. `/images/image.jpg`, without `..`s)
        if ((basedUrl.pathname === urlVal) && config.skipHostRelativeUrls) {
          return false // skip this value
        }

        node.nodes[0].value = basedUrl.toString()
        valueChanged = true

        return false // do not walk deeper
      })

      if (valueChanged) {
        decl.value = CSSValueParser.stringify(parsedValue)
      }

    }
  }
}

module.exports.postcss = true


/***/ }),

/***/ 5417:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}


/***/ }),

/***/ 5696:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { existsSync, readFileSync } = __webpack_require__(9977)
let { dirname, join } = __webpack_require__(197)
let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(1866)

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    /* c8 ignore next 2 */
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    let uriMatch = text.match(charsetUri) || text.match(uri)
    if (uriMatch) {
      return decodeURIComponent(text.substr(uriMatch[0].length))
    }

    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)
    if (baseUriMatch) {
      return fromBase64(text.substr(baseUriMatch[0].length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/g)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap


/***/ }),

/***/ 5776:
/***/ ((module) => {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts)
      this.line = range.start.line
      this.column = range.start.column
      this.endLine = range.end.line
      this.endColumn = range.end.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning


/***/ }),

/***/ 5826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(628)();
}


/***/ }),

/***/ 6109:
/***/ ((module) => {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function (el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle;

  // In one fell swoop
  return (
    // If we have getComputedStyle
    getComputedStyle ?
      // Query it
      // TODO: From CSS-Query notes, we might need (node, null) for FF
      getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
      el.currentStyle
  )[
    // Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })
  ];
};

module.exports = computedStyle;


/***/ }),

/***/ 6589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(7490)

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ 7191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */



var UserAgent_DEPRECATED = __webpack_require__(2213);

var isEventSupported = __webpack_require__(1087);


// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}


/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function() /*string*/ {
  return (UserAgent_DEPRECATED.firefox())
           ? 'DOMMouseScroll'
           : (isEventSupported('wheel'))
               ? 'wheel'
               : 'mousewheel';
};

module.exports = normalizeWheel;


/***/ }),

/***/ 7374:
/***/ ((module) => {

"use strict";


let list = {
  comma(string) {
    return list.split(string, [','], true)
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let inQuote = false
    let prevQuote = ''
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true
        prevQuote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  }
}

module.exports = list
list.default = list


/***/ }),

/***/ 7490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let CssSyntaxError = __webpack_require__(356)
let Stringifier = __webpack_require__(346)
let stringify = __webpack_require__(633)
let { isClean, my } = __webpack_require__(1381)

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

function sourceOffset(inputCSS, position) {
  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
  if (position && typeof position.offset !== 'undefined') {
    return position.offset
  }

  let column = 1
  let line = 1
  let offset = 0

  for (let i = 0; i < inputCSS.length; i++) {
    if (line === position.line && column === position.column) {
      offset = i
      break
    }

    if (inputCSS[i] === '\n') {
      column = 1
      line += 1
    } else {
      column += 1
    }
  }

  return offset
}

class Node {
  get proxyOf() {
    return this
  }

  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      )
    }
    return new CssSyntaxError(message)
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      }
    }
  }

  /* c8 ignore next 3 */
  markClean() {
    this[isClean] = true
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  positionBy(opts = {}) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index)
    } else if (opts.word) {
      let inputString =
        'document' in this.source.input
          ? this.source.input.document
          : this.source.input.css
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
    }
    return pos
  }

  positionInside(index) {
    let column = this.source.start.column
    let line = this.source.start.line
    let inputString =
      'document' in this.source.input
        ? this.source.input.document
        : this.source.input.css
    let offset = sourceOffset(inputString, this.source.start)
    let end = offset + index

    for (let i = offset; i < end; i++) {
      if (inputString[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { column, line, offset: end }
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  rangeBy(opts = {}) {
    let inputString =
      'document' in this.source.input
        ? this.source.input.document
        : this.source.input.css
    let start = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: sourceOffset(inputString, this.source.start)
    }
    let end = this.source.end
      ? {
          column: this.source.end.column + 1,
          line: this.source.end.line,
          offset:
            typeof this.source.end.offset === 'number'
              ? // `source.end.offset` is exclusive, so we don't need to add 1
                this.source.end.offset
              : // Since line/column in this.source.end is inclusive,
                // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
                // So, we add 1 to convert it to exclusive.
                sourceOffset(inputString, this.source.end) + 1
        }
      : {
          column: start.column + 1,
          line: start.line,
          offset: start.offset + 1
        }

    if (opts.word) {
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index)
        end = this.positionInside(index + opts.word.length)
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line,
          offset: sourceOffset(inputString, opts.start)
        }
      } else if (opts.index) {
        start = this.positionInside(opts.index)
      }

      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line,
          offset: sourceOffset(inputString, opts.end)
        }
      } else if (typeof opts.endIndex === 'number') {
        end = this.positionInside(opts.endIndex)
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      }
    }

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = {
        column: start.column + 1,
        line: start.line,
        offset: start.offset + 1
      }
    }

    return { end, start }
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        if (value == null) continue
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  warn(result, text, opts = {}) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }
}

module.exports = Node
Node.default = Node


/***/ }),

/***/ 7520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(7191);


/***/ }),

/***/ 7661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let MapGenerator = __webpack_require__(1670)
let parse = __webpack_require__(4295)
const Result = __webpack_require__(9055)
let stringify = __webpack_require__(633)
let warnOnce = __webpack_require__(3122)

class NoWorkResult {
  get content() {
    return this.result.css
  }

  get css() {
    return this.result.css
  }

  get map() {
    return this.result.map
  }

  get messages() {
    return []
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    if (this._root) {
      return this._root
    }

    let root
    let parser = parse

    try {
      root = parser(this._css, this._opts)
    } catch (error) {
      this.error = error
    }

    if (this.error) {
      throw this.error
    } else {
      this._root = root
      return root
    }
  }

  get [Symbol.toStringTag]() {
    return 'NoWorkResult'
  }

  constructor(processor, css, opts) {
    css = css.toString()
    this.stringified = false

    this._processor = processor
    this._css = css
    this._opts = opts
    this._map = undefined
    let root

    let str = stringify
    this.result = new Result(this._processor, root, this._opts)
    this.result.css = css

    let self = this
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root
      }
    })

    let map = new MapGenerator(str, root, this._opts, css)
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate()
      if (generatedCSS) {
        this.result.css = generatedCSS
      }
      if (generatedMap) {
        this.result.map = generatedMap
      }
    } else {
      map.clearAnnotation()
      this.result.css = map.css
    }
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    return Promise.resolve(this.result)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  sync() {
    if (this.error) throw this.error
    return this.result
  }

  then(onFulfilled, onRejected) {
    if (false) {}

    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this._css
  }

  warnings() {
    return []
  }
}

module.exports = NoWorkResult
NoWorkResult.default = NoWorkResult


/***/ }),

/***/ 7734:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst


  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';


module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }


    if ((a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0]))) return false;
      return true;
    }

    if ((a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      for (i of a.entries())
        if (!b.has(i[0])) return false;
      return true;
    }

    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }


    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 8021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*istanbul ignore start*/


__webpack_unused_export__ = ({
  value: true
});
exports.JJ = diffChars;
__webpack_unused_export__ = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__(5417))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
.
/*istanbul ignore start*/
default
/*istanbul ignore end*/
();

/*istanbul ignore start*/
__webpack_unused_export__ = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}


/***/ }),

/***/ 8202:
/***/ ((module) => {

"use strict";
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */



var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;


/***/ }),

/***/ 8491:
/***/ ((module) => {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next,
    quote,
    prev,
    token,
    escape,
    escapePos,
    whitespacePos,
    parenthesesOpenPos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
        prev.sourceEndIndex += token.length;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash &&
          value.charCodeAt(next + 1) !== star &&
          (!parent ||
            (parent && parent.type === "function" && parent.value !== "calc")))
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);
      token.sourceEndIndex = token.unclosed ? next : next + 1;
      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      next = value.indexOf("*/", pos);

      token = {
        type: "comment",
        sourceIndex: pos,
        sourceEndIndex: next + 2
      };

      if (next === -1) {
        token.unclosed = true;
        next = value.length;
        token.sourceEndIndex = next;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Operation within calc
    } else if (
      (code === slash || code === star) &&
      parent &&
      parent.type === "function" &&
      parent.value === "calc"
    ) {
      token = value[pos];
      tokens.push({
        type: "word",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token
      });
      pos += 1;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      parenthesesOpenPos = pos;
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(parenthesesOpenPos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (parenthesesOpenPos < whitespacePos) {
          if (pos !== whitespacePos + 1) {
            token.nodes = [
              {
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }
            ];
          } else {
            token.nodes = [];
          }
          if (token.unclosed && whitespacePos + 1 !== next) {
            token.after = "";
            token.nodes.push({
              type: "space",
              sourceIndex: whitespacePos + 1,
              sourceEndIndex: next,
              value: value.slice(whitespacePos + 1, next)
            });
          } else {
            token.after = value.slice(whitespacePos + 1, next);
            token.sourceEndIndex = next;
          }
        } else {
          token.after = "";
          token.nodes = [];
        }
        pos = next + 1;
        token.sourceEndIndex = token.unclosed ? next : pos;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        token.sourceEndIndex = pos + 1;
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      parent.sourceEndIndex += after.length;
      after = "";
      balanced -= 1;
      stack[stack.length - 1].sourceEndIndex = pos;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === slash &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else if (
        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
        plus === token.charCodeAt(1) &&
        isUnicodeRange.test(token.slice(2))
      ) {
        tokens.push({
          type: "unicode-range",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
    stack[pos].sourceEndIndex = value.length;
  }

  return stack[0].nodes;
};


/***/ }),

/***/ 9055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Warning = __webpack_require__(5776)

class Result {
  get content() {
    return this.css
  }

  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = ''
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }
}

module.exports = Result
Result.default = Result


/***/ }),

/***/ 9434:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(683)

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root

Container.registerRoot(Root)


/***/ }),

/***/ 9656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Document = __webpack_require__(271)
let LazyResult = __webpack_require__(448)
let NoWorkResult = __webpack_require__(7661)
let Root = __webpack_require__(9434)

class Processor {
  constructor(plugins = []) {
    this.version = '8.5.6'
    this.plugins = this.normalize(plugins)
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (false) {}
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }

  process(css, opts = {}) {
    if (
      !this.plugins.length &&
      !opts.parser &&
      !opts.stringifier &&
      !opts.syntax
    ) {
      return new NoWorkResult(this, css, opts)
    } else {
      return new LazyResult(this, css, opts)
    }
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)


/***/ }),

/***/ 9681:
/***/ ((module) => {

var characterMap = {
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "AE",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "A",
	"": "C",
	"": "C",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "E",
	"": "I",
	"": "I",
	"": "I",
	"": "I",
	"": "I",
	"": "I",
	"": "I",
	"": "I",
	"": "D",
	"": "N",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "O",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "U",
	"": "Y",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "ae",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "a",
	"": "c",
	"": "c",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "e",
	"": "i",
	"": "i",
	"": "i",
	"": "i",
	"": "i",
	"": "i",
	"": "i",
	"": "i",
	"": "d",
	"": "n",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "o",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "u",
	"": "y",
	"": "y",
	"": "A",
	"": "a",
	"": "A",
	"": "a",
	"": "A",
	"": "a",
	"": "C",
	"": "c",
	"": "C",
	"": "c",
	"": "C",
	"": "c",
	"": "C",
	"": "c",
	"C": "C",
	"c": "c",
	"": "D",
	"": "d",
	"": "D",
	"": "d",
	"": "E",
	"": "e",
	"": "E",
	"": "e",
	"": "E",
	"": "e",
	"": "E",
	"": "e",
	"": "E",
	"": "e",
	"": "G",
	"": "G",
	"": "g",
	"": "g",
	"": "G",
	"": "g",
	"": "G",
	"": "g",
	"": "G",
	"": "g",
	"": "H",
	"": "h",
	"": "H",
	"": "h",
	"": "H",
	"": "h",
	"": "I",
	"": "i",
	"": "I",
	"": "i",
	"": "I",
	"": "i",
	"": "I",
	"": "i",
	"": "I",
	"": "i",
	"": "IJ",
	"": "ij",
	"": "J",
	"": "j",
	"": "K",
	"": "k",
	"": "K",
	"": "k",
	"K": "K",
	"k": "k",
	"": "L",
	"": "l",
	"": "L",
	"": "l",
	"": "L",
	"": "l",
	"": "L",
	"": "l",
	"": "l",
	"": "l",
	"": "M",
	"": "m",
	"M": "M",
	"m": "m",
	"": "N",
	"": "n",
	"": "N",
	"": "n",
	"": "N",
	"": "n",
	"": "n",
	"N": "N",
	"n": "n",
	"": "O",
	"": "o",
	"": "O",
	"": "o",
	"": "O",
	"": "o",
	"": "OE",
	"": "oe",
	"P": "P",
	"p": "p",
	"": "R",
	"": "r",
	"": "R",
	"": "r",
	"": "R",
	"": "r",
	"R": "R",
	"r": "r",
	"": "R",
	"": "r",
	"": "S",
	"": "s",
	"": "S",
	"": "s",
	"": "S",
	"": "S",
	"": "s",
	"": "s",
	"": "S",
	"": "s",
	"": "T",
	"": "t",
	"": "t",
	"": "T",
	"": "T",
	"": "t",
	"": "T",
	"": "t",
	"T": "T",
	"t": "t",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"V": "V",
	"v": "v",
	"": "W",
	"": "w",
	"": "W",
	"": "w",
	"X": "X",
	"x": "x",
	"": "Y",
	"": "y",
	"": "Y",
	"Y": "Y",
	"y": "y",
	"": "Z",
	"": "z",
	"": "Z",
	"": "z",
	"": "Z",
	"": "z",
	"": "s",
	"": "f",
	"": "O",
	"": "o",
	"": "U",
	"": "u",
	"": "A",
	"": "a",
	"": "I",
	"": "i",
	"": "O",
	"": "o",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "U",
	"": "u",
	"": "A",
	"": "a",
	"": "AE",
	"": "ae",
	"": "O",
	"": "o",
	"": "TH",
	"": "th",
	"": "P",
	"": "p",
	"": "S",
	"": "s",
	"X": "X",
	"x": "x",
	"": "",
	"": "",
	"": "",
	"": "",
	"A": "A",
	"a": "a",
	"E": "E",
	"e": "e",
	"I": "I",
	"i": "i",
	"": "N",
	"": "n",
	"": "O",
	"": "o",
	"": "O",
	"": "o",
	"": "U",
	"": "u",
	"": "W",
	"": "w",
	"": "Y",
	"": "y",
	"": "A",
	"": "a",
	"": "E",
	"": "e",
	"": "I",
	"": "i",
	"": "O",
	"": "o",
	"": "R",
	"": "r",
	"": "U",
	"": "u",
	"B": "B",
	"b": "b",
	"": "C",
	"": "c",
	"": "E",
	"": "e",
	"F": "F",
	"f": "f",
	"": "G",
	"": "g",
	"": "H",
	"": "h",
	"J": "J",
	"": "j",
	"": "K",
	"": "k",
	"M": "M",
	"m": "m",
	"P": "P",
	"p": "p",
	"Q": "Q",
	"q": "q",
	"": "R",
	"": "r",
	"": "S",
	"": "s",
	"V": "V",
	"v": "v",
	"W": "W",
	"w": "w",
	"X": "X",
	"x": "x",
	"Y": "Y",
	"y": "y",
	"A": "A",
	"a": "a",
	"B": "B",
	"b": "b",
	"": "D",
	"": "d",
	"": "E",
	"": "e",
	"": "E",
	"": "e",
	"": "H",
	"": "h",
	"I": "I",
	"i": "i",
	"": "I",
	"": "i",
	"M": "M",
	"m": "m",
	"O": "O",
	"o": "o",
	"Q": "Q",
	"q": "q",
	"U": "U",
	"u": "u",
	"X": "X",
	"x": "x",
	"Z": "Z",
	"z": "z",
	"":"",
	"":"",
	"":"",
	"":"",
};

var chars = Object.keys(characterMap).join('|');
var allAccents = new RegExp(chars, 'g');
var firstAccent = new RegExp(chars, '');

function matcher(match) {
	return characterMap[match];
}

var removeAccents = function(string) {
	return string.replace(allAccents, matcher);
};

var hasAccents = function(string) {
	return !!string.match(firstAccent);
};

module.exports = removeAccents;
module.exports.has = hasAccents;
module.exports.remove = removeAccents;


/***/ }),

/***/ 9746:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 9977:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AlignmentControl: () => (/* reexport */ AlignmentControl),
  AlignmentToolbar: () => (/* reexport */ AlignmentToolbar),
  Autocomplete: () => (/* reexport */ autocomplete_default),
  BlockAlignmentControl: () => (/* reexport */ BlockAlignmentControl),
  BlockAlignmentToolbar: () => (/* reexport */ BlockAlignmentToolbar),
  BlockBreadcrumb: () => (/* reexport */ block_breadcrumb_default),
  BlockCanvas: () => (/* reexport */ block_canvas_default),
  BlockColorsStyleSelector: () => (/* reexport */ color_style_selector_default),
  BlockContextProvider: () => (/* reexport */ BlockContextProvider),
  BlockControls: () => (/* reexport */ block_controls_default),
  BlockEdit: () => (/* reexport */ BlockEdit),
  BlockEditorKeyboardShortcuts: () => (/* reexport */ keyboard_shortcuts_default),
  BlockEditorProvider: () => (/* reexport */ provider_provider_default),
  BlockFormatControls: () => (/* reexport */ BlockFormatControls),
  BlockIcon: () => (/* reexport */ block_icon_default),
  BlockInspector: () => (/* reexport */ block_inspector_default),
  BlockList: () => (/* reexport */ BlockList),
  BlockMover: () => (/* reexport */ block_mover_default),
  BlockNavigationDropdown: () => (/* reexport */ dropdown_default),
  BlockPopover: () => (/* reexport */ block_popover_default),
  BlockPreview: () => (/* reexport */ block_preview_default),
  BlockSelectionClearer: () => (/* reexport */ BlockSelectionClearer),
  BlockSettingsMenu: () => (/* reexport */ block_settings_menu_default),
  BlockSettingsMenuControls: () => (/* reexport */ block_settings_menu_controls_default),
  BlockStyles: () => (/* reexport */ block_styles_default),
  BlockTitle: () => (/* reexport */ BlockTitle),
  BlockToolbar: () => (/* reexport */ BlockToolbar),
  BlockTools: () => (/* reexport */ BlockTools),
  BlockVerticalAlignmentControl: () => (/* reexport */ BlockVerticalAlignmentControl),
  BlockVerticalAlignmentToolbar: () => (/* reexport */ BlockVerticalAlignmentToolbar),
  ButtonBlockAppender: () => (/* reexport */ button_block_appender_default),
  ButtonBlockerAppender: () => (/* reexport */ ButtonBlockerAppender),
  ColorPalette: () => (/* reexport */ color_palette_default),
  ColorPaletteControl: () => (/* reexport */ ColorPaletteControl),
  ContrastChecker: () => (/* reexport */ contrast_checker_default),
  CopyHandler: () => (/* reexport */ CopyHandler),
  DefaultBlockAppender: () => (/* reexport */ DefaultBlockAppender),
  FontSizePicker: () => (/* reexport */ font_size_picker_default),
  HeadingLevelDropdown: () => (/* reexport */ HeadingLevelDropdown),
  HeightControl: () => (/* reexport */ HeightControl),
  InnerBlocks: () => (/* reexport */ inner_blocks_default),
  Inserter: () => (/* reexport */ inserter_default),
  InspectorAdvancedControls: () => (/* reexport */ InspectorAdvancedControls),
  InspectorControls: () => (/* reexport */ inspector_controls_default),
  JustifyContentControl: () => (/* reexport */ JustifyContentControl),
  JustifyToolbar: () => (/* reexport */ JustifyToolbar),
  LineHeightControl: () => (/* reexport */ line_height_control_default),
  LinkControl: () => (/* reexport */ link_control_default),
  MediaPlaceholder: () => (/* reexport */ media_placeholder_default),
  MediaReplaceFlow: () => (/* reexport */ media_replace_flow_default),
  MediaUpload: () => (/* reexport */ media_upload_default),
  MediaUploadCheck: () => (/* reexport */ check_default),
  MultiSelectScrollIntoView: () => (/* reexport */ MultiSelectScrollIntoView),
  NavigableToolbar: () => (/* reexport */ NavigableToolbar),
  ObserveTyping: () => (/* reexport */ observe_typing_default),
  PanelColorSettings: () => (/* reexport */ panel_color_settings_default),
  PlainText: () => (/* reexport */ plain_text_default),
  RecursionProvider: () => (/* reexport */ RecursionProvider),
  RichText: () => (/* reexport */ rich_text_default),
  RichTextShortcut: () => (/* reexport */ RichTextShortcut),
  RichTextToolbarButton: () => (/* reexport */ RichTextToolbarButton),
  SETTINGS_DEFAULTS: () => (/* reexport */ SETTINGS_DEFAULTS),
  SkipToSelectedBlock: () => (/* reexport */ SkipToSelectedBlock),
  ToolSelector: () => (/* reexport */ tool_selector_default),
  Typewriter: () => (/* reexport */ typewriter_default),
  URLInput: () => (/* reexport */ url_input_default),
  URLInputButton: () => (/* reexport */ button_default),
  URLPopover: () => (/* reexport */ url_popover_default),
  Warning: () => (/* reexport */ warning_default),
  WritingFlow: () => (/* reexport */ writing_flow_default),
  __experimentalBlockAlignmentMatrixControl: () => (/* reexport */ block_alignment_matrix_control_default),
  __experimentalBlockFullHeightAligmentControl: () => (/* reexport */ block_full_height_alignment_control_default),
  __experimentalBlockPatternSetup: () => (/* reexport */ block_pattern_setup_default),
  __experimentalBlockPatternsList: () => (/* reexport */ block_patterns_list_default),
  __experimentalBlockVariationPicker: () => (/* reexport */ block_variation_picker_default),
  __experimentalBlockVariationTransforms: () => (/* reexport */ block_variation_transforms_default),
  __experimentalBorderRadiusControl: () => (/* reexport */ BorderRadiusControl),
  __experimentalColorGradientControl: () => (/* reexport */ control_default),
  __experimentalColorGradientSettingsDropdown: () => (/* reexport */ ColorGradientSettingsDropdown),
  __experimentalDateFormatPicker: () => (/* reexport */ DateFormatPicker),
  __experimentalDuotoneControl: () => (/* reexport */ duotone_control_default),
  __experimentalFontAppearanceControl: () => (/* reexport */ FontAppearanceControl),
  __experimentalFontFamilyControl: () => (/* reexport */ FontFamilyControl),
  __experimentalGetBorderClassesAndStyles: () => (/* reexport */ getBorderClassesAndStyles),
  __experimentalGetColorClassesAndStyles: () => (/* reexport */ getColorClassesAndStyles),
  __experimentalGetElementClassName: () => (/* reexport */ __experimentalGetElementClassName),
  __experimentalGetGapCSSValue: () => (/* reexport */ getGapCSSValue),
  __experimentalGetGradientClass: () => (/* reexport */ __experimentalGetGradientClass),
  __experimentalGetGradientObjectByGradientValue: () => (/* reexport */ __experimentalGetGradientObjectByGradientValue),
  __experimentalGetShadowClassesAndStyles: () => (/* reexport */ getShadowClassesAndStyles),
  __experimentalGetSpacingClassesAndStyles: () => (/* reexport */ getSpacingClassesAndStyles),
  __experimentalImageEditor: () => (/* reexport */ ImageEditor),
  __experimentalImageSizeControl: () => (/* reexport */ ImageSizeControl),
  __experimentalImageURLInputUI: () => (/* reexport */ ImageURLInputUI),
  __experimentalInspectorPopoverHeader: () => (/* reexport */ InspectorPopoverHeader),
  __experimentalLetterSpacingControl: () => (/* reexport */ LetterSpacingControl),
  __experimentalLibrary: () => (/* reexport */ library_default),
  __experimentalLinkControl: () => (/* reexport */ DeprecatedExperimentalLinkControl),
  __experimentalLinkControlSearchInput: () => (/* reexport */ __experimentalLinkControlSearchInput),
  __experimentalLinkControlSearchItem: () => (/* reexport */ __experimentalLinkControlSearchItem),
  __experimentalLinkControlSearchResults: () => (/* reexport */ __experimentalLinkControlSearchResults),
  __experimentalListView: () => (/* reexport */ list_view_list_view_default),
  __experimentalPanelColorGradientSettings: () => (/* reexport */ panel_color_gradient_settings_default),
  __experimentalPreviewOptions: () => (/* reexport */ PreviewOptions),
  __experimentalPublishDateTimePicker: () => (/* reexport */ publish_date_time_picker_default),
  __experimentalRecursionProvider: () => (/* reexport */ DeprecatedExperimentalRecursionProvider),
  __experimentalResponsiveBlockControl: () => (/* reexport */ responsive_block_control_default),
  __experimentalSpacingSizesControl: () => (/* reexport */ SpacingSizesControl),
  __experimentalTextDecorationControl: () => (/* reexport */ TextDecorationControl),
  __experimentalTextTransformControl: () => (/* reexport */ TextTransformControl),
  __experimentalUnitControl: () => (/* reexport */ UnitControl),
  __experimentalUseBlockOverlayActive: () => (/* reexport */ useBlockOverlayActive),
  __experimentalUseBlockPreview: () => (/* reexport */ useBlockPreview),
  __experimentalUseBorderProps: () => (/* reexport */ useBorderProps),
  __experimentalUseColorProps: () => (/* reexport */ useColorProps),
  __experimentalUseCustomSides: () => (/* reexport */ useCustomSides),
  __experimentalUseGradient: () => (/* reexport */ __experimentalUseGradient),
  __experimentalUseHasRecursion: () => (/* reexport */ DeprecatedExperimentalUseHasRecursion),
  __experimentalUseMultipleOriginColorsAndGradients: () => (/* reexport */ useMultipleOriginColorsAndGradients),
  __experimentalUseResizeCanvas: () => (/* reexport */ useResizeCanvas),
  __experimentalWritingModeControl: () => (/* reexport */ WritingModeControl),
  __unstableBlockNameContext: () => (/* reexport */ block_name_context_default),
  __unstableBlockSettingsMenuFirstItem: () => (/* reexport */ block_settings_menu_first_item_default),
  __unstableBlockToolbarLastItem: () => (/* reexport */ block_toolbar_last_item_default),
  __unstableEditorStyles: () => (/* reexport */ editor_styles_default),
  __unstableIframe: () => (/* reexport */ iframe_default),
  __unstableInserterMenuExtension: () => (/* reexport */ inserter_menu_extension_default),
  __unstableRichTextInputEvent: () => (/* reexport */ __unstableRichTextInputEvent),
  __unstableUseBlockSelectionClearer: () => (/* reexport */ useBlockSelectionClearer),
  __unstableUseClipboardHandler: () => (/* reexport */ __unstableUseClipboardHandler),
  __unstableUseMouseMoveTypingReset: () => (/* reexport */ useMouseMoveTypingReset),
  __unstableUseTypewriter: () => (/* reexport */ useTypewriter),
  __unstableUseTypingObserver: () => (/* reexport */ useTypingObserver),
  createCustomColorsHOC: () => (/* reexport */ createCustomColorsHOC),
  getColorClassName: () => (/* reexport */ getColorClassName),
  getColorObjectByAttributeValues: () => (/* reexport */ getColorObjectByAttributeValues),
  getColorObjectByColorValue: () => (/* reexport */ getColorObjectByColorValue),
  getComputedFluidTypographyValue: () => (/* reexport */ getComputedFluidTypographyValue),
  getCustomValueFromPreset: () => (/* reexport */ getCustomValueFromPreset),
  getFontSize: () => (/* reexport */ utils_getFontSize),
  getFontSizeClass: () => (/* reexport */ getFontSizeClass),
  getFontSizeObjectByValue: () => (/* reexport */ utils_getFontSizeObjectByValue),
  getGradientSlugByValue: () => (/* reexport */ getGradientSlugByValue),
  getGradientValueBySlug: () => (/* reexport */ getGradientValueBySlug),
  getPxFromCssUnit: () => (/* reexport */ get_px_from_css_unit_default),
  getSpacingPresetCssVar: () => (/* reexport */ getSpacingPresetCssVar),
  getTypographyClassesAndStyles: () => (/* reexport */ getTypographyClassesAndStyles),
  isValueSpacingPreset: () => (/* reexport */ isValueSpacingPreset),
  privateApis: () => (/* reexport */ privateApis),
  store: () => (/* reexport */ store),
  storeConfig: () => (/* reexport */ storeConfig),
  transformStyles: () => (/* reexport */ transform_styles_default),
  useBlockBindingsUtils: () => (/* reexport */ useBlockBindingsUtils),
  useBlockCommands: () => (/* reexport */ useBlockCommands),
  useBlockDisplayInformation: () => (/* reexport */ useBlockDisplayInformation),
  useBlockEditContext: () => (/* reexport */ useBlockEditContext),
  useBlockEditingMode: () => (/* reexport */ useBlockEditingMode),
  useBlockProps: () => (/* reexport */ use_block_props_useBlockProps),
  useCachedTruthy: () => (/* reexport */ useCachedTruthy),
  useHasRecursion: () => (/* reexport */ useHasRecursion),
  useInnerBlocksProps: () => (/* reexport */ useInnerBlocksProps),
  useSetting: () => (/* reexport */ useSetting),
  useSettings: () => (/* reexport */ use_settings_useSettings),
  useStyleOverride: () => (/* reexport */ useStyleOverride),
  withColorContext: () => (/* reexport */ with_color_context_default),
  withColors: () => (/* reexport */ withColors),
  withFontSizes: () => (/* reexport */ with_font_sizes_default)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/private-selectors.js
var private_selectors_namespaceObject = {};
__webpack_require__.r(private_selectors_namespaceObject);
__webpack_require__.d(private_selectors_namespaceObject, {
  getAllPatterns: () => (getAllPatterns),
  getBlockRemovalRules: () => (getBlockRemovalRules),
  getBlockSettings: () => (getBlockSettings),
  getBlockStyles: () => (getBlockStyles),
  getBlockWithoutAttributes: () => (getBlockWithoutAttributes),
  getClosestAllowedInsertionPoint: () => (getClosestAllowedInsertionPoint),
  getClosestAllowedInsertionPointForPattern: () => (getClosestAllowedInsertionPointForPattern),
  getContentLockingParent: () => (getContentLockingParent),
  getEnabledBlockParents: () => (getEnabledBlockParents),
  getEnabledClientIdsTree: () => (getEnabledClientIdsTree),
  getExpandedBlock: () => (getExpandedBlock),
  getInserterMediaCategories: () => (getInserterMediaCategories),
  getInsertionPoint: () => (getInsertionPoint),
  getLastFocus: () => (getLastFocus),
  getLastInsertedBlocksClientIds: () => (getLastInsertedBlocksClientIds),
  getOpenedBlockSettingsMenu: () => (getOpenedBlockSettingsMenu),
  getParentSectionBlock: () => (getParentSectionBlock),
  getPatternBySlug: () => (getPatternBySlug),
  getRegisteredInserterMediaCategories: () => (getRegisteredInserterMediaCategories),
  getRemovalPromptData: () => (getRemovalPromptData),
  getReusableBlocks: () => (getReusableBlocks),
  getSectionRootClientId: () => (getSectionRootClientId),
  getStyleOverrides: () => (getStyleOverrides),
  getTemporarilyEditingAsBlocks: () => (getTemporarilyEditingAsBlocks),
  getTemporarilyEditingFocusModeToRevert: () => (getTemporarilyEditingFocusModeToRevert),
  getZoomLevel: () => (getZoomLevel),
  hasAllowedPatterns: () => (hasAllowedPatterns),
  hasBlockSpotlight: () => (private_selectors_hasBlockSpotlight),
  isBlockHidden: () => (isBlockHidden),
  isBlockInterfaceHidden: () => (private_selectors_isBlockInterfaceHidden),
  isBlockSubtreeDisabled: () => (isBlockSubtreeDisabled),
  isContainerInsertableToInContentOnlyMode: () => (isContainerInsertableToInContentOnlyMode),
  isDragging: () => (private_selectors_isDragging),
  isSectionBlock: () => (isSectionBlock),
  isZoomOut: () => (isZoomOut)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  __experimentalGetActiveBlockIdByBlockNames: () => (__experimentalGetActiveBlockIdByBlockNames),
  __experimentalGetAllowedBlocks: () => (__experimentalGetAllowedBlocks),
  __experimentalGetAllowedPatterns: () => (__experimentalGetAllowedPatterns),
  __experimentalGetBlockListSettingsForBlocks: () => (__experimentalGetBlockListSettingsForBlocks),
  __experimentalGetDirectInsertBlock: () => (__experimentalGetDirectInsertBlock),
  __experimentalGetGlobalBlocksByName: () => (__experimentalGetGlobalBlocksByName),
  __experimentalGetLastBlockAttributeChanges: () => (__experimentalGetLastBlockAttributeChanges),
  __experimentalGetParsedPattern: () => (__experimentalGetParsedPattern),
  __experimentalGetPatternTransformItems: () => (__experimentalGetPatternTransformItems),
  __experimentalGetPatternsByBlockTypes: () => (__experimentalGetPatternsByBlockTypes),
  __experimentalGetReusableBlockTitle: () => (__experimentalGetReusableBlockTitle),
  __unstableGetBlockWithoutInnerBlocks: () => (__unstableGetBlockWithoutInnerBlocks),
  __unstableGetClientIdWithClientIdsTree: () => (__unstableGetClientIdWithClientIdsTree),
  __unstableGetClientIdsTree: () => (__unstableGetClientIdsTree),
  __unstableGetContentLockingParent: () => (__unstableGetContentLockingParent),
  __unstableGetSelectedBlocksWithPartialSelection: () => (__unstableGetSelectedBlocksWithPartialSelection),
  __unstableGetTemporarilyEditingAsBlocks: () => (__unstableGetTemporarilyEditingAsBlocks),
  __unstableGetTemporarilyEditingFocusModeToRevert: () => (__unstableGetTemporarilyEditingFocusModeToRevert),
  __unstableGetVisibleBlocks: () => (__unstableGetVisibleBlocks),
  __unstableHasActiveBlockOverlayActive: () => (__unstableHasActiveBlockOverlayActive),
  __unstableIsFullySelected: () => (__unstableIsFullySelected),
  __unstableIsLastBlockChangeIgnored: () => (__unstableIsLastBlockChangeIgnored),
  __unstableIsSelectionCollapsed: () => (__unstableIsSelectionCollapsed),
  __unstableIsSelectionMergeable: () => (__unstableIsSelectionMergeable),
  __unstableIsWithinBlockOverlay: () => (__unstableIsWithinBlockOverlay),
  __unstableSelectionHasUnmergeableBlock: () => (__unstableSelectionHasUnmergeableBlock),
  areInnerBlocksControlled: () => (areInnerBlocksControlled),
  canEditBlock: () => (canEditBlock),
  canInsertBlockType: () => (canInsertBlockType),
  canInsertBlocks: () => (canInsertBlocks),
  canLockBlockType: () => (canLockBlockType),
  canMoveBlock: () => (canMoveBlock),
  canMoveBlocks: () => (canMoveBlocks),
  canRemoveBlock: () => (canRemoveBlock),
  canRemoveBlocks: () => (canRemoveBlocks),
  didAutomaticChange: () => (didAutomaticChange),
  getAdjacentBlockClientId: () => (getAdjacentBlockClientId),
  getAllowedBlocks: () => (getAllowedBlocks),
  getBlock: () => (getBlock),
  getBlockAttributes: () => (getBlockAttributes),
  getBlockCount: () => (getBlockCount),
  getBlockEditingMode: () => (getBlockEditingMode),
  getBlockHierarchyRootClientId: () => (getBlockHierarchyRootClientId),
  getBlockIndex: () => (getBlockIndex),
  getBlockInsertionPoint: () => (getBlockInsertionPoint),
  getBlockListSettings: () => (getBlockListSettings),
  getBlockMode: () => (getBlockMode),
  getBlockName: () => (getBlockName),
  getBlockNamesByClientId: () => (getBlockNamesByClientId),
  getBlockOrder: () => (getBlockOrder),
  getBlockParents: () => (getBlockParents),
  getBlockParentsByBlockName: () => (getBlockParentsByBlockName),
  getBlockRootClientId: () => (getBlockRootClientId),
  getBlockSelectionEnd: () => (getBlockSelectionEnd),
  getBlockSelectionStart: () => (getBlockSelectionStart),
  getBlockTransformItems: () => (getBlockTransformItems),
  getBlocks: () => (getBlocks),
  getBlocksByClientId: () => (getBlocksByClientId),
  getBlocksByName: () => (getBlocksByName),
  getClientIdsOfDescendants: () => (getClientIdsOfDescendants),
  getClientIdsWithDescendants: () => (getClientIdsWithDescendants),
  getDirectInsertBlock: () => (getDirectInsertBlock),
  getDraggedBlockClientIds: () => (getDraggedBlockClientIds),
  getFirstMultiSelectedBlockClientId: () => (getFirstMultiSelectedBlockClientId),
  getGlobalBlockCount: () => (getGlobalBlockCount),
  getHoveredBlockClientId: () => (getHoveredBlockClientId),
  getInserterItems: () => (getInserterItems),
  getLastMultiSelectedBlockClientId: () => (getLastMultiSelectedBlockClientId),
  getLowestCommonAncestorWithSelectedBlock: () => (getLowestCommonAncestorWithSelectedBlock),
  getMultiSelectedBlockClientIds: () => (getMultiSelectedBlockClientIds),
  getMultiSelectedBlocks: () => (getMultiSelectedBlocks),
  getMultiSelectedBlocksEndClientId: () => (getMultiSelectedBlocksEndClientId),
  getMultiSelectedBlocksStartClientId: () => (getMultiSelectedBlocksStartClientId),
  getNextBlockClientId: () => (getNextBlockClientId),
  getPatternsByBlockTypes: () => (getPatternsByBlockTypes),
  getPreviousBlockClientId: () => (getPreviousBlockClientId),
  getSelectedBlock: () => (getSelectedBlock),
  getSelectedBlockClientId: () => (getSelectedBlockClientId),
  getSelectedBlockClientIds: () => (getSelectedBlockClientIds),
  getSelectedBlockCount: () => (getSelectedBlockCount),
  getSelectedBlocksInitialCaretPosition: () => (getSelectedBlocksInitialCaretPosition),
  getSelectionEnd: () => (getSelectionEnd),
  getSelectionStart: () => (getSelectionStart),
  getSettings: () => (getSettings),
  getTemplate: () => (getTemplate),
  getTemplateLock: () => (getTemplateLock),
  hasBlockMovingClientId: () => (hasBlockMovingClientId),
  hasDraggedInnerBlock: () => (hasDraggedInnerBlock),
  hasInserterItems: () => (hasInserterItems),
  hasMultiSelection: () => (hasMultiSelection),
  hasSelectedBlock: () => (hasSelectedBlock),
  hasSelectedInnerBlock: () => (hasSelectedInnerBlock),
  isAncestorBeingDragged: () => (isAncestorBeingDragged),
  isAncestorMultiSelected: () => (isAncestorMultiSelected),
  isBlockBeingDragged: () => (isBlockBeingDragged),
  isBlockHighlighted: () => (isBlockHighlighted),
  isBlockInsertionPointVisible: () => (isBlockInsertionPointVisible),
  isBlockMultiSelected: () => (isBlockMultiSelected),
  isBlockSelected: () => (isBlockSelected),
  isBlockValid: () => (isBlockValid),
  isBlockVisible: () => (isBlockVisible),
  isBlockWithinSelection: () => (isBlockWithinSelection),
  isCaretWithinFormattedText: () => (isCaretWithinFormattedText),
  isDraggingBlocks: () => (isDraggingBlocks),
  isFirstMultiSelectedBlock: () => (isFirstMultiSelectedBlock),
  isGroupable: () => (isGroupable),
  isLastBlockChangePersistent: () => (isLastBlockChangePersistent),
  isMultiSelecting: () => (selectors_isMultiSelecting),
  isSelectionEnabled: () => (selectors_isSelectionEnabled),
  isTyping: () => (selectors_isTyping),
  isUngroupable: () => (isUngroupable),
  isValidTemplate: () => (isValidTemplate),
  wasBlockJustInserted: () => (wasBlockJustInserted)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/private-actions.js
var private_actions_namespaceObject = {};
__webpack_require__.r(private_actions_namespaceObject);
__webpack_require__.d(private_actions_namespaceObject, {
  __experimentalUpdateSettings: () => (__experimentalUpdateSettings),
  clearBlockRemovalPrompt: () => (clearBlockRemovalPrompt),
  deleteStyleOverride: () => (deleteStyleOverride),
  ensureDefaultBlock: () => (ensureDefaultBlock),
  expandBlock: () => (expandBlock),
  hideBlockInterface: () => (hideBlockInterface),
  modifyContentLockBlock: () => (modifyContentLockBlock),
  privateRemoveBlocks: () => (privateRemoveBlocks),
  resetZoomLevel: () => (resetZoomLevel),
  setBlockRemovalRules: () => (setBlockRemovalRules),
  setInsertionPoint: () => (setInsertionPoint),
  setLastFocus: () => (setLastFocus),
  setOpenedBlockSettingsMenu: () => (setOpenedBlockSettingsMenu),
  setStyleOverride: () => (setStyleOverride),
  setZoomLevel: () => (setZoomLevel),
  showBlockInterface: () => (showBlockInterface),
  startDragging: () => (startDragging),
  stopDragging: () => (stopDragging),
  stopEditingAsBlocks: () => (stopEditingAsBlocks),
  toggleBlockSpotlight: () => (toggleBlockSpotlight)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  __unstableDeleteSelection: () => (__unstableDeleteSelection),
  __unstableExpandSelection: () => (__unstableExpandSelection),
  __unstableMarkAutomaticChange: () => (__unstableMarkAutomaticChange),
  __unstableMarkLastChangeAsPersistent: () => (__unstableMarkLastChangeAsPersistent),
  __unstableMarkNextChangeAsNotPersistent: () => (__unstableMarkNextChangeAsNotPersistent),
  __unstableSaveReusableBlock: () => (__unstableSaveReusableBlock),
  __unstableSetEditorMode: () => (__unstableSetEditorMode),
  __unstableSetTemporarilyEditingAsBlocks: () => (__unstableSetTemporarilyEditingAsBlocks),
  __unstableSplitSelection: () => (__unstableSplitSelection),
  clearSelectedBlock: () => (clearSelectedBlock),
  duplicateBlocks: () => (duplicateBlocks),
  enterFormattedText: () => (enterFormattedText),
  exitFormattedText: () => (exitFormattedText),
  flashBlock: () => (flashBlock),
  hideInsertionPoint: () => (hideInsertionPoint),
  hoverBlock: () => (hoverBlock),
  insertAfterBlock: () => (insertAfterBlock),
  insertBeforeBlock: () => (insertBeforeBlock),
  insertBlock: () => (insertBlock),
  insertBlocks: () => (insertBlocks),
  insertDefaultBlock: () => (insertDefaultBlock),
  mergeBlocks: () => (mergeBlocks),
  moveBlockToPosition: () => (moveBlockToPosition),
  moveBlocksDown: () => (moveBlocksDown),
  moveBlocksToPosition: () => (moveBlocksToPosition),
  moveBlocksUp: () => (moveBlocksUp),
  multiSelect: () => (multiSelect),
  receiveBlocks: () => (receiveBlocks),
  registerInserterMediaCategory: () => (registerInserterMediaCategory),
  removeBlock: () => (removeBlock),
  removeBlocks: () => (removeBlocks),
  replaceBlock: () => (replaceBlock),
  replaceBlocks: () => (replaceBlocks),
  replaceInnerBlocks: () => (replaceInnerBlocks),
  resetBlocks: () => (resetBlocks),
  resetSelection: () => (resetSelection),
  selectBlock: () => (selectBlock),
  selectNextBlock: () => (selectNextBlock),
  selectPreviousBlock: () => (selectPreviousBlock),
  selectionChange: () => (selectionChange),
  setBlockEditingMode: () => (setBlockEditingMode),
  setBlockMovingClientId: () => (setBlockMovingClientId),
  setBlockVisibility: () => (setBlockVisibility),
  setHasControlledInnerBlocks: () => (setHasControlledInnerBlocks),
  setTemplateValidity: () => (setTemplateValidity),
  showInsertionPoint: () => (showInsertionPoint),
  startDraggingBlocks: () => (startDraggingBlocks),
  startMultiSelect: () => (startMultiSelect),
  startTyping: () => (startTyping),
  stopDraggingBlocks: () => (stopDraggingBlocks),
  stopMultiSelect: () => (stopMultiSelect),
  stopTyping: () => (stopTyping),
  synchronizeTemplate: () => (synchronizeTemplate),
  toggleBlockHighlight: () => (toggleBlockHighlight),
  toggleBlockMode: () => (toggleBlockMode),
  toggleSelection: () => (toggleSelection),
  unsetBlockEditingMode: () => (unsetBlockEditingMode),
  updateBlock: () => (updateBlock),
  updateBlockAttributes: () => (updateBlockAttributes),
  updateBlockListSettings: () => (updateBlockListSettings),
  updateSettings: () => (updateSettings),
  validateBlocksToTemplate: () => (validateBlocksToTemplate)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/upload-media/build-module/store/selectors.js
var store_selectors_namespaceObject = {};
__webpack_require__.r(store_selectors_namespaceObject);
__webpack_require__.d(store_selectors_namespaceObject, {
  getItems: () => (getItems),
  getSettings: () => (selectors_getSettings),
  isUploading: () => (isUploading),
  isUploadingById: () => (isUploadingById),
  isUploadingByUrl: () => (isUploadingByUrl)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/upload-media/build-module/store/private-selectors.js
var store_private_selectors_namespaceObject = {};
__webpack_require__.r(store_private_selectors_namespaceObject);
__webpack_require__.d(store_private_selectors_namespaceObject, {
  getAllItems: () => (getAllItems),
  getBlobUrls: () => (getBlobUrls),
  getItem: () => (getItem),
  getPausedUploadForPost: () => (getPausedUploadForPost),
  isBatchUploaded: () => (isBatchUploaded),
  isPaused: () => (isPaused),
  isUploadingToPost: () => (isUploadingToPost)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/upload-media/build-module/store/actions.js
var store_actions_namespaceObject = {};
__webpack_require__.r(store_actions_namespaceObject);
__webpack_require__.d(store_actions_namespaceObject, {
  addItems: () => (addItems),
  cancelItem: () => (cancelItem)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/upload-media/build-module/store/private-actions.js
var store_private_actions_namespaceObject = {};
__webpack_require__.r(store_private_actions_namespaceObject);
__webpack_require__.d(store_private_actions_namespaceObject, {
  addItem: () => (addItem),
  finishOperation: () => (finishOperation),
  pauseQueue: () => (pauseQueue),
  prepareItem: () => (prepareItem),
  processItem: () => (processItem),
  removeItem: () => (removeItem),
  resumeQueue: () => (resumeQueue),
  revokeBlobUrls: () => (revokeBlobUrls),
  updateSettings: () => (private_actions_updateSettings),
  uploadItem: () => (uploadItem)
});

// NAMESPACE OBJECT: ./node_modules/@wordpress/block-editor/build-module/components/global-styles/index.js
var global_styles_namespaceObject = {};
__webpack_require__.r(global_styles_namespaceObject);
__webpack_require__.d(global_styles_namespaceObject, {
  AdvancedPanel: () => (AdvancedPanel),
  BackgroundPanel: () => (background_panel_BackgroundImagePanel),
  BorderPanel: () => (BorderPanel),
  ColorPanel: () => (ColorPanel),
  DimensionsPanel: () => (DimensionsPanel),
  FiltersPanel: () => (FiltersPanel),
  GlobalStylesContext: () => (GlobalStylesContext),
  ImageSettingsPanel: () => (ImageSettingsPanel),
  TypographyPanel: () => (TypographyPanel),
  areGlobalStyleConfigsEqual: () => (areGlobalStyleConfigsEqual),
  getBlockCSSSelector: () => (getBlockCSSSelector),
  getBlockSelectors: () => (getBlockSelectors),
  getGlobalStylesChanges: () => (getGlobalStylesChanges),
  getLayoutStyles: () => (getLayoutStyles),
  toStyles: () => (toStyles),
  useGlobalSetting: () => (useGlobalSetting),
  useGlobalStyle: () => (useGlobalStyle),
  useGlobalStylesOutput: () => (useGlobalStylesOutput),
  useGlobalStylesOutputWithConfig: () => (useGlobalStylesOutputWithConfig),
  useGlobalStylesReset: () => (useGlobalStylesReset),
  useHasBackgroundPanel: () => (useHasBackgroundPanel),
  useHasBorderPanel: () => (useHasBorderPanel),
  useHasBorderPanelControls: () => (useHasBorderPanelControls),
  useHasColorPanel: () => (useHasColorPanel),
  useHasDimensionsPanel: () => (useHasDimensionsPanel),
  useHasFiltersPanel: () => (useHasFiltersPanel),
  useHasImageSettingsPanel: () => (useHasImageSettingsPanel),
  useHasTypographyPanel: () => (useHasTypographyPanel),
  useSettingsForBlockElement: () => (useSettingsForBlockElement)
});

;// external "ReactJSXRuntime"
const external_ReactJSXRuntime_namespaceObject = window["ReactJSXRuntime"];
;// external ["wp","blocks"]
const external_wp_blocks_namespaceObject = window["wp"]["blocks"];
;// external ["wp","element"]
const external_wp_element_namespaceObject = window["wp"]["element"];
;// external ["wp","data"]
const external_wp_data_namespaceObject = window["wp"]["data"];
;// external ["wp","compose"]
const external_wp_compose_namespaceObject = window["wp"]["compose"];
;// external ["wp","hooks"]
const external_wp_hooks_namespaceObject = window["wp"]["hooks"];
;// ./node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js

const mayDisplayControlsKey = Symbol("mayDisplayControls");
const mayDisplayParentControlsKey = Symbol("mayDisplayParentControls");
const blockEditingModeKey = Symbol("blockEditingMode");
const blockBindingsKey = Symbol("blockBindings");
const isPreviewModeKey = Symbol("isPreviewMode");
const DEFAULT_BLOCK_EDIT_CONTEXT = {
  name: "",
  isSelected: false
};
const Context = (0,external_wp_element_namespaceObject.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
Context.displayName = "BlockEditContext";
const { Provider } = Context;
function useBlockEditContext() {
  return (0,external_wp_element_namespaceObject.useContext)(Context);
}


;// external ["wp","deprecated"]
const external_wp_deprecated_namespaceObject = window["wp"]["deprecated"];
var external_wp_deprecated_default = /*#__PURE__*/__webpack_require__.n(external_wp_deprecated_namespaceObject);
// EXTERNAL MODULE: ./node_modules/fast-deep-equal/es6/index.js
var es6 = __webpack_require__(7734);
var es6_default = /*#__PURE__*/__webpack_require__.n(es6);
;// external ["wp","i18n"]
const external_wp_i18n_namespaceObject = window["wp"]["i18n"];
;// ./node_modules/@wordpress/block-editor/build-module/store/defaults.js

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};
const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Black"),
      slug: "black",
      color: "#000000"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Cyan bluish gray"),
      slug: "cyan-bluish-gray",
      color: "#abb8c3"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("White"),
      slug: "white",
      color: "#ffffff"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Pale pink"),
      slug: "pale-pink",
      color: "#f78da7"
    },
    { name: (0,external_wp_i18n_namespaceObject.__)("Vivid red"), slug: "vivid-red", color: "#cf2e2e" },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Luminous vivid orange"),
      slug: "luminous-vivid-orange",
      color: "#ff6900"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Luminous vivid amber"),
      slug: "luminous-vivid-amber",
      color: "#fcb900"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Light green cyan"),
      slug: "light-green-cyan",
      color: "#7bdcb5"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Vivid green cyan"),
      slug: "vivid-green-cyan",
      color: "#00d084"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Pale cyan blue"),
      slug: "pale-cyan-blue",
      color: "#8ed1fc"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Vivid cyan blue"),
      slug: "vivid-cyan-blue",
      color: "#0693e3"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Vivid purple"),
      slug: "vivid-purple",
      color: "#9b51e0"
    }
  ],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [
    {
      name: (0,external_wp_i18n_namespaceObject._x)("Small", "font size name"),
      size: 13,
      slug: "small"
    },
    {
      name: (0,external_wp_i18n_namespaceObject._x)("Normal", "font size name"),
      size: 16,
      slug: "normal"
    },
    {
      name: (0,external_wp_i18n_namespaceObject._x)("Medium", "font size name"),
      size: 20,
      slug: "medium"
    },
    {
      name: (0,external_wp_i18n_namespaceObject._x)("Large", "font size name"),
      size: 36,
      slug: "large"
    },
    {
      name: (0,external_wp_i18n_namespaceObject._x)("Huge", "font size name"),
      size: 42,
      slug: "huge"
    }
  ],
  // Image default size slug.
  imageDefaultSize: "large",
  imageSizes: [
    { slug: "thumbnail", name: (0,external_wp_i18n_namespaceObject.__)("Thumbnail") },
    { slug: "medium", name: (0,external_wp_i18n_namespaceObject.__)("Medium") },
    { slug: "large", name: (0,external_wp_i18n_namespaceObject.__)("Large") },
    { slug: "full", name: (0,external_wp_i18n_namespaceObject.__)("Full Size") }
  ],
  // Allow plugin to disable Image Editor if need be.
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  // Allows to disable block locking interface.
  canLockBlocks: true,
  // Allows to disable Openverse media category in the inserter.
  enableOpenverseMediaCategory: true,
  clearBlockSelection: true,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  isPreviewMode: false,
  // These settings will be completely revamped in the future.
  // The goal is to evolve this into an API which will instruct
  // the block inspector to animate transitions between what it
  // displays based on the relationship between the selected block
  // and its parent, and only enable it if the parent is controlling
  // its children blocks.
  blockInspectorAnimation: {
    animationParent: "core/navigation",
    "core/navigation": { enterDirection: "leftToRight" },
    "core/navigation-submenu": { enterDirection: "rightToLeft" },
    "core/navigation-link": { enterDirection: "rightToLeft" },
    "core/search": { enterDirection: "rightToLeft" },
    "core/social-links": { enterDirection: "rightToLeft" },
    "core/page-list": { enterDirection: "rightToLeft" },
    "core/spacer": { enterDirection: "rightToLeft" },
    "core/home-link": { enterDirection: "rightToLeft" },
    "core/site-title": { enterDirection: "rightToLeft" },
    "core/site-logo": { enterDirection: "rightToLeft" }
  },
  generateAnchors: false,
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Vivid cyan blue to vivid purple"),
      gradient: "linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)",
      slug: "vivid-cyan-blue-to-vivid-purple"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Light green cyan to vivid green cyan"),
      gradient: "linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)",
      slug: "light-green-cyan-to-vivid-green-cyan"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Luminous vivid amber to luminous vivid orange"),
      gradient: "linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)",
      slug: "luminous-vivid-amber-to-luminous-vivid-orange"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Luminous vivid orange to vivid red"),
      gradient: "linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)",
      slug: "luminous-vivid-orange-to-vivid-red"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Very light gray to cyan bluish gray"),
      gradient: "linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)",
      slug: "very-light-gray-to-cyan-bluish-gray"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Cool to warm spectrum"),
      gradient: "linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)",
      slug: "cool-to-warm-spectrum"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Blush light purple"),
      gradient: "linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)",
      slug: "blush-light-purple"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Blush bordeaux"),
      gradient: "linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)",
      slug: "blush-bordeaux"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Luminous dusk"),
      gradient: "linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)",
      slug: "luminous-dusk"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Pale ocean"),
      gradient: "linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)",
      slug: "pale-ocean"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Electric grass"),
      gradient: "linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)",
      slug: "electric-grass"
    },
    {
      name: (0,external_wp_i18n_namespaceObject.__)("Midnight"),
      gradient: "linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)",
      slug: "midnight"
    }
  ],
  __unstableResolvedAssets: { styles: [], scripts: [] }
};


;// ./node_modules/@wordpress/block-editor/build-module/store/array.js
function insertAt(array, elements, index) {
  return [
    ...array.slice(0, index),
    ...Array.isArray(elements) ? elements : [elements],
    ...array.slice(index)
  ];
}
function moveTo(array, from, to, count = 1) {
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(
    withoutMovedElements,
    array.slice(from, from + count),
    to
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/store/private-keys.js
const globalStylesDataKey = Symbol("globalStylesDataKey");
const globalStylesLinksDataKey = Symbol("globalStylesLinks");
const selectBlockPatternsKey = Symbol("selectBlockPatternsKey");
const reusableBlocksSelectKey = Symbol("reusableBlocksSelect");
const sectionRootClientIdKey = Symbol("sectionRootClientIdKey");
const mediaEditKey = Symbol("mediaEditKey");


;// external ["wp","privateApis"]
const external_wp_privateApis_namespaceObject = window["wp"]["privateApis"];
;// ./node_modules/@wordpress/block-editor/build-module/lock-unlock.js

const { lock, unlock } = (0,external_wp_privateApis_namespaceObject.__dangerousOptInToUnstableAPIsOnlyForCoreModules)(
  "I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.",
  "@wordpress/block-editor"
);


;// ./node_modules/@wordpress/block-editor/build-module/store/reducer.js









const { isContentBlock } = unlock(external_wp_blocks_namespaceObject.privateApis);
const identity = (x) => x;
function mapBlockOrder(blocks2, rootClientId = "") {
  const result = /* @__PURE__ */ new Map();
  const current = [];
  result.set(rootClientId, current);
  blocks2.forEach((block) => {
    const { clientId, innerBlocks } = block;
    current.push(clientId);
    mapBlockOrder(innerBlocks, clientId).forEach(
      (order, subClientId) => {
        result.set(subClientId, order);
      }
    );
  });
  return result;
}
function mapBlockParents(blocks2, rootClientId = "") {
  const result = [];
  const stack = [[rootClientId, blocks2]];
  while (stack.length) {
    const [parent, currentBlocks] = stack.shift();
    currentBlocks.forEach(({ innerBlocks, ...block }) => {
      result.push([block.clientId, parent]);
      if (innerBlocks?.length) {
        stack.push([block.clientId, innerBlocks]);
      }
    });
  }
  return result;
}
function flattenBlocks(blocks2, transform = identity) {
  const result = [];
  const stack = [...blocks2];
  while (stack.length) {
    const { innerBlocks, ...block } = stack.shift();
    stack.push(...innerBlocks);
    result.push([block.clientId, transform(block)]);
  }
  return result;
}
function getFlattenedClientIds(blocks2) {
  const result = {};
  const stack = [...blocks2];
  while (stack.length) {
    const { innerBlocks, ...block } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = true;
  }
  return result;
}
function getFlattenedBlocksWithoutAttributes(blocks2) {
  return flattenBlocks(blocks2, (block) => {
    const { attributes, ...restBlock } = block;
    return restBlock;
  });
}
function getFlattenedBlockAttributes(blocks2) {
  return flattenBlocks(blocks2, (block) => block.attributes);
}
function hasSameKeys(a, b) {
  return es6_default()(Object.keys(a), Object.keys(b));
}
function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === "UPDATE_BLOCK_ATTRIBUTES" && lastAction !== void 0 && lastAction.type === "UPDATE_BLOCK_ATTRIBUTES" && es6_default()(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}
function updateBlockTreeForBlocks(state, blocks2) {
  const treeToUpdate = state.tree;
  const stack = [...blocks2];
  const flattenedBlocks = [...blocks2];
  while (stack.length) {
    const block = stack.shift();
    stack.push(...block.innerBlocks);
    flattenedBlocks.push(...block.innerBlocks);
  }
  for (const block of flattenedBlocks) {
    treeToUpdate.set(block.clientId, {});
  }
  for (const block of flattenedBlocks) {
    treeToUpdate.set(
      block.clientId,
      Object.assign(treeToUpdate.get(block.clientId), {
        ...state.byClientId.get(block.clientId),
        attributes: state.attributes.get(block.clientId),
        innerBlocks: block.innerBlocks.map(
          (subBlock) => treeToUpdate.get(subBlock.clientId)
        )
      })
    );
  }
}
function updateParentInnerBlocksInTree(state, updatedClientIds, updateChildrenOfUpdatedClientIds = false) {
  const treeToUpdate = state.tree;
  const uncontrolledParents = /* @__PURE__ */ new Set([]);
  const controlledParents = /* @__PURE__ */ new Set();
  for (const clientId of updatedClientIds) {
    let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents.get(clientId);
    do {
      if (state.controlledInnerBlocks[current]) {
        controlledParents.add(current);
        break;
      } else {
        uncontrolledParents.add(current);
        current = state.parents.get(current);
      }
    } while (current !== void 0);
  }
  for (const clientId of uncontrolledParents) {
    treeToUpdate.set(clientId, { ...treeToUpdate.get(clientId) });
  }
  for (const clientId of uncontrolledParents) {
    treeToUpdate.get(clientId).innerBlocks = (state.order.get(clientId) || []).map((subClientId) => treeToUpdate.get(subClientId));
  }
  for (const clientId of controlledParents) {
    treeToUpdate.set("controlled||" + clientId, {
      innerBlocks: (state.order.get(clientId) || []).map(
        (subClientId) => treeToUpdate.get(subClientId)
      )
    });
  }
}
const withBlockTree = (reducer) => (state = {}, action) => {
  const newState = reducer(state, action);
  if (newState === state) {
    return state;
  }
  newState.tree = state.tree ? state.tree : /* @__PURE__ */ new Map();
  switch (action.type) {
    case "RECEIVE_BLOCKS":
    case "INSERT_BLOCKS": {
      newState.tree = new Map(newState.tree);
      updateBlockTreeForBlocks(newState, action.blocks);
      updateParentInnerBlocksInTree(
        newState,
        action.rootClientId ? [action.rootClientId] : [""],
        true
      );
      break;
    }
    case "UPDATE_BLOCK":
      newState.tree = new Map(newState.tree);
      newState.tree.set(action.clientId, {
        ...newState.tree.get(action.clientId),
        ...newState.byClientId.get(action.clientId),
        attributes: newState.attributes.get(action.clientId)
      });
      updateParentInnerBlocksInTree(
        newState,
        [action.clientId],
        false
      );
      break;
    case "SYNC_DERIVED_BLOCK_ATTRIBUTES":
    case "UPDATE_BLOCK_ATTRIBUTES": {
      newState.tree = new Map(newState.tree);
      action.clientIds.forEach((clientId) => {
        newState.tree.set(clientId, {
          ...newState.tree.get(clientId),
          attributes: newState.attributes.get(clientId)
        });
      });
      updateParentInnerBlocksInTree(
        newState,
        action.clientIds,
        false
      );
      break;
    }
    case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
      const inserterClientIds = getFlattenedClientIds(
        action.blocks
      );
      newState.tree = new Map(newState.tree);
      action.replacedClientIds.forEach((clientId) => {
        newState.tree.delete(clientId);
        if (!inserterClientIds[clientId]) {
          newState.tree.delete("controlled||" + clientId);
        }
      });
      updateBlockTreeForBlocks(newState, action.blocks);
      updateParentInnerBlocksInTree(
        newState,
        action.blocks.map((b) => b.clientId),
        false
      );
      const parentsOfRemovedBlocks2 = [];
      for (const clientId of action.clientIds) {
        const parentId = state.parents.get(clientId);
        if (parentId !== void 0 && (parentId === "" || newState.byClientId.get(parentId))) {
          parentsOfRemovedBlocks2.push(parentId);
        }
      }
      updateParentInnerBlocksInTree(
        newState,
        parentsOfRemovedBlocks2,
        true
      );
      break;
    }
    case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
      const parentsOfRemovedBlocks = [];
      for (const clientId of action.clientIds) {
        const parentId = state.parents.get(clientId);
        if (parentId !== void 0 && (parentId === "" || newState.byClientId.get(parentId))) {
          parentsOfRemovedBlocks.push(parentId);
        }
      }
      newState.tree = new Map(newState.tree);
      action.removedClientIds.forEach((clientId) => {
        newState.tree.delete(clientId);
        newState.tree.delete("controlled||" + clientId);
      });
      updateParentInnerBlocksInTree(
        newState,
        parentsOfRemovedBlocks,
        true
      );
      break;
    case "MOVE_BLOCKS_TO_POSITION": {
      const updatedBlockUids = [];
      if (action.fromRootClientId) {
        updatedBlockUids.push(action.fromRootClientId);
      } else {
        updatedBlockUids.push("");
      }
      if (action.toRootClientId) {
        updatedBlockUids.push(action.toRootClientId);
      }
      newState.tree = new Map(newState.tree);
      updateParentInnerBlocksInTree(
        newState,
        updatedBlockUids,
        true
      );
      break;
    }
    case "MOVE_BLOCKS_UP":
    case "MOVE_BLOCKS_DOWN": {
      const updatedBlockUids = [
        action.rootClientId ? action.rootClientId : ""
      ];
      newState.tree = new Map(newState.tree);
      updateParentInnerBlocksInTree(
        newState,
        updatedBlockUids,
        true
      );
      break;
    }
    case "SAVE_REUSABLE_BLOCK_SUCCESS": {
      const updatedBlockUids = [];
      newState.attributes.forEach((attributes, clientId) => {
        if (newState.byClientId.get(clientId).name === "core/block" && attributes.ref === action.updatedId) {
          updatedBlockUids.push(clientId);
        }
      });
      newState.tree = new Map(newState.tree);
      updatedBlockUids.forEach((clientId) => {
        newState.tree.set(clientId, {
          ...newState.byClientId.get(clientId),
          attributes: newState.attributes.get(clientId),
          innerBlocks: newState.tree.get(clientId).innerBlocks
        });
      });
      updateParentInnerBlocksInTree(
        newState,
        updatedBlockUids,
        false
      );
    }
  }
  return newState;
};
function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  let explicitPersistent;
  return (state, action) => {
    let nextState = reducer(state, action);
    let nextIsPersistentChange;
    if (action.type === "SET_EXPLICIT_PERSISTENT") {
      explicitPersistent = action.isPersistentChange;
      nextIsPersistentChange = state.isPersistentChange ?? true;
    }
    if (explicitPersistent !== void 0) {
      nextIsPersistentChange = explicitPersistent;
      return nextIsPersistentChange === nextState.isPersistentChange ? nextState : {
        ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }
    const isExplicitPersistentChange = action.type === "MARK_LAST_CHANGE_AS_PERSISTENT" || markNextChangeAsNotPersistent;
    if (state === nextState && !isExplicitPersistentChange) {
      markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
      nextIsPersistentChange = state?.isPersistentChange ?? true;
      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }
      return {
        ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }
    nextState = {
      ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    };
    lastAction = action;
    markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
    return nextState;
  };
}
function withIgnoredBlockChange(reducer) {
  const IGNORED_ACTION_TYPES = /* @__PURE__ */ new Set(["RECEIVE_BLOCKS"]);
  return (state, action) => {
    const nextState = reducer(state, action);
    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }
    return nextState;
  };
}
const withInnerBlocksRemoveCascade = (reducer) => (state, action) => {
  const getAllChildren = (clientIds) => {
    let result = clientIds;
    for (let i = 0; i < result.length; i++) {
      if (!state.order.get(result[i]) || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }
      if (result === clientIds) {
        result = [...result];
      }
      result.push(...state.order.get(result[i]));
    }
    return result;
  };
  if (state) {
    switch (action.type) {
      case "REMOVE_BLOCKS":
        action = {
          ...action,
          type: "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN",
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;
      case "REPLACE_BLOCKS":
        action = {
          ...action,
          type: "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN",
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }
  return reducer(state, action);
};
const withBlockReset = (reducer) => (state, action) => {
  if (action.type === "RESET_BLOCKS") {
    const newState = {
      ...state,
      byClientId: new Map(
        getFlattenedBlocksWithoutAttributes(action.blocks)
      ),
      attributes: new Map(getFlattenedBlockAttributes(action.blocks)),
      order: mapBlockOrder(action.blocks),
      parents: new Map(mapBlockParents(action.blocks)),
      controlledInnerBlocks: {}
    };
    newState.tree = new Map(state?.tree);
    updateBlockTreeForBlocks(newState, action.blocks);
    newState.tree.set("", {
      innerBlocks: action.blocks.map(
        (subBlock) => newState.tree.get(subBlock.clientId)
      )
    });
    return newState;
  }
  return reducer(state, action);
};
const withReplaceInnerBlocks = (reducer) => (state, action) => {
  if (action.type !== "REPLACE_INNER_BLOCKS") {
    return reducer(state, action);
  }
  const nestedControllers = {};
  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];
    while (stack.length) {
      const { innerBlocks, ...block } = stack.shift();
      stack.push(...innerBlocks);
      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  }
  let stateAfterBlocksRemoval = state;
  if (state.order.get(action.rootClientId)) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: "REMOVE_BLOCKS",
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order.get(action.rootClientId)
    });
  }
  let stateAfterInsert = stateAfterBlocksRemoval;
  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, {
      ...action,
      type: "INSERT_BLOCKS",
      index: 0
    });
    const stateAfterInsertOrder = new Map(stateAfterInsert.order);
    Object.keys(nestedControllers).forEach((key) => {
      if (state.order.get(key)) {
        stateAfterInsertOrder.set(key, state.order.get(key));
      }
    });
    stateAfterInsert.order = stateAfterInsertOrder;
    stateAfterInsert.tree = new Map(stateAfterInsert.tree);
    Object.keys(nestedControllers).forEach((_key) => {
      const key = `controlled||${_key}`;
      if (state.tree.has(key)) {
        stateAfterInsert.tree.set(key, state.tree.get(key));
      }
    });
  }
  return stateAfterInsert;
};
const withSaveReusableBlock = (reducer) => (state, action) => {
  if (state && action.type === "SAVE_REUSABLE_BLOCK_SUCCESS") {
    const { id, updatedId } = action;
    if (id === updatedId) {
      return state;
    }
    state = { ...state };
    state.attributes = new Map(state.attributes);
    state.attributes.forEach((attributes, clientId) => {
      const { name } = state.byClientId.get(clientId);
      if (name === "core/block" && attributes.ref === id) {
        state.attributes.set(clientId, {
          ...attributes,
          ref: updatedId
        });
      }
    });
  }
  return reducer(state, action);
};
const withResetControlledBlocks = (reducer) => (state, action) => {
  if (action.type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
    const tempState = reducer(state, {
      type: "REPLACE_INNER_BLOCKS",
      rootClientId: action.clientId,
      blocks: []
    });
    return reducer(tempState, action);
  }
  return reducer(state, action);
};
const blocks = (0,external_wp_compose_namespaceObject.pipe)(
  external_wp_data_namespaceObject.combineReducers,
  withSaveReusableBlock,
  // Needs to be before withBlockCache.
  withBlockTree,
  // Needs to be before withInnerBlocksRemoveCascade.
  withInnerBlocksRemoveCascade,
  withReplaceInnerBlocks,
  // Needs to be after withInnerBlocksRemoveCascade.
  withBlockReset,
  withPersistentBlockChange,
  withIgnoredBlockChange,
  withResetControlledBlocks
)({
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  byClientId(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "RECEIVE_BLOCKS":
      case "INSERT_BLOCKS": {
        const newState = new Map(state);
        getFlattenedBlocksWithoutAttributes(action.blocks).forEach(
          ([key, value]) => {
            newState.set(key, value);
          }
        );
        return newState;
      }
      case "UPDATE_BLOCK": {
        if (!state.has(action.clientId)) {
          return state;
        }
        const { attributes, ...changes } = action.updates;
        if (Object.values(changes).length === 0) {
          return state;
        }
        const newState = new Map(state);
        newState.set(action.clientId, {
          ...state.get(action.clientId),
          ...changes
        });
        return newState;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        if (!action.blocks) {
          return state;
        }
        const newState = new Map(state);
        action.replacedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        getFlattenedBlocksWithoutAttributes(action.blocks).forEach(
          ([key, value]) => {
            newState.set(key, value);
          }
        );
        return newState;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const newState = new Map(state);
        action.removedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        return newState;
      }
    }
    return state;
  },
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  attributes(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "RECEIVE_BLOCKS":
      case "INSERT_BLOCKS": {
        const newState = new Map(state);
        getFlattenedBlockAttributes(action.blocks).forEach(
          ([key, value]) => {
            newState.set(key, value);
          }
        );
        return newState;
      }
      case "UPDATE_BLOCK": {
        if (!state.get(action.clientId) || !action.updates.attributes) {
          return state;
        }
        const newState = new Map(state);
        newState.set(action.clientId, {
          ...state.get(action.clientId),
          ...action.updates.attributes
        });
        return newState;
      }
      case "SYNC_DERIVED_BLOCK_ATTRIBUTES":
      case "UPDATE_BLOCK_ATTRIBUTES": {
        if (action.clientIds.every((id) => !state.get(id))) {
          return state;
        }
        let hasChange = false;
        const newState = new Map(state);
        for (const clientId of action.clientIds) {
          const updatedAttributeEntries = Object.entries(
            !!action.options?.uniqueByBlock ? action.attributes[clientId] : action.attributes ?? {}
          );
          if (updatedAttributeEntries.length === 0) {
            continue;
          }
          let hasUpdatedAttributes = false;
          const existingAttributes = state.get(clientId);
          const newAttributes = {};
          updatedAttributeEntries.forEach(([key, value]) => {
            if (existingAttributes[key] !== value) {
              hasUpdatedAttributes = true;
              newAttributes[key] = value;
            }
          });
          hasChange = hasChange || hasUpdatedAttributes;
          if (hasUpdatedAttributes) {
            newState.set(clientId, {
              ...existingAttributes,
              ...newAttributes
            });
          }
        }
        return hasChange ? newState : state;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        if (!action.blocks) {
          return state;
        }
        const newState = new Map(state);
        action.replacedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        getFlattenedBlockAttributes(action.blocks).forEach(
          ([key, value]) => {
            newState.set(key, value);
          }
        );
        return newState;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const newState = new Map(state);
        action.removedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        return newState;
      }
    }
    return state;
  },
  // The state is using a Map instead of a plain object for performance reasons.
  // You can run the "./test/performance.js" unit test to check the impact
  // code changes can have on this reducer.
  order(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "RECEIVE_BLOCKS": {
        const blockOrder = mapBlockOrder(action.blocks);
        const newState = new Map(state);
        blockOrder.forEach((order, clientId) => {
          if (clientId !== "") {
            newState.set(clientId, order);
          }
        });
        newState.set(
          "",
          (state.get("") ?? []).concat(blockOrder[""])
        );
        return newState;
      }
      case "INSERT_BLOCKS": {
        const { rootClientId = "" } = action;
        const subState = state.get(rootClientId) || [];
        const mappedBlocks = mapBlockOrder(
          action.blocks,
          rootClientId
        );
        const { index = subState.length } = action;
        const newState = new Map(state);
        mappedBlocks.forEach((order, clientId) => {
          newState.set(clientId, order);
        });
        newState.set(
          rootClientId,
          insertAt(
            subState,
            mappedBlocks.get(rootClientId),
            index
          )
        );
        return newState;
      }
      case "MOVE_BLOCKS_TO_POSITION": {
        const {
          fromRootClientId = "",
          toRootClientId = "",
          clientIds
        } = action;
        const { index = state.get(toRootClientId).length } = action;
        if (fromRootClientId === toRootClientId) {
          const subState = state.get(toRootClientId);
          const fromIndex = subState.indexOf(clientIds[0]);
          const newState2 = new Map(state);
          newState2.set(
            toRootClientId,
            moveTo(
              state.get(toRootClientId),
              fromIndex,
              index,
              clientIds.length
            )
          );
          return newState2;
        }
        const newState = new Map(state);
        newState.set(
          fromRootClientId,
          state.get(fromRootClientId)?.filter((id) => !clientIds.includes(id)) ?? []
        );
        newState.set(
          toRootClientId,
          insertAt(state.get(toRootClientId), clientIds, index)
        );
        return newState;
      }
      case "MOVE_BLOCKS_UP": {
        const { clientIds, rootClientId = "" } = action;
        const firstClientId = clientIds[0];
        const subState = state.get(rootClientId);
        if (!subState.length || firstClientId === subState[0]) {
          return state;
        }
        const firstIndex = subState.indexOf(firstClientId);
        const newState = new Map(state);
        newState.set(
          rootClientId,
          moveTo(
            subState,
            firstIndex,
            firstIndex - 1,
            clientIds.length
          )
        );
        return newState;
      }
      case "MOVE_BLOCKS_DOWN": {
        const { clientIds, rootClientId = "" } = action;
        const firstClientId = clientIds[0];
        const lastClientId = clientIds[clientIds.length - 1];
        const subState = state.get(rootClientId);
        if (!subState.length || lastClientId === subState[subState.length - 1]) {
          return state;
        }
        const firstIndex = subState.indexOf(firstClientId);
        const newState = new Map(state);
        newState.set(
          rootClientId,
          moveTo(
            subState,
            firstIndex,
            firstIndex + 1,
            clientIds.length
          )
        );
        return newState;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const { clientIds } = action;
        if (!action.blocks) {
          return state;
        }
        const mappedBlocks = mapBlockOrder(action.blocks);
        const newState = new Map(state);
        action.replacedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        mappedBlocks.forEach((order, clientId) => {
          if (clientId !== "") {
            newState.set(clientId, order);
          }
        });
        newState.forEach((order, clientId) => {
          const newSubOrder = Object.values(order).reduce(
            (result, subClientId) => {
              if (subClientId === clientIds[0]) {
                return [...result, ...mappedBlocks.get("")];
              }
              if (clientIds.indexOf(subClientId) === -1) {
                result.push(subClientId);
              }
              return result;
            },
            []
          );
          newState.set(clientId, newSubOrder);
        });
        return newState;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const newState = new Map(state);
        action.removedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        newState.forEach((order, clientId) => {
          const newSubOrder = order?.filter(
            (id) => !action.removedClientIds.includes(id)
          ) ?? [];
          if (newSubOrder.length !== order.length) {
            newState.set(clientId, newSubOrder);
          }
        });
        return newState;
      }
    }
    return state;
  },
  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents(state = /* @__PURE__ */ new Map(), action) {
    switch (action.type) {
      case "RECEIVE_BLOCKS": {
        const newState = new Map(state);
        mapBlockParents(action.blocks).forEach(
          ([key, value]) => {
            newState.set(key, value);
          }
        );
        return newState;
      }
      case "INSERT_BLOCKS": {
        const newState = new Map(state);
        mapBlockParents(
          action.blocks,
          action.rootClientId || ""
        ).forEach(([key, value]) => {
          newState.set(key, value);
        });
        return newState;
      }
      case "MOVE_BLOCKS_TO_POSITION": {
        const newState = new Map(state);
        action.clientIds.forEach((id) => {
          newState.set(id, action.toRootClientId || "");
        });
        return newState;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const newState = new Map(state);
        action.replacedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        mapBlockParents(
          action.blocks,
          state.get(action.clientIds[0])
        ).forEach(([key, value]) => {
          newState.set(key, value);
        });
        return newState;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const newState = new Map(state);
        action.removedClientIds.forEach((clientId) => {
          newState.delete(clientId);
        });
        return newState;
      }
    }
    return state;
  },
  controlledInnerBlocks(state = {}, { type, clientId, hasControlledInnerBlocks }) {
    if (type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
      return {
        ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }
    return state;
  }
});
function isBlockInterfaceHidden(state = false, action) {
  switch (action.type) {
    case "HIDE_BLOCK_INTERFACE":
      return true;
    case "SHOW_BLOCK_INTERFACE":
      return false;
  }
  return state;
}
function isTyping(state = false, action) {
  switch (action.type) {
    case "START_TYPING":
      return true;
    case "STOP_TYPING":
      return false;
  }
  return state;
}
function isDragging(state = false, action) {
  switch (action.type) {
    case "START_DRAGGING":
      return true;
    case "STOP_DRAGGING":
      return false;
  }
  return state;
}
function draggedBlocks(state = [], action) {
  switch (action.type) {
    case "START_DRAGGING_BLOCKS":
      return action.clientIds;
    case "STOP_DRAGGING_BLOCKS":
      return [];
  }
  return state;
}
function blockVisibility(state = {}, action) {
  if (action.type === "SET_BLOCK_VISIBILITY") {
    return {
      ...state,
      ...action.updates
    };
  }
  return state;
}
function selectionHelper(state = {}, action) {
  switch (action.type) {
    case "CLEAR_SELECTED_BLOCK": {
      if (state.clientId) {
        return {};
      }
      return state;
    }
    case "SELECT_BLOCK":
      if (action.clientId === state.clientId) {
        return state;
      }
      return { clientId: action.clientId };
    case "REPLACE_INNER_BLOCKS":
    case "INSERT_BLOCKS": {
      if (!action.updateSelection || !action.blocks.length) {
        return state;
      }
      return { clientId: action.blocks[0].clientId };
    }
    case "REMOVE_BLOCKS":
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }
      return {};
    case "REPLACE_BLOCKS": {
      if (action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }
      const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];
      if (!blockToSelect) {
        return {};
      }
      if (blockToSelect.clientId === state.clientId) {
        return state;
      }
      return { clientId: blockToSelect.clientId };
    }
  }
  return state;
}
function selection(state = {}, action) {
  switch (action.type) {
    case "SELECTION_CHANGE":
      if (action.clientId) {
        return {
          selectionStart: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.startOffset
          },
          selectionEnd: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.endOffset
          }
        };
      }
      return {
        selectionStart: action.start || state.selectionStart,
        selectionEnd: action.end || state.selectionEnd
      };
    case "RESET_SELECTION":
      const { selectionStart: selectionStart2, selectionEnd: selectionEnd2 } = action;
      return {
        selectionStart: selectionStart2,
        selectionEnd: selectionEnd2
      };
    case "MULTI_SELECT":
      const { start, end } = action;
      if (start === state.selectionStart?.clientId && end === state.selectionEnd?.clientId) {
        return state;
      }
      return {
        selectionStart: { clientId: start },
        selectionEnd: { clientId: end }
      };
    case "RESET_BLOCKS":
      const startClientId = state?.selectionStart?.clientId;
      const endClientId = state?.selectionEnd?.clientId;
      if (!startClientId && !endClientId) {
        return state;
      }
      if (!action.blocks.some(
        (block) => block.clientId === startClientId
      )) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      }
      if (!action.blocks.some(
        (block) => block.clientId === endClientId
      )) {
        return {
          ...state,
          selectionEnd: state.selectionStart
        };
      }
  }
  const selectionStart = selectionHelper(state.selectionStart, action);
  const selectionEnd = selectionHelper(state.selectionEnd, action);
  if (selectionStart === state.selectionStart && selectionEnd === state.selectionEnd) {
    return state;
  }
  return {
    selectionStart,
    selectionEnd
  };
}
function isMultiSelecting(state = false, action) {
  switch (action.type) {
    case "START_MULTI_SELECT":
      return true;
    case "STOP_MULTI_SELECT":
      return false;
  }
  return state;
}
function isSelectionEnabled(state = true, action) {
  switch (action.type) {
    case "TOGGLE_SELECTION":
      return action.isSelectionEnabled;
  }
  return state;
}
function removalPromptData(state = false, action) {
  switch (action.type) {
    case "DISPLAY_BLOCK_REMOVAL_PROMPT":
      const { clientIds, selectPrevious, message } = action;
      return {
        clientIds,
        selectPrevious,
        message
      };
    case "CLEAR_BLOCK_REMOVAL_PROMPT":
      return false;
  }
  return state;
}
function blockRemovalRules(state = false, action) {
  switch (action.type) {
    case "SET_BLOCK_REMOVAL_RULES":
      return action.rules;
  }
  return state;
}
function initialPosition(state = null, action) {
  if (action.type === "REPLACE_BLOCKS" && action.initialPosition !== void 0) {
    return action.initialPosition;
  } else if ([
    "MULTI_SELECT",
    "SELECT_BLOCK",
    "RESET_SELECTION",
    "INSERT_BLOCKS",
    "REPLACE_INNER_BLOCKS"
  ].includes(action.type)) {
    return action.initialPosition;
  }
  return state;
}
function blocksMode(state = {}, action) {
  if (action.type === "TOGGLE_BLOCK_MODE") {
    const { clientId } = action;
    return {
      ...state,
      [clientId]: state[clientId] && state[clientId] === "html" ? "visual" : "html"
    };
  }
  return state;
}
function insertionCue(state = null, action) {
  switch (action.type) {
    case "SHOW_INSERTION_POINT": {
      const {
        rootClientId,
        index,
        __unstableWithInserter,
        operation,
        nearestSide
      } = action;
      const nextState = {
        rootClientId,
        index,
        __unstableWithInserter,
        operation,
        nearestSide
      };
      return es6_default()(state, nextState) ? state : nextState;
    }
    case "HIDE_INSERTION_POINT":
      return null;
  }
  return state;
}
function template(state = { isValid: true }, action) {
  switch (action.type) {
    case "SET_TEMPLATE_VALIDITY":
      return {
        ...state,
        isValid: action.isValid
      };
  }
  return state;
}
function settings(state = SETTINGS_DEFAULTS, action) {
  switch (action.type) {
    case "UPDATE_SETTINGS": {
      const updatedSettings = action.reset ? {
        ...SETTINGS_DEFAULTS,
        ...action.settings
      } : {
        ...state,
        ...action.settings
      };
      Object.defineProperty(updatedSettings, "__unstableIsPreviewMode", {
        get() {
          external_wp_deprecated_default()("__unstableIsPreviewMode", {
            since: "6.8",
            alternative: "isPreviewMode"
          });
          return this.isPreviewMode;
        }
      });
      return updatedSettings;
    }
  }
  return state;
}
function preferences(state = PREFERENCES_DEFAULTS, action) {
  switch (action.type) {
    case "INSERT_BLOCKS":
    case "REPLACE_BLOCKS": {
      const nextInsertUsage = action.blocks.reduce(
        (prevUsage, block) => {
          const { attributes, name: blockName } = block;
          let id = blockName;
          const match = (0,external_wp_data_namespaceObject.select)(external_wp_blocks_namespaceObject.store).getActiveBlockVariation(
            blockName,
            attributes
          );
          if (match?.name) {
            id += "/" + match.name;
          }
          if (blockName === "core/block") {
            id += "/" + attributes.ref;
          }
          return {
            ...prevUsage,
            [id]: {
              time: action.time,
              count: prevUsage[id] ? prevUsage[id].count + 1 : 1
            }
          };
        },
        state.insertUsage
      );
      return {
        ...state,
        insertUsage: nextInsertUsage
      };
    }
  }
  return state;
}
const blockListSettings = (state = {}, action) => {
  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case "REPLACE_BLOCKS":
    case "REMOVE_BLOCKS": {
      return Object.fromEntries(
        Object.entries(state).filter(
          ([id]) => !action.clientIds.includes(id)
        )
      );
    }
    case "UPDATE_BLOCK_LIST_SETTINGS": {
      const updates = typeof action.clientId === "string" ? { [action.clientId]: action.settings } : action.clientId;
      for (const clientId in updates) {
        if (!updates[clientId]) {
          if (!state[clientId]) {
            delete updates[clientId];
          }
        } else if (es6_default()(state[clientId], updates[clientId])) {
          delete updates[clientId];
        }
      }
      if (Object.keys(updates).length === 0) {
        return state;
      }
      const merged = { ...state, ...updates };
      for (const clientId in updates) {
        if (!updates[clientId]) {
          delete merged[clientId];
        }
      }
      return merged;
    }
  }
  return state;
};
function lastBlockAttributesChange(state = null, action) {
  switch (action.type) {
    case "UPDATE_BLOCK":
      if (!action.updates.attributes) {
        break;
      }
      return { [action.clientId]: action.updates.attributes };
    case "UPDATE_BLOCK_ATTRIBUTES":
      return action.clientIds.reduce(
        (accumulator, id) => ({
          ...accumulator,
          [id]: !!action.options?.uniqueByBlock ? action.attributes[id] : action.attributes
        }),
        {}
      );
  }
  return state;
}
function highlightedBlock(state, action) {
  switch (action.type) {
    case "TOGGLE_BLOCK_HIGHLIGHT":
      const { clientId, isHighlighted } = action;
      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }
      return state;
    case "SELECT_BLOCK":
      if (action.clientId !== state) {
        return null;
      }
  }
  return state;
}
function hasBlockSpotlight(state, action) {
  switch (action.type) {
    case "TOGGLE_BLOCK_SPOTLIGHT":
      const { clientId, hasBlockSpotlight: _hasBlockSpotlight } = action;
      if (_hasBlockSpotlight) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }
      return state;
    case "SELECT_BLOCK":
      if (action.clientId !== state) {
        return null;
      }
      return state;
    case "SELECTION_CHANGE":
      if (action.start?.clientId !== state || action.end?.clientId !== state) {
        return null;
      }
      return state;
    case "CLEAR_SELECTED_BLOCK":
      return null;
  }
  return state;
}
function expandedBlock(state = null, action) {
  switch (action.type) {
    case "SET_BLOCK_EXPANDED_IN_LIST_VIEW":
      return action.clientId;
    case "SELECT_BLOCK":
      if (action.clientId !== state) {
        return null;
      }
  }
  return state;
}
function lastBlockInserted(state = {}, action) {
  switch (action.type) {
    case "INSERT_BLOCKS":
    case "REPLACE_BLOCKS":
      if (!action.blocks.length) {
        return state;
      }
      const clientIds = action.blocks.map((block) => {
        return block.clientId;
      });
      const source = action.meta?.source;
      return { clientIds, source };
    case "RESET_BLOCKS":
      return {};
  }
  return state;
}
function temporarilyEditingAsBlocks(state = "", action) {
  if (action.type === "SET_TEMPORARILY_EDITING_AS_BLOCKS") {
    return action.temporarilyEditingAsBlocks;
  }
  return state;
}
function temporarilyEditingFocusModeRevert(state = "", action) {
  if (action.type === "SET_TEMPORARILY_EDITING_AS_BLOCKS") {
    return action.focusModeToRevert;
  }
  return state;
}
function blockEditingModes(state = /* @__PURE__ */ new Map(), action) {
  switch (action.type) {
    case "SET_BLOCK_EDITING_MODE":
      if (state.get(action.clientId) === action.mode) {
        return state;
      }
      return new Map(state).set(action.clientId, action.mode);
    case "UNSET_BLOCK_EDITING_MODE": {
      if (!state.has(action.clientId)) {
        return state;
      }
      const newState = new Map(state);
      newState.delete(action.clientId);
      return newState;
    }
    case "RESET_BLOCKS": {
      return state.has("") ? (/* @__PURE__ */ new Map()).set("", state.get("")) : state;
    }
  }
  return state;
}
function openedBlockSettingsMenu(state = null, action) {
  if ("SET_OPENED_BLOCK_SETTINGS_MENU" === action.type) {
    return action?.clientId ?? null;
  }
  return state;
}
function styleOverrides(state = /* @__PURE__ */ new Map(), action) {
  switch (action.type) {
    case "SET_STYLE_OVERRIDE":
      return new Map(state).set(action.id, action.style);
    case "DELETE_STYLE_OVERRIDE": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
  }
  return state;
}
function registeredInserterMediaCategories(state = [], action) {
  switch (action.type) {
    case "REGISTER_INSERTER_MEDIA_CATEGORY":
      return [...state, action.category];
  }
  return state;
}
function lastFocus(state = false, action) {
  switch (action.type) {
    case "LAST_FOCUS":
      return action.lastFocus;
  }
  return state;
}
function zoomLevel(state = 100, action) {
  switch (action.type) {
    case "SET_ZOOM_LEVEL":
      return action.zoom;
    case "RESET_ZOOM_LEVEL":
      return 100;
  }
  return state;
}
function insertionPoint(state = null, action) {
  switch (action.type) {
    case "SET_INSERTION_POINT":
      return action.value;
    case "SELECT_BLOCK":
      return null;
  }
  return state;
}
const combinedReducers = (0,external_wp_data_namespaceObject.combineReducers)({
  blocks,
  isDragging,
  isTyping,
  isBlockInterfaceHidden,
  draggedBlocks,
  selection,
  isMultiSelecting,
  isSelectionEnabled,
  initialPosition,
  blocksMode,
  blockListSettings,
  insertionPoint,
  insertionCue,
  template,
  settings,
  preferences,
  lastBlockAttributesChange,
  lastFocus,
  expandedBlock,
  highlightedBlock,
  lastBlockInserted,
  temporarilyEditingAsBlocks,
  temporarilyEditingFocusModeRevert,
  blockVisibility,
  blockEditingModes,
  styleOverrides,
  removalPromptData,
  blockRemovalRules,
  openedBlockSettingsMenu,
  registeredInserterMediaCategories,
  zoomLevel,
  hasBlockSpotlight
});
function getBlockTreeBlock(state, clientId) {
  if (clientId === "") {
    const rootBlock = state.blocks.tree.get(clientId);
    if (!rootBlock) {
      return;
    }
    return {
      clientId: "",
      ...rootBlock
    };
  }
  if (!state.blocks.controlledInnerBlocks[clientId]) {
    return state.blocks.tree.get(clientId);
  }
  const controlledTree = state.blocks.tree.get(`controlled||${clientId}`);
  const regularTree = state.blocks.tree.get(clientId);
  return {
    ...regularTree,
    innerBlocks: controlledTree?.innerBlocks
  };
}
function traverseBlockTree(state, clientId, callback) {
  const tree = getBlockTreeBlock(state, clientId);
  if (!tree) {
    return;
  }
  callback(tree);
  if (!tree?.innerBlocks?.length) {
    return;
  }
  for (const innerBlock of tree?.innerBlocks) {
    traverseBlockTree(state, innerBlock.clientId, callback);
  }
}
function findParentInClientIdsList(state, clientId, clientIds) {
  if (!clientIds.length) {
    return;
  }
  let parent = state.blocks.parents.get(clientId);
  while (parent !== void 0) {
    if (clientIds.includes(parent)) {
      return parent;
    }
    parent = state.blocks.parents.get(parent);
  }
}
function hasBindings(block) {
  return block?.attributes?.metadata?.bindings && Object.keys(block?.attributes?.metadata?.bindings).length;
}
function getDerivedBlockEditingModesForTree(state, treeClientId = "") {
  const isZoomedOut = state?.zoomLevel < 100 || state?.zoomLevel === "auto-scaled";
  const derivedBlockEditingModes = /* @__PURE__ */ new Map();
  const sectionRootClientId = state.settings?.[sectionRootClientIdKey];
  const sectionClientIds = state.blocks.order.get(sectionRootClientId);
  const hasDisabledBlocks = Array.from(state.blockEditingModes).some(
    ([, mode]) => mode === "disabled"
  );
  const templatePartClientIds = [];
  const syncedPatternClientIds = [];
  Object.keys(state.blocks.controlledInnerBlocks).forEach((clientId) => {
    const block = state.blocks.byClientId?.get(clientId);
    if (block?.name === "core/template-part") {
      templatePartClientIds.push(clientId);
    }
    if (block?.name === "core/block") {
      syncedPatternClientIds.push(clientId);
    }
  });
  const contentOnlyTemplateLockedClientIds = Object.keys(
    state.blockListSettings
  ).filter(
    (clientId) => state.blockListSettings[clientId]?.templateLock === "contentOnly"
  );
  const unsyncedPatternClientIds = !!window?.__experimentalContentOnlyPatternInsertion ? Array.from(state.blocks.attributes.keys()).filter(
    (clientId) => state.blocks.attributes.get(clientId)?.metadata?.patternName
  ) : [];
  const contentOnlyParents = [
    ...contentOnlyTemplateLockedClientIds,
    ...unsyncedPatternClientIds,
    ...window?.__experimentalContentOnlyPatternInsertion ? templatePartClientIds : []
  ];
  traverseBlockTree(state, treeClientId, (block) => {
    const { clientId, name: blockName } = block;
    if (state.blockEditingModes.has(clientId)) {
      return;
    }
    if (hasDisabledBlocks) {
      let ancestorBlockEditingMode;
      let parent = state.blocks.parents.get(clientId);
      while (parent !== void 0) {
        if (state.blockEditingModes.has(parent)) {
          ancestorBlockEditingMode = state.blockEditingModes.get(parent);
        }
        if (ancestorBlockEditingMode) {
          break;
        }
        parent = state.blocks.parents.get(parent);
      }
      if (ancestorBlockEditingMode === "disabled") {
        derivedBlockEditingModes.set(clientId, "disabled");
        return;
      }
    }
    if (isZoomedOut) {
      if (clientId === sectionRootClientId) {
        derivedBlockEditingModes.set(clientId, "contentOnly");
        return;
      }
      if (!sectionClientIds?.length) {
        derivedBlockEditingModes.set(clientId, "disabled");
        return;
      }
      if (sectionClientIds.includes(clientId)) {
        derivedBlockEditingModes.set(clientId, "contentOnly");
        return;
      }
      derivedBlockEditingModes.set(clientId, "disabled");
      return;
    }
    if (syncedPatternClientIds.length) {
      if (syncedPatternClientIds.includes(clientId)) {
        if (findParentInClientIdsList(
          state,
          clientId,
          syncedPatternClientIds
        )) {
          derivedBlockEditingModes.set(clientId, "disabled");
          return;
        }
        return;
      }
      const parentPatternClientId = findParentInClientIdsList(
        state,
        clientId,
        syncedPatternClientIds
      );
      if (parentPatternClientId) {
        if (findParentInClientIdsList(
          state,
          parentPatternClientId,
          syncedPatternClientIds
        )) {
          derivedBlockEditingModes.set(clientId, "disabled");
          return;
        }
        if (hasBindings(block)) {
          derivedBlockEditingModes.set(clientId, "contentOnly");
          return;
        }
        derivedBlockEditingModes.set(clientId, "disabled");
      }
    }
    if (contentOnlyParents.length) {
      const hasContentOnlyParent = !!findParentInClientIdsList(
        state,
        clientId,
        contentOnlyParents
      );
      if (hasContentOnlyParent) {
        if (isContentBlock(blockName)) {
          derivedBlockEditingModes.set(clientId, "contentOnly");
        } else {
          derivedBlockEditingModes.set(clientId, "disabled");
        }
      }
    }
  });
  return derivedBlockEditingModes;
}
function getDerivedBlockEditingModesUpdates({
  prevState,
  nextState,
  addedBlocks,
  removedClientIds
}) {
  const prevDerivedBlockEditingModes = prevState.derivedBlockEditingModes;
  let nextDerivedBlockEditingModes;
  removedClientIds?.forEach((clientId) => {
    traverseBlockTree(prevState, clientId, (block) => {
      if (prevDerivedBlockEditingModes.has(block.clientId)) {
        if (!nextDerivedBlockEditingModes) {
          nextDerivedBlockEditingModes = new Map(
            prevDerivedBlockEditingModes
          );
        }
        nextDerivedBlockEditingModes.delete(block.clientId);
      }
    });
  });
  addedBlocks?.forEach((addedBlock) => {
    const updates = getDerivedBlockEditingModesForTree(
      nextState,
      addedBlock.clientId
    );
    if (updates.size) {
      if (!nextDerivedBlockEditingModes) {
        nextDerivedBlockEditingModes = new Map([
          ...prevDerivedBlockEditingModes?.size ? prevDerivedBlockEditingModes : [],
          ...updates
        ]);
      } else {
        nextDerivedBlockEditingModes = new Map([
          ...nextDerivedBlockEditingModes?.size ? nextDerivedBlockEditingModes : [],
          ...updates
        ]);
      }
    }
  });
  return nextDerivedBlockEditingModes;
}
function withDerivedBlockEditingModes(reducer) {
  return (state, action) => {
    const nextState = reducer(state, action);
    if (action.type !== "SET_EDITOR_MODE" && nextState === state) {
      return state;
    }
    switch (action.type) {
      case "REMOVE_BLOCKS": {
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          removedClientIds: action.clientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "RECEIVE_BLOCKS":
      case "INSERT_BLOCKS": {
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks: action.blocks
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "UPDATE_BLOCK_ATTRIBUTES": {
        const addedBlocks = [];
        const removedClientIds = [];
        for (const clientId of action?.clientIds) {
          const attributes = action.options?.uniqueByBlock ? action.attributes[clientId] : action.attributes;
          if (!attributes) {
            break;
          }
          if (
            // patternName is switching from falsy to truthy, indicating
            // this block is becoming an unsynced pattern.
            attributes.metadata?.patternName && !state.blocks.attributes.get(clientId)?.metadata?.patternName
          ) {
            addedBlocks.push(
              nextState.blocks.tree.get(clientId)
            );
          } else if (
            // patternName is switching from truthy to falsy, this block is becoming
            // a regular block but was an unsynced pattern.
            // Check that `metadata` is part of the included attributes, as
            // `updateBlockAttributes` merges attributes, if it isn't present
            // the previous `metadata` would be retained.
            attributes.metadata && !attributes.metadata?.patternName && state.blocks.attributes.get(clientId)?.metadata?.patternName
          ) {
            removedClientIds.push(clientId);
          }
        }
        if (!addedBlocks?.length && !removedClientIds?.length) {
          break;
        }
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks,
          removedClientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "UPDATE_BLOCK_LIST_SETTINGS": {
        const addedBlocks = [];
        const removedClientIds = [];
        const updates = typeof action.clientId === "string" ? { [action.clientId]: action.settings } : action.clientId;
        for (const clientId in updates) {
          const isNewContentOnlyBlock = state.blockListSettings[clientId]?.templateLock !== "contentOnly" && nextState.blockListSettings[clientId]?.templateLock === "contentOnly";
          const wasContentOnlyBlock = state.blockListSettings[clientId]?.templateLock === "contentOnly" && nextState.blockListSettings[clientId]?.templateLock !== "contentOnly";
          if (isNewContentOnlyBlock) {
            addedBlocks.push(
              nextState.blocks.tree.get(clientId)
            );
          } else if (wasContentOnlyBlock) {
            removedClientIds.push(clientId);
          }
        }
        if (!addedBlocks.length && !removedClientIds.length) {
          break;
        }
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks,
          removedClientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "SET_BLOCK_EDITING_MODE":
      case "UNSET_BLOCK_EDITING_MODE":
      case "SET_HAS_CONTROLLED_INNER_BLOCKS": {
        const updatedBlock = getBlockTreeBlock(
          nextState,
          action.clientId
        );
        if (!updatedBlock) {
          break;
        }
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          removedClientIds: [action.clientId],
          addedBlocks: [updatedBlock]
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "REPLACE_BLOCKS": {
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks: action.blocks,
          removedClientIds: action.clientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "REPLACE_INNER_BLOCKS": {
        const removedClientIds = state.blocks.order.get(
          action.rootClientId
        );
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks: action.blocks,
          removedClientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "MOVE_BLOCKS_TO_POSITION": {
        const addedBlocks = action.clientIds.map((clientId) => {
          return nextState.blocks.byClientId.get(clientId);
        });
        const nextDerivedBlockEditingModes = getDerivedBlockEditingModesUpdates({
          prevState: state,
          nextState,
          addedBlocks,
          removedClientIds: action.clientIds
        });
        if (nextDerivedBlockEditingModes) {
          return {
            ...nextState,
            derivedBlockEditingModes: nextDerivedBlockEditingModes ?? state.derivedBlockEditingModes
          };
        }
        break;
      }
      case "UPDATE_SETTINGS": {
        if (state?.settings?.[sectionRootClientIdKey] !== nextState?.settings?.[sectionRootClientIdKey]) {
          return {
            ...nextState,
            derivedBlockEditingModes: getDerivedBlockEditingModesForTree(nextState)
          };
        }
        break;
      }
      case "RESET_BLOCKS":
      case "SET_EDITOR_MODE":
      case "RESET_ZOOM_LEVEL":
      case "SET_ZOOM_LEVEL": {
        return {
          ...nextState,
          derivedBlockEditingModes: getDerivedBlockEditingModesForTree(nextState)
        };
      }
    }
    nextState.derivedBlockEditingModes = state?.derivedBlockEditingModes ?? /* @__PURE__ */ new Map();
    return nextState;
  };
}
function withAutomaticChangeReset(reducer) {
  return (state, action) => {
    const nextState = reducer(state, action);
    if (!state) {
      return nextState;
    }
    nextState.automaticChangeStatus = state.automaticChangeStatus;
    if (action.type === "MARK_AUTOMATIC_CHANGE") {
      return {
        ...nextState,
        automaticChangeStatus: "pending"
      };
    }
    if (action.type === "MARK_AUTOMATIC_CHANGE_FINAL" && state.automaticChangeStatus === "pending") {
      return {
        ...nextState,
        automaticChangeStatus: "final"
      };
    }
    if (nextState.blocks === state.blocks && nextState.selection === state.selection) {
      return nextState;
    }
    if (nextState.automaticChangeStatus !== "final" && nextState.selection !== state.selection) {
      return nextState;
    }
    return {
      ...nextState,
      automaticChangeStatus: void 0
    };
  };
}
var reducer_default = (0,external_wp_compose_namespaceObject.pipe)(
  withDerivedBlockEditingModes,
  withAutomaticChangeReset
)(combinedReducers);


;// external ["wp","primitives"]
const external_wp_primitives_namespaceObject = window["wp"]["primitives"];
;// ./node_modules/@wordpress/icons/build-module/library/symbol.js


var symbol_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z" }) });


;// external ["wp","richText"]
const external_wp_richText_namespaceObject = window["wp"]["richText"];
;// external ["wp","blockSerializationDefaultParser"]
const external_wp_blockSerializationDefaultParser_namespaceObject = window["wp"]["blockSerializationDefaultParser"];
;// ./node_modules/@wordpress/block-editor/build-module/store/constants.js
const STORE_NAME = "core/block-editor";


;// ./node_modules/@wordpress/block-editor/build-module/utils/object.js
function setImmutably(object, path, value) {
  path = Array.isArray(path) ? [...path] : [path];
  object = Array.isArray(object) ? [...object] : { ...object };
  const leaf = path.pop();
  let prev = object;
  for (const key of path) {
    const lvl = prev[key];
    prev = prev[key] = Array.isArray(lvl) ? [...lvl] : { ...lvl };
  }
  prev[leaf] = value;
  return object;
}
const getValueFromObjectPath = (object, path, defaultValue) => {
  const arrayPath = Array.isArray(path) ? path : path.split(".");
  let value = object;
  arrayPath.forEach((fieldName) => {
    value = value?.[fieldName];
  });
  return value ?? defaultValue;
};
function uniqByProperty(array, property) {
  const seen = /* @__PURE__ */ new Set();
  return array.filter((item) => {
    const value = item[property];
    return seen.has(value) ? false : seen.add(value);
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/store/get-block-settings.js




const blockedPaths = [
  "color",
  "border",
  "dimensions",
  "typography",
  "spacing"
];
const deprecatedFlags = {
  "color.palette": (settings) => settings.colors,
  "color.gradients": (settings) => settings.gradients,
  "color.custom": (settings) => settings.disableCustomColors === void 0 ? void 0 : !settings.disableCustomColors,
  "color.customGradient": (settings) => settings.disableCustomGradients === void 0 ? void 0 : !settings.disableCustomGradients,
  "typography.fontSizes": (settings) => settings.fontSizes,
  "typography.customFontSize": (settings) => settings.disableCustomFontSizes === void 0 ? void 0 : !settings.disableCustomFontSizes,
  "typography.lineHeight": (settings) => settings.enableCustomLineHeight,
  "spacing.units": (settings) => {
    if (settings.enableCustomUnits === void 0) {
      return;
    }
    if (settings.enableCustomUnits === true) {
      return ["px", "em", "rem", "vh", "vw", "%"];
    }
    return settings.enableCustomUnits;
  },
  "spacing.padding": (settings) => settings.enableCustomSpacing
};
const prefixedFlags = {
  /*
   * These were only available in the plugin
   * and can be removed when the minimum WordPress version
   * for the plugin is 5.9.
   */
  "border.customColor": "border.color",
  "border.customStyle": "border.style",
  "border.customWidth": "border.width",
  "typography.customFontStyle": "typography.fontStyle",
  "typography.customFontWeight": "typography.fontWeight",
  "typography.customLetterSpacing": "typography.letterSpacing",
  "typography.customTextDecorations": "typography.textDecoration",
  "typography.customTextTransforms": "typography.textTransform",
  /*
   * These were part of WordPress 5.8 and we need to keep them.
   */
  "border.customRadius": "border.radius",
  "spacing.customMargin": "spacing.margin",
  "spacing.customPadding": "spacing.padding",
  "typography.customLineHeight": "typography.lineHeight"
};
const removeCustomPrefixes = (path) => {
  return prefixedFlags[path] || path;
};
function getBlockSettings(state, clientId, ...paths) {
  const blockName = getBlockName(state, clientId);
  const candidates = [];
  if (clientId) {
    let id = clientId;
    do {
      const name = getBlockName(state, id);
      if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "__experimentalSettings", false)) {
        candidates.push(id);
      }
    } while (id = state.blocks.parents.get(id));
  }
  return paths.map((path) => {
    if (blockedPaths.includes(path)) {
      console.warn(
        "Top level useSetting paths are disabled. Please use a subpath to query the information needed."
      );
      return void 0;
    }
    let result = (0,external_wp_hooks_namespaceObject.applyFilters)(
      "blockEditor.useSetting.before",
      void 0,
      path,
      clientId,
      blockName
    );
    if (void 0 !== result) {
      return result;
    }
    const normalizedPath = removeCustomPrefixes(path);
    for (const candidateClientId of candidates) {
      const candidateAtts = getBlockAttributes(
        state,
        candidateClientId
      );
      result = getValueFromObjectPath(
        candidateAtts.settings?.blocks?.[blockName],
        normalizedPath
      ) ?? getValueFromObjectPath(
        candidateAtts.settings,
        normalizedPath
      );
      if (result !== void 0) {
        break;
      }
    }
    const settings = getSettings(state);
    if (result === void 0 && blockName) {
      result = getValueFromObjectPath(
        settings.__experimentalFeatures?.blocks?.[blockName],
        normalizedPath
      );
    }
    if (result === void 0) {
      result = getValueFromObjectPath(
        settings.__experimentalFeatures,
        normalizedPath
      );
    }
    if (result !== void 0) {
      if (external_wp_blocks_namespaceObject.__EXPERIMENTAL_PATHS_WITH_OVERRIDE[normalizedPath]) {
        return result.custom ?? result.theme ?? result.default;
      }
      return result;
    }
    const deprecatedSettingsValue = deprecatedFlags[normalizedPath]?.(settings);
    if (deprecatedSettingsValue !== void 0) {
      return deprecatedSettingsValue;
    }
    return normalizedPath === "typography.dropCap" ? true : void 0;
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/store/private-selectors.js







const { isContentBlock: private_selectors_isContentBlock } = unlock(external_wp_blocks_namespaceObject.privateApis);

function private_selectors_isBlockInterfaceHidden(state) {
  return state.isBlockInterfaceHidden;
}
function getLastInsertedBlocksClientIds(state) {
  return state?.lastBlockInserted?.clientIds;
}
function getBlockWithoutAttributes(state, clientId) {
  return state.blocks.byClientId.get(clientId);
}
const isBlockSubtreeDisabled = (state, clientId) => {
  const isChildSubtreeDisabled = (childClientId) => {
    return getBlockEditingMode(state, childClientId) === "disabled" && getBlockOrder(state, childClientId).every(
      isChildSubtreeDisabled
    );
  };
  return getBlockOrder(state, clientId).every(isChildSubtreeDisabled);
};
function isContainerInsertableToInContentOnlyMode(state, blockName, rootClientId) {
  const isBlockContentBlock = private_selectors_isContentBlock(blockName);
  const rootBlockName = getBlockName(state, rootClientId);
  const isContainerContentBlock = private_selectors_isContentBlock(rootBlockName);
  const isRootBlockMain = getSectionRootClientId(state) === rootClientId;
  return isRootBlockMain || isContainerContentBlock && isBlockContentBlock;
}
function getEnabledClientIdsTreeUnmemoized(state, rootClientId) {
  const blockOrder = getBlockOrder(state, rootClientId);
  const result = [];
  for (const clientId of blockOrder) {
    const innerBlocks = getEnabledClientIdsTreeUnmemoized(
      state,
      clientId
    );
    if (getBlockEditingMode(state, clientId) !== "disabled") {
      result.push({ clientId, innerBlocks });
    } else {
      result.push(...innerBlocks);
    }
  }
  return result;
}
const getEnabledClientIdsTree = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  () => (0,external_wp_data_namespaceObject.createSelector)(getEnabledClientIdsTreeUnmemoized, (state) => [
    state.blocks.order,
    state.derivedBlockEditingModes,
    state.blockEditingModes
  ])
);
const getEnabledBlockParents = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId, ascending = false) => {
    return getBlockParents(state, clientId, ascending).filter(
      (parent) => getBlockEditingMode(state, parent) !== "disabled"
    );
  },
  (state) => [
    state.blocks.parents,
    state.blockEditingModes,
    state.settings.templateLock,
    state.blockListSettings
  ]
);
function getRemovalPromptData(state) {
  return state.removalPromptData;
}
function getBlockRemovalRules(state) {
  return state.blockRemovalRules;
}
function getOpenedBlockSettingsMenu(state) {
  return state.openedBlockSettingsMenu;
}
const getStyleOverrides = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    const clientIds = getClientIdsWithDescendants(state);
    const clientIdMap = clientIds.reduce((acc, clientId, index) => {
      acc[clientId] = index;
      return acc;
    }, {});
    return [...state.styleOverrides].sort((overrideA, overrideB) => {
      const [, { clientId: clientIdA }] = overrideA;
      const [, { clientId: clientIdB }] = overrideB;
      const aIndex = clientIdMap[clientIdA] ?? -1;
      const bIndex = clientIdMap[clientIdB] ?? -1;
      return aIndex - bIndex;
    });
  },
  (state) => [state.blocks.order, state.styleOverrides]
);
function getRegisteredInserterMediaCategories(state) {
  return state.registeredInserterMediaCategories;
}
const getInserterMediaCategories = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    const {
      settings: {
        inserterMediaCategories,
        allowedMimeTypes,
        enableOpenverseMediaCategory
      },
      registeredInserterMediaCategories
    } = state;
    if (!inserterMediaCategories && !registeredInserterMediaCategories.length || !allowedMimeTypes) {
      return;
    }
    const coreInserterMediaCategoriesNames = inserterMediaCategories?.map(({ name }) => name) || [];
    const mergedCategories = [
      ...inserterMediaCategories || [],
      ...(registeredInserterMediaCategories || []).filter(
        ({ name }) => !coreInserterMediaCategoriesNames.includes(name)
      )
    ];
    return mergedCategories.filter((category) => {
      if (!enableOpenverseMediaCategory && category.name === "openverse") {
        return false;
      }
      return Object.values(allowedMimeTypes).some(
        (mimeType) => mimeType.startsWith(`${category.mediaType}/`)
      );
    });
  },
  (state) => [
    state.settings.inserterMediaCategories,
    state.settings.allowedMimeTypes,
    state.settings.enableOpenverseMediaCategory,
    state.registeredInserterMediaCategories
  ]
);
const hasAllowedPatterns = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, rootClientId = null) => {
      const { getAllPatterns: getAllPatterns2 } = unlock(select(STORE_NAME));
      const patterns = getAllPatterns2();
      const { allowedBlockTypes } = getSettings(state);
      return patterns.some((pattern) => {
        const { inserter = true } = pattern;
        if (!inserter) {
          return false;
        }
        const grammar = getGrammar(pattern);
        return checkAllowListRecursive(grammar, allowedBlockTypes) && grammar.every(
          ({ name: blockName }) => canInsertBlockType(state, blockName, rootClientId)
        );
      });
    },
    (state, rootClientId) => [
      ...getAllPatternsDependants(select)(state),
      ...getInsertBlockTypeDependants(select)(state, rootClientId)
    ]
  )
);
const getPatternBySlug = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, patternName) => {
      if (patternName?.startsWith("core/block/")) {
        const _id = parseInt(
          patternName.slice("core/block/".length),
          10
        );
        const block = unlock(select(STORE_NAME)).getReusableBlocks().find(({ id }) => id === _id);
        if (!block) {
          return null;
        }
        return mapUserPattern(
          block,
          state.settings.__experimentalUserPatternCategories
        );
      }
      return [
        // This setting is left for back compat.
        ...state.settings.__experimentalBlockPatterns ?? [],
        ...state.settings[selectBlockPatternsKey]?.(select) ?? []
      ].find(({ name }) => name === patternName);
    },
    (state, patternName) => patternName?.startsWith("core/block/") ? [
      unlock(select(STORE_NAME)).getReusableBlocks(),
      state.settings.__experimentalReusableBlocks
    ] : [
      state.settings.__experimentalBlockPatterns,
      state.settings[selectBlockPatternsKey]?.(select)
    ]
  )
);
const getAllPatterns = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)((state) => {
    return [
      ...unlock(select(STORE_NAME)).getReusableBlocks().map(
        (userPattern) => mapUserPattern(
          userPattern,
          state.settings.__experimentalUserPatternCategories
        )
      ),
      // This setting is left for back compat.
      ...state.settings.__experimentalBlockPatterns ?? [],
      ...state.settings[selectBlockPatternsKey]?.(select) ?? []
    ].filter(
      (x, index, arr) => index === arr.findIndex((y) => x.name === y.name)
    );
  }, getAllPatternsDependants(select))
);
const EMPTY_ARRAY = [];
const getReusableBlocks = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (state) => {
    const reusableBlocksSelect = state.settings[reusableBlocksSelectKey];
    return (reusableBlocksSelect ? reusableBlocksSelect(select) : state.settings.__experimentalReusableBlocks) ?? EMPTY_ARRAY;
  }
);
function getLastFocus(state) {
  return state.lastFocus;
}
function private_selectors_isDragging(state) {
  return state.isDragging;
}
function getExpandedBlock(state) {
  return state.expandedBlock;
}
const getContentLockingParent = (state, clientId) => {
  let current = clientId;
  let result;
  while (!result && (current = state.blocks.parents.get(current))) {
    if (getTemplateLock(state, current) === "contentOnly") {
      result = current;
    }
  }
  return result;
};
const getParentSectionBlock = (state, clientId) => {
  let current = clientId;
  let result;
  while (!result && (current = state.blocks.parents.get(current))) {
    if (isSectionBlock(state, current)) {
      result = current;
    }
  }
  return result;
};
function isSectionBlock(state, clientId) {
  const blockName = getBlockName(state, clientId);
  if (blockName === "core/block" || getTemplateLock(state, clientId) === "contentOnly") {
    return true;
  }
  const attributes = getBlockAttributes(state, clientId);
  const isTemplatePart = blockName === "core/template-part";
  if ((attributes?.metadata?.patternName || isTemplatePart) && !!window?.__experimentalContentOnlyPatternInsertion) {
    return true;
  }
  return false;
}
function getTemporarilyEditingAsBlocks(state) {
  return state.temporarilyEditingAsBlocks;
}
function getTemporarilyEditingFocusModeToRevert(state) {
  return state.temporarilyEditingFocusModeRevert;
}
const getBlockStyles = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientIds) => clientIds.reduce((styles, clientId) => {
    styles[clientId] = state.blocks.attributes.get(clientId)?.style;
    return styles;
  }, {}),
  (state, clientIds) => [
    ...clientIds.map(
      (clientId) => state.blocks.attributes.get(clientId)?.style
    )
  ]
);
function getSectionRootClientId(state) {
  return state.settings?.[sectionRootClientIdKey];
}
function isZoomOut(state) {
  return state.zoomLevel === "auto-scaled" || state.zoomLevel < 100;
}
function getZoomLevel(state) {
  return state.zoomLevel;
}
function getClosestAllowedInsertionPoint(state, name, clientId = "") {
  const blockNames = Array.isArray(name) ? name : [name];
  const areBlockNamesAllowedInClientId = (id) => blockNames.every(
    (currentName) => canInsertBlockType(state, currentName, id)
  );
  if (!clientId) {
    if (areBlockNamesAllowedInClientId(clientId)) {
      return clientId;
    }
    const sectionRootClientId = getSectionRootClientId(state);
    if (sectionRootClientId && areBlockNamesAllowedInClientId(sectionRootClientId)) {
      return sectionRootClientId;
    }
    return null;
  }
  let current = clientId;
  while (current !== null && !areBlockNamesAllowedInClientId(current)) {
    const parentClientId = getBlockRootClientId(state, current);
    current = parentClientId;
  }
  return current;
}
function getClosestAllowedInsertionPointForPattern(state, pattern, clientId) {
  const { allowedBlockTypes } = getSettings(state);
  const isAllowed = checkAllowListRecursive(
    getGrammar(pattern),
    allowedBlockTypes
  );
  if (!isAllowed) {
    return null;
  }
  const names = getGrammar(pattern).map(({ blockName: name }) => name);
  return getClosestAllowedInsertionPoint(state, names, clientId);
}
function getInsertionPoint(state) {
  return state.insertionPoint;
}
const isBlockHidden = (state, clientId) => {
  const blockName = getBlockName(state, clientId);
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(state, blockName, "visibility", true)) {
    return false;
  }
  const attributes = state.blocks.attributes.get(clientId);
  return attributes?.metadata?.blockVisibility === false;
};
function private_selectors_hasBlockSpotlight(state) {
  return !!state.hasBlockSpotlight;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/utils.js

const INSERTER_PATTERN_TYPES = {
  user: "user",
  theme: "theme",
  directory: "directory"
};
const INSERTER_SYNC_TYPES = {
  full: "fully",
  unsynced: "unsynced"
};
const allPatternsCategory = {
  name: "allPatterns",
  label: (0,external_wp_i18n_namespaceObject._x)("All", "patterns")
};
const myPatternsCategory = {
  name: "myPatterns",
  label: (0,external_wp_i18n_namespaceObject.__)("My patterns")
};
const starterPatternsCategory = {
  name: "core/starter-content",
  label: (0,external_wp_i18n_namespaceObject.__)("Starter content")
};
function isPatternFiltered(pattern, sourceFilter, syncFilter) {
  const isUserPattern = pattern.name.startsWith("core/block");
  const isDirectoryPattern = pattern.source === "core" || pattern.source?.startsWith("pattern-directory");
  if (sourceFilter === INSERTER_PATTERN_TYPES.theme && (isUserPattern || isDirectoryPattern)) {
    return true;
  }
  if (sourceFilter === INSERTER_PATTERN_TYPES.directory && (isUserPattern || !isDirectoryPattern)) {
    return true;
  }
  if (sourceFilter === INSERTER_PATTERN_TYPES.user && pattern.type !== INSERTER_PATTERN_TYPES.user) {
    return true;
  }
  if (syncFilter === INSERTER_SYNC_TYPES.full && pattern.syncStatus !== "") {
    return true;
  }
  if (syncFilter === INSERTER_SYNC_TYPES.unsynced && pattern.syncStatus !== "unsynced" && isUserPattern) {
    return true;
  }
  return false;
}


;// ./node_modules/@wordpress/block-editor/build-module/store/utils.js








const isFiltered = Symbol("isFiltered");
const parsedPatternCache = /* @__PURE__ */ new WeakMap();
const grammarMapCache = /* @__PURE__ */ new WeakMap();
function mapUserPattern(userPattern, __experimentalUserPatternCategories = []) {
  return {
    name: `core/block/${userPattern.id}`,
    id: userPattern.id,
    type: INSERTER_PATTERN_TYPES.user,
    title: userPattern.title?.raw,
    categories: userPattern.wp_pattern_category?.map((catId) => {
      const category = __experimentalUserPatternCategories.find(
        ({ id }) => id === catId
      );
      return category ? category.slug : catId;
    }),
    content: userPattern.content?.raw,
    syncStatus: userPattern.wp_pattern_sync_status
  };
}
function parsePattern(pattern) {
  const blocks = (0,external_wp_blocks_namespaceObject.parse)(pattern.content, {
    __unstableSkipMigrationLogs: true
  });
  if (blocks.length === 1) {
    blocks[0].attributes = {
      ...blocks[0].attributes,
      metadata: {
        ...blocks[0].attributes.metadata || {},
        categories: pattern.categories,
        patternName: pattern.name,
        name: blocks[0].attributes.metadata?.name || pattern.title
      }
    };
  }
  return {
    ...pattern,
    blocks
  };
}
function getParsedPattern(pattern) {
  let parsedPattern = parsedPatternCache.get(pattern);
  if (!parsedPattern) {
    parsedPattern = parsePattern(pattern);
    parsedPatternCache.set(pattern, parsedPattern);
  }
  return parsedPattern;
}
function getGrammar(pattern) {
  let grammarMap = grammarMapCache.get(pattern);
  if (!grammarMap) {
    grammarMap = (0,external_wp_blockSerializationDefaultParser_namespaceObject.parse)(pattern.content);
    grammarMap = grammarMap.filter((block) => block.blockName !== null);
    grammarMapCache.set(pattern, grammarMap);
  }
  return grammarMap;
}
const checkAllowList = (list, item, defaultResult = null) => {
  if (typeof list === "boolean") {
    return list;
  }
  if (Array.isArray(list)) {
    if (list.includes("core/post-content") && item === null) {
      return true;
    }
    return list.includes(item);
  }
  return defaultResult;
};
const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (typeof allowedBlockTypes === "boolean") {
    return allowedBlockTypes;
  }
  const blocksQueue = [...blocks];
  while (blocksQueue.length > 0) {
    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(
      allowedBlockTypes,
      block.name || block.blockName,
      true
    );
    if (!isAllowed) {
      return false;
    }
    block.innerBlocks?.forEach((innerBlock) => {
      blocksQueue.push(innerBlock);
    });
  }
  return true;
};
const getAllPatternsDependants = (select) => (state) => {
  return [
    state.settings.__experimentalBlockPatterns,
    state.settings.__experimentalUserPatternCategories,
    state.settings.__experimentalReusableBlocks,
    state.settings[selectBlockPatternsKey]?.(select),
    state.blockPatterns,
    unlock(select(STORE_NAME)).getReusableBlocks()
  ];
};
const getInsertBlockTypeDependants = () => (state, rootClientId) => {
  return [
    state.blockListSettings[rootClientId],
    state.blocks.byClientId.get(rootClientId),
    state.settings.allowedBlockTypes,
    state.settings.templateLock,
    getBlockEditingMode(state, rootClientId),
    getSectionRootClientId(state),
    isSectionBlock(state, rootClientId)
  ];
};


;// ./node_modules/@wordpress/block-editor/build-module/utils/sorting.js
const comparator = (field, items, order) => {
  return (a, b) => {
    let cmpA, cmpB;
    if (typeof field === "function") {
      cmpA = field(a);
      cmpB = field(b);
    } else {
      cmpA = a[field];
      cmpB = b[field];
    }
    if (cmpA > cmpB) {
      return order === "asc" ? 1 : -1;
    } else if (cmpB > cmpA) {
      return order === "asc" ? -1 : 1;
    }
    const orderA = items.findIndex((item) => item === a);
    const orderB = items.findIndex((item) => item === b);
    if (orderA > orderB) {
      return 1;
    } else if (orderB > orderA) {
      return -1;
    }
    return 0;
  };
};
function orderBy(items, field, order = "asc") {
  return items.concat().sort(comparator(field, items, order));
}


;// ./node_modules/@wordpress/block-editor/build-module/store/selectors.js












const { isContentBlock: selectors_isContentBlock } = unlock(external_wp_blocks_namespaceObject.privateApis);
const MILLISECONDS_PER_HOUR = 3600 * 1e3;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1e3;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1e3;
const selectors_EMPTY_ARRAY = [];
const EMPTY_SET = /* @__PURE__ */ new Set();
const DEFAULT_INSERTER_OPTIONS = {
  [isFiltered]: true
};
function getBlockName(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  const socialLinkName = "core/social-link";
  if (external_wp_element_namespaceObject.Platform.OS !== "web" && block?.name === socialLinkName) {
    const attributes = state.blocks.attributes.get(clientId);
    const { service } = attributes ?? {};
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }
  return block ? block.name : null;
}
function isBlockValid(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  return !!block && block.isValid;
}
function getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId.get(clientId);
  if (!block) {
    return null;
  }
  return state.blocks.attributes.get(clientId);
}
function getBlock(state, clientId) {
  if (!state.blocks.byClientId.has(clientId)) {
    return null;
  }
  return state.blocks.tree.get(clientId);
}
const __unstableGetBlockWithoutInnerBlocks = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId) => {
    const block = state.blocks.byClientId.get(clientId);
    if (!block) {
      return null;
    }
    return {
      ...block,
      attributes: getBlockAttributes(state, clientId)
    };
  },
  (state, clientId) => [
    state.blocks.byClientId.get(clientId),
    state.blocks.attributes.get(clientId)
  ]
);
function getBlocks(state, rootClientId) {
  const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || "" : "controlled||" + rootClientId;
  return state.blocks.tree.get(treeKey)?.innerBlocks || selectors_EMPTY_ARRAY;
}
const __unstableGetClientIdWithClientIdsTree = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId) => {
    external_wp_deprecated_default()(
      "wp.data.select( 'core/block-editor' ).__unstableGetClientIdWithClientIdsTree",
      {
        since: "6.3",
        version: "6.5"
      }
    );
    return {
      clientId,
      innerBlocks: __unstableGetClientIdsTree(state, clientId)
    };
  },
  (state) => [state.blocks.order]
);
const __unstableGetClientIdsTree = (0,external_wp_data_namespaceObject.createSelector)(
  (state, rootClientId = "") => {
    external_wp_deprecated_default()(
      "wp.data.select( 'core/block-editor' ).__unstableGetClientIdsTree",
      {
        since: "6.3",
        version: "6.5"
      }
    );
    return getBlockOrder(state, rootClientId).map(
      (clientId) => __unstableGetClientIdWithClientIdsTree(state, clientId)
    );
  },
  (state) => [state.blocks.order]
);
const getClientIdsOfDescendants = (0,external_wp_data_namespaceObject.createSelector)(
  (state, rootIds) => {
    rootIds = Array.isArray(rootIds) ? [...rootIds] : [rootIds];
    const ids = [];
    for (const rootId of rootIds) {
      const order = state.blocks.order.get(rootId);
      if (order) {
        ids.push(...order);
      }
    }
    let index = 0;
    while (index < ids.length) {
      const id = ids[index];
      const order = state.blocks.order.get(id);
      if (order) {
        ids.splice(index + 1, 0, ...order);
      }
      index++;
    }
    return ids;
  },
  (state) => [state.blocks.order]
);
const getClientIdsWithDescendants = (state) => getClientIdsOfDescendants(state, "");
const getGlobalBlockCount = (0,external_wp_data_namespaceObject.createSelector)(
  (state, blockName) => {
    const clientIds = getClientIdsWithDescendants(state);
    if (!blockName) {
      return clientIds.length;
    }
    let count = 0;
    for (const clientId of clientIds) {
      const block = state.blocks.byClientId.get(clientId);
      if (block.name === blockName) {
        count++;
      }
    }
    return count;
  },
  (state) => [state.blocks.order, state.blocks.byClientId]
);
const getBlocksByName = (0,external_wp_data_namespaceObject.createSelector)(
  (state, blockName) => {
    if (!blockName) {
      return selectors_EMPTY_ARRAY;
    }
    const blockNames = Array.isArray(blockName) ? blockName : [blockName];
    const clientIds = getClientIdsWithDescendants(state);
    const foundBlocks = clientIds.filter((clientId) => {
      const block = state.blocks.byClientId.get(clientId);
      return blockNames.includes(block.name);
    });
    return foundBlocks.length > 0 ? foundBlocks : selectors_EMPTY_ARRAY;
  },
  (state) => [state.blocks.order, state.blocks.byClientId]
);
function __experimentalGetGlobalBlocksByName(state, blockName) {
  external_wp_deprecated_default()(
    "wp.data.select( 'core/block-editor' ).__experimentalGetGlobalBlocksByName",
    {
      since: "6.5",
      alternative: `wp.data.select( 'core/block-editor' ).getBlocksByName`
    }
  );
  return getBlocksByName(state, blockName);
}
const getBlocksByClientId = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(
    (clientId) => getBlock(state, clientId)
  ),
  (state, clientIds) => (Array.isArray(clientIds) ? clientIds : [clientIds]).map(
    (clientId) => state.blocks.tree.get(clientId)
  )
);
const getBlockNamesByClientId = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientIds) => getBlocksByClientId(state, clientIds).filter(Boolean).map((block) => block.name),
  (state, clientIds) => getBlocksByClientId(state, clientIds)
);
function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}
function getSelectionStart(state) {
  return state.selection.selectionStart;
}
function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
function getSelectedBlockCount(state) {
  const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;
  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }
  return state.selection.selectionStart.clientId ? 1 : 0;
}
function hasSelectedBlock(state) {
  const { selectionStart, selectionEnd } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
function getSelectedBlockClientId(state) {
  const { selectionStart, selectionEnd } = state.selection;
  const { clientId } = selectionStart;
  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }
  return clientId;
}
function getSelectedBlock(state) {
  const clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}
function getBlockRootClientId(state, clientId) {
  return state.blocks.parents.get(clientId) ?? null;
}
const getBlockParents = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId, ascending = false) => {
    const parents = [];
    let current = clientId;
    while (current = state.blocks.parents.get(current)) {
      parents.push(current);
    }
    if (!parents.length) {
      return selectors_EMPTY_ARRAY;
    }
    return ascending ? parents : parents.reverse();
  },
  (state) => [state.blocks.parents]
);
const getBlockParentsByBlockName = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId, blockName, ascending = false) => {
    const parents = getBlockParents(state, clientId, ascending);
    const hasName = Array.isArray(blockName) ? (name) => blockName.includes(name) : (name) => blockName === name;
    return parents.filter((id) => hasName(getBlockName(state, id)));
  },
  (state) => [state.blocks.parents]
);
function getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;
  do {
    parent = current;
    current = state.blocks.parents.get(current);
  } while (current);
  return parent;
}
function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = getSelectedBlockClientId(state);
  const clientParents = [...getBlockParents(state, clientId), clientId];
  const selectedParents = [
    ...getBlockParents(state, selectedId),
    selectedId
  ];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);
  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }
  return lowestCommonAncestor;
}
function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
  if (startClientId === void 0) {
    startClientId = getSelectedBlockClientId(state);
  }
  if (startClientId === void 0) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  }
  if (!startClientId) {
    return null;
  }
  const rootClientId = getBlockRootClientId(state, startClientId);
  if (rootClientId === null) {
    return null;
  }
  const { order } = state.blocks;
  const orderSet = order.get(rootClientId);
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier;
  if (nextIndex < 0) {
    return null;
  }
  if (nextIndex === orderSet.length) {
    return null;
  }
  return orderSet[nextIndex];
}
function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
function getSelectedBlocksInitialCaretPosition(state) {
  return state.initialPosition;
}
const getSelectedBlockClientIds = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    const { selectionStart, selectionEnd } = state.selection;
    if (!selectionStart.clientId || !selectionEnd.clientId) {
      return selectors_EMPTY_ARRAY;
    }
    if (selectionStart.clientId === selectionEnd.clientId) {
      return [selectionStart.clientId];
    }
    const rootClientId = getBlockRootClientId(
      state,
      selectionStart.clientId
    );
    if (rootClientId === null) {
      return selectors_EMPTY_ARRAY;
    }
    const blockOrder = getBlockOrder(state, rootClientId);
    const startIndex = blockOrder.indexOf(selectionStart.clientId);
    const endIndex = blockOrder.indexOf(selectionEnd.clientId);
    if (startIndex > endIndex) {
      return blockOrder.slice(endIndex, startIndex + 1);
    }
    return blockOrder.slice(startIndex, endIndex + 1);
  },
  (state) => [
    state.blocks.order,
    state.selection.selectionStart.clientId,
    state.selection.selectionEnd.clientId
  ]
);
function getMultiSelectedBlockClientIds(state) {
  const { selectionStart, selectionEnd } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return selectors_EMPTY_ARRAY;
  }
  return getSelectedBlockClientIds(state);
}
const getMultiSelectedBlocks = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
    if (!multiSelectedBlockClientIds.length) {
      return selectors_EMPTY_ARRAY;
    }
    return multiSelectedBlockClientIds.map(
      (clientId) => getBlock(state, clientId)
    );
  },
  (state) => [
    ...getSelectedBlockClientIds.getDependants(state),
    state.blocks.byClientId,
    state.blocks.order,
    state.blocks.attributes
  ]
);
function getFirstMultiSelectedBlockClientId(state) {
  return getMultiSelectedBlockClientIds(state)[0] || null;
}
function getLastMultiSelectedBlockClientId(state) {
  const selectedClientIds = getMultiSelectedBlockClientIds(state);
  return selectedClientIds[selectedClientIds.length - 1] || null;
}
function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}
function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
const isAncestorMultiSelected = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientId) => {
    let ancestorClientId = clientId;
    let isMultiSelected = false;
    while (ancestorClientId && !isMultiSelected) {
      ancestorClientId = getBlockRootClientId(state, ancestorClientId);
      isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
    }
    return isMultiSelected;
  },
  (state) => [
    state.blocks.order,
    state.selection.selectionStart.clientId,
    state.selection.selectionEnd.clientId
  ]
);
function getMultiSelectedBlocksStartClientId(state) {
  const { selectionStart, selectionEnd } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }
  return selectionStart.clientId || null;
}
function getMultiSelectedBlocksEndClientId(state) {
  const { selectionStart, selectionEnd } = state.selection;
  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }
  return selectionEnd.clientId || null;
}
function __unstableIsFullySelected(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === "undefined" && typeof selectionFocus.offset === "undefined";
}
function __unstableIsSelectionCollapsed(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
}
function __unstableSelectionHasUnmergeableBlock(state) {
  return getSelectedBlockClientIds(state).some((clientId) => {
    const blockName = getBlockName(state, clientId);
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
    return !blockType.merge;
  });
}
function __unstableIsSelectionMergeable(state, isForward) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return false;
  }
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
    return false;
  }
  const anchorRootClientId = getBlockRootClientId(
    state,
    selectionAnchor.clientId
  );
  const focusRootClientId = getBlockRootClientId(
    state,
    selectionFocus.clientId
  );
  if (anchorRootClientId !== focusRootClientId) {
    return false;
  }
  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
  const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
  const targetBlockName = getBlockName(state, targetBlockClientId);
  const targetBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlockName);
  if (!targetBlockType.merge) {
    return false;
  }
  const blockToMerge = getBlock(state, blockToMergeClientId);
  if (blockToMerge.name === targetBlockName) {
    return true;
  }
  const blocksToMerge = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blockToMerge, targetBlockName);
  return blocksToMerge && blocksToMerge.length;
}
const __unstableGetSelectedBlocksWithPartialSelection = (state) => {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return selectors_EMPTY_ARRAY;
  }
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
    return selectors_EMPTY_ARRAY;
  }
  const anchorRootClientId = getBlockRootClientId(
    state,
    selectionAnchor.clientId
  );
  const focusRootClientId = getBlockRootClientId(
    state,
    selectionFocus.clientId
  );
  if (anchorRootClientId !== focusRootClientId) {
    return selectors_EMPTY_ARRAY;
  }
  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
  const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
  const blockA = getBlock(state, selectionStart.clientId);
  const blockB = getBlock(state, selectionEnd.clientId);
  const htmlA = blockA.attributes[selectionStart.attributeKey];
  const htmlB = blockB.attributes[selectionEnd.attributeKey];
  let valueA = (0,external_wp_richText_namespaceObject.create)({ html: htmlA });
  let valueB = (0,external_wp_richText_namespaceObject.create)({ html: htmlB });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, 0, selectionStart.offset);
  valueB = (0,external_wp_richText_namespaceObject.remove)(valueB, selectionEnd.offset, valueB.text.length);
  return [
    {
      ...blockA,
      attributes: {
        ...blockA.attributes,
        [selectionStart.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
          value: valueA
        })
      }
    },
    {
      ...blockB,
      attributes: {
        ...blockB.attributes,
        [selectionEnd.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({
          value: valueB
        })
      }
    }
  ];
};
function getBlockOrder(state, rootClientId) {
  return state.blocks.order.get(rootClientId || "") || selectors_EMPTY_ARRAY;
}
function getBlockIndex(state, clientId) {
  const rootClientId = getBlockRootClientId(state, clientId);
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}
function isBlockSelected(state, clientId) {
  const { selectionStart, selectionEnd } = state.selection;
  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }
  return selectionStart.clientId === clientId;
}
function hasSelectedInnerBlock(state, clientId, deep = false) {
  const selectedBlockClientIds = getSelectedBlockClientIds(state);
  if (!selectedBlockClientIds.length) {
    return false;
  }
  if (deep) {
    return selectedBlockClientIds.some(
      (id) => (
        // Pass true because we don't care about order and it's more
        // performant.
        getBlockParents(state, id, true).includes(clientId)
      )
    );
  }
  return selectedBlockClientIds.some(
    (id) => getBlockRootClientId(state, id) === clientId
  );
}
function hasDraggedInnerBlock(state, clientId, deep = false) {
  return getBlockOrder(state, clientId).some(
    (innerClientId) => isBlockBeingDragged(state, innerClientId) || deep && hasDraggedInnerBlock(state, innerClientId, deep)
  );
}
function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }
  const clientIds = getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
function hasMultiSelection(state) {
  const { selectionStart, selectionEnd } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}
function selectors_isMultiSelecting(state) {
  return state.isMultiSelecting;
}
function selectors_isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || "visual";
}
function selectors_isTyping(state) {
  return state.isTyping;
}
function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
function isAncestorBeingDragged(state, clientId) {
  if (!isDraggingBlocks(state)) {
    return false;
  }
  const parents = getBlockParents(state, clientId);
  return parents.some(
    (parentClientId) => isBlockBeingDragged(state, parentClientId)
  );
}
function isCaretWithinFormattedText() {
  external_wp_deprecated_default()(
    'wp.data.select( "core/block-editor" ).isCaretWithinFormattedText',
    {
      since: "6.1",
      version: "6.3"
    }
  );
  return false;
}
const getBlockInsertionPoint = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    let rootClientId, index;
    const {
      insertionCue,
      selection: { selectionEnd }
    } = state;
    if (insertionCue !== null) {
      return insertionCue;
    }
    const { clientId } = selectionEnd;
    if (clientId) {
      rootClientId = getBlockRootClientId(state, clientId) || void 0;
      index = getBlockIndex(state, selectionEnd.clientId) + 1;
    } else {
      index = getBlockOrder(state).length;
    }
    return { rootClientId, index };
  },
  (state) => [
    state.insertionCue,
    state.selection.selectionEnd.clientId,
    state.blocks.parents,
    state.blocks.order
  ]
);
function isBlockInsertionPointVisible(state) {
  return state.insertionCue !== null;
}
function isValidTemplate(state) {
  return state.template.isValid;
}
function getTemplate(state) {
  return state.settings.template;
}
function getTemplateLock(state, rootClientId) {
  if (!rootClientId) {
    return state.settings.templateLock ?? false;
  }
  return getBlockListSettings(state, rootClientId)?.templateLock ?? false;
}
const isBlockVisibleInTheInserter = (state, blockNameOrType, rootClientId = null) => {
  let blockType;
  let blockName;
  if (blockNameOrType && "object" === typeof blockNameOrType) {
    blockType = blockNameOrType;
    blockName = blockNameOrType.name;
  } else {
    blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockNameOrType);
    blockName = blockNameOrType;
  }
  if (!blockType) {
    return false;
  }
  const { allowedBlockTypes } = getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(
    allowedBlockTypes,
    blockName,
    true
  );
  if (!isBlockAllowedInEditor) {
    return false;
  }
  const parents = (Array.isArray(blockType.parent) ? blockType.parent : []).concat(Array.isArray(blockType.ancestor) ? blockType.ancestor : []);
  if (parents.length > 0) {
    if (parents.includes("core/post-content")) {
      return true;
    }
    let current = rootClientId;
    let hasParent = false;
    do {
      if (parents.includes(getBlockName(state, current))) {
        hasParent = true;
        break;
      }
      current = state.blocks.parents.get(current);
    } while (current);
    return hasParent;
  }
  return true;
};
const canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
  if (!isBlockVisibleInTheInserter(state, blockName, rootClientId)) {
    return false;
  }
  let blockType;
  if (blockName && "object" === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
  }
  if (getTemplateLock(state, rootClientId)) {
    return false;
  }
  const blockEditingMode = getBlockEditingMode(state, rootClientId ?? "");
  if (blockEditingMode === "disabled") {
    return false;
  }
  const parentBlockListSettings = getBlockListSettings(state, rootClientId);
  if (rootClientId && parentBlockListSettings === void 0) {
    return false;
  }
  const isContentRoleBlock = selectors_isContentBlock(blockName);
  const isParentSectionBlock = !!isSectionBlock(state, rootClientId);
  const isBlockWithinSection = !!getParentSectionBlock(
    state,
    rootClientId
  );
  if ((isParentSectionBlock || isBlockWithinSection) && !isContentRoleBlock) {
    return false;
  }
  if ((isParentSectionBlock || blockEditingMode === "contentOnly") && !isContainerInsertableToInContentOnlyMode(
    state,
    blockName,
    rootClientId
  )) {
    return false;
  }
  const parentName = getBlockName(state, rootClientId);
  const parentBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(parentName);
  const parentAllowedChildBlocks = parentBlockType?.allowedBlocks;
  let hasParentAllowedBlock = checkAllowList(
    parentAllowedChildBlocks,
    blockName
  );
  if (hasParentAllowedBlock !== false) {
    const parentAllowedBlocks = parentBlockListSettings?.allowedBlocks;
    const hasParentListAllowedBlock = checkAllowList(
      parentAllowedBlocks,
      blockName
    );
    if (hasParentListAllowedBlock !== null) {
      hasParentAllowedBlock = hasParentListAllowedBlock;
    }
  }
  const blockAllowedParentBlocks = blockType.parent;
  const hasBlockAllowedParent = checkAllowList(
    blockAllowedParentBlocks,
    parentName
  );
  let hasBlockAllowedAncestor = true;
  const blockAllowedAncestorBlocks = blockType.ancestor;
  if (blockAllowedAncestorBlocks) {
    const ancestors = [
      rootClientId,
      ...getBlockParents(state, rootClientId)
    ];
    hasBlockAllowedAncestor = ancestors.some(
      (ancestorClientId) => checkAllowList(
        blockAllowedAncestorBlocks,
        getBlockName(state, ancestorClientId)
      )
    );
  }
  const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);
  if (!canInsert) {
    return canInsert;
  }
  return (0,external_wp_hooks_namespaceObject.applyFilters)(
    "blockEditor.__unstableCanInsertBlockType",
    canInsert,
    blockType,
    rootClientId,
    {
      // Pass bound selectors of the current registry. If we're in a nested
      // context, the data will differ from the one selected from the root
      // registry.
      getBlock: getBlock.bind(null, state),
      getBlockParentsByBlockName: getBlockParentsByBlockName.bind(
        null,
        state
      )
    }
  );
};
const canInsertBlockType = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    canInsertBlockTypeUnmemoized,
    (state, blockName, rootClientId) => getInsertBlockTypeDependants(select)(state, rootClientId)
  )
);
function canInsertBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(
    (id) => canInsertBlockType(state, getBlockName(state, id), rootClientId)
  );
}
function canRemoveBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  if (attributes.lock?.remove !== void 0) {
    return !attributes.lock.remove;
  }
  const rootClientId = getBlockRootClientId(state, clientId);
  if (getTemplateLock(state, rootClientId)) {
    return false;
  }
  const isBlockWithinSection = !!getParentSectionBlock(state, clientId);
  const isContentRoleBlock = selectors_isContentBlock(
    getBlockName(state, clientId)
  );
  if (isBlockWithinSection && !isContentRoleBlock) {
    return false;
  }
  const isParentSectionBlock = !!isSectionBlock(state, rootClientId);
  const rootBlockEditingMode = getBlockEditingMode(state, rootClientId);
  if ((isParentSectionBlock || rootBlockEditingMode === "contentOnly") && !isContainerInsertableToInContentOnlyMode(
    state,
    getBlockName(state, clientId),
    rootClientId
  )) {
    return false;
  }
  return rootBlockEditingMode !== "disabled";
}
function canRemoveBlocks(state, clientIds) {
  return clientIds.every((clientId) => canRemoveBlock(state, clientId));
}
function canMoveBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  if (attributes.lock?.move !== void 0) {
    return !attributes.lock.move;
  }
  const rootClientId = getBlockRootClientId(state, clientId);
  const templateLock = getTemplateLock(state, rootClientId);
  if (templateLock === "all" || templateLock === "contentOnly") {
    return false;
  }
  const isBlockWithinSection = !!getParentSectionBlock(state, clientId);
  const isContentRoleBlock = selectors_isContentBlock(
    getBlockName(state, clientId)
  );
  if (isBlockWithinSection && !isContentRoleBlock) {
    return false;
  }
  const isParentSectionBlock = !!isSectionBlock(state, rootClientId);
  const rootBlockEditingMode = getBlockEditingMode(state, rootClientId);
  if ((isParentSectionBlock || rootBlockEditingMode === "contentOnly") && !isContainerInsertableToInContentOnlyMode(
    state,
    getBlockName(state, clientId),
    rootClientId
  )) {
    return false;
  }
  return getBlockEditingMode(state, rootClientId) !== "disabled";
}
function canMoveBlocks(state, clientIds) {
  return clientIds.every((clientId) => canMoveBlock(state, clientId));
}
function canEditBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);
  if (attributes === null) {
    return true;
  }
  const { lock } = attributes;
  return !lock?.edit;
}
function canLockBlockType(state, nameOrType) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, "lock", true)) {
    return false;
  }
  return !!state.settings?.canLockBlocks;
}
function getInsertUsage(state, id) {
  return state.preferences.insertUsage?.[id] ?? null;
}
const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "inserter", true)) {
    return false;
  }
  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
const getItemFromVariation = (state, item) => (variation) => {
  const variationId = `${item.id}/${variation.name}`;
  const { time, count = 0 } = getInsertUsage(state, variationId) || {};
  return {
    ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty("example") ? variation.example : item.example,
    initialAttributes: {
      ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};
const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  }
  const duration = Date.now() - time;
  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;
    case duration < MILLISECONDS_PER_DAY:
      return count * 2;
    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;
    default:
      return count / 4;
  }
};
const buildBlockTypeItem = (state, { buildScope = "inserter" }) => (blockType) => {
  const id = blockType.name;
  let isDisabled = false;
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType.name, "multiple", true)) {
    isDisabled = getBlocksByClientId(
      state,
      getClientIdsWithDescendants(state)
    ).some(({ name }) => name === blockType.name);
  }
  const { time, count = 0 } = getInsertUsage(state, id) || {};
  const blockItemBase = {
    id,
    name: blockType.name,
    title: blockType.title,
    icon: blockType.icon,
    isDisabled,
    frecency: calculateFrecency(time, count)
  };
  if (buildScope === "transform") {
    return blockItemBase;
  }
  const inserterVariations = (0,external_wp_blocks_namespaceObject.getBlockVariations)(
    blockType.name,
    "inserter"
  );
  return {
    ...blockItemBase,
    initialAttributes: {},
    description: blockType.description,
    category: blockType.category,
    keywords: blockType.keywords,
    parent: blockType.parent,
    ancestor: blockType.ancestor,
    variations: inserterVariations,
    example: blockType.example,
    utility: 1
    // Deprecated.
  };
};
const getInserterItems = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, rootClientId = null, options = DEFAULT_INSERTER_OPTIONS) => {
      const buildReusableBlockInserterItem = (reusableBlock) => {
        const icon = !reusableBlock.wp_pattern_sync_status ? {
          src: symbol_default,
          foreground: "var(--wp-block-synced-color)"
        } : symbol_default;
        const userPattern = mapUserPattern(reusableBlock);
        const { time, count = 0 } = getInsertUsage(state, userPattern.name) || {};
        const frecency = calculateFrecency(time, count);
        return {
          id: userPattern.name,
          name: "core/block",
          initialAttributes: { ref: reusableBlock.id },
          title: userPattern.title,
          icon,
          category: "reusable",
          keywords: ["reusable"],
          isDisabled: false,
          utility: 1,
          // Deprecated.
          frecency,
          content: userPattern.content,
          get blocks() {
            return getParsedPattern(userPattern).blocks;
          },
          syncStatus: userPattern.syncStatus
        };
      };
      const patternInserterItems = canInsertBlockTypeUnmemoized(
        state,
        "core/block",
        rootClientId
      ) ? unlock(select(STORE_NAME)).getReusableBlocks().map(buildReusableBlockInserterItem) : [];
      const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
        buildScope: "inserter"
      });
      let blockTypeInserterItems = (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(
        (blockType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "inserter", true)
      ).map(buildBlockTypeInserterItem);
      if (options[isFiltered] !== false) {
        blockTypeInserterItems = blockTypeInserterItems.filter(
          (blockType) => canIncludeBlockTypeInInserter(
            state,
            blockType,
            rootClientId
          )
        );
      } else {
        blockTypeInserterItems = blockTypeInserterItems.filter(
          (blockType) => isBlockVisibleInTheInserter(
            state,
            blockType,
            rootClientId
          )
        ).map((blockType) => ({
          ...blockType,
          isAllowedInCurrentRoot: canIncludeBlockTypeInInserter(
            state,
            blockType,
            rootClientId
          )
        }));
      }
      const stretchVariations = [];
      const items = blockTypeInserterItems.reduce(
        (accumulator, item) => {
          const { variations = [] } = item;
          if (!variations.some(({ isDefault }) => isDefault)) {
            accumulator.push(item);
          }
          if (variations.length) {
            const variationMapper = getItemFromVariation(
              state,
              item
            );
            variations.map(variationMapper).forEach((variation) => {
              if (variation.id === "core/paragraph/stretchy-paragraph" || variation.id === "core/heading/stretchy-heading") {
                stretchVariations.push(variation);
              } else {
                accumulator.push(variation);
              }
            });
          }
          return accumulator;
        },
        []
      );
      items.push(...stretchVariations);
      const groupByType = (blocks, block) => {
        const { core, noncore } = blocks;
        const type = block.name.startsWith("core/") ? core : noncore;
        type.push(block);
        return blocks;
      };
      const { core: coreItems, noncore: nonCoreItems } = items.reduce(
        groupByType,
        { core: [], noncore: [] }
      );
      const sortedBlockTypes = [...coreItems, ...nonCoreItems];
      return [...sortedBlockTypes, ...patternInserterItems];
    },
    (state, rootClientId) => [
      (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
      unlock(select(STORE_NAME)).getReusableBlocks(),
      state.blocks.order,
      state.preferences.insertUsage,
      ...getInsertBlockTypeDependants(select)(state, rootClientId)
    ]
  )
);
const getBlockTransformItems = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, blocks, rootClientId = null) => {
      const normalizedBlocks = Array.isArray(blocks) ? blocks : [blocks];
      const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
        buildScope: "transform"
      });
      const blockTypeTransformItems = (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(
        (blockType) => canIncludeBlockTypeInInserter(
          state,
          blockType,
          rootClientId
        )
      ).map(buildBlockTypeTransformItem);
      const itemsByName = Object.fromEntries(
        Object.entries(blockTypeTransformItems).map(
          ([, value]) => [value.name, value]
        )
      );
      const possibleTransforms = (0,external_wp_blocks_namespaceObject.getPossibleBlockTransformations)(
        normalizedBlocks
      ).reduce((accumulator, block) => {
        if (itemsByName[block?.name]) {
          accumulator.push(itemsByName[block.name]);
        }
        return accumulator;
      }, []);
      return orderBy(
        possibleTransforms,
        (block) => itemsByName[block.name].frecency,
        "desc"
      );
    },
    (state, blocks, rootClientId) => [
      (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
      state.preferences.insertUsage,
      ...getInsertBlockTypeDependants(select)(state, rootClientId)
    ]
  )
);
const hasInserterItems = (state, rootClientId = null) => {
  const hasBlockType = (0,external_wp_blocks_namespaceObject.getBlockTypes)().some(
    (blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)
  );
  if (hasBlockType) {
    return true;
  }
  const hasReusableBlock = canInsertBlockTypeUnmemoized(
    state,
    "core/block",
    rootClientId
  );
  return hasReusableBlock;
};
const getAllowedBlocks = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, rootClientId = null) => {
      if (!rootClientId) {
        return;
      }
      const blockTypes = (0,external_wp_blocks_namespaceObject.getBlockTypes)().filter(
        (blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)
      );
      const hasReusableBlock = canInsertBlockTypeUnmemoized(
        state,
        "core/block",
        rootClientId
      );
      if (hasReusableBlock) {
        blockTypes.push("core/block");
      }
      return blockTypes;
    },
    (state, rootClientId) => [
      (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
      ...getInsertBlockTypeDependants(select)(state, rootClientId)
    ]
  )
);
const __experimentalGetAllowedBlocks = (0,external_wp_data_namespaceObject.createSelector)(
  (state, rootClientId = null) => {
    external_wp_deprecated_default()(
      'wp.data.select( "core/block-editor" ).__experimentalGetAllowedBlocks',
      {
        alternative: 'wp.data.select( "core/block-editor" ).getAllowedBlocks',
        since: "6.2",
        version: "6.4"
      }
    );
    return getAllowedBlocks(state, rootClientId);
  },
  (state, rootClientId) => getAllowedBlocks.getDependants(state, rootClientId)
);
function getDirectInsertBlock(state, rootClientId = null) {
  if (!rootClientId) {
    return;
  }
  const { defaultBlock, directInsert } = state.blockListSettings[rootClientId] ?? {};
  if (!defaultBlock || !directInsert) {
    return;
  }
  return defaultBlock;
}
function __experimentalGetDirectInsertBlock(state, rootClientId = null) {
  external_wp_deprecated_default()(
    'wp.data.select( "core/block-editor" ).__experimentalGetDirectInsertBlock',
    {
      alternative: 'wp.data.select( "core/block-editor" ).getDirectInsertBlock',
      since: "6.3",
      version: "6.4"
    }
  );
  return getDirectInsertBlock(state, rootClientId);
}
const __experimentalGetParsedPattern = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (state, patternName) => {
    const pattern = unlock(select(STORE_NAME)).getPatternBySlug(
      patternName
    );
    return pattern ? getParsedPattern(pattern) : null;
  }
);
const getAllowedPatternsDependants = (select) => (state, rootClientId) => [
  ...getAllPatternsDependants(select)(state),
  ...getInsertBlockTypeDependants(select)(state, rootClientId)
];
const patternsWithParsedBlocks = /* @__PURE__ */ new WeakMap();
function enhancePatternWithParsedBlocks(pattern) {
  let enhancedPattern = patternsWithParsedBlocks.get(pattern);
  if (!enhancedPattern) {
    enhancedPattern = {
      ...pattern,
      get blocks() {
        return getParsedPattern(pattern).blocks;
      }
    };
    patternsWithParsedBlocks.set(pattern, enhancedPattern);
  }
  return enhancedPattern;
}
const __experimentalGetAllowedPatterns = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => {
    return (0,external_wp_data_namespaceObject.createSelector)(
      (state, rootClientId = null, options = DEFAULT_INSERTER_OPTIONS) => {
        const { getAllPatterns } = unlock(select(STORE_NAME));
        const patterns = getAllPatterns();
        const { allowedBlockTypes } = getSettings(state);
        const parsedPatterns = patterns.filter(({ inserter = true }) => !!inserter).map(enhancePatternWithParsedBlocks);
        const availableParsedPatterns = parsedPatterns.filter(
          (pattern) => checkAllowListRecursive(
            getGrammar(pattern),
            allowedBlockTypes
          )
        );
        const patternsAllowed = availableParsedPatterns.filter(
          (pattern) => getGrammar(pattern).every(
            ({ blockName: name }) => options[isFiltered] !== false ? canInsertBlockType(
              state,
              name,
              rootClientId
            ) : isBlockVisibleInTheInserter(
              state,
              name,
              rootClientId
            )
          )
        );
        return patternsAllowed;
      },
      getAllowedPatternsDependants(select)
    );
  }
);
const getPatternsByBlockTypes = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, blockNames, rootClientId = null) => {
      if (!blockNames) {
        return selectors_EMPTY_ARRAY;
      }
      const patterns = select(STORE_NAME).__experimentalGetAllowedPatterns(
        rootClientId
      );
      const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
      const filteredPatterns = patterns.filter(
        (pattern) => pattern?.blockTypes?.some?.(
          (blockName) => normalizedBlockNames.includes(blockName)
        )
      );
      if (filteredPatterns.length === 0) {
        return selectors_EMPTY_ARRAY;
      }
      return filteredPatterns;
    },
    (state, blockNames, rootClientId) => getAllowedPatternsDependants(select)(state, rootClientId)
  )
);
const __experimentalGetPatternsByBlockTypes = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => {
    external_wp_deprecated_default()(
      'wp.data.select( "core/block-editor" ).__experimentalGetPatternsByBlockTypes',
      {
        alternative: 'wp.data.select( "core/block-editor" ).getPatternsByBlockTypes',
        since: "6.2",
        version: "6.4"
      }
    );
    return select(STORE_NAME).getPatternsByBlockTypes;
  }
);
const __experimentalGetPatternTransformItems = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, blocks, rootClientId = null) => {
      if (!blocks) {
        return selectors_EMPTY_ARRAY;
      }
      if (blocks.some(
        ({ clientId, innerBlocks }) => innerBlocks.length || areInnerBlocksControlled(state, clientId)
      )) {
        return selectors_EMPTY_ARRAY;
      }
      const selectedBlockNames = Array.from(
        new Set(blocks.map(({ name }) => name))
      );
      return select(STORE_NAME).getPatternsByBlockTypes(
        selectedBlockNames,
        rootClientId
      );
    },
    (state, blocks, rootClientId) => getAllowedPatternsDependants(select)(state, rootClientId)
  )
);
function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
function getSettings(state) {
  return state.settings;
}
function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
const __experimentalGetBlockListSettingsForBlocks = (0,external_wp_data_namespaceObject.createSelector)(
  (state, clientIds = []) => {
    return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
      if (!state.blockListSettings[clientId]) {
        return blockListSettingsForBlocks;
      }
      return {
        ...blockListSettingsForBlocks,
        [clientId]: state.blockListSettings[clientId]
      };
    }, {});
  },
  (state) => [state.blockListSettings]
);
const __experimentalGetReusableBlockTitle = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (0,external_wp_data_namespaceObject.createSelector)(
    (state, ref) => {
      external_wp_deprecated_default()(
        "wp.data.select( 'core/block-editor' ).__experimentalGetReusableBlockTitle",
        {
          since: "6.6",
          version: "6.8"
        }
      );
      const reusableBlock = unlock(select(STORE_NAME)).getReusableBlocks().find((block) => block.id === ref);
      if (!reusableBlock) {
        return null;
      }
      return reusableBlock.title?.raw;
    },
    () => [unlock(select(STORE_NAME)).getReusableBlocks()]
  )
);
function __unstableIsLastBlockChangeIgnored(state) {
  return state.blocks.isIgnoredChange;
}
function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
function hasBlockMovingClientId() {
  external_wp_deprecated_default()(
    'wp.data.select( "core/block-editor" ).hasBlockMovingClientId',
    {
      since: "6.7",
      hint: "Block moving mode feature has been removed"
    }
  );
  return false;
}
function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
const __experimentalGetActiveBlockIdByBlockNames = (0,external_wp_data_namespaceObject.createSelector)(
  (state, validBlockNames) => {
    if (!validBlockNames.length) {
      return null;
    }
    const selectedBlockClientId = getSelectedBlockClientId(state);
    if (validBlockNames.includes(
      getBlockName(state, selectedBlockClientId)
    )) {
      return selectedBlockClientId;
    }
    const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
    const entityAreaParents = getBlockParentsByBlockName(
      state,
      selectedBlockClientId || multiSelectedBlockClientIds[0],
      validBlockNames
    );
    if (entityAreaParents) {
      return entityAreaParents[entityAreaParents.length - 1];
    }
    return null;
  },
  (state, validBlockNames) => [
    state.selection.selectionStart.clientId,
    state.selection.selectionEnd.clientId,
    validBlockNames
  ]
);
function wasBlockJustInserted(state, clientId, source) {
  const { lastBlockInserted } = state;
  return lastBlockInserted.clientIds?.includes(clientId) && lastBlockInserted.source === source;
}
function isBlockVisible(state, clientId) {
  return state.blockVisibility?.[clientId] ?? true;
}
function getHoveredBlockClientId() {
  external_wp_deprecated_default()(
    "wp.data.select( 'core/block-editor' ).getHoveredBlockClientId",
    {
      since: "6.9",
      version: "7.1"
    }
  );
  return void 0;
}
const __unstableGetVisibleBlocks = (0,external_wp_data_namespaceObject.createSelector)(
  (state) => {
    const visibleBlocks = new Set(
      Object.keys(state.blockVisibility).filter(
        (key) => state.blockVisibility[key]
      )
    );
    if (visibleBlocks.size === 0) {
      return EMPTY_SET;
    }
    return visibleBlocks;
  },
  (state) => [state.blockVisibility]
);
function __unstableHasActiveBlockOverlayActive(state, clientId) {
  if (getBlockEditingMode(state, clientId) !== "default") {
    return false;
  }
  if (!canEditBlock(state, clientId)) {
    return true;
  }
  if (isZoomOut(state)) {
    const sectionRootClientId = getSectionRootClientId(state);
    if (sectionRootClientId) {
      const sectionClientIds = getBlockOrder(
        state,
        sectionRootClientId
      );
      if (sectionClientIds?.includes(clientId)) {
        return true;
      }
    } else if (clientId && !getBlockRootClientId(state, clientId)) {
      return true;
    }
  }
  const blockSupportDisable = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
    getBlockName(state, clientId),
    "__experimentalDisableBlockOverlay",
    false
  );
  const shouldEnableIfUnselected = blockSupportDisable ? false : areInnerBlocksControlled(state, clientId);
  return shouldEnableIfUnselected && !isBlockSelected(state, clientId) && !hasSelectedInnerBlock(state, clientId, true);
}
function __unstableIsWithinBlockOverlay(state, clientId) {
  let parent = state.blocks.parents.get(clientId);
  while (!!parent) {
    if (__unstableHasActiveBlockOverlayActive(state, parent)) {
      return true;
    }
    parent = state.blocks.parents.get(parent);
  }
  return false;
}
function getBlockEditingMode(state, clientId = "") {
  if (clientId === null) {
    clientId = "";
  }
  if (state.derivedBlockEditingModes?.has(clientId)) {
    return state.derivedBlockEditingModes.get(clientId);
  }
  if (state.blockEditingModes.has(clientId)) {
    return state.blockEditingModes.get(clientId);
  }
  return "default";
}
const isUngroupable = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (state, clientId = "") => {
    const _clientId = clientId || getSelectedBlockClientId(state);
    if (!_clientId) {
      return false;
    }
    const { getGroupingBlockName } = select(external_wp_blocks_namespaceObject.store);
    const block = getBlock(state, _clientId);
    const groupingBlockName = getGroupingBlockName();
    const _isUngroupable = block && (block.name === groupingBlockName || (0,external_wp_blocks_namespaceObject.getBlockType)(block.name)?.transforms?.ungroup) && !!block.innerBlocks.length;
    return _isUngroupable && canRemoveBlock(state, _clientId);
  }
);
const isGroupable = (0,external_wp_data_namespaceObject.createRegistrySelector)(
  (select) => (state, clientIds = selectors_EMPTY_ARRAY) => {
    const { getGroupingBlockName } = select(external_wp_blocks_namespaceObject.store);
    const groupingBlockName = getGroupingBlockName();
    const _clientIds = clientIds?.length ? clientIds : getSelectedBlockClientIds(state);
    const rootClientId = _clientIds?.length ? getBlockRootClientId(state, _clientIds[0]) : void 0;
    const groupingBlockAvailable = canInsertBlockType(
      state,
      groupingBlockName,
      rootClientId
    );
    const _isGroupable = groupingBlockAvailable && _clientIds.length;
    return _isGroupable && canRemoveBlocks(state, _clientIds);
  }
);
const __unstableGetContentLockingParent = (state, clientId) => {
  external_wp_deprecated_default()(
    "wp.data.select( 'core/block-editor' ).__unstableGetContentLockingParent",
    {
      since: "6.1",
      version: "6.7"
    }
  );
  return getContentLockingParent(state, clientId);
};
function __unstableGetTemporarilyEditingAsBlocks(state) {
  external_wp_deprecated_default()(
    "wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingAsBlocks",
    {
      since: "6.1",
      version: "6.7"
    }
  );
  return getTemporarilyEditingAsBlocks(state);
}
function __unstableGetTemporarilyEditingFocusModeToRevert(state) {
  external_wp_deprecated_default()(
    "wp.data.select( 'core/block-editor' ).__unstableGetTemporarilyEditingFocusModeToRevert",
    {
      since: "6.5",
      version: "6.7"
    }
  );
  return getTemporarilyEditingFocusModeToRevert(state);
}


;// external ["wp","a11y"]
const external_wp_a11y_namespaceObject = window["wp"]["a11y"];
;// ./node_modules/@wordpress/block-editor/build-module/store/private-actions.js






const castArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const privateSettings = [
  "inserterMediaCategories",
  "blockInspectorAnimation",
  "mediaSideload"
];
function __experimentalUpdateSettings(settings, { stripExperimentalSettings = false, reset = false } = {}) {
  let incomingSettings = settings;
  if (Object.hasOwn(incomingSettings, "__unstableIsPreviewMode")) {
    external_wp_deprecated_default()(
      "__unstableIsPreviewMode argument in wp.data.dispatch('core/block-editor').updateSettings",
      {
        since: "6.8",
        alternative: "isPreviewMode"
      }
    );
    incomingSettings = { ...incomingSettings };
    incomingSettings.isPreviewMode = incomingSettings.__unstableIsPreviewMode;
    delete incomingSettings.__unstableIsPreviewMode;
  }
  let cleanSettings = incomingSettings;
  if (stripExperimentalSettings && external_wp_element_namespaceObject.Platform.OS === "web") {
    cleanSettings = {};
    for (const key in incomingSettings) {
      if (!privateSettings.includes(key)) {
        cleanSettings[key] = incomingSettings[key];
      }
    }
  }
  return {
    type: "UPDATE_SETTINGS",
    settings: cleanSettings,
    reset
  };
}
function hideBlockInterface() {
  return {
    type: "HIDE_BLOCK_INTERFACE"
  };
}
function showBlockInterface() {
  return {
    type: "SHOW_BLOCK_INTERFACE"
  };
}
const privateRemoveBlocks = (clientIds, selectPrevious = true, forceRemove = false) => ({ select, dispatch, registry }) => {
  if (!clientIds || !clientIds.length) {
    return;
  }
  clientIds = castArray(clientIds);
  const canRemoveBlocks = select.canRemoveBlocks(clientIds);
  if (!canRemoveBlocks) {
    return;
  }
  const rules = !forceRemove && select.getBlockRemovalRules();
  if (rules) {
    let flattenBlocks2 = function(blocks) {
      const result = [];
      const stack = [...blocks];
      while (stack.length) {
        const { innerBlocks, ...block } = stack.shift();
        stack.push(...innerBlocks);
        result.push(block);
      }
      return result;
    };
    var flattenBlocks = flattenBlocks2;
    const blockList = clientIds.map(select.getBlock);
    const flattenedBlocks = flattenBlocks2(blockList);
    let message;
    for (const rule of rules) {
      message = rule.callback(flattenedBlocks);
      if (message) {
        dispatch(
          displayBlockRemovalPrompt(
            clientIds,
            selectPrevious,
            message
          )
        );
        return;
      }
    }
  }
  if (selectPrevious) {
    dispatch.selectPreviousBlock(clientIds[0], selectPrevious);
  }
  registry.batch(() => {
    dispatch({ type: "REMOVE_BLOCKS", clientIds });
    dispatch(ensureDefaultBlock());
  });
};
const ensureDefaultBlock = () => ({ select, dispatch }) => {
  const count = select.getBlockCount();
  if (count > 0) {
    return;
  }
  const { __unstableHasCustomAppender } = select.getSettings();
  if (__unstableHasCustomAppender) {
    return;
  }
  dispatch.insertDefaultBlock();
};
function displayBlockRemovalPrompt(clientIds, selectPrevious, message) {
  return {
    type: "DISPLAY_BLOCK_REMOVAL_PROMPT",
    clientIds,
    selectPrevious,
    message
  };
}
function clearBlockRemovalPrompt() {
  return {
    type: "CLEAR_BLOCK_REMOVAL_PROMPT"
  };
}
function setBlockRemovalRules(rules = false) {
  return {
    type: "SET_BLOCK_REMOVAL_RULES",
    rules
  };
}
function setOpenedBlockSettingsMenu(clientId) {
  return {
    type: "SET_OPENED_BLOCK_SETTINGS_MENU",
    clientId
  };
}
function setStyleOverride(id, style) {
  return {
    type: "SET_STYLE_OVERRIDE",
    id,
    style
  };
}
function deleteStyleOverride(id) {
  return {
    type: "DELETE_STYLE_OVERRIDE",
    id
  };
}
function setLastFocus(lastFocus = null) {
  return {
    type: "LAST_FOCUS",
    lastFocus
  };
}
function stopEditingAsBlocks(clientId) {
  return ({ select, dispatch, registry }) => {
    const focusModeToRevert = unlock(
      registry.select(store)
    ).getTemporarilyEditingFocusModeToRevert();
    dispatch.__unstableMarkNextChangeAsNotPersistent();
    dispatch.updateBlockAttributes(clientId, {
      templateLock: "contentOnly"
    });
    dispatch.updateBlockListSettings(clientId, {
      ...select.getBlockListSettings(clientId),
      templateLock: "contentOnly"
    });
    dispatch.updateSettings({ focusMode: focusModeToRevert });
    dispatch.__unstableSetTemporarilyEditingAsBlocks();
  };
}
function startDragging() {
  return {
    type: "START_DRAGGING"
  };
}
function stopDragging() {
  return {
    type: "STOP_DRAGGING"
  };
}
function expandBlock(clientId) {
  return {
    type: "SET_BLOCK_EXPANDED_IN_LIST_VIEW",
    clientId
  };
}
function setInsertionPoint(value) {
  return {
    type: "SET_INSERTION_POINT",
    value
  };
}
const modifyContentLockBlock = (clientId) => ({ select, dispatch }) => {
  dispatch.selectBlock(clientId);
  dispatch.__unstableMarkNextChangeAsNotPersistent();
  dispatch.updateBlockAttributes(clientId, {
    templateLock: void 0
  });
  dispatch.updateBlockListSettings(clientId, {
    ...select.getBlockListSettings(clientId),
    templateLock: false
  });
  const focusModeToRevert = select.getSettings().focusMode;
  dispatch.updateSettings({ focusMode: true });
  dispatch.__unstableSetTemporarilyEditingAsBlocks(
    clientId,
    focusModeToRevert
  );
};
const setZoomLevel = (zoom = 100) => ({ select, dispatch }) => {
  if (zoom !== 100) {
    const firstSelectedClientId = select.getBlockSelectionStart();
    const sectionRootClientId = select.getSectionRootClientId();
    if (firstSelectedClientId) {
      let sectionClientId;
      if (sectionRootClientId) {
        const sectionClientIds = select.getBlockOrder(sectionRootClientId);
        if (sectionClientIds?.includes(firstSelectedClientId)) {
          sectionClientId = firstSelectedClientId;
        } else {
          sectionClientId = select.getBlockParents(firstSelectedClientId).find(
            (parent) => sectionClientIds.includes(parent)
          );
        }
      } else {
        sectionClientId = select.getBlockHierarchyRootClientId(
          firstSelectedClientId
        );
      }
      if (sectionClientId) {
        dispatch.selectBlock(sectionClientId);
      } else {
        dispatch.clearSelectedBlock();
      }
      (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("You are currently in zoom-out mode."));
    }
  }
  dispatch({
    type: "SET_ZOOM_LEVEL",
    zoom
  });
};
function resetZoomLevel() {
  return {
    type: "RESET_ZOOM_LEVEL"
  };
}
function toggleBlockSpotlight(clientId, hasBlockSpotlight) {
  return {
    type: "TOGGLE_BLOCK_SPOTLIGHT",
    clientId,
    hasBlockSpotlight
  };
}


;// external ["wp","notices"]
const external_wp_notices_namespaceObject = window["wp"]["notices"];
;// external ["wp","preferences"]
const external_wp_preferences_namespaceObject = window["wp"]["preferences"];
;// ./node_modules/@wordpress/block-editor/build-module/utils/selection.js

const START_OF_SELECTED_AREA = "\x86";
function retrieveSelectedAttribute(blockAttributes) {
  if (!blockAttributes) {
    return;
  }
  return Object.keys(blockAttributes).find((name) => {
    const value = blockAttributes[name];
    return (typeof value === "string" || value instanceof external_wp_richText_namespaceObject.RichTextData) && // To do: refactor this to use rich text's selection instead, so we
    // no longer have to use on this hack inserting a special character.
    value.toString().indexOf(START_OF_SELECTED_AREA) !== -1;
  });
}
function findRichTextAttributeKey(blockType) {
  for (const [key, value] of Object.entries(blockType.attributes)) {
    if (value.source === "rich-text" || value.source === "html") {
      return key;
    }
  }
}


;// ./node_modules/@wordpress/block-editor/build-module/store/actions.js









const actions_castArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
const resetBlocks = (blocks) => ({ dispatch }) => {
  dispatch({ type: "RESET_BLOCKS", blocks });
  dispatch(validateBlocksToTemplate(blocks));
};
const validateBlocksToTemplate = (blocks) => ({ select, dispatch }) => {
  const template = select.getTemplate();
  const templateLock = select.getTemplateLock();
  const isBlocksValidToTemplate = !template || templateLock !== "all" || (0,external_wp_blocks_namespaceObject.doBlocksMatchTemplate)(blocks, template);
  const isValidTemplate = select.isValidTemplate();
  if (isBlocksValidToTemplate !== isValidTemplate) {
    dispatch.setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
};
function resetSelection(selectionStart, selectionEnd, initialPosition) {
  return {
    type: "RESET_SELECTION",
    selectionStart,
    selectionEnd,
    initialPosition
  };
}
function receiveBlocks(blocks) {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
    since: "5.9",
    alternative: "resetBlocks or insertBlocks"
  });
  return {
    type: "RECEIVE_BLOCKS",
    blocks
  };
}
function updateBlockAttributes(clientIds, attributes, options = { uniqueByBlock: false }) {
  if (typeof options === "boolean") {
    options = { uniqueByBlock: options };
  }
  return {
    type: "UPDATE_BLOCK_ATTRIBUTES",
    clientIds: actions_castArray(clientIds),
    attributes,
    options
  };
}
function updateBlock(clientId, updates) {
  return {
    type: "UPDATE_BLOCK",
    clientId,
    updates
  };
}
function selectBlock(clientId, initialPosition = 0) {
  return {
    type: "SELECT_BLOCK",
    initialPosition,
    clientId
  };
}
function hoverBlock() {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).hoverBlock', {
    since: "6.9",
    version: "7.1"
  });
  return {
    type: "DO_NOTHING"
  };
}
const selectPreviousBlock = (clientId, fallbackToParent = false) => ({ select, dispatch }) => {
  const previousBlockClientId = select.getPreviousBlockClientId(clientId);
  if (previousBlockClientId) {
    dispatch.selectBlock(previousBlockClientId, -1);
  } else if (fallbackToParent) {
    const firstParentClientId = select.getBlockRootClientId(clientId);
    if (firstParentClientId) {
      dispatch.selectBlock(firstParentClientId, -1);
    }
  }
};
const selectNextBlock = (clientId) => ({ select, dispatch }) => {
  const nextBlockClientId = select.getNextBlockClientId(clientId);
  if (nextBlockClientId) {
    dispatch.selectBlock(nextBlockClientId);
  }
};
function startMultiSelect() {
  return {
    type: "START_MULTI_SELECT"
  };
}
function stopMultiSelect() {
  return {
    type: "STOP_MULTI_SELECT"
  };
}
const multiSelect = (start, end, __experimentalInitialPosition = 0) => ({ select, dispatch }) => {
  const startBlockRootClientId = select.getBlockRootClientId(start);
  const endBlockRootClientId = select.getBlockRootClientId(end);
  if (startBlockRootClientId !== endBlockRootClientId) {
    return;
  }
  dispatch({
    type: "MULTI_SELECT",
    start,
    end,
    initialPosition: __experimentalInitialPosition
  });
  const blockCount = select.getSelectedBlockCount();
  (0,external_wp_a11y_namespaceObject.speak)(
    (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %s: number of selected blocks */
      (0,external_wp_i18n_namespaceObject._n)("%s block selected.", "%s blocks selected.", blockCount),
      blockCount
    ),
    "assertive"
  );
};
function clearSelectedBlock() {
  return {
    type: "CLEAR_SELECTED_BLOCK"
  };
}
function toggleSelection(isSelectionEnabled = true) {
  return {
    type: "TOGGLE_SELECTION",
    isSelectionEnabled
  };
}
const replaceBlocks = (clientIds, blocks, indexToSelect, initialPosition = 0, meta) => ({ select, dispatch, registry }) => {
  clientIds = actions_castArray(clientIds);
  blocks = actions_castArray(blocks);
  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  for (let index = 0; index < blocks.length; index++) {
    const block = blocks[index];
    const canInsertBlock = select.canInsertBlockType(
      block.name,
      rootClientId
    );
    if (!canInsertBlock) {
      return;
    }
  }
  registry.batch(() => {
    dispatch({
      type: "REPLACE_BLOCKS",
      clientIds,
      blocks,
      time: Date.now(),
      indexToSelect,
      initialPosition,
      meta
    });
    dispatch.ensureDefaultBlock();
  });
};
function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
const createOnMove = (type) => (clientIds, rootClientId) => ({ select, dispatch }) => {
  const canMoveBlocks = select.canMoveBlocks(clientIds);
  if (!canMoveBlocks) {
    return;
  }
  dispatch({ type, clientIds: actions_castArray(clientIds), rootClientId });
};
const moveBlocksDown = createOnMove("MOVE_BLOCKS_DOWN");
const moveBlocksUp = createOnMove("MOVE_BLOCKS_UP");
const moveBlocksToPosition = (clientIds, fromRootClientId = "", toRootClientId = "", index) => ({ select, dispatch }) => {
  const canMoveBlocks = select.canMoveBlocks(clientIds);
  if (!canMoveBlocks) {
    return;
  }
  if (fromRootClientId !== toRootClientId) {
    const canRemoveBlocks = select.canRemoveBlocks(clientIds);
    if (!canRemoveBlocks) {
      return;
    }
    const canInsertBlocks = select.canInsertBlocks(
      clientIds,
      toRootClientId
    );
    if (!canInsertBlocks) {
      return;
    }
  }
  dispatch({
    type: "MOVE_BLOCKS_TO_POSITION",
    fromRootClientId,
    toRootClientId,
    clientIds,
    index
  });
};
function moveBlockToPosition(clientId, fromRootClientId = "", toRootClientId = "", index) {
  return moveBlocksToPosition(
    [clientId],
    fromRootClientId,
    toRootClientId,
    index
  );
}
function insertBlock(block, index, rootClientId, updateSelection, meta) {
  return insertBlocks(
    [block],
    index,
    rootClientId,
    updateSelection,
    0,
    meta
  );
}
const insertBlocks = (blocks, index, rootClientId, updateSelection = true, initialPosition = 0, meta) => ({ select, dispatch }) => {
  if (initialPosition !== null && typeof initialPosition === "object") {
    meta = initialPosition;
    initialPosition = 0;
    external_wp_deprecated_default()(
      "meta argument in wp.data.dispatch('core/block-editor')",
      {
        since: "5.8",
        hint: "The meta argument is now the 6th argument of the function"
      }
    );
  }
  blocks = actions_castArray(blocks);
  const allowedBlocks = [];
  for (const block of blocks) {
    const isValid = select.canInsertBlockType(
      block.name,
      rootClientId
    );
    if (isValid) {
      allowedBlocks.push(block);
    }
  }
  if (allowedBlocks.length) {
    dispatch({
      type: "INSERT_BLOCKS",
      blocks: allowedBlocks,
      index,
      rootClientId,
      time: Date.now(),
      updateSelection,
      initialPosition: updateSelection ? initialPosition : null,
      meta
    });
  }
};
function showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
  const { __unstableWithInserter, operation, nearestSide } = __unstableOptions;
  return {
    type: "SHOW_INSERTION_POINT",
    rootClientId,
    index,
    __unstableWithInserter,
    operation,
    nearestSide
  };
}
const hideInsertionPoint = () => ({ select, dispatch }) => {
  if (!select.isBlockInsertionPointVisible()) {
    return;
  }
  dispatch({
    type: "HIDE_INSERTION_POINT"
  });
};
function setTemplateValidity(isValid) {
  return {
    type: "SET_TEMPLATE_VALIDITY",
    isValid
  };
}
const synchronizeTemplate = () => ({ select, dispatch }) => {
  dispatch({ type: "SYNCHRONIZE_TEMPLATE" });
  const blocks = select.getBlocks();
  const template = select.getTemplate();
  const updatedBlockList = (0,external_wp_blocks_namespaceObject.synchronizeBlocksWithTemplate)(
    blocks,
    template
  );
  dispatch.resetBlocks(updatedBlockList);
};
const __unstableDeleteSelection = (isForward) => ({ registry, select, dispatch }) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return;
  }
  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
    return false;
  }
  const anchorRootClientId = select.getBlockRootClientId(
    selectionAnchor.clientId
  );
  const focusRootClientId = select.getBlockRootClientId(
    selectionFocus.clientId
  );
  if (anchorRootClientId !== focusRootClientId) {
    return;
  }
  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const targetSelection = isForward ? selectionEnd : selectionStart;
  const targetBlock = select.getBlock(targetSelection.clientId);
  const targetBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlock.name);
  if (!targetBlockType.merge) {
    return;
  }
  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockB = select.getBlock(selectionB.clientId);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  let valueA = (0,external_wp_richText_namespaceObject.create)({ html: htmlA });
  let valueB = (0,external_wp_richText_namespaceObject.create)({ html: htmlB });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,external_wp_richText_namespaceObject.insert)(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset);
  const cloneA = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockA, {
    [selectionA.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({ value: valueA })
  });
  const cloneB = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockB, {
    [selectionB.attributeKey]: (0,external_wp_richText_namespaceObject.toHTMLString)({ value: valueB })
  });
  const followingBlock = isForward ? cloneA : cloneB;
  const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(followingBlock, targetBlockType.name);
  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }
  let updatedAttributes;
  if (isForward) {
    const blockToMerge = blocksWithTheSameType.pop();
    updatedAttributes = targetBlockType.merge(
      blockToMerge.attributes,
      cloneB.attributes
    );
  } else {
    const blockToMerge = blocksWithTheSameType.shift();
    updatedAttributes = targetBlockType.merge(
      cloneA.attributes,
      blockToMerge.attributes
    );
  }
  const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
  const convertedHtml = updatedAttributes[newAttributeKey];
  const convertedValue = (0,external_wp_richText_namespaceObject.create)({ html: convertedHtml });
  const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
  const newValue = (0,external_wp_richText_namespaceObject.remove)(convertedValue, newOffset, newOffset + 1);
  const newHtml = (0,external_wp_richText_namespaceObject.toHTMLString)({ value: newValue });
  updatedAttributes[newAttributeKey] = newHtml;
  const selectedBlockClientIds = select.getSelectedBlockClientIds();
  const replacement = [
    ...isForward ? blocksWithTheSameType : [],
    {
      // Preserve the original client ID.
      ...targetBlock,
      attributes: {
        ...targetBlock.attributes,
        ...updatedAttributes
      }
    },
    ...isForward ? [] : blocksWithTheSameType
  ];
  registry.batch(() => {
    dispatch.selectionChange(
      targetBlock.clientId,
      newAttributeKey,
      newOffset,
      newOffset
    );
    dispatch.replaceBlocks(
      selectedBlockClientIds,
      replacement,
      0,
      // If we don't pass the `indexToSelect` it will default to the last block.
      select.getSelectedBlocksInitialCaretPosition()
    );
  });
};
const __unstableSplitSelection = (blocks = []) => ({ registry, select, dispatch }) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  const anchorRootClientId = select.getBlockRootClientId(
    selectionAnchor.clientId
  );
  const focusRootClientId = select.getBlockRootClientId(
    selectionFocus.clientId
  );
  if (anchorRootClientId !== focusRootClientId) {
    return;
  }
  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
  let selectionStart, selectionEnd;
  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }
  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockB = select.getBlock(selectionB.clientId);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const attributeKeyA = typeof selectionA.attributeKey === "string" ? selectionA.attributeKey : findRichTextAttributeKey(blockAType);
  const attributeKeyB = typeof selectionB.attributeKey === "string" ? selectionB.attributeKey : findRichTextAttributeKey(blockBType);
  const blockAttributes = select.getBlockAttributes(
    selectionA.clientId
  );
  const bindings = blockAttributes?.metadata?.bindings;
  if (bindings?.[attributeKeyA]) {
    if (blocks.length) {
      const { createWarningNotice } = registry.dispatch(external_wp_notices_namespaceObject.store);
      createWarningNotice(
        (0,external_wp_i18n_namespaceObject.__)(
          "Blocks can't be inserted into other blocks with bindings"
        ),
        {
          type: "snackbar"
        }
      );
      return;
    }
    dispatch.insertAfterBlock(selectionA.clientId);
    return;
  }
  if (!attributeKeyA || !attributeKeyB || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
    return;
  }
  if (selectionA.clientId === selectionB.clientId && attributeKeyA === attributeKeyB && selectionA.offset === selectionB.offset) {
    if (blocks.length) {
      if ((0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(blockA)) {
        dispatch.replaceBlocks(
          [selectionA.clientId],
          blocks,
          blocks.length - 1,
          -1
        );
        return;
      }
    } else if (!select.getBlockOrder(selectionA.clientId).length) {
      let createEmpty2 = function() {
        const defaultBlockName2 = (0,external_wp_blocks_namespaceObject.getDefaultBlockName)();
        return select.canInsertBlockType(
          defaultBlockName2,
          anchorRootClientId
        ) ? (0,external_wp_blocks_namespaceObject.createBlock)(defaultBlockName2) : (0,external_wp_blocks_namespaceObject.createBlock)(
          select.getBlockName(selectionA.clientId)
        );
      };
      var createEmpty = createEmpty2;
      const length = blockAttributes[attributeKeyA].length;
      if (selectionA.offset === 0 && length) {
        dispatch.insertBlocks(
          [createEmpty2()],
          select.getBlockIndex(selectionA.clientId),
          anchorRootClientId,
          false
        );
        return;
      }
      if (selectionA.offset === length) {
        dispatch.insertBlocks(
          [createEmpty2()],
          select.getBlockIndex(selectionA.clientId) + 1,
          anchorRootClientId
        );
        return;
      }
    }
  }
  const htmlA = blockA.attributes[attributeKeyA];
  const htmlB = blockB.attributes[attributeKeyB];
  let valueA = (0,external_wp_richText_namespaceObject.create)({ html: htmlA });
  let valueB = (0,external_wp_richText_namespaceObject.create)({ html: htmlB });
  valueA = (0,external_wp_richText_namespaceObject.remove)(valueA, selectionA.offset, valueA.text.length);
  valueB = (0,external_wp_richText_namespaceObject.remove)(valueB, 0, selectionB.offset);
  let head = {
    // Preserve the original client ID.
    ...blockA,
    // If both start and end are the same, should only copy innerBlocks
    // once.
    innerBlocks: blockA.clientId === blockB.clientId ? [] : blockA.innerBlocks,
    attributes: {
      ...blockA.attributes,
      [attributeKeyA]: (0,external_wp_richText_namespaceObject.toHTMLString)({ value: valueA })
    }
  };
  let tail = {
    ...blockB,
    // Only preserve the original client ID if the end is different.
    clientId: blockA.clientId === blockB.clientId ? (0,external_wp_blocks_namespaceObject.createBlock)(blockB.name).clientId : blockB.clientId,
    attributes: {
      ...blockB.attributes,
      [attributeKeyB]: (0,external_wp_richText_namespaceObject.toHTMLString)({ value: valueB })
    }
  };
  const defaultBlockName = (0,external_wp_blocks_namespaceObject.getDefaultBlockName)();
  if (
    // A block is only split when the selection is within the same
    // block.
    blockA.clientId === blockB.clientId && defaultBlockName && tail.name !== defaultBlockName && select.canInsertBlockType(defaultBlockName, anchorRootClientId)
  ) {
    const switched = (0,external_wp_blocks_namespaceObject.switchToBlockType)(tail, defaultBlockName);
    if (switched?.length === 1) {
      tail = switched[0];
    }
  }
  if (!blocks.length) {
    dispatch.replaceBlocks(select.getSelectedBlockClientIds(), [
      head,
      tail
    ]);
    return;
  }
  let selection;
  const output = [];
  const clonedBlocks = [...blocks];
  const firstBlock = clonedBlocks.shift();
  const headType = (0,external_wp_blocks_namespaceObject.getBlockType)(head.name);
  const firstBlocks = headType.merge && firstBlock.name === headType.name ? [firstBlock] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(firstBlock, headType.name);
  if (firstBlocks?.length) {
    const first = firstBlocks.shift();
    head = {
      ...head,
      attributes: {
        ...head.attributes,
        ...headType.merge(head.attributes, first.attributes)
      }
    };
    output.push(head);
    selection = {
      clientId: head.clientId,
      attributeKey: attributeKeyA,
      offset: (0,external_wp_richText_namespaceObject.create)({ html: head.attributes[attributeKeyA] }).text.length
    };
    clonedBlocks.unshift(...firstBlocks);
  } else {
    if (!(0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(head)) {
      output.push(head);
    }
    output.push(firstBlock);
  }
  const lastBlock = clonedBlocks.pop();
  const tailType = (0,external_wp_blocks_namespaceObject.getBlockType)(tail.name);
  if (clonedBlocks.length) {
    output.push(...clonedBlocks);
  }
  if (lastBlock) {
    const lastBlocks = tailType.merge && tailType.name === lastBlock.name ? [lastBlock] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(lastBlock, tailType.name);
    if (lastBlocks?.length) {
      const last = lastBlocks.pop();
      output.push({
        ...tail,
        attributes: {
          ...tail.attributes,
          ...tailType.merge(last.attributes, tail.attributes)
        }
      });
      output.push(...lastBlocks);
      selection = {
        clientId: tail.clientId,
        attributeKey: attributeKeyB,
        offset: (0,external_wp_richText_namespaceObject.create)({
          html: last.attributes[attributeKeyB]
        }).text.length
      };
    } else {
      output.push(lastBlock);
      if (!(0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(tail)) {
        output.push(tail);
      }
    }
  } else if (!(0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(tail)) {
    output.push(tail);
  }
  registry.batch(() => {
    dispatch.replaceBlocks(
      select.getSelectedBlockClientIds(),
      output,
      output.length - 1,
      0
    );
    if (selection) {
      dispatch.selectionChange(
        selection.clientId,
        selection.attributeKey,
        selection.offset,
        selection.offset
      );
    }
  });
};
const __unstableExpandSelection = () => ({ select, dispatch }) => {
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  dispatch.selectionChange({
    start: { clientId: selectionAnchor.clientId },
    end: { clientId: selectionFocus.clientId }
  });
};
const mergeBlocks = (firstBlockClientId, secondBlockClientId) => ({ registry, select, dispatch }) => {
  const clientIdA = firstBlockClientId;
  const clientIdB = secondBlockClientId;
  const blockA = select.getBlock(clientIdA);
  const blockAType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockA.name);
  if (!blockAType || select.getBlockEditingMode(clientIdA) === "disabled" || select.getBlockEditingMode(clientIdB) === "disabled") {
    return;
  }
  const blockB = select.getBlock(clientIdB);
  if (!blockAType.merge && (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockA.name, "__experimentalOnMerge")) {
    const blocksWithTheSameType2 = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
      blockB,
      blockAType.name
    );
    if (blocksWithTheSameType2?.length !== 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }
    const [blockWithSameType] = blocksWithTheSameType2;
    if (blockWithSameType.innerBlocks.length < 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }
    registry.batch(() => {
      dispatch.insertBlocks(
        blockWithSameType.innerBlocks,
        void 0,
        clientIdA
      );
      dispatch.removeBlock(clientIdB);
      dispatch.selectBlock(
        blockWithSameType.innerBlocks[0].clientId
      );
      const nextBlockClientId = select.getNextBlockClientId(clientIdA);
      if (nextBlockClientId && select.getBlockName(clientIdA) === select.getBlockName(nextBlockClientId)) {
        const rootAttributes = select.getBlockAttributes(clientIdA);
        const previousRootAttributes = select.getBlockAttributes(nextBlockClientId);
        if (Object.keys(rootAttributes).every(
          (key) => rootAttributes[key] === previousRootAttributes[key]
        )) {
          dispatch.moveBlocksToPosition(
            select.getBlockOrder(nextBlockClientId),
            nextBlockClientId,
            clientIdA
          );
          dispatch.removeBlock(nextBlockClientId, false);
        }
      }
    });
    return;
  }
  if ((0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(blockA)) {
    dispatch.removeBlock(
      clientIdA,
      select.isBlockSelected(clientIdA)
    );
    return;
  }
  if ((0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(blockB)) {
    dispatch.removeBlock(
      clientIdB,
      select.isBlockSelected(clientIdB)
    );
    return;
  }
  if (!blockAType.merge) {
    if ((0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(blockB, "content")) {
      dispatch.removeBlock(
        clientIdB,
        select.isBlockSelected(clientIdB)
      );
    } else {
      dispatch.selectBlock(blockA.clientId);
    }
    return;
  }
  const blockBType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockB.name);
  const { clientId, attributeKey, offset } = select.getSelectionStart();
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== void 0 && offset !== void 0 && // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback instance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;
  if (!attributeDefinition) {
    if (typeof attributeKey === "number") {
      window.console.error(
        `RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`
      );
    } else {
      window.console.error(
        "The RichText identifier prop does not match any attributes defined by the block."
      );
    }
  }
  const cloneA = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockA);
  const cloneB = (0,external_wp_blocks_namespaceObject.cloneBlock)(blockB);
  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const value = (0,external_wp_richText_namespaceObject.insert)(
      (0,external_wp_richText_namespaceObject.create)({ html }),
      START_OF_SELECTED_AREA,
      offset,
      offset
    );
    selectedBlock.attributes[attributeKey] = (0,external_wp_richText_namespaceObject.toHTMLString)({
      value
    });
  }
  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0,external_wp_blocks_namespaceObject.switchToBlockType)(cloneB, blockA.name);
  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }
  const updatedAttributes = blockAType.merge(
    cloneA.attributes,
    blocksWithTheSameType[0].attributes
  );
  if (canRestoreTextSelection) {
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = (0,external_wp_richText_namespaceObject.create)({ html: convertedHtml });
    const newOffset = convertedValue.text.indexOf(
      START_OF_SELECTED_AREA
    );
    const newValue = (0,external_wp_richText_namespaceObject.remove)(convertedValue, newOffset, newOffset + 1);
    const newHtml = (0,external_wp_richText_namespaceObject.toHTMLString)({ value: newValue });
    updatedAttributes[newAttributeKey] = newHtml;
    dispatch.selectionChange(
      blockA.clientId,
      newAttributeKey,
      newOffset,
      newOffset
    );
  }
  dispatch.replaceBlocks(
    [blockA.clientId, blockB.clientId],
    [
      {
        ...blockA,
        attributes: {
          ...blockA.attributes,
          ...updatedAttributes
        }
      },
      ...blocksWithTheSameType.slice(1)
    ],
    0
    // If we don't pass the `indexToSelect` it will default to the last block.
  );
};
const removeBlocks = (clientIds, selectPrevious = true) => privateRemoveBlocks(clientIds, selectPrevious);
function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
function replaceInnerBlocks(rootClientId, blocks, updateSelection = false, initialPosition = 0) {
  return {
    type: "REPLACE_INNER_BLOCKS",
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
function toggleBlockMode(clientId) {
  return {
    type: "TOGGLE_BLOCK_MODE",
    clientId
  };
}
function startTyping() {
  return {
    type: "START_TYPING"
  };
}
function stopTyping() {
  return {
    type: "STOP_TYPING"
  };
}
function startDraggingBlocks(clientIds = []) {
  return {
    type: "START_DRAGGING_BLOCKS",
    clientIds
  };
}
function stopDraggingBlocks() {
  return {
    type: "STOP_DRAGGING_BLOCKS"
  };
}
function enterFormattedText() {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
    since: "6.1",
    version: "6.3"
  });
  return {
    type: "DO_NOTHING"
  };
}
function exitFormattedText() {
  external_wp_deprecated_default()('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
    since: "6.1",
    version: "6.3"
  });
  return {
    type: "DO_NOTHING"
  };
}
function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  if (typeof clientId === "string") {
    return {
      type: "SELECTION_CHANGE",
      clientId,
      attributeKey,
      startOffset,
      endOffset
    };
  }
  return { type: "SELECTION_CHANGE", ...clientId };
}
const insertDefaultBlock = (attributes, rootClientId, index) => ({ dispatch }) => {
  const defaultBlockName = (0,external_wp_blocks_namespaceObject.getDefaultBlockName)();
  if (!defaultBlockName) {
    return;
  }
  const block = (0,external_wp_blocks_namespaceObject.createBlock)(defaultBlockName, attributes);
  return dispatch.insertBlock(block, index, rootClientId);
};
function updateBlockListSettings(clientId, settings) {
  return {
    type: "UPDATE_BLOCK_LIST_SETTINGS",
    clientId,
    settings
  };
}
function updateSettings(settings) {
  return __experimentalUpdateSettings(settings, {
    stripExperimentalSettings: true
  });
}
function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: "SAVE_REUSABLE_BLOCK_SUCCESS",
    id,
    updatedId
  };
}
function __unstableMarkLastChangeAsPersistent() {
  return { type: "MARK_LAST_CHANGE_AS_PERSISTENT" };
}
function __unstableMarkNextChangeAsNotPersistent() {
  return { type: "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT" };
}
const __unstableMarkAutomaticChange = () => ({ dispatch }) => {
  dispatch({ type: "MARK_AUTOMATIC_CHANGE" });
  const { requestIdleCallback = (cb) => setTimeout(cb, 100) } = window;
  requestIdleCallback(() => {
    dispatch({ type: "MARK_AUTOMATIC_CHANGE_FINAL" });
  });
};
const __unstableSetEditorMode = (mode) => ({ registry }) => {
  registry.dispatch(external_wp_preferences_namespaceObject.store).set("core", "editorTool", mode);
  if (mode === "navigation") {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("You are currently in Write mode."));
  } else if (mode === "edit") {
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("You are currently in Design mode."));
  }
};
function setBlockMovingClientId() {
  external_wp_deprecated_default()(
    'wp.data.dispatch( "core/block-editor" ).setBlockMovingClientId',
    {
      since: "6.7",
      hint: "Block moving mode feature has been removed"
    }
  );
  return {
    type: "DO_NOTHING"
  };
}
const duplicateBlocks = (clientIds, updateSelection = true) => ({ select, dispatch }) => {
  if (!clientIds || !clientIds.length) {
    return;
  }
  const blocks = select.getBlocksByClientId(clientIds);
  if (blocks.some((block) => !block)) {
    return;
  }
  const blockNames = blocks.map((block) => block.name);
  if (blockNames.some(
    (blockName) => !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "multiple", true)
  )) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientIds[0]);
  const clientIdsArray = actions_castArray(clientIds);
  const lastSelectedIndex = select.getBlockIndex(
    clientIdsArray[clientIdsArray.length - 1]
  );
  const clonedBlocks = blocks.map(
    (block) => (0,external_wp_blocks_namespaceObject.__experimentalCloneSanitizedBlock)(block)
  );
  dispatch.insertBlocks(
    clonedBlocks,
    lastSelectedIndex + 1,
    rootClientId,
    updateSelection
  );
  if (clonedBlocks.length > 1 && updateSelection) {
    dispatch.multiSelect(
      clonedBlocks[0].clientId,
      clonedBlocks[clonedBlocks.length - 1].clientId
    );
  }
  return clonedBlocks.map((block) => block.clientId);
};
const insertBeforeBlock = (clientId) => ({ select, dispatch }) => {
  if (!clientId) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);
  if (isLocked) {
    return;
  }
  const blockIndex = select.getBlockIndex(clientId);
  const directInsertBlock = rootClientId ? select.getDirectInsertBlock(rootClientId) : null;
  if (!directInsertBlock) {
    return dispatch.insertDefaultBlock({}, rootClientId, blockIndex);
  }
  const copiedAttributes = {};
  if (directInsertBlock.attributesToCopy) {
    const attributes = select.getBlockAttributes(clientId);
    directInsertBlock.attributesToCopy.forEach((key) => {
      if (attributes[key]) {
        copiedAttributes[key] = attributes[key];
      }
    });
  }
  const block = (0,external_wp_blocks_namespaceObject.createBlock)(directInsertBlock.name, {
    ...directInsertBlock.attributes,
    ...copiedAttributes
  });
  return dispatch.insertBlock(block, blockIndex, rootClientId);
};
const insertAfterBlock = (clientId) => ({ select, dispatch }) => {
  if (!clientId) {
    return;
  }
  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);
  if (isLocked) {
    return;
  }
  const blockIndex = select.getBlockIndex(clientId);
  const directInsertBlock = rootClientId ? select.getDirectInsertBlock(rootClientId) : null;
  if (!directInsertBlock) {
    return dispatch.insertDefaultBlock(
      {},
      rootClientId,
      blockIndex + 1
    );
  }
  const copiedAttributes = {};
  if (directInsertBlock.attributesToCopy) {
    const attributes = select.getBlockAttributes(clientId);
    directInsertBlock.attributesToCopy.forEach((key) => {
      if (attributes[key]) {
        copiedAttributes[key] = attributes[key];
      }
    });
  }
  const block = (0,external_wp_blocks_namespaceObject.createBlock)(directInsertBlock.name, {
    ...directInsertBlock.attributes,
    ...copiedAttributes
  });
  return dispatch.insertBlock(block, blockIndex + 1, rootClientId);
};
function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: "TOGGLE_BLOCK_HIGHLIGHT",
    clientId,
    isHighlighted
  };
}
const flashBlock = (clientId, timeout = 150) => async ({ dispatch }) => {
  dispatch(toggleBlockHighlight(clientId, true));
  await new Promise((resolve) => setTimeout(resolve, timeout));
  dispatch(toggleBlockHighlight(clientId, false));
};
function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: "SET_HAS_CONTROLLED_INNER_BLOCKS",
    hasControlledInnerBlocks,
    clientId
  };
}
function setBlockVisibility(updates) {
  return {
    type: "SET_BLOCK_VISIBILITY",
    updates
  };
}
function __unstableSetTemporarilyEditingAsBlocks(temporarilyEditingAsBlocks, focusModeToRevert) {
  return {
    type: "SET_TEMPORARILY_EDITING_AS_BLOCKS",
    temporarilyEditingAsBlocks,
    focusModeToRevert
  };
}
const registerInserterMediaCategory = (category) => ({ select, dispatch }) => {
  if (!category || typeof category !== "object") {
    console.error(
      "Category should be an `InserterMediaCategory` object."
    );
    return;
  }
  if (!category.name) {
    console.error(
      "Category should have a `name` that should be unique among all media categories."
    );
    return;
  }
  if (!category.labels?.name) {
    console.error("Category should have a `labels.name`.");
    return;
  }
  if (!["image", "audio", "video"].includes(category.mediaType)) {
    console.error(
      "Category should have `mediaType` property that is one of `image|audio|video`."
    );
    return;
  }
  if (!category.fetch || typeof category.fetch !== "function") {
    console.error(
      "Category should have a `fetch` function defined with the following signature `(InserterMediaRequest) => Promise<InserterMediaItem[]>`."
    );
    return;
  }
  const registeredInserterMediaCategories = select.getRegisteredInserterMediaCategories();
  if (registeredInserterMediaCategories.some(
    ({ name }) => name === category.name
  )) {
    console.error(
      `A category is already registered with the same name: "${category.name}".`
    );
    return;
  }
  if (registeredInserterMediaCategories.some(
    ({ labels: { name } = {} }) => name === category.labels?.name
  )) {
    console.error(
      `A category is already registered with the same labels.name: "${category.labels.name}".`
    );
    return;
  }
  dispatch({
    type: "REGISTER_INSERTER_MEDIA_CATEGORY",
    category: { ...category, isExternalResource: true }
  });
};
function setBlockEditingMode(clientId = "", mode) {
  return {
    type: "SET_BLOCK_EDITING_MODE",
    clientId,
    mode
  };
}
function unsetBlockEditingMode(clientId = "") {
  return {
    type: "UNSET_BLOCK_EDITING_MODE",
    clientId
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/store/index.js








const storeConfig = {
  reducer: reducer_default,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject
};
const store = (0,external_wp_data_namespaceObject.createReduxStore)(STORE_NAME, {
  ...storeConfig,
  persist: ["preferences"]
});
const registeredStore = (0,external_wp_data_namespaceObject.registerStore)(STORE_NAME, {
  ...storeConfig,
  persist: ["preferences"]
});
unlock(registeredStore).registerPrivateActions(private_actions_namespaceObject);
unlock(registeredStore).registerPrivateSelectors(private_selectors_namespaceObject);
unlock(store).registerPrivateActions(private_actions_namespaceObject);
unlock(store).registerPrivateSelectors(private_selectors_namespaceObject);


;// ./node_modules/@wordpress/block-editor/build-module/components/use-settings/index.js





function use_settings_useSettings(...paths) {
  const { clientId = null } = useBlockEditContext();
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(store)).getBlockSettings(
      clientId,
      ...paths
    ),
    [clientId, ...paths]
  );
}
function useSetting(path) {
  external_wp_deprecated_default()("wp.blockEditor.useSetting", {
    since: "6.5",
    alternative: "wp.blockEditor.useSettings",
    note: "The new useSettings function can retrieve multiple settings at once, with better performance."
  });
  const [value] = use_settings_useSettings(path);
  return value;
}


;// external ["wp","styleEngine"]
const external_wp_styleEngine_namespaceObject = window["wp"]["styleEngine"];
;// ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/fluid-utils.js
const DEFAULT_MAXIMUM_VIEWPORT_WIDTH = "1600px";
const DEFAULT_MINIMUM_VIEWPORT_WIDTH = "320px";
const DEFAULT_SCALE_FACTOR = 1;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;
const DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;
const DEFAULT_MINIMUM_FONT_SIZE_LIMIT = "14px";
function getComputedFluidTypographyValue({
  minimumFontSize,
  maximumFontSize,
  fontSize,
  minimumViewportWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,
  maximumViewportWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,
  scaleFactor = DEFAULT_SCALE_FACTOR,
  minimumFontSizeLimit
}) {
  minimumFontSizeLimit = !!getTypographyValueAndUnit(minimumFontSizeLimit) ? minimumFontSizeLimit : DEFAULT_MINIMUM_FONT_SIZE_LIMIT;
  if (fontSize) {
    const fontSizeParsed = getTypographyValueAndUnit(fontSize);
    if (!fontSizeParsed?.unit) {
      return null;
    }
    const minimumFontSizeLimitParsed = getTypographyValueAndUnit(
      minimumFontSizeLimit,
      {
        coerceTo: fontSizeParsed.unit
      }
    );
    if (!!minimumFontSizeLimitParsed?.value && !minimumFontSize && !maximumFontSize) {
      if (fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value) {
        return null;
      }
    }
    if (!maximumFontSize) {
      maximumFontSize = `${fontSizeParsed.value}${fontSizeParsed.unit}`;
    }
    if (!minimumFontSize) {
      const fontSizeValueInPx = fontSizeParsed.unit === "px" ? fontSizeParsed.value : fontSizeParsed.value * 16;
      const minimumFontSizeFactor = Math.min(
        Math.max(
          1 - 0.075 * Math.log2(fontSizeValueInPx),
          DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN
        ),
        DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX
      );
      const calculatedMinimumFontSize = roundToPrecision(
        fontSizeParsed.value * minimumFontSizeFactor,
        3
      );
      if (!!minimumFontSizeLimitParsed?.value && calculatedMinimumFontSize < minimumFontSizeLimitParsed?.value) {
        minimumFontSize = `${minimumFontSizeLimitParsed.value}${minimumFontSizeLimitParsed.unit}`;
      } else {
        minimumFontSize = `${calculatedMinimumFontSize}${fontSizeParsed.unit}`;
      }
    }
  }
  const minimumFontSizeParsed = getTypographyValueAndUnit(minimumFontSize);
  const fontSizeUnit = minimumFontSizeParsed?.unit || "rem";
  const maximumFontSizeParsed = getTypographyValueAndUnit(maximumFontSize, {
    coerceTo: fontSizeUnit
  });
  if (!minimumFontSizeParsed || !maximumFontSizeParsed) {
    return null;
  }
  const minimumFontSizeRem = getTypographyValueAndUnit(minimumFontSize, {
    coerceTo: "rem"
  });
  const maximumViewportWidthParsed = getTypographyValueAndUnit(
    maximumViewportWidth,
    { coerceTo: fontSizeUnit }
  );
  const minimumViewportWidthParsed = getTypographyValueAndUnit(
    minimumViewportWidth,
    { coerceTo: fontSizeUnit }
  );
  if (!maximumViewportWidthParsed || !minimumViewportWidthParsed || !minimumFontSizeRem) {
    return null;
  }
  const linearDenominator = maximumViewportWidthParsed.value - minimumViewportWidthParsed.value;
  if (!linearDenominator) {
    return null;
  }
  const minViewportWidthOffsetValue = roundToPrecision(
    minimumViewportWidthParsed.value / 100,
    3
  );
  const viewportWidthOffset = roundToPrecision(minViewportWidthOffsetValue, 3) + fontSizeUnit;
  const linearFactor = 100 * ((maximumFontSizeParsed.value - minimumFontSizeParsed.value) / linearDenominator);
  const linearFactorScaled = roundToPrecision(
    (linearFactor || 1) * scaleFactor,
    3
  );
  const fluidTargetFontSize = `${minimumFontSizeRem.value}${minimumFontSizeRem.unit} + ((1vw - ${viewportWidthOffset}) * ${linearFactorScaled})`;
  return `clamp(${minimumFontSize}, ${fluidTargetFontSize}, ${maximumFontSize})`;
}
function getTypographyValueAndUnit(rawValue, options = {}) {
  if (typeof rawValue !== "string" && typeof rawValue !== "number") {
    return null;
  }
  if (isFinite(rawValue)) {
    rawValue = `${rawValue}px`;
  }
  const { coerceTo, rootSizeValue, acceptableUnits } = {
    coerceTo: "",
    // Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( "html" ) ).fontSize`.
    rootSizeValue: 16,
    acceptableUnits: ["rem", "px", "em"],
    ...options
  };
  const acceptableUnitsGroup = acceptableUnits?.join("|");
  const regexUnits = new RegExp(
    `^(\\d*\\.?\\d+)(${acceptableUnitsGroup}){1,1}$`
  );
  const matches = rawValue.match(regexUnits);
  if (!matches || matches.length < 3) {
    return null;
  }
  let [, value, unit] = matches;
  let returnValue = parseFloat(value);
  if ("px" === coerceTo && ("em" === unit || "rem" === unit)) {
    returnValue = returnValue * rootSizeValue;
    unit = coerceTo;
  }
  if ("px" === unit && ("em" === coerceTo || "rem" === coerceTo)) {
    returnValue = returnValue / rootSizeValue;
    unit = coerceTo;
  }
  if (("em" === coerceTo || "rem" === coerceTo) && ("em" === unit || "rem" === unit)) {
    unit = coerceTo;
  }
  return {
    value: roundToPrecision(returnValue, 3),
    unit
  };
}
function roundToPrecision(value, digits = 3) {
  const base = Math.pow(10, digits);
  return Number.isFinite(value) ? parseFloat(Math.round(value * base) / base) : void 0;
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/format-font-style.js

function formatFontStyle(fontStyle) {
  if (!fontStyle) {
    return {};
  }
  if (typeof fontStyle === "object") {
    return fontStyle;
  }
  let name;
  switch (fontStyle) {
    case "normal":
      name = (0,external_wp_i18n_namespaceObject._x)("Regular", "font style");
      break;
    case "italic":
      name = (0,external_wp_i18n_namespaceObject._x)("Italic", "font style");
      break;
    case "oblique":
      name = (0,external_wp_i18n_namespaceObject._x)("Oblique", "font style");
      break;
    default:
      name = fontStyle;
      break;
  }
  return { name, value: fontStyle };
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/format-font-weight.js

function formatFontWeight(fontWeight) {
  if (!fontWeight) {
    return {};
  }
  if (typeof fontWeight === "object") {
    return fontWeight;
  }
  let name;
  switch (fontWeight) {
    case "normal":
    case "400":
      name = (0,external_wp_i18n_namespaceObject._x)("Regular", "font weight");
      break;
    case "bold":
    case "700":
      name = (0,external_wp_i18n_namespaceObject._x)("Bold", "font weight");
      break;
    case "100":
      name = (0,external_wp_i18n_namespaceObject._x)("Thin", "font weight");
      break;
    case "200":
      name = (0,external_wp_i18n_namespaceObject._x)("Extra Light", "font weight");
      break;
    case "300":
      name = (0,external_wp_i18n_namespaceObject._x)("Light", "font weight");
      break;
    case "500":
      name = (0,external_wp_i18n_namespaceObject._x)("Medium", "font weight");
      break;
    case "600":
      name = (0,external_wp_i18n_namespaceObject._x)("Semi Bold", "font weight");
      break;
    case "800":
      name = (0,external_wp_i18n_namespaceObject._x)("Extra Bold", "font weight");
      break;
    case "900":
      name = (0,external_wp_i18n_namespaceObject._x)("Black", "font weight");
      break;
    case "1000":
      name = (0,external_wp_i18n_namespaceObject._x)("Extra Black", "font weight");
      break;
    default:
      name = fontWeight;
      break;
  }
  return { name, value: fontWeight };
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/get-font-styles-and-weights.js



const FONT_STYLES = [
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Regular", "font style"),
    value: "normal"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Italic", "font style"),
    value: "italic"
  }
];
const FONT_WEIGHTS = [
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Thin", "font weight"),
    value: "100"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Extra Light", "font weight"),
    value: "200"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Light", "font weight"),
    value: "300"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Regular", "font weight"),
    value: "400"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Medium", "font weight"),
    value: "500"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Semi Bold", "font weight"),
    value: "600"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Bold", "font weight"),
    value: "700"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Extra Bold", "font weight"),
    value: "800"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Black", "font weight"),
    value: "900"
  },
  {
    name: (0,external_wp_i18n_namespaceObject._x)("Extra Black", "font weight"),
    value: "1000"
  }
];
function getFontStylesAndWeights(fontFamilyFaces) {
  let fontStyles = [];
  let fontWeights = [];
  const combinedStyleAndWeightOptions = [];
  const isSystemFont = !fontFamilyFaces || fontFamilyFaces?.length === 0;
  let isVariableFont = false;
  fontFamilyFaces?.forEach((face) => {
    if ("string" === typeof face.fontWeight && /\s/.test(face.fontWeight.trim())) {
      isVariableFont = true;
      let [startValue, endValue] = face.fontWeight.split(" ");
      startValue = parseInt(startValue.slice(0, 1));
      if (endValue === "1000") {
        endValue = 10;
      } else {
        endValue = parseInt(endValue.slice(0, 1));
      }
      for (let i = startValue; i <= endValue; i++) {
        const fontWeightValue = `${i.toString()}00`;
        if (!fontWeights.some(
          (weight) => weight.value === fontWeightValue
        )) {
          fontWeights.push(formatFontWeight(fontWeightValue));
        }
      }
    }
    const fontWeight = formatFontWeight(
      "number" === typeof face.fontWeight ? face.fontWeight.toString() : face.fontWeight
    );
    const fontStyle = formatFontStyle(face.fontStyle);
    if (fontStyle && Object.keys(fontStyle).length) {
      if (!fontStyles.some(
        (style) => style.value === fontStyle.value
      )) {
        fontStyles.push(fontStyle);
      }
    }
    if (fontWeight && Object.keys(fontWeight).length) {
      if (!fontWeights.some(
        (weight) => weight.value === fontWeight.value
      )) {
        if (!isVariableFont) {
          fontWeights.push(fontWeight);
        }
      }
    }
  });
  if (!fontWeights.some((weight) => weight.value >= "600")) {
    fontWeights.push({
      name: (0,external_wp_i18n_namespaceObject._x)("Bold", "font weight"),
      value: "700"
    });
  }
  if (!fontStyles.some((style) => style.value === "italic")) {
    fontStyles.push({
      name: (0,external_wp_i18n_namespaceObject._x)("Italic", "font style"),
      value: "italic"
    });
  }
  if (isSystemFont) {
    fontStyles = FONT_STYLES;
    fontWeights = FONT_WEIGHTS;
  }
  fontStyles = fontStyles.length === 0 ? FONT_STYLES : fontStyles;
  fontWeights = fontWeights.length === 0 ? FONT_WEIGHTS : fontWeights;
  fontStyles.forEach(({ name: styleName, value: styleValue }) => {
    fontWeights.forEach(({ name: weightName, value: weightValue }) => {
      const optionName = styleValue === "normal" ? weightName : (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: 1: Font weight name. 2: Font style name. */
        (0,external_wp_i18n_namespaceObject._x)("%1$s %2$s", "font"),
        weightName,
        styleName
      );
      combinedStyleAndWeightOptions.push({
        key: `${styleValue}-${weightValue}`,
        name: optionName,
        style: {
          fontStyle: styleValue,
          fontWeight: weightValue
        }
      });
    });
  });
  return {
    fontStyles,
    fontWeights,
    combinedStyleAndWeightOptions,
    isSystemFont,
    isVariableFont
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-utils.js


function getTypographyFontSizeValue(preset, settings) {
  const { size: defaultSize } = preset;
  if (!defaultSize || "0" === defaultSize || false === preset?.fluid) {
    return defaultSize;
  }
  if (!isFluidTypographyEnabled(settings?.typography) && !isFluidTypographyEnabled(preset)) {
    return defaultSize;
  }
  let fluidTypographySettings = getFluidTypographyOptionsFromSettings(settings);
  fluidTypographySettings = typeof fluidTypographySettings?.fluid === "object" ? fluidTypographySettings?.fluid : {};
  const fluidFontSizeValue = getComputedFluidTypographyValue({
    minimumFontSize: preset?.fluid?.min,
    maximumFontSize: preset?.fluid?.max,
    fontSize: defaultSize,
    minimumFontSizeLimit: fluidTypographySettings?.minFontSize,
    maximumViewportWidth: fluidTypographySettings?.maxViewportWidth,
    minimumViewportWidth: fluidTypographySettings?.minViewportWidth
  });
  if (!!fluidFontSizeValue) {
    return fluidFontSizeValue;
  }
  return defaultSize;
}
function isFluidTypographyEnabled(typographySettings) {
  const fluidSettings = typographySettings?.fluid;
  return true === fluidSettings || fluidSettings && typeof fluidSettings === "object" && Object.keys(fluidSettings).length > 0;
}
function getFluidTypographyOptionsFromSettings(settings) {
  const typographySettings = settings?.typography;
  const layoutSettings = settings?.layout;
  const defaultMaxViewportWidth = getTypographyValueAndUnit(
    layoutSettings?.wideSize
  ) ? layoutSettings?.wideSize : null;
  return isFluidTypographyEnabled(typographySettings) && defaultMaxViewportWidth ? {
    fluid: {
      maxViewportWidth: defaultMaxViewportWidth,
      ...typographySettings.fluid
    }
  } : {
    fluid: typographySettings?.fluid
  };
}
function getMergedFontFamiliesAndFontFamilyFaces(settings, selectedFontFamily) {
  const fontFamiliesFromSettings = settings?.typography?.fontFamilies;
  const fontFamilies = ["default", "theme", "custom"].flatMap(
    (key) => fontFamiliesFromSettings?.[key] ?? []
  );
  const fontFamilyFaces = fontFamilies.find(
    (family) => family.fontFamily === selectedFontFamily
  )?.fontFace ?? [];
  return { fontFamilies, fontFamilyFaces };
}
function findNearestFontWeight(availableFontWeights, newFontWeightValue) {
  newFontWeightValue = "number" === typeof newFontWeightValue ? newFontWeightValue.toString() : newFontWeightValue;
  if (!newFontWeightValue || typeof newFontWeightValue !== "string") {
    return "";
  }
  if (!availableFontWeights || availableFontWeights.length === 0) {
    return newFontWeightValue;
  }
  const nearestFontWeight = availableFontWeights?.reduce(
    (nearest, { value: fw }) => {
      const currentDiff = Math.abs(
        parseInt(fw) - parseInt(newFontWeightValue)
      );
      const nearestDiff = Math.abs(
        parseInt(nearest) - parseInt(newFontWeightValue)
      );
      return currentDiff < nearestDiff ? fw : nearest;
    },
    availableFontWeights[0]?.value
  );
  return nearestFontWeight;
}
function findNearestFontStyle(availableFontStyles, newFontStyleValue) {
  if (typeof newFontStyleValue !== "string" || !newFontStyleValue) {
    return "";
  }
  const validStyles = ["normal", "italic", "oblique"];
  if (!validStyles.includes(newFontStyleValue)) {
    return "";
  }
  if (!availableFontStyles || availableFontStyles.length === 0 || availableFontStyles.find(
    (style) => style.value === newFontStyleValue
  )) {
    return newFontStyleValue;
  }
  if (newFontStyleValue === "oblique" && !availableFontStyles.find((style) => style.value === "oblique")) {
    return "italic";
  }
  return "";
}
function findNearestStyleAndWeight(fontFamilyFaces, fontStyle, fontWeight) {
  let nearestFontStyle = fontStyle;
  let nearestFontWeight = fontWeight;
  const { fontStyles, fontWeights, combinedStyleAndWeightOptions } = getFontStylesAndWeights(fontFamilyFaces);
  const hasFontStyle = fontStyles?.some(
    ({ value: fs }) => fs === fontStyle
  );
  const hasFontWeight = fontWeights?.some(
    ({ value: fw }) => fw?.toString() === fontWeight?.toString()
  );
  if (!hasFontStyle) {
    nearestFontStyle = fontStyle ? findNearestFontStyle(fontStyles, fontStyle) : combinedStyleAndWeightOptions?.find(
      (option) => option.style.fontWeight === findNearestFontWeight(fontWeights, fontWeight)
    )?.style?.fontStyle;
  }
  if (!hasFontWeight) {
    nearestFontWeight = fontWeight ? findNearestFontWeight(fontWeights, fontWeight) : combinedStyleAndWeightOptions?.find(
      (option) => option.style.fontStyle === (nearestFontStyle || fontStyle)
    )?.style?.fontWeight;
  }
  return { nearestFontStyle, nearestFontWeight };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/utils.js





const ROOT_BLOCK_SELECTOR = "body";
const ROOT_CSS_PROPERTIES_SELECTOR = ":root";
const PRESET_METADATA = [
  {
    path: ["color", "palette"],
    valueKey: "color",
    cssVarInfix: "color",
    classes: [
      { classSuffix: "color", propertyName: "color" },
      {
        classSuffix: "background-color",
        propertyName: "background-color"
      },
      {
        classSuffix: "border-color",
        propertyName: "border-color"
      }
    ]
  },
  {
    path: ["color", "gradients"],
    valueKey: "gradient",
    cssVarInfix: "gradient",
    classes: [
      {
        classSuffix: "gradient-background",
        propertyName: "background"
      }
    ]
  },
  {
    path: ["color", "duotone"],
    valueKey: "colors",
    cssVarInfix: "duotone",
    valueFunc: ({ slug }) => `url( '#wp-duotone-${slug}' )`,
    classes: []
  },
  {
    path: ["shadow", "presets"],
    valueKey: "shadow",
    cssVarInfix: "shadow",
    classes: []
  },
  {
    path: ["typography", "fontSizes"],
    valueFunc: (preset, settings) => getTypographyFontSizeValue(preset, settings),
    valueKey: "size",
    cssVarInfix: "font-size",
    classes: [{ classSuffix: "font-size", propertyName: "font-size" }]
  },
  {
    path: ["typography", "fontFamilies"],
    valueKey: "fontFamily",
    cssVarInfix: "font-family",
    classes: [
      { classSuffix: "font-family", propertyName: "font-family" }
    ]
  },
  {
    path: ["spacing", "spacingSizes"],
    valueKey: "size",
    cssVarInfix: "spacing",
    classes: []
  },
  {
    path: ["border", "radiusSizes"],
    valueKey: "size",
    cssVarInfix: "border-radius",
    classes: []
  }
];
const STYLE_PATH_TO_CSS_VAR_INFIX = {
  "color.background": "color",
  "color.text": "color",
  "filter.duotone": "duotone",
  "elements.link.color.text": "color",
  "elements.link.:hover.color.text": "color",
  "elements.link.typography.fontFamily": "font-family",
  "elements.link.typography.fontSize": "font-size",
  "elements.button.color.text": "color",
  "elements.button.color.background": "color",
  "elements.caption.color.text": "color",
  "elements.button.typography.fontFamily": "font-family",
  "elements.button.typography.fontSize": "font-size",
  "elements.heading.color": "color",
  "elements.heading.color.background": "color",
  "elements.heading.typography.fontFamily": "font-family",
  "elements.heading.gradient": "gradient",
  "elements.heading.color.gradient": "gradient",
  "elements.h1.color": "color",
  "elements.h1.color.background": "color",
  "elements.h1.typography.fontFamily": "font-family",
  "elements.h1.color.gradient": "gradient",
  "elements.h2.color": "color",
  "elements.h2.color.background": "color",
  "elements.h2.typography.fontFamily": "font-family",
  "elements.h2.color.gradient": "gradient",
  "elements.h3.color": "color",
  "elements.h3.color.background": "color",
  "elements.h3.typography.fontFamily": "font-family",
  "elements.h3.color.gradient": "gradient",
  "elements.h4.color": "color",
  "elements.h4.color.background": "color",
  "elements.h4.typography.fontFamily": "font-family",
  "elements.h4.color.gradient": "gradient",
  "elements.h5.color": "color",
  "elements.h5.color.background": "color",
  "elements.h5.typography.fontFamily": "font-family",
  "elements.h5.color.gradient": "gradient",
  "elements.h6.color": "color",
  "elements.h6.color.background": "color",
  "elements.h6.typography.fontFamily": "font-family",
  "elements.h6.color.gradient": "gradient",
  "color.gradient": "gradient",
  shadow: "shadow",
  "typography.fontSize": "font-size",
  "typography.fontFamily": "font-family"
};
const STYLE_PATH_TO_PRESET_BLOCK_ATTRIBUTE = {
  "color.background": "backgroundColor",
  "color.text": "textColor",
  "color.gradient": "gradient",
  "typography.fontSize": "fontSize",
  "typography.fontFamily": "fontFamily"
};
function useToolsPanelDropdownMenuProps() {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  return !isMobile ? {
    popoverProps: {
      placement: "left-start",
      // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
      offset: 259
    }
  } : {};
}
function findInPresetsBy(features, blockName, presetPath, presetProperty, presetValueValue) {
  const orderedPresetsByOrigin = [
    getValueFromObjectPath(features, [
      "blocks",
      blockName,
      ...presetPath
    ]),
    getValueFromObjectPath(features, presetPath)
  ];
  for (const presetByOrigin of orderedPresetsByOrigin) {
    if (presetByOrigin) {
      const origins = ["custom", "theme", "default"];
      for (const origin of origins) {
        const presets = presetByOrigin[origin];
        if (presets) {
          const presetObject = presets.find(
            (preset) => preset[presetProperty] === presetValueValue
          );
          if (presetObject) {
            if (presetProperty === "slug") {
              return presetObject;
            }
            const highestPresetObjectWithSameSlug = findInPresetsBy(
              features,
              blockName,
              presetPath,
              "slug",
              presetObject.slug
            );
            if (highestPresetObjectWithSameSlug[presetProperty] === presetObject[presetProperty]) {
              return presetObject;
            }
            return void 0;
          }
        }
      }
    }
  }
}
function getPresetVariableFromValue(features, blockName, variableStylePath, presetPropertyValue) {
  if (!presetPropertyValue) {
    return presetPropertyValue;
  }
  const cssVarInfix = STYLE_PATH_TO_CSS_VAR_INFIX[variableStylePath];
  const metadata = PRESET_METADATA.find(
    (data) => data.cssVarInfix === cssVarInfix
  );
  if (!metadata) {
    return presetPropertyValue;
  }
  const { valueKey, path } = metadata;
  const presetObject = findInPresetsBy(
    features,
    blockName,
    path,
    valueKey,
    presetPropertyValue
  );
  if (!presetObject) {
    return presetPropertyValue;
  }
  return `var:preset|${cssVarInfix}|${presetObject.slug}`;
}
function getValueFromPresetVariable(features, blockName, variable, [presetType, slug]) {
  const metadata = PRESET_METADATA.find(
    (data) => data.cssVarInfix === presetType
  );
  if (!metadata) {
    return variable;
  }
  const presetObject = findInPresetsBy(
    features.settings,
    blockName,
    metadata.path,
    "slug",
    slug
  );
  if (presetObject) {
    const { valueKey } = metadata;
    const result = presetObject[valueKey];
    return getValueFromVariable(features, blockName, result);
  }
  return variable;
}
function getValueFromCustomVariable(features, blockName, variable, path) {
  const result = getValueFromObjectPath(features.settings, [
    "blocks",
    blockName,
    "custom",
    ...path
  ]) ?? getValueFromObjectPath(features.settings, ["custom", ...path]);
  if (!result) {
    return variable;
  }
  return getValueFromVariable(features, blockName, result);
}
function getValueFromVariable(features, blockName, variable) {
  if (!variable || typeof variable !== "string") {
    if (typeof variable?.ref === "string") {
      variable = getValueFromObjectPath(features, variable.ref);
      if (!variable || !!variable?.ref) {
        return variable;
      }
    } else {
      return variable;
    }
  }
  const USER_VALUE_PREFIX = "var:";
  const THEME_VALUE_PREFIX = "var(--wp--";
  const THEME_VALUE_SUFFIX = ")";
  let parsedVar;
  if (variable.startsWith(USER_VALUE_PREFIX)) {
    parsedVar = variable.slice(USER_VALUE_PREFIX.length).split("|");
  } else if (variable.startsWith(THEME_VALUE_PREFIX) && variable.endsWith(THEME_VALUE_SUFFIX)) {
    parsedVar = variable.slice(THEME_VALUE_PREFIX.length, -THEME_VALUE_SUFFIX.length).split("--");
  } else {
    return variable;
  }
  const [type, ...path] = parsedVar;
  if (type === "preset") {
    return getValueFromPresetVariable(
      features,
      blockName,
      variable,
      path
    );
  }
  if (type === "custom") {
    return getValueFromCustomVariable(
      features,
      blockName,
      variable,
      path
    );
  }
  return variable;
}
function scopeSelector(scope, selector) {
  if (!scope || !selector) {
    return selector;
  }
  const scopes = scope.split(",");
  const selectors = selector.split(",");
  const selectorsScoped = [];
  scopes.forEach((outer) => {
    selectors.forEach((inner) => {
      selectorsScoped.push(`${outer.trim()} ${inner.trim()}`);
    });
  });
  return selectorsScoped.join(", ");
}
function scopeFeatureSelectors(scope, selectors) {
  if (!scope || !selectors) {
    return;
  }
  const featureSelectors = {};
  Object.entries(selectors).forEach(([feature, selector]) => {
    if (typeof selector === "string") {
      featureSelectors[feature] = scopeSelector(scope, selector);
    }
    if (typeof selector === "object") {
      featureSelectors[feature] = {};
      Object.entries(selector).forEach(
        ([subfeature, subfeatureSelector]) => {
          featureSelectors[feature][subfeature] = scopeSelector(
            scope,
            subfeatureSelector
          );
        }
      );
    }
  });
  return featureSelectors;
}
function appendToSelector(selector, toAppend) {
  if (!selector.includes(",")) {
    return selector + toAppend;
  }
  const selectors = selector.split(",");
  const newSelectors = selectors.map((sel) => sel + toAppend);
  return newSelectors.join(",");
}
function areGlobalStyleConfigsEqual(original, variation) {
  if (typeof original !== "object" || typeof variation !== "object") {
    return original === variation;
  }
  return es6_default()(original?.styles, variation?.styles) && es6_default()(original?.settings, variation?.settings);
}
function getBlockStyleVariationSelector(variation, blockSelector) {
  const variationClass = `.is-style-${variation}`;
  if (!blockSelector) {
    return variationClass;
  }
  const ancestorRegex = /((?::\([^)]+\))?\s*)([^\s:]+)/;
  const addVariationClass = (_match, group1, group2) => {
    return group1 + group2 + variationClass;
  };
  const result = blockSelector.split(",").map((part) => part.replace(ancestorRegex, addVariationClass));
  return result.join(",");
}
function getResolvedThemeFilePath(file, themeFileURIs) {
  if (!file || !themeFileURIs || !Array.isArray(themeFileURIs)) {
    return file;
  }
  const uri = themeFileURIs.find(
    (themeFileUri) => themeFileUri?.name === file
  );
  if (!uri?.href) {
    return file;
  }
  return uri?.href;
}
function getResolvedRefValue(ruleValue, tree) {
  if (!ruleValue || !tree) {
    return ruleValue;
  }
  if (typeof ruleValue !== "string" && ruleValue?.ref) {
    const resolvedRuleValue = (0,external_wp_styleEngine_namespaceObject.getCSSValueFromRawStyle)(
      getValueFromObjectPath(tree, ruleValue.ref)
    );
    if (resolvedRuleValue?.ref) {
      return void 0;
    }
    if (resolvedRuleValue === void 0) {
      return ruleValue;
    }
    return resolvedRuleValue;
  }
  return ruleValue;
}
function getResolvedValue(ruleValue, tree) {
  if (!ruleValue || !tree) {
    return ruleValue;
  }
  const resolvedValue = getResolvedRefValue(ruleValue, tree);
  if (resolvedValue?.url) {
    resolvedValue.url = getResolvedThemeFilePath(
      resolvedValue.url,
      tree?._links?.["wp:theme-file"]
    );
  }
  return resolvedValue;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/context.js

const DEFAULT_GLOBAL_STYLES_CONTEXT = {
  user: {},
  base: {},
  merged: {},
  setUserConfig: () => {
  }
};
const GlobalStylesContext = (0,external_wp_element_namespaceObject.createContext)(
  DEFAULT_GLOBAL_STYLES_CONTEXT
);
GlobalStylesContext.displayName = "GlobalStylesContext";


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/hooks.js









const EMPTY_CONFIG = { settings: {}, styles: {} };
const VALID_SETTINGS = [
  "appearanceTools",
  "useRootPaddingAwareAlignments",
  "background.backgroundImage",
  "background.backgroundRepeat",
  "background.backgroundSize",
  "background.backgroundPosition",
  "border.color",
  "border.radius",
  "border.style",
  "border.width",
  "border.radiusSizes",
  "shadow.presets",
  "shadow.defaultPresets",
  "color.background",
  "color.button",
  "color.caption",
  "color.custom",
  "color.customDuotone",
  "color.customGradient",
  "color.defaultDuotone",
  "color.defaultGradients",
  "color.defaultPalette",
  "color.duotone",
  "color.gradients",
  "color.heading",
  "color.link",
  "color.palette",
  "color.text",
  "custom",
  "dimensions.aspectRatio",
  "dimensions.minHeight",
  "layout.contentSize",
  "layout.definitions",
  "layout.wideSize",
  "lightbox.enabled",
  "lightbox.allowEditing",
  "position.fixed",
  "position.sticky",
  "spacing.customSpacingSize",
  "spacing.defaultSpacingSizes",
  "spacing.spacingSizes",
  "spacing.spacingScale",
  "spacing.blockGap",
  "spacing.margin",
  "spacing.padding",
  "spacing.units",
  "typography.fluid",
  "typography.customFontSize",
  "typography.defaultFontSizes",
  "typography.dropCap",
  "typography.fontFamilies",
  "typography.fontSizes",
  "typography.fontStyle",
  "typography.fontWeight",
  "typography.letterSpacing",
  "typography.lineHeight",
  "typography.textAlign",
  "typography.textColumns",
  "typography.textDecoration",
  "typography.textTransform",
  "typography.writingMode"
];
const useGlobalStylesReset = () => {
  const { user, setUserConfig } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const config = {
    settings: user.settings,
    styles: user.styles
  };
  const canReset = !!config && !es6_default()(config, EMPTY_CONFIG);
  return [
    canReset,
    (0,external_wp_element_namespaceObject.useCallback)(() => setUserConfig(EMPTY_CONFIG), [setUserConfig])
  ];
};
function useGlobalSetting(propertyPath, blockName, source = "all") {
  const { setUserConfig, ...configs } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const appendedBlockPath = blockName ? ".blocks." + blockName : "";
  const appendedPropertyPath = propertyPath ? "." + propertyPath : "";
  const contextualPath = `settings${appendedBlockPath}${appendedPropertyPath}`;
  const globalPath = `settings${appendedPropertyPath}`;
  const sourceKey = source === "all" ? "merged" : source;
  const settingValue = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const configToUse = configs[sourceKey];
    if (!configToUse) {
      throw "Unsupported source";
    }
    if (propertyPath) {
      return getValueFromObjectPath(configToUse, contextualPath) ?? getValueFromObjectPath(configToUse, globalPath);
    }
    let result = {};
    VALID_SETTINGS.forEach((setting) => {
      const value = getValueFromObjectPath(
        configToUse,
        `settings${appendedBlockPath}.${setting}`
      ) ?? getValueFromObjectPath(configToUse, `settings.${setting}`);
      if (value !== void 0) {
        result = setImmutably(result, setting.split("."), value);
      }
    });
    return result;
  }, [
    configs,
    sourceKey,
    propertyPath,
    contextualPath,
    globalPath,
    appendedBlockPath
  ]);
  const setSetting = (newValue) => {
    setUserConfig(
      (currentConfig) => setImmutably(currentConfig, contextualPath.split("."), newValue)
    );
  };
  return [settingValue, setSetting];
}
function useGlobalStyle(path, blockName, source = "all", { shouldDecodeEncode = true } = {}) {
  const {
    merged: mergedConfig,
    base: baseConfig,
    user: userConfig,
    setUserConfig
  } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const appendedPath = path ? "." + path : "";
  const finalPath = !blockName ? `styles${appendedPath}` : `styles.blocks.${blockName}${appendedPath}`;
  const setStyle = (newValue) => {
    setUserConfig(
      (currentConfig) => setImmutably(
        currentConfig,
        finalPath.split("."),
        shouldDecodeEncode ? getPresetVariableFromValue(
          mergedConfig.settings,
          blockName,
          path,
          newValue
        ) : newValue
      )
    );
  };
  let rawResult, result;
  switch (source) {
    case "all":
      rawResult = getValueFromObjectPath(mergedConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;
    case "user":
      rawResult = getValueFromObjectPath(userConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(mergedConfig, blockName, rawResult) : rawResult;
      break;
    case "base":
      rawResult = getValueFromObjectPath(baseConfig, finalPath);
      result = shouldDecodeEncode ? getValueFromVariable(baseConfig, blockName, rawResult) : rawResult;
      break;
    default:
      throw "Unsupported source";
  }
  return [result, setStyle];
}
function useSettingsForBlockElement(parentSettings, blockName, element) {
  const { supportedStyles, supports } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return {
        supportedStyles: unlock(
          select(external_wp_blocks_namespaceObject.store)
        ).getSupportedStyles(blockName, element),
        supports: select(external_wp_blocks_namespaceObject.store).getBlockType(blockName)?.supports
      };
    },
    [blockName, element]
  );
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const updatedSettings = { ...parentSettings };
    if (!supportedStyles.includes("fontSize")) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        fontSizes: {},
        customFontSize: false,
        defaultFontSizes: false
      };
    }
    if (!supportedStyles.includes("fontFamily")) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        fontFamilies: {}
      };
    }
    updatedSettings.color = {
      ...updatedSettings.color,
      text: updatedSettings.color?.text && supportedStyles.includes("color"),
      background: updatedSettings.color?.background && (supportedStyles.includes("background") || supportedStyles.includes("backgroundColor")),
      button: updatedSettings.color?.button && supportedStyles.includes("buttonColor"),
      heading: updatedSettings.color?.heading && supportedStyles.includes("headingColor"),
      link: updatedSettings.color?.link && supportedStyles.includes("linkColor"),
      caption: updatedSettings.color?.caption && supportedStyles.includes("captionColor")
    };
    if (!supportedStyles.includes("background")) {
      updatedSettings.color.gradients = [];
      updatedSettings.color.customGradient = false;
    }
    if (!supportedStyles.includes("filter")) {
      updatedSettings.color.defaultDuotone = false;
      updatedSettings.color.customDuotone = false;
    }
    [
      "lineHeight",
      "fontStyle",
      "fontWeight",
      "letterSpacing",
      "textAlign",
      "textTransform",
      "textDecoration",
      "writingMode"
    ].forEach((key) => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.typography = {
          ...updatedSettings.typography,
          [key]: false
        };
      }
    });
    if (!supportedStyles.includes("columnCount")) {
      updatedSettings.typography = {
        ...updatedSettings.typography,
        textColumns: false
      };
    }
    ["contentSize", "wideSize"].forEach((key) => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.layout = {
          ...updatedSettings.layout,
          [key]: false
        };
      }
    });
    ["padding", "margin", "blockGap"].forEach((key) => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.spacing = {
          ...updatedSettings.spacing,
          [key]: false
        };
      }
      const sides = Array.isArray(supports?.spacing?.[key]) ? supports?.spacing?.[key] : supports?.spacing?.[key]?.sides;
      if (sides?.length && updatedSettings.spacing?.[key]) {
        updatedSettings.spacing = {
          ...updatedSettings.spacing,
          [key]: {
            ...updatedSettings.spacing?.[key],
            sides
          }
        };
      }
    });
    ["aspectRatio", "minHeight"].forEach((key) => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.dimensions = {
          ...updatedSettings.dimensions,
          [key]: false
        };
      }
    });
    ["radius", "color", "style", "width"].forEach((key) => {
      if (!supportedStyles.includes(
        "border" + key.charAt(0).toUpperCase() + key.slice(1)
      )) {
        updatedSettings.border = {
          ...updatedSettings.border,
          [key]: false
        };
      }
    });
    ["backgroundImage", "backgroundSize"].forEach((key) => {
      if (!supportedStyles.includes(key)) {
        updatedSettings.background = {
          ...updatedSettings.background,
          [key]: false
        };
      }
    });
    updatedSettings.shadow = supportedStyles.includes("shadow") ? updatedSettings.shadow : false;
    if (element) {
      updatedSettings.typography.textAlign = false;
    }
    return updatedSettings;
  }, [parentSettings, supportedStyles, supports, element]);
}
function useColorsPerOrigin(settings) {
  const customColors = settings?.color?.palette?.custom;
  const themeColors = settings?.color?.palette?.theme;
  const defaultColors = settings?.color?.palette?.default;
  const shouldDisplayDefaultColors = settings?.color?.defaultPalette;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];
    if (themeColors && themeColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Theme",
          "Indicates this palette comes from the theme."
        ),
        colors: themeColors
      });
    }
    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Default",
          "Indicates this palette comes from WordPress."
        ),
        colors: defaultColors
      });
    }
    if (customColors && customColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Custom",
          "Indicates this palette is created by the user."
        ),
        colors: customColors
      });
    }
    return result;
  }, [
    customColors,
    themeColors,
    defaultColors,
    shouldDisplayDefaultColors
  ]);
}
function useGradientsPerOrigin(settings) {
  const customGradients = settings?.color?.gradients?.custom;
  const themeGradients = settings?.color?.gradients?.theme;
  const defaultGradients = settings?.color?.gradients?.default;
  const shouldDisplayDefaultGradients = settings?.color?.defaultGradients;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];
    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Theme",
          "Indicates this palette comes from the theme."
        ),
        gradients: themeGradients
      });
    }
    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Default",
          "Indicates this palette comes from WordPress."
        ),
        gradients: defaultGradients
      });
    }
    if (customGradients && customGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Custom",
          "Indicates this palette is created by the user."
        ),
        gradients: customGradients
      });
    }
    return result;
  }, [
    customGradients,
    themeGradients,
    defaultGradients,
    shouldDisplayDefaultGradients
  ]);
}


;// ./node_modules/clsx/dist/clsx.mjs
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f)}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* harmony default export */ const dist_clsx = (clsx);
;// ./node_modules/@wordpress/block-editor/build-module/hooks/utils.js













const utils_cleanEmptyObject = (object) => {
  if (object === null || typeof object !== "object" || Array.isArray(object)) {
    return object;
  }
  const cleanedNestedObjects = Object.entries(object).map(([key, value]) => [key, utils_cleanEmptyObject(value)]).filter(([, value]) => value !== void 0);
  return !cleanedNestedObjects.length ? void 0 : Object.fromEntries(cleanedNestedObjects);
};
function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  if (Object.values(activeSupports ?? {}).every(
    (isActive) => !isActive
  )) {
    return result;
  }
  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }
  let referenceBlockAttributes = source[0]?.attributes;
  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      referenceBlockAttributes = source[index]?.attributes;
    } else {
      return result;
    }
  }
  let returnBlock = result;
  Object.entries(activeSupports).forEach(([support, isActive]) => {
    if (isActive) {
      migrationPaths[support].forEach((path) => {
        const styleValue = getValueFromObjectPath(
          referenceBlockAttributes,
          path
        );
        if (styleValue) {
          returnBlock = {
            ...returnBlock,
            attributes: setImmutably(
              returnBlock.attributes,
              path,
              styleValue
            )
          };
        }
      });
    }
  });
  return returnBlock;
}
function shouldSkipSerialization(blockNameOrType, featureSet, feature) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockNameOrType, featureSet);
  const skipSerialization = support?.__experimentalSkipSerialization;
  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }
  return skipSerialization;
}
const pendingStyleOverrides = /* @__PURE__ */ new WeakMap();
function useStyleOverride({ id, css }) {
  return usePrivateStyleOverride({ id, css });
}
function usePrivateStyleOverride({
  id,
  css,
  assets,
  __unstableType,
  variation,
  clientId
} = {}) {
  const { setStyleOverride, deleteStyleOverride } = unlock(
    (0,external_wp_data_namespaceObject.useDispatch)(store)
  );
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const fallbackId = (0,external_wp_element_namespaceObject.useId)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!css && !assets) {
      return;
    }
    const _id = id || fallbackId;
    const override = {
      id,
      css,
      assets,
      __unstableType,
      variation,
      clientId
    };
    if (!pendingStyleOverrides.get(registry)) {
      pendingStyleOverrides.set(registry, []);
    }
    pendingStyleOverrides.get(registry).push([_id, override]);
    window.queueMicrotask(() => {
      if (pendingStyleOverrides.get(registry)?.length) {
        registry.batch(() => {
          pendingStyleOverrides.get(registry).forEach((args) => {
            setStyleOverride(...args);
          });
          pendingStyleOverrides.set(registry, []);
        });
      }
    });
    return () => {
      const isPending = pendingStyleOverrides.get(registry)?.find(([currentId]) => currentId === _id);
      if (isPending) {
        pendingStyleOverrides.set(
          registry,
          pendingStyleOverrides.get(registry).filter(([currentId]) => currentId !== _id)
        );
      } else {
        deleteStyleOverride(_id);
      }
    };
  }, [
    id,
    css,
    clientId,
    assets,
    __unstableType,
    fallbackId,
    setStyleOverride,
    deleteStyleOverride,
    registry
  ]);
}
function useBlockSettings(name, parentLayout) {
  const [
    backgroundImage,
    backgroundSize,
    customFontFamilies,
    defaultFontFamilies,
    themeFontFamilies,
    defaultFontSizesEnabled,
    customFontSizes,
    defaultFontSizes,
    themeFontSizes,
    customFontSize,
    fontStyle,
    fontWeight,
    lineHeight,
    textAlign,
    textColumns,
    textDecoration,
    writingMode,
    textTransform,
    letterSpacing,
    padding,
    margin,
    blockGap,
    defaultSpacingSizesEnabled,
    customSpacingSize,
    userSpacingSizes,
    defaultSpacingSizes,
    themeSpacingSizes,
    units,
    aspectRatio,
    minHeight,
    layout,
    borderColor,
    borderRadius,
    borderStyle,
    borderWidth,
    borderRadiusSizes,
    customColorsEnabled,
    customColors,
    customDuotone,
    themeColors,
    defaultColors,
    defaultPalette,
    defaultDuotone,
    userDuotonePalette,
    themeDuotonePalette,
    defaultDuotonePalette,
    userGradientPalette,
    themeGradientPalette,
    defaultGradientPalette,
    defaultGradients,
    areCustomGradientsEnabled,
    isBackgroundEnabled,
    isLinkEnabled,
    isTextEnabled,
    isHeadingEnabled,
    isButtonEnabled,
    shadow
  ] = use_settings_useSettings(
    "background.backgroundImage",
    "background.backgroundSize",
    "typography.fontFamilies.custom",
    "typography.fontFamilies.default",
    "typography.fontFamilies.theme",
    "typography.defaultFontSizes",
    "typography.fontSizes.custom",
    "typography.fontSizes.default",
    "typography.fontSizes.theme",
    "typography.customFontSize",
    "typography.fontStyle",
    "typography.fontWeight",
    "typography.lineHeight",
    "typography.textAlign",
    "typography.textColumns",
    "typography.textDecoration",
    "typography.writingMode",
    "typography.textTransform",
    "typography.letterSpacing",
    "spacing.padding",
    "spacing.margin",
    "spacing.blockGap",
    "spacing.defaultSpacingSizes",
    "spacing.customSpacingSize",
    "spacing.spacingSizes.custom",
    "spacing.spacingSizes.default",
    "spacing.spacingSizes.theme",
    "spacing.units",
    "dimensions.aspectRatio",
    "dimensions.minHeight",
    "layout",
    "border.color",
    "border.radius",
    "border.style",
    "border.width",
    "border.radiusSizes",
    "color.custom",
    "color.palette.custom",
    "color.customDuotone",
    "color.palette.theme",
    "color.palette.default",
    "color.defaultPalette",
    "color.defaultDuotone",
    "color.duotone.custom",
    "color.duotone.theme",
    "color.duotone.default",
    "color.gradients.custom",
    "color.gradients.theme",
    "color.gradients.default",
    "color.defaultGradients",
    "color.customGradient",
    "color.background",
    "color.link",
    "color.text",
    "color.heading",
    "color.button",
    "shadow"
  );
  const rawSettings = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return {
      background: {
        backgroundImage,
        backgroundSize
      },
      color: {
        palette: {
          custom: customColors,
          theme: themeColors,
          default: defaultColors
        },
        gradients: {
          custom: userGradientPalette,
          theme: themeGradientPalette,
          default: defaultGradientPalette
        },
        duotone: {
          custom: userDuotonePalette,
          theme: themeDuotonePalette,
          default: defaultDuotonePalette
        },
        defaultGradients,
        defaultPalette,
        defaultDuotone,
        custom: customColorsEnabled,
        customGradient: areCustomGradientsEnabled,
        customDuotone,
        background: isBackgroundEnabled,
        link: isLinkEnabled,
        heading: isHeadingEnabled,
        button: isButtonEnabled,
        text: isTextEnabled
      },
      typography: {
        fontFamilies: {
          custom: customFontFamilies,
          default: defaultFontFamilies,
          theme: themeFontFamilies
        },
        fontSizes: {
          custom: customFontSizes,
          default: defaultFontSizes,
          theme: themeFontSizes
        },
        customFontSize,
        defaultFontSizes: defaultFontSizesEnabled,
        fontStyle,
        fontWeight,
        lineHeight,
        textAlign,
        textColumns,
        textDecoration,
        textTransform,
        letterSpacing,
        writingMode
      },
      spacing: {
        spacingSizes: {
          custom: userSpacingSizes,
          default: defaultSpacingSizes,
          theme: themeSpacingSizes
        },
        customSpacingSize,
        defaultSpacingSizes: defaultSpacingSizesEnabled,
        padding,
        margin,
        blockGap,
        units
      },
      border: {
        color: borderColor,
        radius: borderRadius,
        style: borderStyle,
        width: borderWidth,
        radiusSizes: borderRadiusSizes
      },
      dimensions: {
        aspectRatio,
        minHeight
      },
      layout,
      parentLayout,
      shadow
    };
  }, [
    backgroundImage,
    backgroundSize,
    customFontFamilies,
    defaultFontFamilies,
    themeFontFamilies,
    defaultFontSizesEnabled,
    customFontSizes,
    defaultFontSizes,
    themeFontSizes,
    customFontSize,
    fontStyle,
    fontWeight,
    lineHeight,
    textAlign,
    textColumns,
    textDecoration,
    textTransform,
    letterSpacing,
    writingMode,
    padding,
    margin,
    blockGap,
    defaultSpacingSizesEnabled,
    customSpacingSize,
    userSpacingSizes,
    defaultSpacingSizes,
    themeSpacingSizes,
    units,
    aspectRatio,
    minHeight,
    layout,
    parentLayout,
    borderColor,
    borderRadius,
    borderStyle,
    borderWidth,
    borderRadiusSizes,
    customColorsEnabled,
    customColors,
    customDuotone,
    themeColors,
    defaultColors,
    defaultPalette,
    defaultDuotone,
    userDuotonePalette,
    themeDuotonePalette,
    defaultDuotonePalette,
    userGradientPalette,
    themeGradientPalette,
    defaultGradientPalette,
    defaultGradients,
    areCustomGradientsEnabled,
    isBackgroundEnabled,
    isLinkEnabled,
    isTextEnabled,
    isHeadingEnabled,
    isButtonEnabled,
    shadow
  ]);
  return useSettingsForBlockElement(rawSettings, name);
}
function createBlockEditFilter(features) {
  features = features.map((settings) => {
    return { ...settings, Edit: (0,external_wp_element_namespaceObject.memo)(settings.edit) };
  });
  const withBlockEditHooks = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
    (OriginalBlockEdit) => (props) => {
      const context = useBlockEditContext();
      return [
        ...features.map((feature, i) => {
          const {
            Edit,
            hasSupport,
            attributeKeys = [],
            shareWithChildBlocks
          } = feature;
          const shouldDisplayControls = context[mayDisplayControlsKey] || context[mayDisplayParentControlsKey] && shareWithChildBlocks;
          if (!shouldDisplayControls || !hasSupport(props.name)) {
            return null;
          }
          const neededProps = {};
          for (const key of attributeKeys) {
            if (props.attributes[key]) {
              neededProps[key] = props.attributes[key];
            }
          }
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            Edit,
            {
              name: props.name,
              isSelected: props.isSelected,
              clientId: props.clientId,
              setAttributes: props.setAttributes,
              __unstableParentLayout: props.__unstableParentLayout,
              ...neededProps
            },
            i
          );
        }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(OriginalBlockEdit, { ...props }, "edit")
      ];
    },
    "withBlockEditHooks"
  );
  (0,external_wp_hooks_namespaceObject.addFilter)("editor.BlockEdit", "core/editor/hooks", withBlockEditHooks);
}
function BlockProps({
  index,
  useBlockProps: hook,
  setAllWrapperProps,
  ...props
}) {
  const wrapperProps = hook(props);
  const setWrapperProps = (next) => setAllWrapperProps((prev) => {
    const nextAll = [...prev];
    nextAll[index] = next;
    return nextAll;
  });
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setWrapperProps(wrapperProps);
    return () => {
      setWrapperProps(void 0);
    };
  });
  return null;
}
const BlockPropsPure = (0,external_wp_element_namespaceObject.memo)(BlockProps);
function createBlockListBlockFilter(features) {
  const withBlockListBlockHooks = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
    (BlockListBlock) => (props) => {
      const [allWrapperProps, setAllWrapperProps] = (0,external_wp_element_namespaceObject.useState)(
        Array(features.length).fill(void 0)
      );
      return [
        ...features.map((feature, i) => {
          const {
            hasSupport,
            attributeKeys = [],
            useBlockProps,
            isMatch
          } = feature;
          const neededProps = {};
          for (const key of attributeKeys) {
            if (props.attributes[key]) {
              neededProps[key] = props.attributes[key];
            }
          }
          if (
            // Skip rendering if none of the needed attributes are
            // set.
            !Object.keys(neededProps).length || !hasSupport(props.name) || isMatch && !isMatch(neededProps)
          ) {
            return null;
          }
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockPropsPure,
            {
              index: i,
              useBlockProps,
              setAllWrapperProps,
              name: props.name,
              clientId: props.clientId,
              ...neededProps
            },
            i
          );
        }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          BlockListBlock,
          {
            ...props,
            wrapperProps: allWrapperProps.filter(Boolean).reduce((acc, wrapperProps) => {
              return {
                ...acc,
                ...wrapperProps,
                className: dist_clsx(
                  acc.className,
                  wrapperProps.className
                ),
                style: {
                  ...acc.style,
                  ...wrapperProps.style
                }
              };
            }, props.wrapperProps || {})
          },
          "edit"
        )
      ];
    },
    "withBlockListBlockHooks"
  );
  (0,external_wp_hooks_namespaceObject.addFilter)(
    "editor.BlockListBlock",
    "core/editor/hooks",
    withBlockListBlockHooks
  );
}
function createBlockSaveFilter(features) {
  function extraPropsFromHooks(props, name, attributes) {
    return features.reduce((accu, feature) => {
      const { hasSupport, attributeKeys = [], addSaveProps } = feature;
      const neededAttributes = {};
      for (const key of attributeKeys) {
        if (attributes[key]) {
          neededAttributes[key] = attributes[key];
        }
      }
      if (
        // Skip rendering if none of the needed attributes are
        // set.
        !Object.keys(neededAttributes).length || !hasSupport(name)
      ) {
        return accu;
      }
      return addSaveProps(accu, name, neededAttributes);
    }, props);
  }
  (0,external_wp_hooks_namespaceObject.addFilter)(
    "blocks.getSaveContent.extraProps",
    "core/editor/hooks",
    extraPropsFromHooks,
    0
  );
  (0,external_wp_hooks_namespaceObject.addFilter)(
    "blocks.getSaveContent.extraProps",
    "core/editor/hooks",
    (props) => {
      if (props.hasOwnProperty("className") && !props.className) {
        delete props.className;
      }
      return props;
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/compat.js


function migrateLightBlockWrapper(settings) {
  const { apiVersion = 1 } = settings;
  if (apiVersion < 2 && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "lightBlockWrapper", false)) {
    settings.apiVersion = 2;
  }
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/compat/migrateLightBlockWrapper",
  migrateLightBlockWrapper
);

;// external ["wp","components"]
const external_wp_components_namespaceObject = window["wp"]["components"];
;// ./node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js

const BlockControlsDefault = (0,external_wp_components_namespaceObject.createSlotFill)("BlockControls");
const BlockControlsBlock = (0,external_wp_components_namespaceObject.createSlotFill)("BlockControlsBlock");
const BlockControlsInline = (0,external_wp_components_namespaceObject.createSlotFill)("BlockFormatControls");
const BlockControlsOther = (0,external_wp_components_namespaceObject.createSlotFill)("BlockControlsOther");
const BlockControlsParent = (0,external_wp_components_namespaceObject.createSlotFill)("BlockControlsParent");
const groups = {
  default: BlockControlsDefault,
  block: BlockControlsBlock,
  inline: BlockControlsInline,
  other: BlockControlsOther,
  parent: BlockControlsParent
};
var groups_default = groups;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-controls/hook.js


function useBlockControlsFill(group, shareWithChildBlocks) {
  const context = useBlockEditContext();
  if (context[mayDisplayControlsKey]) {
    return groups_default[group]?.Fill;
  }
  if (context[mayDisplayParentControlsKey] && shareWithChildBlocks) {
    return groups_default.parent.Fill;
  }
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js



function BlockControlsFill({
  group = "default",
  controls,
  children,
  __experimentalShareWithChildBlocks = false
}) {
  const Fill = useBlockControlsFill(
    group,
    __experimentalShareWithChildBlocks
  );
  if (!Fill) {
    return null;
  }
  const innerMarkup = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    group === "default" && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { controls }),
    children
  ] });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Fill, { children: (fillProps) => {
    const { forwardedContext = [] } = fillProps;
    return forwardedContext.reduce(
      (inner, [Provider, props]) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Provider, { ...props, children: inner }),
      innerMarkup
    );
  } }) });
}


;// external ["wp","warning"]
const external_wp_warning_namespaceObject = window["wp"]["warning"];
var external_wp_warning_default = /*#__PURE__*/__webpack_require__.n(external_wp_warning_namespaceObject);
;// ./node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js






const { ComponentsContext } = unlock(external_wp_components_namespaceObject.privateApis);
function BlockControlsSlot({ group = "default", ...props }) {
  const toolbarState = (0,external_wp_element_namespaceObject.useContext)(external_wp_components_namespaceObject.__experimentalToolbarContext);
  const contextState = (0,external_wp_element_namespaceObject.useContext)(ComponentsContext);
  const fillProps = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      forwardedContext: [
        [external_wp_components_namespaceObject.__experimentalToolbarContext.Provider, { value: toolbarState }],
        [ComponentsContext.Provider, { value: contextState }]
      ]
    }),
    [toolbarState, contextState]
  );
  const slotFill = groups_default[group];
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(slotFill.name);
  if (!slotFill) {
    external_wp_warning_default()(`Unknown BlockControls group "${group}" provided.`);
    return null;
  }
  if (!fills?.length) {
    return null;
  }
  const { Slot } = slotFill;
  const slot = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Slot, { ...props, bubblesVirtually: true, fillProps });
  if (group === "default") {
    return slot;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: slot });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js



const BlockControls = BlockControlsFill;
BlockControls.Slot = BlockControlsSlot;
const BlockFormatControls = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockControlsFill, { group: "inline", ...props });
};
BlockFormatControls.Slot = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockControlsSlot, { group: "inline", ...props });
};
var block_controls_default = BlockControls;


;// ./node_modules/@wordpress/icons/build-module/library/justify-left.js


var justify_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-center.js


var justify_center_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12.5 15v5H11v-5H4V9h7V4h1.5v5h7v6h-7Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-right.js


var justify_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-space-between.js


var justify_space_between_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-stretch.js


var justify_stretch_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4 4H5.5V20H4V4ZM7 10L17 10V14L7 14V10ZM20 4H18.5V20H20V4Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/arrow-right.js


var arrow_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/arrow-down.js


var arrow_down_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/layouts/definitions.js
const LAYOUT_DEFINITIONS = {
  default: {
    name: "default",
    slug: "flow",
    className: "is-layout-flow",
    baseStyles: [
      {
        selector: " > .alignleft",
        rules: {
          float: "left",
          "margin-inline-start": "0",
          "margin-inline-end": "2em"
        }
      },
      {
        selector: " > .alignright",
        rules: {
          float: "right",
          "margin-inline-start": "2em",
          "margin-inline-end": "0"
        }
      },
      {
        selector: " > .aligncenter",
        rules: {
          "margin-left": "auto !important",
          "margin-right": "auto !important"
        }
      }
    ],
    spacingStyles: [
      {
        selector: " > :first-child",
        rules: {
          "margin-block-start": "0"
        }
      },
      {
        selector: " > :last-child",
        rules: {
          "margin-block-end": "0"
        }
      },
      {
        selector: " > *",
        rules: {
          "margin-block-start": null,
          "margin-block-end": "0"
        }
      }
    ]
  },
  constrained: {
    name: "constrained",
    slug: "constrained",
    className: "is-layout-constrained",
    baseStyles: [
      {
        selector: " > .alignleft",
        rules: {
          float: "left",
          "margin-inline-start": "0",
          "margin-inline-end": "2em"
        }
      },
      {
        selector: " > .alignright",
        rules: {
          float: "right",
          "margin-inline-start": "2em",
          "margin-inline-end": "0"
        }
      },
      {
        selector: " > .aligncenter",
        rules: {
          "margin-left": "auto !important",
          "margin-right": "auto !important"
        }
      },
      {
        selector: " > :where(:not(.alignleft):not(.alignright):not(.alignfull))",
        rules: {
          "max-width": "var(--wp--style--global--content-size)",
          "margin-left": "auto !important",
          "margin-right": "auto !important"
        }
      },
      {
        selector: " > .alignwide",
        rules: {
          "max-width": "var(--wp--style--global--wide-size)"
        }
      }
    ],
    spacingStyles: [
      {
        selector: " > :first-child",
        rules: {
          "margin-block-start": "0"
        }
      },
      {
        selector: " > :last-child",
        rules: {
          "margin-block-end": "0"
        }
      },
      {
        selector: " > *",
        rules: {
          "margin-block-start": null,
          "margin-block-end": "0"
        }
      }
    ]
  },
  flex: {
    name: "flex",
    slug: "flex",
    className: "is-layout-flex",
    displayMode: "flex",
    baseStyles: [
      {
        selector: "",
        rules: {
          "flex-wrap": "wrap",
          "align-items": "center"
        }
      },
      {
        selector: " > :is(*, div)",
        // :is(*, div) instead of just * increases the specificity by 001.
        rules: {
          margin: "0"
        }
      }
    ],
    spacingStyles: [
      {
        selector: "",
        rules: {
          gap: null
        }
      }
    ]
  },
  grid: {
    name: "grid",
    slug: "grid",
    className: "is-layout-grid",
    displayMode: "grid",
    baseStyles: [
      {
        selector: " > :is(*, div)",
        // :is(*, div) instead of just * increases the specificity by 001.
        rules: {
          margin: "0"
        }
      }
    ],
    spacingStyles: [
      {
        selector: "",
        rules: {
          gap: null
        }
      }
    ]
  }
};


;// ./node_modules/@wordpress/block-editor/build-module/layouts/utils.js


function appendSelectors(selectors, append = "") {
  return selectors.split(",").map(
    (subselector) => `${subselector}${append ? ` ${append}` : ""}`
  ).join(",");
}
function getBlockGapCSS(selector, layoutDefinitions = LAYOUT_DEFINITIONS, layoutType, blockGapValue) {
  let output = "";
  if (layoutDefinitions?.[layoutType]?.spacingStyles?.length && blockGapValue) {
    layoutDefinitions[layoutType].spacingStyles.forEach((gapStyle) => {
      output += `${appendSelectors(
        selector,
        gapStyle.selector.trim()
      )} { `;
      output += Object.entries(gapStyle.rules).map(
        ([cssProperty, value]) => `${cssProperty}: ${value ? value : blockGapValue}`
      ).join("; ");
      output += "; }";
    });
  }
  return output;
}
function getAlignmentsInfo(layout) {
  const { contentSize, wideSize, type = "default" } = layout;
  const alignmentInfo = {};
  const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%|svw|lvw|dvw|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax)?$/i;
  if (sizeRegex.test(contentSize) && type === "constrained") {
    alignmentInfo.none = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)("Max %s wide"), contentSize);
  }
  if (sizeRegex.test(wideSize)) {
    alignmentInfo.wide = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)("Max %s wide"), wideSize);
  }
  return alignmentInfo;
}


;// ./node_modules/@wordpress/icons/build-module/library/sides-all.js


var sides_all_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/sides-horizontal.js


var sides_horizontal_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m4.5 7.5v9h1.5v-9z" }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m18 7.5v9h1.5v-9z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/sides-vertical.js


var sides_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m7.5 6h9v-1.5h-9z" }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m7.5 19.5h9v-1.5h-9z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/sides-top.js


var sides_top_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m16.5 6h-9v-1.5h9z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/sides-right.js


var sides_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m18 16.5v-9h1.5v9z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/sides-bottom.js


var sides_bottom_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m16.5 19.5h-9v-1.5h9z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/sides-left.js


var sides_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      d: "m7.5 6h9v-1.5h-9zm0 13.5h9v-1.5h-9zm-3-3h1.5v-9h-1.5zm13.5-9v9h1.5v-9z",
      style: { opacity: 0.25 }
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m4.5 16.5v-9h1.5v9z" })
] });


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/utils.js


const RANGE_CONTROL_MAX_SIZE = 8;
const ALL_SIDES = ["top", "right", "bottom", "left"];
const DEFAULT_VALUES = {
  top: void 0,
  right: void 0,
  bottom: void 0,
  left: void 0
};
const ICONS = {
  custom: sides_all_default,
  axial: sides_all_default,
  horizontal: sides_horizontal_default,
  vertical: sides_vertical_default,
  top: sides_top_default,
  right: sides_right_default,
  bottom: sides_bottom_default,
  left: sides_left_default
};
const LABELS = {
  default: (0,external_wp_i18n_namespaceObject.__)("Spacing control"),
  top: (0,external_wp_i18n_namespaceObject.__)("Top"),
  bottom: (0,external_wp_i18n_namespaceObject.__)("Bottom"),
  left: (0,external_wp_i18n_namespaceObject.__)("Left"),
  right: (0,external_wp_i18n_namespaceObject.__)("Right"),
  mixed: (0,external_wp_i18n_namespaceObject.__)("Mixed"),
  vertical: (0,external_wp_i18n_namespaceObject.__)("Vertical"),
  horizontal: (0,external_wp_i18n_namespaceObject.__)("Horizontal"),
  axial: (0,external_wp_i18n_namespaceObject.__)("Horizontal & vertical"),
  custom: (0,external_wp_i18n_namespaceObject.__)("Custom")
};
const VIEWS = {
  axial: "axial",
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left",
  custom: "custom"
};
function isValueSpacingPreset(value) {
  if (!value?.includes) {
    return false;
  }
  return value === "0" || value.includes("var:preset|spacing|");
}
function getCustomValueFromPreset(value, spacingSizes) {
  if (!isValueSpacingPreset(value)) {
    return value;
  }
  const slug = getSpacingPresetSlug(value);
  const spacingSize = spacingSizes.find(
    (size) => String(size.slug) === slug
  );
  return spacingSize?.size;
}
function getPresetValueFromCustomValue(value, spacingSizes) {
  if (!value || isValueSpacingPreset(value) || value === "0") {
    return value;
  }
  const spacingMatch = spacingSizes.find(
    (size) => String(size.size) === String(value)
  );
  if (spacingMatch?.slug) {
    return `var:preset|spacing|${spacingMatch.slug}`;
  }
  return value;
}
function getSpacingPresetCssVar(value) {
  if (!value) {
    return;
  }
  const slug = value.match(/var:preset\|spacing\|(.+)/);
  if (!slug) {
    return value;
  }
  return `var(--wp--preset--spacing--${slug[1]})`;
}
function getSpacingPresetSlug(value) {
  if (!value) {
    return;
  }
  if (value === "0" || value === "default") {
    return value;
  }
  const slug = value.match(/var:preset\|spacing\|(.+)/);
  return slug ? slug[1] : void 0;
}
function getSliderValueFromPreset(presetValue, spacingSizes) {
  if (presetValue === void 0) {
    return 0;
  }
  const slug = parseFloat(presetValue, 10) === 0 ? "0" : getSpacingPresetSlug(presetValue);
  const sliderValue = spacingSizes.findIndex((spacingSize) => {
    return String(spacingSize.slug) === slug;
  });
  return sliderValue !== -1 ? sliderValue : NaN;
}
function hasAxisSupport(sides, axis) {
  if (!sides || !sides.length) {
    return false;
  }
  const hasHorizontalSupport = sides.includes("horizontal") || sides.includes("left") && sides.includes("right");
  const hasVerticalSupport = sides.includes("vertical") || sides.includes("top") && sides.includes("bottom");
  if (axis === "horizontal") {
    return hasHorizontalSupport;
  }
  if (axis === "vertical") {
    return hasVerticalSupport;
  }
  return hasHorizontalSupport || hasVerticalSupport;
}
function hasBalancedSidesSupport(sides = []) {
  const counts = { top: 0, right: 0, bottom: 0, left: 0 };
  sides.forEach((side) => counts[side] += 1);
  return (counts.top + counts.bottom) % 2 === 0 && (counts.left + counts.right) % 2 === 0;
}
function getInitialView(values = {}, sides) {
  const { top, right, bottom, left } = values;
  const sideValues = [top, right, bottom, left].filter(Boolean);
  const hasMatchingAxialValues = top === bottom && left === right && (!!top || !!left);
  const hasNoValuesAndBalancedSides = !sideValues.length && hasBalancedSidesSupport(sides);
  const hasOnlyAxialSides = sides?.includes("horizontal") && sides?.includes("vertical") && sides?.length === 2;
  if (hasAxisSupport(sides) && (hasMatchingAxialValues || hasNoValuesAndBalancedSides)) {
    return VIEWS.axial;
  }
  if (hasOnlyAxialSides && sideValues.length === 1) {
    let side;
    Object.entries(values).some(([key, value]) => {
      side = key;
      return value !== void 0;
    });
    return side;
  }
  if (sides?.length === 1 && !sideValues.length) {
    return sides[0];
  }
  return VIEWS.custom;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/gap.js

function getGapBoxControlValueFromStyle(blockGapValue) {
  if (!blockGapValue) {
    return null;
  }
  const isValueString = typeof blockGapValue === "string";
  return {
    top: isValueString ? blockGapValue : blockGapValue?.top,
    left: isValueString ? blockGapValue : blockGapValue?.left
  };
}
function getGapCSSValue(blockGapValue, defaultValue = "0") {
  const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);
  if (!blockGapBoxControlValue) {
    return null;
  }
  const row = getSpacingPresetCssVar(blockGapBoxControlValue?.top) || defaultValue;
  const column = getSpacingPresetCssVar(blockGapBoxControlValue?.left) || defaultValue;
  return row === column ? row : `${row} ${column}`;
}


;// ./node_modules/@wordpress/icons/build-module/library/justify-top.js


var justify_top_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-center-vertical.js


var justify_center_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-bottom.js


var justify_bottom_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-stretch-vertical.js


var justify_stretch_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4 4L20 4L20 5.5L4 5.5L4 4ZM10 7L14 7L14 17L10 17L10 7ZM20 18.5L4 18.5L4 20L20 20L20 18.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/justify-space-between-vertical.js


var justify_space_between_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7 4H17V8L7 8V4ZM7 16L17 16V20L7 20V16ZM20 11.25H4V12.75H20V11.25Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js




const BLOCK_ALIGNMENTS_CONTROLS = {
  top: {
    icon: justify_top_default,
    title: (0,external_wp_i18n_namespaceObject._x)("Align top", "Block vertical alignment setting")
  },
  center: {
    icon: justify_center_vertical_default,
    title: (0,external_wp_i18n_namespaceObject._x)("Align middle", "Block vertical alignment setting")
  },
  bottom: {
    icon: justify_bottom_default,
    title: (0,external_wp_i18n_namespaceObject._x)("Align bottom", "Block vertical alignment setting")
  },
  stretch: {
    icon: justify_stretch_vertical_default,
    title: (0,external_wp_i18n_namespaceObject._x)("Stretch to fill", "Block vertical alignment setting")
  },
  "space-between": {
    icon: justify_space_between_vertical_default,
    title: (0,external_wp_i18n_namespaceObject._x)("Space between", "Block vertical alignment setting")
  }
};
const DEFAULT_CONTROLS = ["top", "center", "bottom"];
const DEFAULT_CONTROL = "top";
function BlockVerticalAlignmentUI({
  value,
  onChange,
  controls = DEFAULT_CONTROLS,
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? void 0 : align);
  }
  const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? { isCollapsed } : {};
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    UIComponent,
    {
      icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
      label: (0,external_wp_i18n_namespaceObject._x)(
        "Change vertical alignment",
        "Block vertical alignment setting label"
      ),
      controls: controls.map((control) => {
        return {
          ...BLOCK_ALIGNMENTS_CONTROLS[control],
          isActive: value === control,
          role: isCollapsed ? "menuitemradio" : void 0,
          onClick: applyOrUnset(control)
        };
      }),
      ...extraProps
    }
  );
}
var ui_default = BlockVerticalAlignmentUI;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js


const BlockVerticalAlignmentControl = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ui_default, { ...props, isToolbar: false });
};
const BlockVerticalAlignmentToolbar = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ui_default, { ...props, isToolbar: true });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js




const icons = {
  left: justify_left_default,
  center: justify_center_default,
  right: justify_right_default,
  "space-between": justify_space_between_default,
  stretch: justify_stretch_default
};
function JustifyContentUI({
  allowedControls = ["left", "center", "right", "space-between"],
  isCollapsed = true,
  onChange,
  value,
  popoverProps,
  isToolbar
}) {
  const handleClick = (next) => {
    if (next === value) {
      onChange(void 0);
    } else {
      onChange(next);
    }
  };
  const icon = value ? icons[value] : icons.left;
  const allControls = [
    {
      name: "left",
      icon: justify_left_default,
      title: (0,external_wp_i18n_namespaceObject.__)("Justify items left"),
      isActive: "left" === value,
      onClick: () => handleClick("left")
    },
    {
      name: "center",
      icon: justify_center_default,
      title: (0,external_wp_i18n_namespaceObject.__)("Justify items center"),
      isActive: "center" === value,
      onClick: () => handleClick("center")
    },
    {
      name: "right",
      icon: justify_right_default,
      title: (0,external_wp_i18n_namespaceObject.__)("Justify items right"),
      isActive: "right" === value,
      onClick: () => handleClick("right")
    },
    {
      name: "space-between",
      icon: justify_space_between_default,
      title: (0,external_wp_i18n_namespaceObject.__)("Space between items"),
      isActive: "space-between" === value,
      onClick: () => handleClick("space-between")
    },
    {
      name: "stretch",
      icon: justify_stretch_default,
      title: (0,external_wp_i18n_namespaceObject.__)("Stretch items"),
      isActive: "stretch" === value,
      onClick: () => handleClick("stretch")
    }
  ];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? { isCollapsed } : {};
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    UIComponent,
    {
      icon,
      popoverProps,
      label: (0,external_wp_i18n_namespaceObject.__)("Change items justification"),
      controls: allControls.filter(
        (elem) => allowedControls.includes(elem.name)
      ),
      ...extraProps
    }
  );
}
var ui_ui_default = JustifyContentUI;


;// ./node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js


const JustifyContentControl = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ui_ui_default, { ...props, isToolbar: false });
};
const JustifyToolbar = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ui_ui_default, { ...props, isToolbar: true });
};


;// ./node_modules/@wordpress/block-editor/build-module/layouts/flex.js









const justifyContentMap = {
  left: "flex-start",
  right: "flex-end",
  center: "center",
  "space-between": "space-between"
};
const alignItemsMap = {
  left: "flex-start",
  right: "flex-end",
  center: "center",
  stretch: "stretch"
};
const verticalAlignmentMap = {
  top: "flex-start",
  center: "center",
  bottom: "flex-end",
  stretch: "stretch",
  "space-between": "space-between"
};
const defaultAlignments = {
  horizontal: "center",
  vertical: "top"
};
const flexWrapOptions = ["wrap", "nowrap"];
var flex_default = {
  name: "flex",
  label: (0,external_wp_i18n_namespaceObject.__)("Flex"),
  inspectorControls: function FlexLayoutInspectorControls({
    layout = {},
    onChange,
    layoutBlockSupport = {}
  }) {
    const { allowOrientation = true, allowJustification = true } = layoutBlockSupport;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Flex, { children: [
        allowJustification && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          FlexLayoutJustifyContentControl,
          {
            layout,
            onChange
          }
        ) }),
        allowOrientation && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          OrientationControl,
          {
            layout,
            onChange
          }
        ) })
      ] }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(FlexWrapControl, { layout, onChange })
    ] });
  },
  toolBarControls: function FlexLayoutToolbarControls({
    layout = {},
    onChange,
    layoutBlockSupport
  }) {
    const { allowVerticalAlignment = true, allowJustification = true } = layoutBlockSupport;
    if (!allowJustification && !allowVerticalAlignment) {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: [
      allowJustification && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        FlexLayoutJustifyContentControl,
        {
          layout,
          onChange,
          isToolbar: true
        }
      ),
      allowVerticalAlignment && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        FlexLayoutVerticalAlignmentControl,
        {
          layout,
          onChange
        }
      )
    ] });
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const { orientation = "horizontal" } = layout;
    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, "spacing", "blockGap") ? getGapCSSValue(style?.spacing?.blockGap, "0.5em") : void 0;
    const justifyContent = justifyContentMap[layout.justifyContent];
    const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : "wrap";
    const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
    const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
    let output = "";
    const rules = [];
    if (flexWrap && flexWrap !== "wrap") {
      rules.push(`flex-wrap: ${flexWrap}`);
    }
    if (orientation === "horizontal") {
      if (verticalAlignment) {
        rules.push(`align-items: ${verticalAlignment}`);
      }
      if (justifyContent) {
        rules.push(`justify-content: ${justifyContent}`);
      }
    } else {
      if (verticalAlignment) {
        rules.push(`justify-content: ${verticalAlignment}`);
      }
      rules.push("flex-direction: column");
      rules.push(`align-items: ${alignItems}`);
    }
    if (rules.length) {
      output = `${appendSelectors(selector)} {
				${rules.join("; ")};
			}`;
    }
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(
        selector,
        layoutDefinitions,
        "flex",
        blockGapValue
      );
    }
    return output;
  },
  getOrientation(layout) {
    const { orientation = "horizontal" } = layout;
    return orientation;
  },
  getAlignments() {
    return [];
  }
};
function FlexLayoutVerticalAlignmentControl({ layout, onChange }) {
  const { orientation = "horizontal" } = layout;
  const defaultVerticalAlignment = orientation === "horizontal" ? defaultAlignments.horizontal : defaultAlignments.vertical;
  const { verticalAlignment = defaultVerticalAlignment } = layout;
  const onVerticalAlignmentChange = (value) => {
    onChange({
      ...layout,
      verticalAlignment: value
    });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockVerticalAlignmentControl,
    {
      onChange: onVerticalAlignmentChange,
      value: verticalAlignment,
      controls: orientation === "horizontal" ? ["top", "center", "bottom", "stretch"] : ["top", "center", "bottom", "space-between"]
    }
  );
}
const POPOVER_PROPS = {
  placement: "bottom-start"
};
function FlexLayoutJustifyContentControl({
  layout,
  onChange,
  isToolbar = false
}) {
  const { justifyContent = "left", orientation = "horizontal" } = layout;
  const onJustificationChange = (value) => {
    onChange({
      ...layout,
      justifyContent: value
    });
  };
  const allowedControls = ["left", "center", "right"];
  if (orientation === "horizontal") {
    allowedControls.push("space-between");
  } else {
    allowedControls.push("stretch");
  }
  if (isToolbar) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      JustifyContentControl,
      {
        allowedControls,
        value: justifyContent,
        onChange: onJustificationChange,
        popoverProps: POPOVER_PROPS
      }
    );
  }
  const justificationOptions = [
    {
      value: "left",
      icon: justify_left_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Justify items left")
    },
    {
      value: "center",
      icon: justify_center_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Justify items center")
    },
    {
      value: "right",
      icon: justify_right_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Justify items right")
    }
  ];
  if (orientation === "horizontal") {
    justificationOptions.push({
      value: "space-between",
      icon: justify_space_between_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Space between items")
    });
  } else {
    justificationOptions.push({
      value: "stretch",
      icon: justify_stretch_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Stretch items")
    });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      __next40pxDefaultSize: true,
      __nextHasNoMarginBottom: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Justification"),
      value: justifyContent,
      onChange: onJustificationChange,
      className: "block-editor-hooks__flex-layout-justification-controls",
      children: justificationOptions.map(({ value, icon, label }) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            value,
            icon,
            label
          },
          value
        );
      })
    }
  );
}
function FlexWrapControl({ layout, onChange }) {
  const { flexWrap = "wrap" } = layout;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToggleControl,
    {
      __nextHasNoMarginBottom: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Allow to wrap to multiple lines"),
      onChange: (value) => {
        onChange({
          ...layout,
          flexWrap: value ? "wrap" : "nowrap"
        });
      },
      checked: flexWrap === "wrap"
    }
  );
}
function OrientationControl({ layout, onChange }) {
  const {
    orientation = "horizontal",
    verticalAlignment,
    justifyContent
  } = layout;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      __next40pxDefaultSize: true,
      __nextHasNoMarginBottom: true,
      className: "block-editor-hooks__flex-layout-orientation-controls",
      label: (0,external_wp_i18n_namespaceObject.__)("Orientation"),
      value: orientation,
      onChange: (value) => {
        let newVerticalAlignment = verticalAlignment;
        let newJustification = justifyContent;
        if (value === "horizontal") {
          if (verticalAlignment === "space-between") {
            newVerticalAlignment = "center";
          }
          if (justifyContent === "stretch") {
            newJustification = "left";
          }
        } else {
          if (verticalAlignment === "stretch") {
            newVerticalAlignment = "top";
          }
          if (justifyContent === "space-between") {
            newJustification = "left";
          }
        }
        return onChange({
          ...layout,
          orientation: value,
          verticalAlignment: newVerticalAlignment,
          justifyContent: newJustification
        });
      },
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            icon: arrow_right_default,
            value: "horizontal",
            label: (0,external_wp_i18n_namespaceObject.__)("Horizontal")
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            icon: arrow_down_default,
            value: "vertical",
            label: (0,external_wp_i18n_namespaceObject.__)("Vertical")
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/layouts/flow.js





var flow_default = {
  name: "default",
  label: (0,external_wp_i18n_namespaceObject.__)("Flow"),
  inspectorControls: function DefaultLayoutInspectorControls() {
    return null;
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);
    let blockGapValue = "";
    if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === "string") {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }
    let output = "";
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(
        selector,
        layoutDefinitions,
        "default",
        blockGapValue
      );
    }
    return output;
  },
  getOrientation() {
    return "vertical";
  },
  getAlignments(layout, isBlockBasedTheme) {
    const alignmentInfo = getAlignmentsInfo(layout);
    if (layout.alignments !== void 0) {
      if (!layout.alignments.includes("none")) {
        layout.alignments.unshift("none");
      }
      return layout.alignments.map((alignment) => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }
    const alignments = [
      { name: "left" },
      { name: "center" },
      { name: "right" }
    ];
    if (!isBlockBasedTheme) {
      const { contentSize, wideSize } = layout;
      if (contentSize) {
        alignments.unshift({ name: "full" });
      }
      if (wideSize) {
        alignments.unshift({
          name: "wide",
          info: alignmentInfo.wide
        });
      }
    }
    alignments.unshift({ name: "none", info: alignmentInfo.none });
    return alignments;
  }
};


;// ./node_modules/@wordpress/icons/build-module/icon/index.js

var icon_default = (0,external_wp_element_namespaceObject.forwardRef)(
  ({ icon, size = 24, ...props }, ref) => {
    return (0,external_wp_element_namespaceObject.cloneElement)(icon, {
      width: size,
      height: size,
      ...props,
      ref
    });
  }
);


;// ./node_modules/@wordpress/icons/build-module/library/align-none.js


var align_none_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM5 9h14v6H5V9Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/stretch-wide.js


var stretch_wide_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M16 5.5H8V4h8v1.5ZM16 20H8v-1.5h8V20ZM5 9h14v6H5V9Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/layouts/constrained.js











var constrained_default = {
  name: "constrained",
  label: (0,external_wp_i18n_namespaceObject.__)("Constrained"),
  inspectorControls: function DefaultLayoutInspectorControls({
    layout,
    onChange,
    layoutBlockSupport = {}
  }) {
    const { wideSize, contentSize, justifyContent = "center" } = layout;
    const {
      allowJustification = true,
      allowCustomContentAndWideSize = true
    } = layoutBlockSupport;
    const onJustificationChange = (value) => {
      onChange({
        ...layout,
        justifyContent: value
      });
    };
    const justificationOptions = [
      {
        value: "left",
        icon: justify_left_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Justify items left")
      },
      {
        value: "center",
        icon: justify_center_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Justify items center")
      },
      {
        value: "right",
        icon: justify_right_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Justify items right")
      }
    ];
    const [availableUnits] = use_settings_useSettings("spacing.units");
    const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
      availableUnits: availableUnits || ["%", "px", "em", "rem", "vw"]
    });
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.__experimentalVStack,
      {
        spacing: 4,
        className: "block-editor-hooks__layout-constrained",
        children: [
          allowCustomContentAndWideSize && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalUnitControl,
              {
                __next40pxDefaultSize: true,
                label: (0,external_wp_i18n_namespaceObject.__)("Content width"),
                labelPosition: "top",
                value: contentSize || wideSize || "",
                onChange: (nextWidth) => {
                  nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
                  onChange({
                    ...layout,
                    contentSize: nextWidth
                  });
                },
                units,
                prefix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: align_none_default }) })
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalUnitControl,
              {
                __next40pxDefaultSize: true,
                label: (0,external_wp_i18n_namespaceObject.__)("Wide width"),
                labelPosition: "top",
                value: wideSize || contentSize || "",
                onChange: (nextWidth) => {
                  nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
                  onChange({
                    ...layout,
                    wideSize: nextWidth
                  });
                },
                units,
                prefix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: stretch_wide_default }) })
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-hooks__layout-constrained-helptext", children: (0,external_wp_i18n_namespaceObject.__)(
              "Customize the width for all elements that are assigned to the center or wide columns."
            ) })
          ] }),
          allowJustification && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalToggleGroupControl,
            {
              __next40pxDefaultSize: true,
              __nextHasNoMarginBottom: true,
              label: (0,external_wp_i18n_namespaceObject.__)("Justification"),
              value: justifyContent,
              onChange: onJustificationChange,
              children: justificationOptions.map(
                ({ value, icon, label }) => {
                  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
                    {
                      value,
                      icon,
                      label
                    },
                    value
                  );
                }
              )
            }
          )
        ]
      }
    );
  },
  toolBarControls: function DefaultLayoutToolbarControls({
    layout = {},
    onChange,
    layoutBlockSupport
  }) {
    const { allowJustification = true } = layoutBlockSupport;
    if (!allowJustification) {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      DefaultLayoutJustifyContentControl,
      {
        layout,
        onChange
      }
    ) });
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout = {},
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const { contentSize, wideSize, justifyContent } = layout;
    const blockGapStyleValue = getGapCSSValue(style?.spacing?.blockGap);
    let blockGapValue = "";
    if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
      if (blockGapStyleValue?.top) {
        blockGapValue = getGapCSSValue(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === "string") {
        blockGapValue = getGapCSSValue(blockGapStyleValue);
      }
    }
    const marginLeft = justifyContent === "left" ? "0 !important" : "auto !important";
    const marginRight = justifyContent === "right" ? "0 !important" : "auto !important";
    let output = !!contentSize || !!wideSize ? `
					${appendSelectors(
      selector,
      "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
    )} {
						max-width: ${contentSize ?? wideSize};
						margin-left: ${marginLeft};
						margin-right: ${marginRight};
					}
					${appendSelectors(selector, "> .alignwide")}  {
						max-width: ${wideSize ?? contentSize};
					}
					${appendSelectors(selector, "> .alignfull")} {
						max-width: none;
					}
				` : "";
    if (justifyContent === "left") {
      output += `${appendSelectors(
        selector,
        "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
      )}
			{ margin-left: ${marginLeft}; }`;
    } else if (justifyContent === "right") {
      output += `${appendSelectors(
        selector,
        "> :where(:not(.alignleft):not(.alignright):not(.alignfull))"
      )}
			{ margin-right: ${marginRight}; }`;
    }
    if (style?.spacing?.padding) {
      const paddingValues = (0,external_wp_styleEngine_namespaceObject.getCSSRules)(style);
      paddingValues.forEach((rule) => {
        if (rule.key === "paddingRight") {
          const paddingRightValue = rule.value === "0" ? "0px" : rule.value;
          output += `
					${appendSelectors(selector, "> .alignfull")} {
						margin-right: calc(${paddingRightValue} * -1);
					}
					`;
        } else if (rule.key === "paddingLeft") {
          const paddingLeftValue = rule.value === "0" ? "0px" : rule.value;
          output += `
					${appendSelectors(selector, "> .alignfull")} {
						margin-left: calc(${paddingLeftValue} * -1);
					}
					`;
        }
      });
    }
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(
        selector,
        layoutDefinitions,
        "constrained",
        blockGapValue
      );
    }
    return output;
  },
  getOrientation() {
    return "vertical";
  },
  getAlignments(layout) {
    const alignmentInfo = getAlignmentsInfo(layout);
    if (layout.alignments !== void 0) {
      if (!layout.alignments.includes("none")) {
        layout.alignments.unshift("none");
      }
      return layout.alignments.map((alignment) => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }
    const { contentSize, wideSize } = layout;
    const alignments = [
      { name: "left" },
      { name: "center" },
      { name: "right" }
    ];
    if (contentSize) {
      alignments.unshift({ name: "full" });
    }
    if (wideSize) {
      alignments.unshift({ name: "wide", info: alignmentInfo.wide });
    }
    alignments.unshift({ name: "none", info: alignmentInfo.none });
    return alignments;
  }
};
const constrained_POPOVER_PROPS = {
  placement: "bottom-start"
};
function DefaultLayoutJustifyContentControl({ layout, onChange }) {
  const { justifyContent = "center" } = layout;
  const onJustificationChange = (value) => {
    onChange({
      ...layout,
      justifyContent: value
    });
  };
  const allowedControls = ["left", "center", "right"];
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    JustifyContentControl,
    {
      allowedControls,
      value: justifyContent,
      onChange: onJustificationChange,
      popoverProps: constrained_POPOVER_PROPS
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/layouts/grid.js








const RANGE_CONTROL_MAX_VALUES = {
  px: 600,
  "%": 100,
  vw: 100,
  vh: 100,
  em: 38,
  rem: 38,
  svw: 100,
  lvw: 100,
  dvw: 100,
  svh: 100,
  lvh: 100,
  dvh: 100,
  vi: 100,
  svi: 100,
  lvi: 100,
  dvi: 100,
  vb: 100,
  svb: 100,
  lvb: 100,
  dvb: 100,
  vmin: 100,
  svmin: 100,
  lvmin: 100,
  dvmin: 100,
  vmax: 100,
  svmax: 100,
  lvmax: 100,
  dvmax: 100
};
const units = [
  { value: "px", label: "px", default: 0 },
  { value: "rem", label: "rem", default: 0 },
  { value: "em", label: "em", default: 0 }
];
var grid_default = {
  name: "grid",
  label: (0,external_wp_i18n_namespaceObject.__)("Grid"),
  inspectorControls: function GridLayoutInspectorControls({
    layout = {},
    onChange,
    layoutBlockSupport = {}
  }) {
    const { allowSizingOnChildren = false } = layoutBlockSupport;
    const showColumnsControl = window.__experimentalEnableGridInteractivity || !!layout?.columnCount;
    const showMinWidthControl = window.__experimentalEnableGridInteractivity || !layout?.columnCount;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        GridLayoutTypeControl,
        {
          layout,
          onChange
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 4, children: [
        showColumnsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          GridLayoutColumnsAndRowsControl,
          {
            layout,
            onChange,
            allowSizingOnChildren
          }
        ),
        showMinWidthControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          GridLayoutMinimumWidthControl,
          {
            layout,
            onChange
          }
        )
      ] })
    ] });
  },
  toolBarControls: function GridLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    layout,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = LAYOUT_DEFINITIONS
  }) {
    const {
      minimumColumnWidth = null,
      columnCount = null,
      rowCount = null
    } = layout;
    if (false) {}
    const blockGapValue = style?.spacing?.blockGap && !shouldSkipSerialization(blockName, "spacing", "blockGap") ? getGapCSSValue(style?.spacing?.blockGap, "0.5em") : void 0;
    let output = "";
    const rules = [];
    if (minimumColumnWidth && columnCount > 0) {
      const maxValue = `max(${minimumColumnWidth}, ( 100% - (${blockGapValue || "1.2rem"}*${columnCount - 1}) ) / ${columnCount})`;
      rules.push(
        `grid-template-columns: repeat(auto-fill, minmax(${maxValue}, 1fr))`,
        `container-type: inline-size`
      );
      if (rowCount) {
        rules.push(
          `grid-template-rows: repeat(${rowCount}, minmax(1rem, auto))`
        );
      }
    } else if (columnCount) {
      rules.push(
        `grid-template-columns: repeat(${columnCount}, minmax(0, 1fr))`
      );
      if (rowCount) {
        rules.push(
          `grid-template-rows: repeat(${rowCount}, minmax(1rem, auto))`
        );
      }
    } else {
      rules.push(
        `grid-template-columns: repeat(auto-fill, minmax(min(${minimumColumnWidth || "12rem"}, 100%), 1fr))`,
        "container-type: inline-size"
      );
    }
    if (rules.length) {
      output = `${appendSelectors(selector)} { ${rules.join(
        "; "
      )}; }`;
    }
    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(
        selector,
        layoutDefinitions,
        "grid",
        blockGapValue
      );
    }
    return output;
  },
  getOrientation() {
    return "horizontal";
  },
  getAlignments() {
    return [];
  }
};
function GridLayoutMinimumWidthControl({ layout, onChange }) {
  const { minimumColumnWidth, columnCount, isManualPlacement } = layout;
  const defaultValue = isManualPlacement || columnCount ? null : "12rem";
  const value = minimumColumnWidth || defaultValue;
  const [quantity, unit = "rem"] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value);
  const handleSliderChange = (next) => {
    onChange({
      ...layout,
      minimumColumnWidth: [next, unit].join("")
    });
  };
  const handleUnitChange = (newUnit) => {
    let newValue;
    if (["em", "rem"].includes(newUnit) && unit === "px") {
      newValue = (quantity / 16).toFixed(2) + newUnit;
    } else if (["em", "rem"].includes(unit) && newUnit === "px") {
      newValue = Math.round(quantity * 16) + newUnit;
    }
    onChange({
      ...layout,
      minimumColumnWidth: newValue
    });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-hooks__grid-layout-minimum-width-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Minimum column width") }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Flex, { gap: 4, children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalUnitControl,
        {
          size: "__unstable-large",
          onChange: (newValue) => {
            onChange({
              ...layout,
              minimumColumnWidth: newValue === "" ? void 0 : newValue
            });
          },
          onUnitChange: handleUnitChange,
          value,
          units,
          min: 0,
          label: (0,external_wp_i18n_namespaceObject.__)("Minimum column width"),
          hideLabelFromVision: true
        }
      ) }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          onChange: handleSliderChange,
          value: quantity || 0,
          min: 0,
          max: RANGE_CONTROL_MAX_VALUES[unit] || 600,
          withInputField: false,
          label: (0,external_wp_i18n_namespaceObject.__)("Minimum column width"),
          hideLabelFromVision: true
        }
      ) })
    ] })
  ] });
}
function GridLayoutColumnsAndRowsControl({
  layout,
  onChange,
  allowSizingOnChildren
}) {
  const defaultColumnCount = window.__experimentalEnableGridInteractivity ? void 0 : 3;
  const {
    columnCount = defaultColumnCount,
    rowCount,
    isManualPlacement
  } = layout;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-hooks__grid-layout-columns-and-rows-controls", children: [
    (!window.__experimentalEnableGridInteractivity || !isManualPlacement) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Columns") }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Flex, { gap: 4, children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalNumberControl,
        {
          size: "__unstable-large",
          onChange: (value) => {
            if (window.__experimentalEnableGridInteractivity) {
              const defaultNewColumnCount = isManualPlacement ? 1 : void 0;
              const newColumnCount = value === "" || value === "0" ? defaultNewColumnCount : parseInt(value, 10);
              onChange({
                ...layout,
                columnCount: newColumnCount
              });
            } else {
              const newColumnCount = value === "" || value === "0" ? 1 : parseInt(value, 10);
              onChange({
                ...layout,
                columnCount: newColumnCount
              });
            }
          },
          value: columnCount,
          min: 1,
          label: (0,external_wp_i18n_namespaceObject.__)("Columns"),
          hideLabelFromVision: !window.__experimentalEnableGridInteractivity || !isManualPlacement
        }
      ) }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: window.__experimentalEnableGridInteractivity && allowSizingOnChildren && isManualPlacement ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalNumberControl,
        {
          size: "__unstable-large",
          onChange: (value) => {
            const newRowCount = value === "" || value === "0" ? 1 : parseInt(value, 10);
            onChange({
              ...layout,
              rowCount: newRowCount
            });
          },
          value: rowCount,
          min: 1,
          label: (0,external_wp_i18n_namespaceObject.__)("Rows")
        }
      ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          value: columnCount ?? 1,
          onChange: (value) => onChange({
            ...layout,
            columnCount: value === "" || value === "0" ? 1 : value
          }),
          min: 1,
          max: 16,
          withInputField: false,
          label: (0,external_wp_i18n_namespaceObject.__)("Columns"),
          hideLabelFromVision: true
        }
      ) })
    ] })
  ] }) });
}
function GridLayoutTypeControl({ layout, onChange }) {
  const { columnCount, rowCount, minimumColumnWidth, isManualPlacement } = layout;
  const [tempColumnCount, setTempColumnCount] = (0,external_wp_element_namespaceObject.useState)(
    columnCount || 3
  );
  const [tempRowCount, setTempRowCount] = (0,external_wp_element_namespaceObject.useState)(rowCount);
  const [tempMinimumColumnWidth, setTempMinimumColumnWidth] = (0,external_wp_element_namespaceObject.useState)(
    minimumColumnWidth || "12rem"
  );
  const gridPlacement = isManualPlacement || !!columnCount && !window.__experimentalEnableGridInteractivity ? "manual" : "auto";
  const onChangeType = (value) => {
    if (value === "manual") {
      setTempMinimumColumnWidth(minimumColumnWidth || "12rem");
    } else {
      setTempColumnCount(columnCount || 3);
      setTempRowCount(rowCount);
    }
    onChange({
      ...layout,
      columnCount: value === "manual" ? tempColumnCount : null,
      rowCount: value === "manual" && window.__experimentalEnableGridInteractivity ? tempRowCount : void 0,
      isManualPlacement: value === "manual" && window.__experimentalEnableGridInteractivity ? true : void 0,
      minimumColumnWidth: value === "auto" ? tempMinimumColumnWidth : null
    });
  };
  const helpText = gridPlacement === "manual" ? (0,external_wp_i18n_namespaceObject.__)(
    "Grid items can be manually placed in any position on the grid."
  ) : (0,external_wp_i18n_namespaceObject.__)(
    "Grid items are placed automatically depending on their order."
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      __next40pxDefaultSize: true,
      __nextHasNoMarginBottom: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Grid item position"),
      value: gridPlacement,
      onChange: onChangeType,
      isBlock: true,
      help: window.__experimentalEnableGridInteractivity ? helpText : void 0,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
          {
            value: "auto",
            label: (0,external_wp_i18n_namespaceObject.__)("Auto")
          },
          "auto"
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
          {
            value: "manual",
            label: (0,external_wp_i18n_namespaceObject.__)("Manual")
          },
          "manual"
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/layouts/index.js




const layoutTypes = [flow_default, flex_default, constrained_default, grid_default];
function getLayoutType(name = "default") {
  return layoutTypes.find((layoutType) => layoutType.name === name);
}
function getLayoutTypes() {
  return layoutTypes;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js




const defaultLayout = { type: "default" };
const Layout = (0,external_wp_element_namespaceObject.createContext)(defaultLayout);
Layout.displayName = "BlockLayoutContext";
const LayoutProvider = Layout.Provider;
function useLayout() {
  return (0,external_wp_element_namespaceObject.useContext)(Layout);
}
function LayoutStyle({ layout = {}, css, ...props }) {
  const layoutType = getLayoutType(layout.type);
  const [blockGapSupport] = use_settings_useSettings("spacing.blockGap");
  const hasBlockGapSupport = blockGapSupport !== null;
  if (layoutType) {
    if (css) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("style", { children: css });
    }
    const layoutStyle = layoutType.getLayoutStyle?.({
      hasBlockGapSupport,
      layout,
      ...props
    });
    if (layoutStyle) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("style", { children: layoutStyle });
    }
  }
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/use-available-alignments.js




const use_available_alignments_EMPTY_ARRAY = [];
const use_available_alignments_DEFAULT_CONTROLS = ["none", "left", "center", "right", "wide", "full"];
const WIDE_CONTROLS = ["wide", "full"];
function useAvailableAlignments(controls = use_available_alignments_DEFAULT_CONTROLS) {
  if (!controls.includes("none")) {
    controls = ["none", ...controls];
  }
  const isNoneOnly = controls.length === 1 && controls[0] === "none";
  const [wideControlsEnabled, themeSupportsLayout, isBlockBasedTheme] = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (isNoneOnly) {
        return [false, false, false];
      }
      const settings = select(store).getSettings();
      return [
        settings.alignWide ?? false,
        settings.supportsLayout,
        settings.__unstableIsBlockBasedTheme
      ];
    },
    [isNoneOnly]
  );
  const layout = useLayout();
  if (isNoneOnly) {
    return use_available_alignments_EMPTY_ARRAY;
  }
  const layoutType = getLayoutType(layout?.type);
  if (themeSupportsLayout) {
    const layoutAlignments = layoutType.getAlignments(
      layout,
      isBlockBasedTheme
    );
    const alignments2 = layoutAlignments.filter(
      (alignment) => controls.includes(alignment.name)
    );
    if (alignments2.length === 1 && alignments2[0].name === "none") {
      return use_available_alignments_EMPTY_ARRAY;
    }
    return alignments2;
  }
  if (layoutType.name !== "default" && layoutType.name !== "constrained") {
    return use_available_alignments_EMPTY_ARRAY;
  }
  const alignments = controls.filter((control) => {
    if (layout.alignments) {
      return layout.alignments.includes(control);
    }
    if (!wideControlsEnabled && WIDE_CONTROLS.includes(control)) {
      return false;
    }
    return use_available_alignments_DEFAULT_CONTROLS.includes(control);
  }).map((name) => ({ name }));
  if (alignments.length === 1 && alignments[0].name === "none") {
    return use_available_alignments_EMPTY_ARRAY;
  }
  return alignments;
}


;// ./node_modules/@wordpress/icons/build-module/library/position-left.js


var position_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5 5.5h8V4H5v1.5ZM5 20h8v-1.5H5V20ZM19 9H5v6h14V9Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/position-center.js


var position_center_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM7 9h10v6H7V9Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/position-right.js


var position_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 5.5h-8V4h8v1.5ZM19 20h-8v-1.5h8V20ZM5 9h14v6H5V9Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/stretch-full-width.js


var stretch_full_width_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5 4h14v11H5V4Zm11 16H8v-1.5h8V20Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/constants.js


const constants_BLOCK_ALIGNMENTS_CONTROLS = {
  none: {
    icon: align_none_default,
    title: (0,external_wp_i18n_namespaceObject._x)("None", "Alignment option")
  },
  left: {
    icon: position_left_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align left")
  },
  center: {
    icon: position_center_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align center")
  },
  right: {
    icon: position_right_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align right")
  },
  wide: {
    icon: stretch_wide_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Wide width")
  },
  full: {
    icon: stretch_full_width_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Full width")
  }
};
const constants_DEFAULT_CONTROL = "none";


;// ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/ui.js






function BlockAlignmentUI({
  value,
  onChange,
  controls,
  isToolbar,
  isCollapsed = true
}) {
  const enabledControls = useAvailableAlignments(controls);
  const hasEnabledControls = !!enabledControls.length;
  if (!hasEnabledControls) {
    return null;
  }
  function onChangeAlignment(align) {
    onChange([value, "none"].includes(align) ? void 0 : align);
  }
  const activeAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[constants_DEFAULT_CONTROL];
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const commonProps = {
    icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
    label: (0,external_wp_i18n_namespaceObject.__)("Align")
  };
  const extraProps = isToolbar ? {
    isCollapsed,
    controls: enabledControls.map(({ name: controlName }) => {
      return {
        ...constants_BLOCK_ALIGNMENTS_CONTROLS[controlName],
        isActive: value === controlName || !value && controlName === "none",
        role: isCollapsed ? "menuitemradio" : void 0,
        onClick: () => onChangeAlignment(controlName)
      };
    })
  } : {
    toggleProps: { description: (0,external_wp_i18n_namespaceObject.__)("Change alignment") },
    children: ({ onClose }) => {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { className: "block-editor-block-alignment-control__menu-group", children: enabledControls.map(
        ({ name: controlName, info }) => {
          const { icon, title } = constants_BLOCK_ALIGNMENTS_CONTROLS[controlName];
          const isSelected = controlName === value || !value && controlName === "none";
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.MenuItem,
            {
              icon,
              iconPosition: "left",
              className: dist_clsx(
                "components-dropdown-menu__menu-item",
                {
                  "is-active": isSelected
                }
              ),
              isSelected,
              onClick: () => {
                onChangeAlignment(
                  controlName
                );
                onClose();
              },
              role: "menuitemradio",
              info,
              children: title
            },
            controlName
          );
        }
      ) }) });
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(UIComponent, { ...commonProps, ...extraProps });
}
var block_alignment_control_ui_ui_default = BlockAlignmentUI;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/index.js


const BlockAlignmentControl = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_alignment_control_ui_ui_default, { ...props, isToolbar: false });
};
const BlockAlignmentToolbar = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_alignment_control_ui_ui_default, { ...props, isToolbar: true });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/block-editing-mode/index.js




function useBlockEditingMode(mode) {
  const context = useBlockEditContext();
  const { clientId = "" } = context;
  const { setBlockEditingMode, unsetBlockEditingMode } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const globalBlockEditingMode = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => (
      // Avoid adding the subscription if not needed!
      clientId ? null : select(store).getBlockEditingMode()
    ),
    [clientId]
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (mode) {
      setBlockEditingMode(clientId, mode);
    }
    return () => {
      if (mode) {
        unsetBlockEditingMode(clientId);
      }
    };
  }, [clientId, mode, setBlockEditingMode, unsetBlockEditingMode]);
  return clientId ? context[blockEditingModeKey] : globalBlockEditingMode;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/align.js







const ALL_ALIGNMENTS = ["left", "center", "right", "wide", "full"];
const WIDE_ALIGNMENTS = ["wide", "full"];
function getValidAlignments(blockAlign, hasWideBlockSupport = true, hasWideEnabled = true) {
  let validAlignments;
  if (Array.isArray(blockAlign)) {
    validAlignments = ALL_ALIGNMENTS.filter(
      (value) => blockAlign.includes(value)
    );
  } else if (blockAlign === true) {
    validAlignments = [...ALL_ALIGNMENTS];
  } else {
    validAlignments = [];
  }
  if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
    return validAlignments.filter(
      (alignment) => !WIDE_ALIGNMENTS.includes(alignment)
    );
  }
  return validAlignments;
}
function addAttribute(settings) {
  if ("type" in (settings.attributes?.align ?? {})) {
    return settings;
  }
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "align")) {
    settings.attributes = {
      ...settings.attributes,
      align: {
        type: "string",
        // Allow for '' since it is used by the `updateAlignment` function
        // in toolbar controls for special cases with defined default values.
        enum: [...ALL_ALIGNMENTS, ""]
      }
    };
  }
  return settings;
}
function BlockEditAlignmentToolbarControlsPure({
  name: blockName,
  align,
  setAttributes
}) {
  const blockAllowedAlignments = getValidAlignments(
    (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, "align"),
    (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "alignWide", true)
  );
  const validAlignments = useAvailableAlignments(
    blockAllowedAlignments
  ).map(({ name }) => name);
  const blockEditingMode = useBlockEditingMode();
  if (!validAlignments.length || blockEditingMode !== "default") {
    return null;
  }
  const updateAlignment = (nextAlign) => {
    if (!nextAlign) {
      const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
      const blockDefaultAlign = blockType?.attributes?.align?.default;
      if (blockDefaultAlign) {
        nextAlign = "";
      }
    }
    setAttributes({ align: nextAlign });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockAlignmentControl,
    {
      value: align,
      onChange: updateAlignment,
      controls: validAlignments
    }
  ) });
}
var align_default = {
  shareWithChildBlocks: true,
  edit: BlockEditAlignmentToolbarControlsPure,
  useBlockProps,
  addSaveProps: addAssignedAlign,
  attributeKeys: ["align"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "align", false);
  }
};
function useBlockProps({ name, align }) {
  const blockAllowedAlignments = getValidAlignments(
    (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, "align"),
    (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "alignWide", true)
  );
  const validAlignments = useAvailableAlignments(blockAllowedAlignments);
  if (validAlignments.some((alignment) => alignment.name === align)) {
    return { "data-align": align };
  }
  return {};
}
function addAssignedAlign(props, blockType, attributes) {
  const { align } = attributes;
  const blockAlign = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, "align");
  const hasWideBlockSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "alignWide", true);
  const isAlignValid = getValidAlignments(
    blockAlign,
    hasWideBlockSupport
  ).includes(align);
  if (isAlignValid) {
    props.className = dist_clsx(`align${align}`, props.className);
  }
  return props;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/editor/align/addAttribute",
  addAttribute
);


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/groups.js

const InspectorControlsDefault = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControls");
const InspectorControlsAdvanced = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorAdvancedControls");
const InspectorControlsBindings = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsBindings");
const InspectorControlsBackground = (0,external_wp_components_namespaceObject.createSlotFill)(
  "InspectorControlsBackground"
);
const InspectorControlsBorder = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsBorder");
const InspectorControlsColor = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsColor");
const InspectorControlsFilter = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsFilter");
const InspectorControlsDimensions = (0,external_wp_components_namespaceObject.createSlotFill)(
  "InspectorControlsDimensions"
);
const InspectorControlsPosition = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsPosition");
const InspectorControlsTypography = (0,external_wp_components_namespaceObject.createSlotFill)(
  "InspectorControlsTypography"
);
const InspectorControlsListView = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsListView");
const InspectorControlsStyles = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsStyles");
const InspectorControlsEffects = (0,external_wp_components_namespaceObject.createSlotFill)("InspectorControlsEffects");
const groups_groups = {
  default: InspectorControlsDefault,
  advanced: InspectorControlsAdvanced,
  background: InspectorControlsBackground,
  bindings: InspectorControlsBindings,
  border: InspectorControlsBorder,
  color: InspectorControlsColor,
  dimensions: InspectorControlsDimensions,
  effects: InspectorControlsEffects,
  filter: InspectorControlsFilter,
  list: InspectorControlsListView,
  position: InspectorControlsPosition,
  settings: InspectorControlsDefault,
  // Alias for default.
  styles: InspectorControlsStyles,
  typography: InspectorControlsTypography
};
var groups_groups_default = groups_groups;
const PrivateInspectorControlsAllowedBlocks = (0,external_wp_components_namespaceObject.createSlotFill)(
  Symbol("PrivateInspectorControlsAllowedBlocks")
);


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/fill.js







function InspectorControlsFill({
  children,
  group = "default",
  __experimentalGroup,
  resetAllFilter
}) {
  if (__experimentalGroup) {
    external_wp_deprecated_default()(
      "`__experimentalGroup` property in `InspectorControlsFill`",
      {
        since: "6.2",
        version: "6.4",
        alternative: "`group`"
      }
    );
    group = __experimentalGroup;
  }
  const context = useBlockEditContext();
  const Fill = groups_groups_default[group]?.Fill;
  if (!Fill) {
    external_wp_warning_default()(`Unknown InspectorControls group "${group}" provided.`);
    return null;
  }
  if (!context[mayDisplayControlsKey]) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Fill, { children: (fillProps) => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ToolsPanelInspectorControl,
      {
        fillProps,
        children,
        resetAllFilter
      }
    );
  } }) });
}
function RegisterResetAll({ resetAllFilter, children }) {
  const { registerResetAllFilter, deregisterResetAllFilter } = (0,external_wp_element_namespaceObject.useContext)(external_wp_components_namespaceObject.__experimentalToolsPanelContext);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (resetAllFilter && registerResetAllFilter && deregisterResetAllFilter) {
      registerResetAllFilter(resetAllFilter);
      return () => {
        deregisterResetAllFilter(resetAllFilter);
      };
    }
  }, [resetAllFilter, registerResetAllFilter, deregisterResetAllFilter]);
  return children;
}
function ToolsPanelInspectorControl({ children, resetAllFilter, fillProps }) {
  const { forwardedContext = [] } = fillProps;
  const innerMarkup = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(RegisterResetAll, { resetAllFilter, children });
  return forwardedContext.reduce(
    (inner, [Provider, props]) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Provider, { ...props, children: inner }),
    innerMarkup
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js







function BlockSupportToolsPanel({ children, group, label }) {
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    getBlockAttributes,
    getMultiSelectedBlockClientIds,
    getSelectedBlockClientId,
    hasMultiSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const panelId = getSelectedBlockClientId();
  const resetAll = (0,external_wp_element_namespaceObject.useCallback)(
    (resetFilters = []) => {
      const newAttributes = {};
      const clientIds = hasMultiSelection() ? getMultiSelectedBlockClientIds() : [panelId];
      clientIds.forEach((clientId) => {
        const { style } = getBlockAttributes(clientId);
        let newBlockAttributes = { style };
        resetFilters.forEach((resetFilter) => {
          newBlockAttributes = {
            ...newBlockAttributes,
            ...resetFilter(newBlockAttributes)
          };
        });
        newBlockAttributes = {
          ...newBlockAttributes,
          style: utils_cleanEmptyObject(newBlockAttributes.style)
        };
        newAttributes[clientId] = newBlockAttributes;
      });
      updateBlockAttributes(clientIds, newAttributes, true);
    },
    [
      getBlockAttributes,
      getMultiSelectedBlockClientIds,
      hasMultiSelection,
      panelId,
      updateBlockAttributes
    ]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      className: `${group}-block-support-panel`,
      label,
      resetAll,
      panelId,
      hasInnerWrapper: true,
      shouldRenderPlaceholderItems: true,
      __experimentalFirstVisibleItemClass: "first",
      __experimentalLastVisibleItemClass: "last",
      dropdownMenuProps,
      children
    },
    panelId
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-slot-container.js



function BlockSupportSlotContainer({
  Slot,
  fillProps,
  ...props
}) {
  const toolsPanelContext = (0,external_wp_element_namespaceObject.useContext)(external_wp_components_namespaceObject.__experimentalToolsPanelContext);
  const computedFillProps = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      ...fillProps ?? {},
      forwardedContext: [
        ...fillProps?.forwardedContext ?? [],
        [external_wp_components_namespaceObject.__experimentalToolsPanelContext.Provider, { value: toolsPanelContext }]
      ]
    }),
    [toolsPanelContext, fillProps]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Slot, { ...props, fillProps: computedFillProps, bubblesVirtually: true });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/slot.js







function InspectorControlsSlot({
  __experimentalGroup,
  group = "default",
  label,
  fillProps,
  ...props
}) {
  if (__experimentalGroup) {
    external_wp_deprecated_default()(
      "`__experimentalGroup` property in `InspectorControlsSlot`",
      {
        since: "6.2",
        version: "6.4",
        alternative: "`group`"
      }
    );
    group = __experimentalGroup;
  }
  const slotFill = groups_groups_default[group];
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(slotFill?.name);
  if (!slotFill) {
    external_wp_warning_default()(`Unknown InspectorControls group "${group}" provided.`);
    return null;
  }
  if (!fills?.length) {
    return null;
  }
  const { Slot } = slotFill;
  if (label) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockSupportToolsPanel, { group, label, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockSupportSlotContainer,
      {
        ...props,
        fillProps,
        Slot
      }
    ) });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Slot, { ...props, fillProps, bubblesVirtually: true });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls/index.js



const InspectorControls = InspectorControlsFill;
InspectorControls.Slot = InspectorControlsSlot;
const InspectorAdvancedControls = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(InspectorControlsFill, { ...props, group: "advanced" });
};
InspectorAdvancedControls.Slot = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(InspectorControlsSlot, { ...props, group: "advanced" });
};
InspectorAdvancedControls.slotName = "InspectorAdvancedControls";
var inspector_controls_default = InspectorControls;


;// ./node_modules/@wordpress/icons/build-module/library/reset.js


var reset_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7 11.5h10V13H7z" }) });


;// external ["wp","url"]
const external_wp_url_namespaceObject = window["wp"]["url"];
;// external ["wp","dom"]
const external_wp_dom_namespaceObject = window["wp"]["dom"];
;// external ["wp","blob"]
const external_wp_blob_namespaceObject = window["wp"]["blob"];
;// external ["wp","keycodes"]
const external_wp_keycodes_namespaceObject = window["wp"]["keycodes"];
;// ./node_modules/@wordpress/icons/build-module/library/media.js


var media_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m7 6.5 4 2.5-4 2.5z" }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "m5 3c-1.10457 0-2 .89543-2 2v14c0 1.1046.89543 2 2 2h14c1.1046 0 2-.8954 2-2v-14c0-1.10457-.8954-2-2-2zm14 1.5h-14c-.27614 0-.5.22386-.5.5v10.7072l3.62953-2.6465c.25108-.1831.58905-.1924.84981-.0234l2.92666 1.8969 3.5712-3.4719c.2911-.2831.7545-.2831 1.0456 0l2.9772 2.8945v-9.3568c0-.27614-.2239-.5-.5-.5zm-14.5 14.5v-1.4364l4.09643-2.987 2.99567 1.9417c.2936.1903.6798.1523.9307-.0917l3.4772-3.3806 3.4772 3.3806.0228-.0234v2.5968c0 .2761-.2239.5-.5.5h-14c-.27614 0-.5-.2239-.5-.5z"
    }
  )
] });


;// ./node_modules/@wordpress/icons/build-module/library/upload.js


var upload_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18.5 15v3.5H13V6.7l4.5 4.1 1-1.1-6.2-5.8-5.8 5.8 1 1.1 4-4v11.7h-6V15H4v5h16v-5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/post-featured-image.js


var post_featured_image_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 3H5c-.6 0-1 .4-1 1v7c0 .5.4 1 1 1h14c.5 0 1-.4 1-1V4c0-.6-.4-1-1-1zM5.5 10.5v-.4l1.8-1.3 1.3.8c.3.2.7.2.9-.1L11 8.1l2.4 2.4H5.5zm13 0h-2.9l-4-4c-.3-.3-.8-.3-1.1 0L8.9 8l-1.2-.8c-.3-.2-.6-.2-.9 0l-1.3 1V4.5h13v6zM4 20h9v-1.5H4V20zm0-4h16v-1.5H4V16z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/media-upload/index.js

const MediaUpload = () => null;
var media_upload_default = (0,external_wp_components_namespaceObject.withFilters)("editor.MediaUpload")(MediaUpload);


;// ./node_modules/@wordpress/block-editor/build-module/components/media-upload/check.js


function MediaUploadCheck({ fallback = null, children }) {
  const hasUploadPermissions = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    return !!getSettings().mediaUpload;
  }, []);
  return hasUploadPermissions ? children : fallback;
}
var check_default = MediaUploadCheck;


;// external ["wp","isShallowEqual"]
const external_wp_isShallowEqual_namespaceObject = window["wp"]["isShallowEqual"];
var external_wp_isShallowEqual_default = /*#__PURE__*/__webpack_require__.n(external_wp_isShallowEqual_namespaceObject);
;// ./node_modules/@wordpress/icons/build-module/library/link-off.js


var link_off_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17.031 4.703 15.576 4l-1.56 3H14v.03l-2.324 4.47H9.5V13h1.396l-1.502 2.889h-.95a3.694 3.694 0 0 1 0-7.389H10V7H8.444a5.194 5.194 0 1 0 0 10.389h.17L7.5 19.53l1.416.719L15.049 8.5h.507a3.694 3.694 0 0 1 0 7.39H14v1.5h1.556a5.194 5.194 0 0 0 .273-10.383l1.202-2.304Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/keyboard-return.js


var keyboard_return_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m6.734 16.106 2.176-2.38-1.093-1.028-3.846 4.158 3.846 4.158 1.093-1.028-2.176-2.38h2.811c1.125 0 2.25.03 3.374 0 1.428-.001 3.362-.25 4.963-1.277 1.66-1.065 2.868-2.906 2.868-5.859 0-2.479-1.327-4.896-3.65-5.93-1.82-.813-3.044-.8-4.806-.788l-.567.002v1.5c.184 0 .368 0 .553-.002 1.82-.007 2.704-.014 4.21.657 1.854.827 2.76 2.657 2.76 4.561 0 2.472-.973 3.824-2.178 4.596-1.258.807-2.864 1.04-4.163 1.04h-.02c-1.115.03-2.229 0-3.344 0H6.734Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/chevron-left-small.js


var chevron_left_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m13.1 16-3.4-4 3.4-4 1.1 1-2.6 3 2.6 3-1.1 1z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/chevron-right-small.js


var chevron_right_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M10.8622 8.04053L14.2805 12.0286L10.8622 16.0167L9.72327 15.0405L12.3049 12.0286L9.72327 9.01672L10.8622 8.04053Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/settings-drawer.js






function LinkSettingsDrawer({ children, settingsOpen, setSettingsOpen }) {
  const prefersReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  const MaybeAnimatePresence = prefersReducedMotion ? external_wp_element_namespaceObject.Fragment : external_wp_components_namespaceObject.__unstableAnimatePresence;
  const MaybeMotionDiv = prefersReducedMotion ? "div" : external_wp_components_namespaceObject.__unstableMotion.div;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(LinkSettingsDrawer);
  const settingsDrawerId = `link-control-settings-drawer-${id}`;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        className: "block-editor-link-control__drawer-toggle",
        "aria-expanded": settingsOpen,
        onClick: () => setSettingsOpen(!settingsOpen),
        icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_small_default : chevron_right_small_default,
        "aria-controls": settingsDrawerId,
        children: (0,external_wp_i18n_namespaceObject._x)("Advanced", "Additional link settings")
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MaybeAnimatePresence, { children: settingsOpen && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      MaybeMotionDiv,
      {
        className: "block-editor-link-control__drawer",
        hidden: !settingsOpen,
        id: settingsDrawerId,
        initial: "collapsed",
        animate: "open",
        exit: "collapsed",
        variants: {
          open: { opacity: 1, height: "auto" },
          collapsed: { opacity: 0, height: 0 }
        },
        transition: {
          duration: 0.1
        },
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-link-control__drawer-inner", children })
      }
    ) })
  ] });
}
var settings_drawer_default = LinkSettingsDrawer;


// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(1609);
;// ./node_modules/@wordpress/block-editor/build-module/components/url-input/index.js











function isFunction(maybeFunc) {
  return typeof maybeFunc === "function";
}
class URLInput extends external_wp_element_namespaceObject.Component {
  constructor(props) {
    super(props);
    this.onChange = this.onChange.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.selectLink = this.selectLink.bind(this);
    this.handleOnClick = this.handleOnClick.bind(this);
    this.bindSuggestionNode = this.bindSuggestionNode.bind(this);
    this.autocompleteRef = props.autocompleteRef || (0,external_wp_element_namespaceObject.createRef)();
    this.inputRef = props.inputRef || (0,external_wp_element_namespaceObject.createRef)();
    this.updateSuggestions = (0,external_wp_compose_namespaceObject.debounce)(
      this.updateSuggestions.bind(this),
      200
    );
    this.suggestionNodes = [];
    this.suggestionsRequest = null;
    this.state = {
      suggestions: [],
      showSuggestions: false,
      suggestionsValue: null,
      selectedSuggestion: null,
      suggestionsListboxId: "",
      suggestionOptionIdPrefix: ""
    };
  }
  componentDidUpdate(prevProps) {
    const { showSuggestions, selectedSuggestion } = this.state;
    const { value, __experimentalShowInitialSuggestions = false } = this.props;
    if (showSuggestions && selectedSuggestion !== null && this.suggestionNodes[selectedSuggestion]) {
      this.suggestionNodes[selectedSuggestion].scrollIntoView({
        behavior: "instant",
        block: "nearest",
        inline: "nearest"
      });
    }
    if (prevProps.value !== value && !this.props.disableSuggestions) {
      if (value?.length) {
        this.updateSuggestions(value);
      } else if (__experimentalShowInitialSuggestions) {
        this.updateSuggestions();
      }
    }
  }
  componentDidMount() {
    if (this.shouldShowInitialSuggestions()) {
      this.updateSuggestions();
    }
  }
  componentWillUnmount() {
    this.suggestionsRequest?.cancel?.();
    this.suggestionsRequest = null;
  }
  bindSuggestionNode(index) {
    return (ref) => {
      this.suggestionNodes[index] = ref;
    };
  }
  shouldShowInitialSuggestions() {
    const { __experimentalShowInitialSuggestions = false, value } = this.props;
    return __experimentalShowInitialSuggestions && !(value && value.length);
  }
  updateSuggestions(value = "") {
    const {
      __experimentalFetchLinkSuggestions: fetchLinkSuggestions,
      __experimentalHandleURLSuggestions: handleURLSuggestions
    } = this.props;
    if (!fetchLinkSuggestions) {
      return;
    }
    const isInitialSuggestions = !value?.length;
    value = value.trim();
    if (!isInitialSuggestions && (value.length < 2 || !handleURLSuggestions && (0,external_wp_url_namespaceObject.isURL)(value))) {
      this.suggestionsRequest?.cancel?.();
      this.suggestionsRequest = null;
      this.setState({
        suggestions: [],
        showSuggestions: false,
        suggestionsValue: value,
        selectedSuggestion: null,
        loading: false
      });
      return;
    }
    this.setState({
      selectedSuggestion: null,
      loading: true
    });
    const request = fetchLinkSuggestions(value, {
      isInitialSuggestions
    });
    request.then((suggestions) => {
      if (this.suggestionsRequest !== request) {
        return;
      }
      this.setState({
        suggestions,
        suggestionsValue: value,
        loading: false,
        showSuggestions: !!suggestions.length
      });
      if (!!suggestions.length) {
        this.props.debouncedSpeak(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %d: number of results. */
            (0,external_wp_i18n_namespaceObject._n)(
              "%d result found, use up and down arrow keys to navigate.",
              "%d results found, use up and down arrow keys to navigate.",
              suggestions.length
            ),
            suggestions.length
          ),
          "assertive"
        );
      } else {
        this.props.debouncedSpeak(
          (0,external_wp_i18n_namespaceObject.__)("No results."),
          "assertive"
        );
      }
    }).catch(() => {
      if (this.suggestionsRequest !== request) {
        return;
      }
      this.setState({
        loading: false
      });
    }).finally(() => {
      if (this.suggestionsRequest === request) {
        this.suggestionsRequest = null;
      }
    });
    this.suggestionsRequest = request;
  }
  onChange(newValue) {
    this.props.onChange(newValue);
  }
  onFocus() {
    const { suggestions } = this.state;
    const { disableSuggestions, value } = this.props;
    if (value && !disableSuggestions && !(suggestions && suggestions.length) && this.suggestionsRequest === null) {
      this.updateSuggestions(value);
    }
  }
  onKeyDown(event) {
    this.props.onKeyDown?.(event);
    const { showSuggestions, selectedSuggestion, suggestions, loading } = this.state;
    if (!showSuggestions || !suggestions.length || loading) {
      switch (event.keyCode) {
        // When UP is pressed, if the caret is at the start of the text, move it to the 0
        // position.
        case external_wp_keycodes_namespaceObject.UP: {
          if (0 !== event.target.selectionStart) {
            event.preventDefault();
            event.target.setSelectionRange(0, 0);
          }
          break;
        }
        // When DOWN is pressed, if the caret is not at the end of the text, move it to the
        // last position.
        case external_wp_keycodes_namespaceObject.DOWN: {
          if (this.props.value.length !== event.target.selectionStart) {
            event.preventDefault();
            event.target.setSelectionRange(
              this.props.value.length,
              this.props.value.length
            );
          }
          break;
        }
        // Submitting while loading should trigger onSubmit.
        case external_wp_keycodes_namespaceObject.ENTER: {
          if (this.props.onSubmit) {
            event.preventDefault();
            this.props.onSubmit(null, event);
          }
          break;
        }
      }
      return;
    }
    const suggestion = this.state.suggestions[this.state.selectedSuggestion];
    switch (event.keyCode) {
      case external_wp_keycodes_namespaceObject.UP: {
        event.preventDefault();
        const previousIndex = !selectedSuggestion ? suggestions.length - 1 : selectedSuggestion - 1;
        this.setState({
          selectedSuggestion: previousIndex
        });
        break;
      }
      case external_wp_keycodes_namespaceObject.DOWN: {
        event.preventDefault();
        const nextIndex = selectedSuggestion === null || selectedSuggestion === suggestions.length - 1 ? 0 : selectedSuggestion + 1;
        this.setState({
          selectedSuggestion: nextIndex
        });
        break;
      }
      case external_wp_keycodes_namespaceObject.TAB: {
        if (this.state.selectedSuggestion !== null) {
          this.selectLink(suggestion);
          this.props.speak((0,external_wp_i18n_namespaceObject.__)("Link selected."));
        }
        break;
      }
      case external_wp_keycodes_namespaceObject.ENTER: {
        event.preventDefault();
        if (this.state.selectedSuggestion !== null) {
          this.selectLink(suggestion);
          if (this.props.onSubmit) {
            this.props.onSubmit(suggestion, event);
          }
        } else if (this.props.onSubmit) {
          this.props.onSubmit(null, event);
        }
        break;
      }
    }
  }
  selectLink(suggestion) {
    this.props.onChange(suggestion.url, suggestion);
    this.setState({
      selectedSuggestion: null,
      showSuggestions: false
    });
  }
  handleOnClick(suggestion) {
    this.selectLink(suggestion);
    this.inputRef.current.focus();
  }
  static getDerivedStateFromProps({
    value,
    instanceId,
    disableSuggestions,
    __experimentalShowInitialSuggestions = false
  }, { showSuggestions }) {
    let shouldShowSuggestions = showSuggestions;
    const hasValue = value && value.length;
    if (!__experimentalShowInitialSuggestions && !hasValue) {
      shouldShowSuggestions = false;
    }
    if (disableSuggestions === true) {
      shouldShowSuggestions = false;
    }
    return {
      showSuggestions: shouldShowSuggestions,
      suggestionsListboxId: `block-editor-url-input-suggestions-${instanceId}`,
      suggestionOptionIdPrefix: `block-editor-url-input-suggestion-${instanceId}`
    };
  }
  render() {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      this.renderControl(),
      this.renderSuggestions()
    ] });
  }
  renderControl() {
    const {
      label = null,
      className,
      isFullWidth,
      instanceId,
      placeholder = (0,external_wp_i18n_namespaceObject.__)("Paste URL or type to search"),
      __experimentalRenderControl: renderControl,
      value = "",
      hideLabelFromVision = false,
      help = null,
      disabled = false
    } = this.props;
    const {
      loading,
      showSuggestions,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix
    } = this.state;
    const inputId = `url-input-control-${instanceId}`;
    const controlProps = {
      id: inputId,
      // Passes attribute to label for the for attribute
      label,
      className: dist_clsx("block-editor-url-input", className, {
        "is-full-width": isFullWidth
      }),
      hideLabelFromVision
    };
    const inputProps = {
      id: inputId,
      value,
      required: true,
      type: "text",
      onChange: disabled ? () => {
      } : this.onChange,
      // Disable onChange when disabled
      onFocus: disabled ? () => {
      } : this.onFocus,
      // Disable onFocus when disabled
      placeholder,
      onKeyDown: disabled ? () => {
      } : this.onKeyDown,
      // Disable onKeyDown when disabled
      role: "combobox",
      "aria-label": label ? void 0 : (0,external_wp_i18n_namespaceObject.__)("URL"),
      // Ensure input always has an accessible label
      "aria-expanded": showSuggestions,
      "aria-autocomplete": "list",
      "aria-owns": suggestionsListboxId,
      "aria-activedescendant": selectedSuggestion !== null ? `${suggestionOptionIdPrefix}-${selectedSuggestion}` : void 0,
      ref: this.inputRef,
      disabled,
      suffix: this.props.suffix,
      help
    };
    if (renderControl) {
      return renderControl(controlProps, inputProps, loading);
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.BaseControl, { __nextHasNoMarginBottom: true, ...controlProps, children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControl, { ...inputProps, __next40pxDefaultSize: true }),
      loading && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {})
    ] });
  }
  renderSuggestions() {
    const {
      className,
      __experimentalRenderSuggestions: renderSuggestions
    } = this.props;
    const {
      showSuggestions,
      suggestions,
      suggestionsValue,
      selectedSuggestion,
      suggestionsListboxId,
      suggestionOptionIdPrefix,
      loading
    } = this.state;
    if (!showSuggestions || suggestions.length === 0) {
      return null;
    }
    const suggestionsListProps = {
      id: suggestionsListboxId,
      ref: this.autocompleteRef,
      role: "listbox"
    };
    const buildSuggestionItemProps = (suggestion, index) => {
      return {
        role: "option",
        tabIndex: "-1",
        id: `${suggestionOptionIdPrefix}-${index}`,
        ref: this.bindSuggestionNode(index),
        "aria-selected": index === selectedSuggestion ? true : void 0
      };
    };
    if (isFunction(renderSuggestions)) {
      return renderSuggestions({
        suggestions,
        selectedSuggestion,
        suggestionsListProps,
        buildSuggestionItemProps,
        isLoading: loading,
        handleSuggestionClick: this.handleOnClick,
        isInitialSuggestions: !suggestionsValue?.length,
        currentInputValue: suggestionsValue
      });
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Popover, { placement: "bottom", focusOnMount: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        ...suggestionsListProps,
        className: dist_clsx("block-editor-url-input__suggestions", {
          [`${className}__suggestions`]: className
        }),
        children: suggestions.map((suggestion, index) => /* @__PURE__ */ (0,external_React_.createElement)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            ...buildSuggestionItemProps(suggestion, index),
            key: suggestion.id,
            className: dist_clsx(
              "block-editor-url-input__suggestion",
              {
                "is-selected": index === selectedSuggestion
              }
            ),
            onClick: () => this.handleOnClick(suggestion)
          },
          suggestion.title
        ))
      }
    ) });
  }
}
var url_input_default = (0,external_wp_compose_namespaceObject.compose)(
  external_wp_compose_namespaceObject.withSafeTimeout,
  external_wp_components_namespaceObject.withSpokenMessages,
  external_wp_compose_namespaceObject.withInstanceId,
  (0,external_wp_data_namespaceObject.withSelect)((select, props) => {
    if (isFunction(props.__experimentalFetchLinkSuggestions)) {
      return;
    }
    const { getSettings } = select(store);
    return {
      __experimentalFetchLinkSuggestions: getSettings().__experimentalFetchLinkSuggestions
    };
  })
)(URLInput);


;// ./node_modules/@wordpress/icons/build-module/library/plus.js


var plus_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M11 12.5V17.5H12.5V12.5H17.5V11H12.5V6H11V11H6V12.5H11Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-create-button.js





const LinkControlSearchCreate = ({
  searchTerm,
  onClick,
  itemProps,
  buttonText
}) => {
  if (!searchTerm) {
    return null;
  }
  let text;
  if (buttonText) {
    text = typeof buttonText === "function" ? buttonText(searchTerm) : buttonText;
  } else {
    text = (0,external_wp_element_namespaceObject.createInterpolateElement)(
      (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: search term. */
        (0,external_wp_i18n_namespaceObject.__)("Create: <mark>%s</mark>"),
        searchTerm
      ),
      { mark: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("mark", {}) }
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      ...itemProps,
      iconPosition: "left",
      icon: plus_default,
      className: "block-editor-link-control__search-item",
      onClick,
      children: text
    }
  );
};
var search_create_button_default = LinkControlSearchCreate;


;// ./node_modules/@wordpress/icons/build-module/library/post-list.js


var post_list_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18 5.5H6a.5.5 0 0 0-.5.5v12a.5.5 0 0 0 .5.5h12a.5.5 0 0 0 .5-.5V6a.5.5 0 0 0-.5-.5ZM6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm1 5h1.5v1.5H7V9Zm1.5 4.5H7V15h1.5v-1.5ZM10 9h7v1.5h-7V9Zm7 4.5h-7V15h7v-1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/page.js


var page_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M15.5 7.5h-7V9h7V7.5Zm-7 3.5h7v1.5h-7V11Zm7 3.5h-7V16h7v-1.5Z" }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17 4H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2ZM7 5.5h10a.5.5 0 0 1 .5.5v12a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V6a.5.5 0 0 1 .5-.5Z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/tag.js


var tag_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4.75 4a.75.75 0 0 0-.75.75v7.826c0 .2.08.39.22.53l6.72 6.716a2.313 2.313 0 0 0 3.276-.001l5.61-5.611-.531-.53.532.528a2.315 2.315 0 0 0 0-3.264L13.104 4.22a.75.75 0 0 0-.53-.22H4.75ZM19 12.576a.815.815 0 0 1-.236.574l-5.61 5.611a.814.814 0 0 1-1.153 0L5.5 12.264V5.5h6.763l6.5 6.502a.816.816 0 0 1 .237.574ZM8.75 9.75a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/category.js


var category_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    d: "M6 5.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM4 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2V6zm11-.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5h-3a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5zM13 6a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2h-3a2 2 0 01-2-2V6zm5 8.5h-3a.5.5 0 00-.5.5v3a.5.5 0 00.5.5h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5zM15 13a2 2 0 00-2 2v3a2 2 0 002 2h3a2 2 0 002-2v-3a2 2 0 00-2-2h-3zm-9 1.5h3a.5.5 0 01.5.5v3a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5zM4 15a2 2 0 012-2h3a2 2 0 012 2v3a2 2 0 01-2 2H6a2 2 0 01-2-2v-3z",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }
) });


;// ./node_modules/@wordpress/icons/build-module/library/file.js


var file_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12.848 8a1 1 0 0 1-.914-.594l-.723-1.63a.5.5 0 0 0-.447-.276H5a.5.5 0 0 0-.5.5v11.5a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5v-9A.5.5 0 0 0 19 8h-6.152Zm.612-1.5a.5.5 0 0 1-.462-.31l-.445-1.084A2 2 0 0 0 10.763 4H5a2 2 0 0 0-2 2v11.5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-5.54Z"
  }
) });


;// ./node_modules/@wordpress/icons/build-module/library/globe.js


var globe_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12 4c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8Zm6.5 8c0 .6 0 1.2-.2 1.8h-2.7c0-.6.2-1.1.2-1.8s0-1.2-.2-1.8h2.7c.2.6.2 1.1.2 1.8Zm-.9-3.2h-2.4c-.3-.9-.7-1.8-1.1-2.4-.1-.2-.2-.4-.3-.5 1.6.5 3 1.6 3.8 3ZM12.8 17c-.3.5-.6 1-.8 1.3-.2-.3-.5-.8-.8-1.3-.3-.5-.6-1.1-.8-1.7h3.3c-.2.6-.5 1.2-.8 1.7Zm-2.9-3.2c-.1-.6-.2-1.1-.2-1.8s0-1.2.2-1.8H14c.1.6.2 1.1.2 1.8s0 1.2-.2 1.8H9.9ZM11.2 7c.3-.5.6-1 .8-1.3.2.3.5.8.8 1.3.3.5.6 1.1.8 1.7h-3.3c.2-.6.5-1.2.8-1.7Zm-1-1.2c-.1.2-.2.3-.3.5-.4.7-.8 1.5-1.1 2.4H6.4c.8-1.4 2.2-2.5 3.8-3Zm-1.8 8H5.7c-.2-.6-.2-1.1-.2-1.8s0-1.2.2-1.8h2.7c0 .6-.2 1.1-.2 1.8s0 1.2.2 1.8Zm-2 1.4h2.4c.3.9.7 1.8 1.1 2.4.1.2.2.4.3.5-1.6-.5-3-1.6-3.8-3Zm7.4 3c.1-.2.2-.3.3-.5.4-.7.8-1.5 1.1-2.4h2.4c-.8 1.4-2.2 2.5-3.8 3Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/home.js


var home_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12 4L4 7.9V20h16V7.9L12 4zm6.5 14.5H14V13h-4v5.5H5.5V8.8L12 5.7l6.5 3.1v9.7z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/verse.js


var verse_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17.8 2l-.9.3c-.1 0-3.6 1-5.2 2.1C10 5.5 9.3 6.5 8.9 7.1c-.6.9-1.7 4.7-1.7 6.3l-.9 2.3c-.2.4 0 .8.4 1 .1 0 .2.1.3.1.3 0 .6-.2.7-.5l.6-1.5c.3 0 .7-.1 1.2-.2.7-.1 1.4-.3 2.2-.5.8-.2 1.6-.5 2.4-.8.7-.3 1.4-.7 1.9-1.2s.8-1.2 1-1.9c.2-.7.3-1.6.4-2.4.1-.8.1-1.7.2-2.5 0-.8.1-1.5.2-2.1V2zm-1.9 5.6c-.1.8-.2 1.5-.3 2.1-.2.6-.4 1-.6 1.3-.3.3-.8.6-1.4.9-.7.3-1.4.5-2.2.8-.6.2-1.3.3-1.8.4L15 7.5c.3-.3.6-.7 1-1.1 0 .4 0 .8-.1 1.2zM6 20h8v-1.5H6V20z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-item.js








const TYPES = {
  post: {
    icon: post_list_default,
    label: (0,external_wp_i18n_namespaceObject.__)("Post")
  },
  page: {
    icon: page_default,
    label: (0,external_wp_i18n_namespaceObject.__)("Page")
  },
  post_tag: {
    icon: tag_default,
    label: (0,external_wp_i18n_namespaceObject.__)("Tag")
  },
  category: {
    icon: category_default,
    label: (0,external_wp_i18n_namespaceObject.__)("Category")
  },
  attachment: {
    icon: file_default,
    label: (0,external_wp_i18n_namespaceObject.__)("Attachment")
  }
};
function SearchItemIcon({ isURL, suggestion }) {
  let icon = null;
  if (isURL) {
    icon = globe_default;
  } else if (suggestion.type in TYPES) {
    icon = TYPES[suggestion.type].icon;
    if (suggestion.type === "page") {
      if (suggestion.isFrontPage) {
        icon = home_default;
      }
      if (suggestion.isBlogHome) {
        icon = verse_default;
      }
    }
  }
  if (icon) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      icon_default,
      {
        className: "block-editor-link-control__search-item-icon",
        icon
      }
    );
  }
  return null;
}
function addLeadingSlash(url) {
  const trimmedURL = url?.trim();
  if (!trimmedURL?.length) {
    return url;
  }
  return url?.replace(/^\/?/, "/");
}
function removeTrailingSlash(url) {
  const trimmedURL = url?.trim();
  if (!trimmedURL?.length) {
    return url;
  }
  return url?.replace(/\/$/, "");
}
const partialRight = (fn, ...partialArgs) => (...args) => fn(...args, ...partialArgs);
const defaultTo = (d) => (v) => {
  return v === null || v === void 0 || v !== v ? d : v;
};
function getURLForDisplay(url) {
  if (!url) {
    return url;
  }
  return (0,external_wp_compose_namespaceObject.pipe)(
    external_wp_url_namespaceObject.safeDecodeURI,
    external_wp_url_namespaceObject.getPath,
    defaultTo(""),
    partialRight(external_wp_url_namespaceObject.filterURLForDisplay, 24),
    removeTrailingSlash,
    addLeadingSlash
  )(url);
}
const LinkControlSearchItem = ({
  itemProps,
  suggestion,
  searchTerm,
  onClick,
  isURL = false,
  shouldShowType = false
}) => {
  const info = isURL ? (0,external_wp_i18n_namespaceObject.__)("Press ENTER to add this link") : getURLForDisplay(suggestion.url);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      ...itemProps,
      info,
      iconPosition: "left",
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(SearchItemIcon, { suggestion, isURL }),
      onClick,
      shortcut: shouldShowType && getVisualTypeName(suggestion),
      className: "block-editor-link-control__search-item",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.TextHighlight,
        {
          text: (0,external_wp_dom_namespaceObject.__unstableStripHTML)(suggestion.title),
          highlight: searchTerm
        }
      )
    }
  );
};
function getVisualTypeName(suggestion) {
  if (suggestion.isFrontPage) {
    return (0,external_wp_i18n_namespaceObject.__)("Front page");
  }
  if (suggestion.isBlogHome) {
    return (0,external_wp_i18n_namespaceObject.__)("Blog home");
  }
  if (suggestion.type in TYPES) {
    return TYPES[suggestion.type].label;
  }
  return suggestion.type;
}
var search_item_default = LinkControlSearchItem;
const __experimentalLinkControlSearchItem = (props) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalLinkControlSearchItem", {
    since: "6.8"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LinkControlSearchItem, { ...props });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/constants.js

const CREATE_TYPE = "__CREATE__";
const TEL_TYPE = "tel";
const URL_TYPE = "link";
const MAILTO_TYPE = "mailto";
const INTERNAL_TYPE = "internal";
const LINK_ENTRY_TYPES = [
  URL_TYPE,
  MAILTO_TYPE,
  TEL_TYPE,
  INTERNAL_TYPE
];
const DEFAULT_LINK_SETTINGS = [
  {
    id: "opensInNewTab",
    title: (0,external_wp_i18n_namespaceObject.__)("Open in new tab")
  }
];


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-results.js








function LinkControlSearchResults({
  withCreateSuggestion,
  currentInputValue,
  handleSuggestionClick,
  suggestionsListProps,
  buildSuggestionItemProps,
  suggestions,
  selectedSuggestion,
  isLoading,
  isInitialSuggestions,
  createSuggestionButtonText,
  suggestionsQuery
}) {
  const resultsListClasses = dist_clsx(
    "block-editor-link-control__search-results",
    {
      "is-loading": isLoading
    }
  );
  const isSingleDirectEntryResult = suggestions.length === 1 && LINK_ENTRY_TYPES.includes(suggestions[0].type);
  const shouldShowCreateSuggestion = withCreateSuggestion && !isSingleDirectEntryResult && !isInitialSuggestions;
  const shouldShowSuggestionsTypes = !suggestionsQuery?.type;
  const labelText = isInitialSuggestions ? (0,external_wp_i18n_namespaceObject.__)("Suggestions") : (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: search term. */
    (0,external_wp_i18n_namespaceObject.__)('Search results for "%s"'),
    currentInputValue
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-link-control__search-results-wrapper", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      ...suggestionsListProps,
      className: resultsListClasses,
      "aria-label": labelText,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: suggestions.map((suggestion, index) => {
        if (shouldShowCreateSuggestion && CREATE_TYPE === suggestion.type) {
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            search_create_button_default,
            {
              searchTerm: currentInputValue,
              buttonText: createSuggestionButtonText,
              onClick: () => handleSuggestionClick(suggestion),
              itemProps: buildSuggestionItemProps(
                suggestion,
                index
              ),
              isSelected: index === selectedSuggestion
            },
            suggestion.type
          );
        }
        if (CREATE_TYPE === suggestion.type) {
          return null;
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          search_item_default,
          {
            itemProps: buildSuggestionItemProps(
              suggestion,
              index
            ),
            suggestion,
            index,
            onClick: () => {
              handleSuggestionClick(suggestion);
            },
            isSelected: index === selectedSuggestion,
            isURL: LINK_ENTRY_TYPES.includes(
              suggestion.type
            ),
            searchTerm: currentInputValue,
            shouldShowType: shouldShowSuggestionsTypes,
            isFrontPage: suggestion?.isFrontPage,
            isBlogHome: suggestion?.isBlogHome
          },
          `${suggestion.id}-${suggestion.type}`
        );
      }) })
    }
  ) });
}
var search_results_default = LinkControlSearchResults;
const __experimentalLinkControlSearchResults = (props) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalLinkControlSearchResults", {
    since: "6.8"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LinkControlSearchResults, { ...props });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/is-url-like.js

function isURLLike(val) {
  const hasSpaces = val.includes(" ");
  if (hasSpaces) {
    return false;
  }
  const protocol = (0,external_wp_url_namespaceObject.getProtocol)(val);
  const protocolIsValid = (0,external_wp_url_namespaceObject.isValidProtocol)(protocol);
  const mayBeTLD = hasPossibleTLD(val);
  const isWWW = val?.startsWith("www.");
  const isInternal = val?.startsWith("#") && (0,external_wp_url_namespaceObject.isValidFragment)(val);
  return protocolIsValid || isWWW || isInternal || mayBeTLD;
}
function hasPossibleTLD(url, maxLength = 6) {
  const cleanedURL = url.split(/[?#]/)[0];
  const regex = new RegExp(
    `(?<=\\S)\\.(?:[a-zA-Z_]{2,${maxLength}})(?:\\/|$)`
  );
  return regex.test(cleanedURL);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-search-handler.js






const handleNoop = () => Promise.resolve([]);
const handleDirectEntry = (val) => {
  let type = URL_TYPE;
  const protocol = (0,external_wp_url_namespaceObject.getProtocol)(val) || "";
  if (protocol.includes("mailto")) {
    type = MAILTO_TYPE;
  }
  if (protocol.includes("tel")) {
    type = TEL_TYPE;
  }
  if (val?.startsWith("#")) {
    type = INTERNAL_TYPE;
  }
  return Promise.resolve([
    {
      id: val,
      title: val,
      url: type === "URL" ? (0,external_wp_url_namespaceObject.prependHTTP)(val) : val,
      type
    }
  ]);
};
const handleEntitySearch = async (val, suggestionsQuery, fetchSearchSuggestions, withCreateSuggestion, pageOnFront, pageForPosts) => {
  const { isInitialSuggestions } = suggestionsQuery;
  const results = await fetchSearchSuggestions(val, suggestionsQuery);
  results.map((result) => {
    if (Number(result.id) === pageOnFront) {
      result.isFrontPage = true;
      return result;
    } else if (Number(result.id) === pageForPosts) {
      result.isBlogHome = true;
      return result;
    }
    return result;
  });
  if (isInitialSuggestions) {
    return results;
  }
  return isURLLike(val) || !withCreateSuggestion ? results : results.concat({
    // the `id` prop is intentionally omitted here because it
    // is never exposed as part of the component's public API.
    // see: https://github.com/WordPress/gutenberg/pull/19775#discussion_r378931316.
    title: val,
    // Must match the existing `<input>`s text value.
    url: val,
    // Must match the existing `<input>`s text value.
    type: CREATE_TYPE
  });
};
function useSearchHandler(suggestionsQuery, allowDirectEntry, withCreateSuggestion) {
  const { fetchSearchSuggestions, pageOnFront, pageForPosts } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getSettings } = select(store);
      return {
        pageOnFront: getSettings().pageOnFront,
        pageForPosts: getSettings().pageForPosts,
        fetchSearchSuggestions: getSettings().__experimentalFetchLinkSuggestions
      };
    },
    []
  );
  const directEntryHandler = allowDirectEntry ? handleDirectEntry : handleNoop;
  return (0,external_wp_element_namespaceObject.useCallback)(
    (val, { isInitialSuggestions }) => {
      return isURLLike(val) ? directEntryHandler(val, { isInitialSuggestions }) : handleEntitySearch(
        val,
        { ...suggestionsQuery, isInitialSuggestions },
        fetchSearchSuggestions,
        withCreateSuggestion,
        pageOnFront,
        pageForPosts
      );
    },
    [
      directEntryHandler,
      fetchSearchSuggestions,
      pageOnFront,
      pageForPosts,
      suggestionsQuery,
      withCreateSuggestion
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/search-input.js








const noopSearchHandler = () => Promise.resolve([]);
const noop = () => {
};
const LinkControlSearchInput = (0,external_wp_element_namespaceObject.forwardRef)(
  ({
    value,
    children,
    currentLink = {},
    className = null,
    placeholder = null,
    withCreateSuggestion = false,
    onCreateSuggestion = noop,
    onChange = noop,
    onSelect = noop,
    showSuggestions = true,
    renderSuggestions = (props) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(search_results_default, { ...props }),
    fetchSuggestions = null,
    allowDirectEntry = true,
    showInitialSuggestions = false,
    suggestionsQuery = {},
    withURLSuggestion = true,
    createSuggestionButtonText,
    hideLabelFromVision = false,
    suffix,
    isEntity = false
  }, ref) => {
    const genericSearchHandler = useSearchHandler(
      suggestionsQuery,
      allowDirectEntry,
      withCreateSuggestion,
      withURLSuggestion
    );
    const searchHandler = showSuggestions ? fetchSuggestions || genericSearchHandler : noopSearchHandler;
    const [focusedSuggestion, setFocusedSuggestion] = (0,external_wp_element_namespaceObject.useState)();
    const onInputChange = (selection, suggestion) => {
      onChange(selection);
      setFocusedSuggestion(suggestion);
    };
    const handleRenderSuggestions = (props) => renderSuggestions({
      ...props,
      withCreateSuggestion,
      createSuggestionButtonText,
      suggestionsQuery,
      handleSuggestionClick: (suggestion) => {
        if (props.handleSuggestionClick) {
          props.handleSuggestionClick(suggestion);
        }
        onSuggestionSelected(suggestion);
      }
    });
    const onSuggestionSelected = async (selectedSuggestion) => {
      let suggestion = selectedSuggestion;
      if (CREATE_TYPE === selectedSuggestion.type) {
        try {
          suggestion = await onCreateSuggestion(
            selectedSuggestion.title
          );
          if (suggestion?.url) {
            onSelect(suggestion);
          }
        } catch (e) {
        }
        return;
      }
      if (allowDirectEntry || suggestion && Object.keys(suggestion).length >= 1) {
        const { id, url, ...restLinkProps } = currentLink ?? {};
        onSelect(
          // Some direct entries don't have types or IDs, and we still need to clear the previous ones.
          { ...restLinkProps, ...suggestion },
          suggestion
        );
      }
    };
    const _placeholder = placeholder ?? (0,external_wp_i18n_namespaceObject.__)("Search or type URL");
    const label = hideLabelFromVision && placeholder !== "" ? _placeholder : (0,external_wp_i18n_namespaceObject.__)("Link");
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-link-control__search-input-container", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        url_input_default,
        {
          disableSuggestions: currentLink?.url === value,
          label,
          hideLabelFromVision,
          className,
          value,
          onChange: onInputChange,
          placeholder: _placeholder,
          __experimentalRenderSuggestions: showSuggestions ? handleRenderSuggestions : null,
          __experimentalFetchLinkSuggestions: searchHandler,
          __experimentalHandleURLSuggestions: true,
          __experimentalShowInitialSuggestions: showInitialSuggestions,
          onSubmit: (suggestion, event) => {
            const hasSuggestion = suggestion || focusedSuggestion;
            if (!hasSuggestion && !value?.trim()?.length) {
              event.preventDefault();
            } else {
              onSuggestionSelected(
                hasSuggestion || { url: value }
              );
            }
          },
          inputRef: ref,
          suffix,
          disabled: isEntity
        }
      ),
      children
    ] });
  }
);
var search_input_default = LinkControlSearchInput;
const __experimentalLinkControlSearchInput = (props) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalLinkControlSearchInput", {
    since: "6.8"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LinkControlSearchInput, { ...props });
};


;// ./node_modules/@wordpress/icons/build-module/library/info.js


var info_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5.5 12a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm.75 4v1.5h-1.5V8h1.5Zm0 8v-5h-1.5v5h1.5Z"
  }
) });


;// ./node_modules/@wordpress/icons/build-module/library/pencil.js


var pencil_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m19 7-3-3-8.5 8.5-1 4 4-1L19 7Zm-7 11.5H5V20h7v-1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/copy-small.js


var copy_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5.625 5.5h9.75c.069 0 .125.056.125.125v9.75a.125.125 0 0 1-.125.125h-9.75a.125.125 0 0 1-.125-.125v-9.75c0-.069.056-.125.125-.125ZM4 5.625C4 4.728 4.728 4 5.625 4h9.75C16.273 4 17 4.728 17 5.625v9.75c0 .898-.727 1.625-1.625 1.625h-9.75A1.625 1.625 0 0 1 4 15.375v-9.75Zm14.5 11.656v-9H20v9C20 18.8 18.77 20 17.251 20H6.25v-1.5h11.001c.69 0 1.249-.528 1.249-1.219Z"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/viewer-slot.js

const { Slot: ViewerSlot, Fill: ViewerFill } = (0,external_wp_components_namespaceObject.createSlotFill)(
  "BlockEditorLinkControlViewer"
);
var viewer_slot_default = (/* unused pure expression or super */ null && (ViewerSlot));


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-rich-url-data.js



function reducer(state, action) {
  switch (action.type) {
    case "RESOLVED":
      return {
        ...state,
        isFetching: false,
        richData: action.richData
      };
    case "ERROR":
      return {
        ...state,
        isFetching: false,
        richData: null
      };
    case "LOADING":
      return {
        ...state,
        isFetching: true
      };
    default:
      throw new Error(`Unexpected action type ${action.type}`);
  }
}
function useRemoteUrlData(url) {
  const [state, dispatch] = (0,external_wp_element_namespaceObject.useReducer)(reducer, {
    richData: null,
    isFetching: false
  });
  const { fetchRichUrlData } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    return {
      fetchRichUrlData: getSettings().__experimentalFetchRichUrlData
    };
  }, []);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (url?.length && fetchRichUrlData && typeof AbortController !== "undefined") {
      dispatch({
        type: "LOADING"
      });
      const controller = new window.AbortController();
      const signal = controller.signal;
      fetchRichUrlData(url, {
        signal
      }).then((urlData) => {
        dispatch({
          type: "RESOLVED",
          richData: urlData
        });
      }).catch(() => {
        if (!signal.aborted) {
          dispatch({
            type: "ERROR"
          });
        }
      });
      return () => {
        controller.abort();
      };
    }
  }, [url]);
  return state;
}
var use_rich_url_data_default = useRemoteUrlData;


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/link-preview.js













function filterTitleForDisplay(title) {
  return title.replace(/^[a-z\-.\+]+[0-9]*:(\/\/)?/i, "").replace(/^www\./i, "");
}
function LinkPreview({
  value,
  onEditClick,
  hasRichPreviews = false,
  hasUnlinkControl = false,
  onRemove
}) {
  const showIconLabels = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(external_wp_preferences_namespaceObject.store).get("core", "showIconLabels"),
    []
  );
  const showRichPreviews = hasRichPreviews ? value?.url : null;
  const { richData, isFetching } = use_rich_url_data_default(showRichPreviews);
  const hasRichData = richData && Object.keys(richData).length;
  const displayURL = value && (0,external_wp_url_namespaceObject.filterURLForDisplay)((0,external_wp_url_namespaceObject.safeDecodeURI)(value.url), 24) || "";
  const isEmptyURL = !value?.url?.length;
  const displayTitle = !isEmptyURL && (0,external_wp_dom_namespaceObject.__unstableStripHTML)(richData?.title || value?.title || displayURL);
  const isUrlRedundant = !value?.url || filterTitleForDisplay(displayTitle) === displayURL;
  let icon;
  if (richData?.icon) {
    icon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("img", { src: richData?.icon, alt: "" });
  } else if (isEmptyURL) {
    icon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: info_default, size: 32 });
  } else {
    icon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: globe_default });
  }
  const { createNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const ref = (0,external_wp_compose_namespaceObject.useCopyToClipboard)(value.url, () => {
    createNotice("info", (0,external_wp_i18n_namespaceObject.__)("Link copied to clipboard."), {
      isDismissible: true,
      type: "snackbar"
    });
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      role: "group",
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Manage link"),
      className: dist_clsx("block-editor-link-control__search-item", {
        "is-current": true,
        "is-rich": hasRichData,
        "is-fetching": !!isFetching,
        "is-preview": true,
        "is-error": isEmptyURL,
        "is-url-title": displayTitle === displayURL
      }),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-link-control__search-item-top", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          "span",
          {
            className: "block-editor-link-control__search-item-header",
            role: "figure",
            "aria-label": (
              /* translators: Accessibility text for the link preview when editing a link. */
              (0,external_wp_i18n_namespaceObject.__)("Link information")
            ),
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                "span",
                {
                  className: dist_clsx(
                    "block-editor-link-control__search-item-icon",
                    {
                      "is-image": richData?.icon
                    }
                  ),
                  children: icon
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-link-control__search-item-details", children: !isEmptyURL ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.ExternalLink,
                  {
                    className: "block-editor-link-control__search-item-title",
                    href: value.url,
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { numberOfLines: 1, children: displayTitle })
                  }
                ),
                !isUrlRedundant && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-link-control__search-item-info", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { numberOfLines: 1, children: displayURL }) })
              ] }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-link-control__search-item-error-notice", children: (0,external_wp_i18n_namespaceObject.__)("Link is empty") }) })
            ]
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: pencil_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Edit link"),
            onClick: onEditClick,
            size: "compact",
            showTooltip: !showIconLabels
          }
        ),
        hasUnlinkControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: link_off_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Remove link"),
            onClick: onRemove,
            size: "compact",
            showTooltip: !showIconLabels
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: copy_small_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Copy link"),
            ref,
            accessibleWhenDisabled: true,
            disabled: isEmptyURL,
            size: "compact",
            showTooltip: !showIconLabels
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ViewerSlot, { fillProps: value })
      ] })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/settings.js



const settings_noop = () => {
};
const LinkControlSettings = ({ value, onChange = settings_noop, settings }) => {
  if (!settings || !settings.length) {
    return null;
  }
  const handleSettingChange = (setting) => (newValue) => {
    onChange({
      ...value,
      [setting.id]: newValue
    });
  };
  const theSettings = settings.map((setting) => {
    if ("render" in setting) {
      if (typeof setting.render === "function") {
        const renderedContent = setting.render(
          setting,
          value,
          onChange
        );
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "div",
          {
            className: "block-editor-link-control__setting",
            children: renderedContent
          },
          setting.id
        );
      }
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.CheckboxControl,
      {
        __nextHasNoMarginBottom: true,
        className: "block-editor-link-control__setting",
        label: setting.title,
        onChange: handleSettingChange(setting),
        checked: value ? !!value[setting.id] : false,
        help: setting?.help
      },
      setting.id
    );
  }).filter(Boolean);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-link-control__settings", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Currently selected link settings") }),
    theSettings
  ] });
};
var settings_default = LinkControlSettings;


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-create-page.js


function useCreatePage(handleCreatePage) {
  const cancelableCreateSuggestion = (0,external_wp_element_namespaceObject.useRef)();
  const [isCreatingPage, setIsCreatingPage] = (0,external_wp_element_namespaceObject.useState)(false);
  const [errorMessage, setErrorMessage] = (0,external_wp_element_namespaceObject.useState)(null);
  const createPage = async function(suggestionTitle) {
    setIsCreatingPage(true);
    setErrorMessage(null);
    try {
      cancelableCreateSuggestion.current = makeCancelable(
        // Using Promise.resolve to allow createSuggestion to return a
        // non-Promise based value.
        Promise.resolve(handleCreatePage(suggestionTitle))
      );
      return await cancelableCreateSuggestion.current.promise;
    } catch (error) {
      if (error && error.isCanceled) {
        return;
      }
      setErrorMessage(
        error.message || (0,external_wp_i18n_namespaceObject.__)(
          "An unknown error occurred during creation. Please try again."
        )
      );
      throw error;
    } finally {
      setIsCreatingPage(false);
    }
  };
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      if (cancelableCreateSuggestion.current) {
        cancelableCreateSuggestion.current.cancel();
      }
    };
  }, []);
  return {
    createPage,
    isCreatingPage,
    errorMessage
  };
}
const makeCancelable = (promise) => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(
      (val) => hasCanceled_ ? reject({ isCanceled: true }) : resolve(val),
      (error) => hasCanceled_ ? reject({ isCanceled: true }) : reject(error)
    );
  });
  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled_ = true;
    }
  };
};


// EXTERNAL MODULE: ./node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(5215);
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);
;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/use-internal-value.js


function useInternalValue(value) {
  const [internalValue, setInternalValue] = (0,external_wp_element_namespaceObject.useState)(value || {});
  const [previousValue, setPreviousValue] = (0,external_wp_element_namespaceObject.useState)(value);
  if (!fast_deep_equal_default()(value, previousValue)) {
    setPreviousValue(value);
    setInternalValue(value);
  }
  const setInternalURLInputValue = (nextValue) => {
    setInternalValue({
      ...internalValue,
      url: nextValue
    });
  };
  const setInternalTextInputValue = (nextValue) => {
    setInternalValue({
      ...internalValue,
      title: nextValue
    });
  };
  const createSetInternalSettingValueHandler = (settingsKeys) => (nextValue) => {
    const settingsUpdates = Object.keys(nextValue).reduce(
      (acc, key) => {
        if (settingsKeys.includes(key)) {
          acc[key] = nextValue[key];
        }
        return acc;
      },
      {}
    );
    setInternalValue({
      ...internalValue,
      ...settingsUpdates
    });
  };
  return [
    internalValue,
    setInternalValue,
    setInternalURLInputValue,
    setInternalTextInputValue,
    createSetInternalSettingValueHandler
  ];
}


;// ./node_modules/@wordpress/block-editor/build-module/components/link-control/index.js





















const link_control_noop = () => {
};
const PREFERENCE_SCOPE = "core/block-editor";
const PREFERENCE_KEY = "linkControlSettingsDrawer";
function LinkControl({
  searchInputPlaceholder,
  value,
  settings = DEFAULT_LINK_SETTINGS,
  onChange = link_control_noop,
  onRemove,
  onCancel,
  noDirectEntry = false,
  showSuggestions = true,
  showInitialSuggestions,
  forceIsEditingLink,
  createSuggestion,
  withCreateSuggestion,
  inputValue: propInputValue = "",
  suggestionsQuery = {},
  noURLSuggestion = false,
  createSuggestionButtonText,
  hasRichPreviews = false,
  hasTextControl = false,
  renderControlBottom = null,
  handleEntities = false
}) {
  if (withCreateSuggestion === void 0 && createSuggestion) {
    withCreateSuggestion = true;
  }
  const [settingsOpen, setSettingsOpen] = (0,external_wp_element_namespaceObject.useState)(false);
  const { advancedSettingsPreference } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const prefsStore = select(external_wp_preferences_namespaceObject.store);
    return {
      advancedSettingsPreference: prefsStore.get(PREFERENCE_SCOPE, PREFERENCE_KEY) ?? false
    };
  }, []);
  const { set: setPreference } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_preferences_namespaceObject.store);
  const setSettingsOpenWithPreference = (prefVal) => {
    if (setPreference) {
      setPreference(PREFERENCE_SCOPE, PREFERENCE_KEY, prefVal);
    }
    setSettingsOpen(prefVal);
  };
  const isSettingsOpen = advancedSettingsPreference || settingsOpen;
  const isMountingRef = (0,external_wp_element_namespaceObject.useRef)(true);
  const wrapperNode = (0,external_wp_element_namespaceObject.useRef)();
  const textInputRef = (0,external_wp_element_namespaceObject.useRef)();
  const searchInputRef = (0,external_wp_element_namespaceObject.useRef)();
  const isEndingEditWithFocusRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const settingsKeys = settings.map(({ id }) => id);
  const [
    internalControlValue,
    setInternalControlValue,
    setInternalURLInputValue,
    setInternalTextInputValue,
    createSetInternalSettingValueHandler
  ] = useInternalValue(value);
  const isEntity = handleEntities && !!internalControlValue?.id;
  const baseId = (0,external_wp_compose_namespaceObject.useInstanceId)(LinkControl, "link-control");
  const helpTextId = isEntity ? `${baseId}__help` : null;
  const valueHasChanges = value && !(0,external_wp_isShallowEqual_namespaceObject.isShallowEqualObjects)(internalControlValue, value);
  const [isEditingLink, setIsEditingLink] = (0,external_wp_element_namespaceObject.useState)(
    forceIsEditingLink !== void 0 ? forceIsEditingLink : !value || !value.url
  );
  const { createPage, isCreatingPage, errorMessage } = useCreatePage(createSuggestion);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (forceIsEditingLink === void 0) {
      return;
    }
    setIsEditingLink(forceIsEditingLink);
  }, [forceIsEditingLink]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (isMountingRef.current) {
      return;
    }
    const nextFocusTarget = external_wp_dom_namespaceObject.focus.focusable.find(wrapperNode.current)[0] || wrapperNode.current;
    nextFocusTarget.focus();
    isEndingEditWithFocusRef.current = false;
  }, [isEditingLink, isCreatingPage]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    isMountingRef.current = false;
    return () => {
      isMountingRef.current = true;
    };
  }, []);
  const hasLinkValue = value?.url?.trim()?.length > 0;
  const stopEditing = () => {
    isEndingEditWithFocusRef.current = !!wrapperNode.current?.contains(
      wrapperNode.current.ownerDocument.activeElement
    );
    setIsEditingLink(false);
  };
  const handleSelectSuggestion = (updatedValue) => {
    const nonSettingsChanges = Object.keys(updatedValue).reduce(
      (acc, key) => {
        if (!settingsKeys.includes(key)) {
          acc[key] = updatedValue[key];
        }
        return acc;
      },
      {}
    );
    onChange({
      ...internalControlValue,
      ...nonSettingsChanges,
      // As title is not a setting, it must be manually applied
      // in such a way as to preserve the users changes over
      // any "title" value provided by the "suggestion".
      title: internalControlValue?.title || updatedValue?.title
    });
    stopEditing();
  };
  const handleSubmit = () => {
    if (valueHasChanges) {
      onChange({
        ...value,
        ...internalControlValue,
        url: currentUrlInputValue
      });
    }
    stopEditing();
  };
  const handleSubmitWithEnter = (event) => {
    const { keyCode } = event;
    if (keyCode === external_wp_keycodes_namespaceObject.ENTER && !currentInputIsEmpty) {
      event.preventDefault();
      handleSubmit();
    }
  };
  const resetInternalValues = () => {
    setInternalControlValue(value);
  };
  const handleCancel = (event) => {
    event.preventDefault();
    event.stopPropagation();
    resetInternalValues();
    if (hasLinkValue) {
      stopEditing();
    } else {
      onRemove?.();
    }
    onCancel?.();
  };
  const [shouldFocusSearchInput, setShouldFocusSearchInput] = (0,external_wp_element_namespaceObject.useState)(false);
  const handleUnlink = () => {
    const { id, kind, type, ...restValue } = internalControlValue;
    setInternalControlValue({
      ...restValue,
      id: void 0,
      kind: void 0,
      type: void 0,
      url: void 0
    });
    setShouldFocusSearchInput(true);
  };
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (shouldFocusSearchInput) {
      searchInputRef.current?.focus();
      setShouldFocusSearchInput(false);
    }
  }, [shouldFocusSearchInput]);
  const currentUrlInputValue = propInputValue || internalControlValue?.url || "";
  const currentInputIsEmpty = !currentUrlInputValue?.trim()?.length;
  const shownUnlinkControl = onRemove && value && !isEditingLink && !isCreatingPage;
  const showActions = isEditingLink && hasLinkValue;
  const showTextControl = hasLinkValue && hasTextControl;
  const isEditing = (isEditingLink || !value) && !isCreatingPage;
  const isDisabled = !valueHasChanges || currentInputIsEmpty;
  const showSettings = !!settings?.length && isEditingLink && hasLinkValue;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      tabIndex: -1,
      ref: wrapperNode,
      className: "block-editor-link-control",
      children: [
        isCreatingPage && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-link-control__loading", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {}),
          " ",
          (0,external_wp_i18n_namespaceObject.__)("Creating"),
          "\u2026"
        ] }),
        isEditing && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            "div",
            {
              className: dist_clsx({
                "block-editor-link-control__search-input-wrapper": true,
                "has-text-control": showTextControl,
                "has-actions": showActions
              }),
              children: [
                showTextControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.TextControl,
                  {
                    __nextHasNoMarginBottom: true,
                    ref: textInputRef,
                    className: "block-editor-link-control__field block-editor-link-control__text-content",
                    label: (0,external_wp_i18n_namespaceObject.__)("Text"),
                    value: internalControlValue?.title,
                    onChange: setInternalTextInputValue,
                    onKeyDown: handleSubmitWithEnter,
                    __next40pxDefaultSize: true
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  search_input_default,
                  {
                    ref: searchInputRef,
                    currentLink: value,
                    className: "block-editor-link-control__field block-editor-link-control__search-input",
                    placeholder: searchInputPlaceholder,
                    value: currentUrlInputValue,
                    withCreateSuggestion,
                    onCreateSuggestion: createPage,
                    onChange: setInternalURLInputValue,
                    onSelect: handleSelectSuggestion,
                    showInitialSuggestions,
                    allowDirectEntry: !noDirectEntry,
                    showSuggestions,
                    suggestionsQuery,
                    withURLSuggestion: !noURLSuggestion,
                    createSuggestionButtonText,
                    hideLabelFromVision: !showTextControl,
                    isEntity,
                    suffix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                      SearchSuffixControl,
                      {
                        isEntity,
                        showActions,
                        isDisabled,
                        onUnlink: handleUnlink,
                        onSubmit: handleSubmit,
                        helpTextId
                      }
                    )
                  }
                ),
                isEntity && helpTextId && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  "p",
                  {
                    id: helpTextId,
                    className: "block-editor-link-control__help",
                    children: (0,external_wp_i18n_namespaceObject.sprintf)(
                      /* translators: %s: entity type (e.g., page, post) */
                      (0,external_wp_i18n_namespaceObject.__)("Synced with the selected %s."),
                      internalControlValue?.type || "item"
                    )
                  }
                )
              ]
            }
          ),
          errorMessage && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Notice,
            {
              className: "block-editor-link-control__search-error",
              status: "error",
              isDismissible: false,
              children: errorMessage
            }
          )
        ] }),
        value && !isEditingLink && !isCreatingPage && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          LinkPreview,
          {
            value,
            onEditClick: () => setIsEditingLink(true),
            hasRichPreviews,
            hasUnlinkControl: shownUnlinkControl,
            onRemove: () => {
              onRemove();
              setIsEditingLink(true);
            }
          },
          value?.url
        ),
        showSettings && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-link-control__tools", children: !currentInputIsEmpty && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          settings_drawer_default,
          {
            settingsOpen: isSettingsOpen,
            setSettingsOpen: setSettingsOpenWithPreference,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              settings_default,
              {
                value: internalControlValue,
                settings,
                onChange: createSetInternalSettingValueHandler(
                  settingsKeys
                )
              }
            )
          }
        ) }),
        showActions && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalHStack,
          {
            justify: "right",
            className: "block-editor-link-control__search-actions",
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "tertiary",
                  onClick: handleCancel,
                  children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "primary",
                  onClick: isDisabled ? link_control_noop : handleSubmit,
                  className: "block-editor-link-control__search-submit",
                  "aria-disabled": isDisabled,
                  children: (0,external_wp_i18n_namespaceObject.__)("Apply")
                }
              )
            ]
          }
        ),
        !isCreatingPage && renderControlBottom && renderControlBottom()
      ]
    }
  );
}
function SearchSuffixControl({
  isEntity,
  showActions,
  isDisabled,
  onUnlink,
  onSubmit,
  helpTextId
}) {
  if (isEntity) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        icon: link_off_default,
        onClick: onUnlink,
        "aria-describedby": helpTextId,
        showTooltip: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Unsync and edit"),
        __next40pxDefaultSize: true
      }
    );
  }
  if (showActions) {
    return void 0;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      onClick: isDisabled ? link_control_noop : onSubmit,
      label: (0,external_wp_i18n_namespaceObject.__)("Submit"),
      icon: keyboard_return_default,
      className: "block-editor-link-control__search-submit",
      "aria-disabled": isDisabled,
      size: "small"
    }
  ) });
}
LinkControl.ViewerFill = ViewerFill;
LinkControl.DEFAULT_LINK_SETTINGS = DEFAULT_LINK_SETTINGS;
const DeprecatedExperimentalLinkControl = (props) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalLinkControl", {
    since: "6.8",
    alternative: "wp.blockEditor.LinkControl"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LinkControl, { ...props });
};
DeprecatedExperimentalLinkControl.ViewerFill = LinkControl.ViewerFill;
DeprecatedExperimentalLinkControl.DEFAULT_LINK_SETTINGS = LinkControl.DEFAULT_LINK_SETTINGS;
var link_control_default = LinkControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/media-replace-flow/index.js














const media_replace_flow_noop = () => {
};
let uniqueId = 0;
const MediaReplaceFlow = ({
  mediaURL,
  mediaId,
  mediaIds,
  allowedTypes,
  accept,
  onError,
  onSelect,
  onSelectURL,
  onReset,
  onToggleFeaturedImage,
  useFeaturedImage,
  onFilesUpload = media_replace_flow_noop,
  name = (0,external_wp_i18n_namespaceObject.__)("Replace"),
  createNotice,
  removeNotice,
  children,
  multiple = false,
  addToGallery,
  handleUpload = true,
  popoverProps,
  renderToggle
}) => {
  const { getSettings } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const errorNoticeID = `block-editor/media-replace-flow/error-notice/${++uniqueId}`;
  const onUploadError = (message) => {
    const safeMessage = (0,external_wp_dom_namespaceObject.__unstableStripHTML)(message);
    if (onError) {
      onError(safeMessage);
      return;
    }
    setTimeout(() => {
      createNotice("error", safeMessage, {
        speak: true,
        id: errorNoticeID,
        isDismissible: true
      });
    }, 1e3);
  };
  const selectMedia = (media, closeMenu) => {
    if (useFeaturedImage && onToggleFeaturedImage) {
      onToggleFeaturedImage();
    }
    closeMenu();
    onSelect(media);
    (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("The media file has been replaced"));
    removeNotice(errorNoticeID);
  };
  const uploadFiles = (event, closeMenu) => {
    const files = event.target.files;
    if (!handleUpload) {
      closeMenu();
      return onSelect(files);
    }
    onFilesUpload(files);
    getSettings().mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: ([media]) => {
        selectMedia(media, closeMenu);
      },
      onError: onUploadError
    });
  };
  const openOnArrowDown = (event) => {
    if (event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
      event.preventDefault();
      event.target.click();
    }
  };
  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }
    return allowedTypes.every(
      (allowedType) => allowedType === "image" || allowedType.startsWith("image/")
    );
  };
  const gallery = multiple && onlyAllowsImages();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps,
      contentClassName: "block-editor-media-replace-flow__options",
      renderToggle: ({ isOpen, onToggle }) => {
        if (renderToggle) {
          return renderToggle({
            "aria-expanded": isOpen,
            "aria-haspopup": "true",
            onClick: onToggle,
            onKeyDown: openOnArrowDown,
            children: name
          });
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.ToolbarButton,
          {
            "aria-expanded": isOpen,
            "aria-haspopup": "true",
            onClick: onToggle,
            onKeyDown: openOnArrowDown,
            children: name
          }
        );
      },
      renderContent: ({ onClose }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.NavigableMenu, { className: "block-editor-media-replace-flow__media-upload-menu", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(check_default, { children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              media_upload_default,
              {
                gallery,
                addToGallery,
                multiple,
                value: multiple ? mediaIds : mediaId,
                onSelect: (media) => selectMedia(media, onClose),
                allowedTypes,
                render: ({ open }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.MenuItem,
                  {
                    icon: media_default,
                    onClick: open,
                    children: (0,external_wp_i18n_namespaceObject.__)("Open Media Library")
                  }
                )
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.FormFileUpload,
              {
                onChange: (event) => {
                  uploadFiles(event, onClose);
                },
                accept,
                multiple: !!multiple,
                render: ({ openFileDialog }) => {
                  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.MenuItem,
                    {
                      icon: upload_default,
                      onClick: () => {
                        openFileDialog();
                      },
                      children: (0,external_wp_i18n_namespaceObject._x)("Upload", "verb")
                    }
                  );
                }
              }
            )
          ] }),
          onToggleFeaturedImage && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.MenuItem,
            {
              icon: post_featured_image_default,
              onClick: onToggleFeaturedImage,
              isPressed: useFeaturedImage,
              children: (0,external_wp_i18n_namespaceObject.__)("Use featured image")
            }
          ),
          mediaURL && onReset && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.MenuItem,
            {
              onClick: () => {
                onReset();
                onClose();
              },
              children: (0,external_wp_i18n_namespaceObject.__)("Reset")
            }
          ),
          typeof children === "function" ? children({ onClose }) : children
        ] }),
        onSelectURL && // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("form", { className: "block-editor-media-flow__url-input", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-media-replace-flow__image-url-label", children: (0,external_wp_i18n_namespaceObject.__)("Current media URL:") }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            link_control_default,
            {
              value: { url: mediaURL },
              settings: [],
              showSuggestions: false,
              onChange: ({ url }) => {
                onSelectURL(url);
              },
              searchInputPlaceholder: (0,external_wp_i18n_namespaceObject.__)(
                "Paste or type URL"
              )
            }
          )
        ] })
      ] })
    }
  );
};
var media_replace_flow_default = (0,external_wp_compose_namespaceObject.compose)([
  (0,external_wp_data_namespaceObject.withDispatch)((dispatch) => {
    const { createNotice, removeNotice } = dispatch(external_wp_notices_namespaceObject.store);
    return {
      createNotice,
      removeNotice
    };
  }),
  (0,external_wp_components_namespaceObject.withFilters)("editor.MediaReplaceFlow")
])(MediaReplaceFlow);


;// ./node_modules/@wordpress/block-editor/build-module/components/background-image-control/index.js

















const IMAGE_BACKGROUND_TYPE = "image";
const BACKGROUND_POPOVER_PROPS = {
  placement: "left-start",
  offset: 36,
  shift: true,
  className: "block-editor-global-styles-background-panel__popover"
};
const background_image_control_noop = () => {
};
const focusToggleButton = (containerRef) => {
  window.requestAnimationFrame(() => {
    const [toggleButton] = external_wp_dom_namespaceObject.focus.tabbable.find(containerRef?.current);
    if (!toggleButton) {
      return;
    }
    toggleButton.focus();
  });
};
function backgroundSizeHelpText(value) {
  if (value === "cover" || value === void 0) {
    return (0,external_wp_i18n_namespaceObject.__)("Image covers the space evenly.");
  }
  if (value === "contain") {
    return (0,external_wp_i18n_namespaceObject.__)("Image is contained without distortion.");
  }
  return (0,external_wp_i18n_namespaceObject.__)("Image has a fixed width.");
}
const coordsToBackgroundPosition = (value) => {
  if (!value || isNaN(value.x) && isNaN(value.y)) {
    return void 0;
  }
  const x = isNaN(value.x) ? 0.5 : value.x;
  const y = isNaN(value.y) ? 0.5 : value.y;
  return `${x * 100}% ${y * 100}%`;
};
const backgroundPositionToCoords = (value) => {
  if (!value) {
    return { x: void 0, y: void 0 };
  }
  let [x, y] = value.split(" ").map((v) => parseFloat(v) / 100);
  x = isNaN(x) ? void 0 : x;
  y = isNaN(y) ? x : y;
  return { x, y };
};
function InspectorImagePreviewItem({
  as = "span",
  imgUrl,
  toggleProps = {},
  filename,
  label,
  onToggleCallback = background_image_control_noop
}) {
  const { isOpen, ...restToggleProps } = toggleProps;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (typeof isOpen !== "undefined") {
      onToggleCallback(isOpen);
    }
  }, [isOpen, onToggleCallback]);
  const renderPreviewContent = () => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.__experimentalHStack,
      {
        justify: "flex-start",
        as: "span",
        className: "block-editor-global-styles-background-panel__inspector-preview-inner",
        children: [
          imgUrl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            "span",
            {
              className: "block-editor-global-styles-background-panel__inspector-image-indicator-wrapper",
              "aria-hidden": true,
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                "span",
                {
                  className: "block-editor-global-styles-background-panel__inspector-image-indicator",
                  style: {
                    backgroundImage: `url(${imgUrl})`
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.FlexItem, { as: "span", style: imgUrl ? {} : { flexGrow: 1 }, children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalTruncate,
              {
                numberOfLines: 1,
                className: "block-editor-global-styles-background-panel__inspector-media-replace-title",
                children: label
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "span", children: imgUrl ? (0,external_wp_i18n_namespaceObject.sprintf)(
              /* translators: %s: file name */
              (0,external_wp_i18n_namespaceObject.__)("Background image: %s"),
              filename || label
            ) : (0,external_wp_i18n_namespaceObject.__)("No background image selected") })
          ] })
        ]
      }
    );
  };
  return as === "button" ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { __next40pxDefaultSize: true, ...restToggleProps, children: renderPreviewContent() }) : renderPreviewContent();
}
function BackgroundControlsPanel({
  label,
  filename,
  url: imgUrl,
  children,
  onToggle: onToggleCallback = background_image_control_noop,
  hasImageValue,
  onReset,
  containerRef
}) {
  if (!hasImageValue) {
    return;
  }
  const imgLabel = label || (0,external_wp_url_namespaceObject.getFilename)(imgUrl) || (0,external_wp_i18n_namespaceObject.__)("Add background image");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps: BACKGROUND_POPOVER_PROPS,
      renderToggle: ({ onToggle, isOpen }) => {
        const toggleProps = {
          onClick: onToggle,
          className: "block-editor-global-styles-background-panel__dropdown-toggle",
          "aria-expanded": isOpen,
          "aria-label": (0,external_wp_i18n_namespaceObject.__)(
            "Background size, position and repeat options."
          ),
          isOpen
        };
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            InspectorImagePreviewItem,
            {
              imgUrl,
              filename,
              label: imgLabel,
              toggleProps,
              as: "button",
              onToggleCallback
            }
          ),
          onReset && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              __next40pxDefaultSize: true,
              label: (0,external_wp_i18n_namespaceObject.__)("Reset"),
              className: "block-editor-global-styles-background-panel__reset",
              size: "small",
              icon: reset_default,
              onClick: () => {
                onReset();
                if (isOpen) {
                  onToggle();
                }
                focusToggleButton(containerRef);
              }
            }
          )
        ] });
      },
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalDropdownContentWrapper,
        {
          className: "block-editor-global-styles-background-panel__dropdown-content-wrapper",
          paddingSize: "medium",
          children
        }
      )
    }
  );
}
function LoadingSpinner() {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Placeholder, { className: "block-editor-global-styles-background-panel__loading", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {}) });
}
function BackgroundImageControls({
  onChange,
  style,
  inheritedValue,
  onRemoveImage = background_image_control_noop,
  onResetImage = background_image_control_noop,
  displayInPanel,
  defaultValues,
  containerRef
}) {
  const [isUploading, setIsUploading] = (0,external_wp_element_namespaceObject.useState)(false);
  const { getSettings } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { id, title, url } = style?.background?.backgroundImage || {
    ...inheritedValue?.background?.backgroundImage
  };
  const { createErrorNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const onUploadError = (message) => {
    createErrorNotice(message, { type: "snackbar" });
    setIsUploading(false);
  };
  const resetBackgroundImage = () => onChange(
    setImmutably(
      style,
      ["background", "backgroundImage"],
      void 0
    )
  );
  const onSelectMedia = (media) => {
    if (!media || !media.url) {
      resetBackgroundImage();
      setIsUploading(false);
      return;
    }
    if ((0,external_wp_blob_namespaceObject.isBlobURL)(media.url)) {
      setIsUploading(true);
      return;
    }
    if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
      onUploadError(
        (0,external_wp_i18n_namespaceObject.__)("Only images can be used as a background image.")
      );
      return;
    }
    const sizeValue = style?.background?.backgroundSize || defaultValues?.backgroundSize;
    const positionValue = style?.background?.backgroundPosition;
    onChange(
      setImmutably(style, ["background"], {
        ...style?.background,
        backgroundImage: {
          url: media.url,
          id: media.id,
          source: "file",
          title: media.title || void 0
        },
        backgroundPosition: (
          /*
           * A background image uploaded and set in the editor receives a default background position of '50% 0',
           * when the background image size is the equivalent of "Tile".
           * This is to increase the chance that the image's focus point is visible.
           * This is in-editor only to assist with the user experience.
           */
          !positionValue && ("auto" === sizeValue || !sizeValue) ? "50% 0" : positionValue
        ),
        backgroundSize: sizeValue
      })
    );
    setIsUploading(false);
    focusToggleButton(containerRef);
  };
  const onFilesDrop = (filesList) => {
    getSettings().mediaUpload({
      allowedTypes: [IMAGE_BACKGROUND_TYPE],
      filesList,
      onFileChange([image]) {
        onSelectMedia(image);
      },
      onError: onUploadError,
      multiple: false
    });
  };
  const hasValue = hasBackgroundImageValue(style);
  const onRemove = () => onChange(
    setImmutably(style, ["background"], {
      backgroundImage: "none"
    })
  );
  const canRemove = !hasValue && hasBackgroundImageValue(inheritedValue);
  const imgLabel = title || (0,external_wp_url_namespaceObject.getFilename)(url) || (0,external_wp_i18n_namespaceObject.__)("Add background image");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-global-styles-background-panel__image-tools-panel-item", children: [
    isUploading && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LoadingSpinner, {}),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      media_replace_flow_default,
      {
        mediaId: id,
        mediaURL: url,
        allowedTypes: [IMAGE_BACKGROUND_TYPE],
        accept: "image/*",
        onSelect: onSelectMedia,
        popoverProps: {
          className: dist_clsx({
            "block-editor-global-styles-background-panel__media-replace-popover": displayInPanel
          })
        },
        name: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          InspectorImagePreviewItem,
          {
            imgUrl: url,
            filename: title,
            label: imgLabel
          }
        ),
        renderToggle: (props) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { ...props, __next40pxDefaultSize: true }),
        onError: onUploadError,
        onReset: () => {
          focusToggleButton(containerRef);
          onResetImage();
        },
        children: canRemove && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.MenuItem,
          {
            onClick: () => {
              focusToggleButton(containerRef);
              onRemove();
              onRemoveImage();
            },
            children: (0,external_wp_i18n_namespaceObject.__)("Remove")
          }
        )
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.DropZone,
      {
        onFilesDrop,
        label: (0,external_wp_i18n_namespaceObject.__)("Drop to upload")
      }
    )
  ] });
}
function BackgroundSizeControls({
  onChange,
  style,
  inheritedValue,
  defaultValues
}) {
  const sizeValue = style?.background?.backgroundSize || inheritedValue?.background?.backgroundSize;
  const repeatValue = style?.background?.backgroundRepeat || inheritedValue?.background?.backgroundRepeat;
  const imageValue = style?.background?.backgroundImage?.url || inheritedValue?.background?.backgroundImage?.url;
  const isUploadedImage = style?.background?.backgroundImage?.id;
  const positionValue = style?.background?.backgroundPosition || inheritedValue?.background?.backgroundPosition;
  const attachmentValue = style?.background?.backgroundAttachment || inheritedValue?.background?.backgroundAttachment;
  let currentValueForToggle = !sizeValue && isUploadedImage ? defaultValues?.backgroundSize : sizeValue || "auto";
  currentValueForToggle = !["cover", "contain", "auto"].includes(
    currentValueForToggle
  ) ? "auto" : currentValueForToggle;
  const repeatCheckedValue = !(repeatValue === "no-repeat" || currentValueForToggle === "cover" && repeatValue === void 0);
  const updateBackgroundSize = (next) => {
    let nextRepeat = repeatValue;
    let nextPosition = positionValue;
    if (next === "contain") {
      nextRepeat = "no-repeat";
      nextPosition = void 0;
    }
    if (next === "cover") {
      nextRepeat = void 0;
      nextPosition = void 0;
    }
    if ((currentValueForToggle === "cover" || currentValueForToggle === "contain") && next === "auto") {
      nextRepeat = void 0;
      if (!!style?.background?.backgroundImage?.id) {
        nextPosition = "50% 0";
      }
    }
    if (!next && currentValueForToggle === "auto") {
      next = "auto";
    }
    onChange(
      setImmutably(style, ["background"], {
        ...style?.background,
        backgroundPosition: nextPosition,
        backgroundRepeat: nextRepeat,
        backgroundSize: next
      })
    );
  };
  const updateBackgroundPosition = (next) => {
    onChange(
      setImmutably(
        style,
        ["background", "backgroundPosition"],
        coordsToBackgroundPosition(next)
      )
    );
  };
  const toggleIsRepeated = () => onChange(
    setImmutably(
      style,
      ["background", "backgroundRepeat"],
      repeatCheckedValue === true ? "no-repeat" : "repeat"
    )
  );
  const toggleScrollWithPage = () => onChange(
    setImmutably(
      style,
      ["background", "backgroundAttachment"],
      attachmentValue === "fixed" ? "scroll" : "fixed"
    )
  );
  const backgroundPositionValue = !positionValue && isUploadedImage && "contain" === sizeValue ? defaultValues?.backgroundPosition : positionValue;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 3, className: "single-column", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.FocalPointPicker,
      {
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Focal point"),
        url: imageValue,
        value: backgroundPositionToCoords(backgroundPositionValue),
        onChange: updateBackgroundPosition
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToggleControl,
      {
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Fixed background"),
        checked: attachmentValue === "fixed",
        onChange: toggleScrollWithPage
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.__experimentalToggleGroupControl,
      {
        __nextHasNoMarginBottom: true,
        size: "__unstable-large",
        label: (0,external_wp_i18n_namespaceObject.__)("Size"),
        value: currentValueForToggle,
        onChange: updateBackgroundSize,
        isBlock: true,
        help: backgroundSizeHelpText(
          sizeValue || defaultValues?.backgroundSize
        ),
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
            {
              value: "cover",
              label: (0,external_wp_i18n_namespaceObject._x)(
                "Cover",
                "Size option for background image control"
              )
            },
            "cover"
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
            {
              value: "contain",
              label: (0,external_wp_i18n_namespaceObject._x)(
                "Contain",
                "Size option for background image control"
              )
            },
            "contain"
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
            {
              value: "auto",
              label: (0,external_wp_i18n_namespaceObject._x)(
                "Tile",
                "Size option for background image control"
              )
            },
            "tile"
          )
        ]
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "flex-start", spacing: 2, as: "span", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalUnitControl,
        {
          "aria-label": (0,external_wp_i18n_namespaceObject.__)("Background image width"),
          onChange: updateBackgroundSize,
          value: sizeValue,
          size: "__unstable-large",
          __unstableInputWidth: "100px",
          min: 0,
          placeholder: (0,external_wp_i18n_namespaceObject.__)("Auto"),
          disabled: currentValueForToggle !== "auto" || currentValueForToggle === void 0
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ToggleControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Repeat"),
          checked: repeatCheckedValue,
          onChange: toggleIsRepeated,
          disabled: currentValueForToggle === "cover"
        }
      )
    ] })
  ] });
}
function BackgroundImagePanel({
  value,
  onChange,
  inheritedValue = value,
  settings,
  defaultValues = {}
}) {
  const { globalStyles, _links } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    const _settings = getSettings();
    return {
      globalStyles: _settings[globalStylesDataKey],
      _links: _settings[globalStylesLinksDataKey]
    };
  }, []);
  const resolvedInheritedValue = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const resolvedValues = {
      background: {}
    };
    if (!inheritedValue?.background) {
      return inheritedValue;
    }
    Object.entries(inheritedValue?.background).forEach(
      ([key, backgroundValue]) => {
        resolvedValues.background[key] = getResolvedValue(
          backgroundValue,
          {
            styles: globalStyles,
            _links
          }
        );
      }
    );
    return resolvedValues;
  }, [globalStyles, _links, inheritedValue]);
  const resetBackground = () => onChange(setImmutably(value, ["background"], {}));
  const { title, url } = value?.background?.backgroundImage || {
    ...resolvedInheritedValue?.background?.backgroundImage
  };
  const hasImageValue = hasBackgroundImageValue(value) || hasBackgroundImageValue(resolvedInheritedValue);
  const imageValue = value?.background?.backgroundImage || inheritedValue?.background?.backgroundImage;
  const shouldShowBackgroundImageControls = hasImageValue && "none" !== imageValue && (settings?.background?.backgroundSize || settings?.background?.backgroundPosition || settings?.background?.backgroundRepeat);
  const [isDropDownOpen, setIsDropDownOpen] = (0,external_wp_element_namespaceObject.useState)(false);
  const containerRef = (0,external_wp_element_namespaceObject.useRef)();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      ref: containerRef,
      className: dist_clsx(
        "block-editor-global-styles-background-panel__inspector-media-replace-container",
        {
          "is-open": isDropDownOpen
        }
      ),
      children: shouldShowBackgroundImageControls ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BackgroundControlsPanel,
        {
          label: title,
          filename: title,
          url,
          onToggle: setIsDropDownOpen,
          hasImageValue,
          onReset: resetBackground,
          containerRef,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 3, className: "single-column", children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BackgroundImageControls,
              {
                onChange,
                style: value,
                inheritedValue: resolvedInheritedValue,
                displayInPanel: true,
                onResetImage: () => {
                  setIsDropDownOpen(false);
                  resetBackground();
                },
                onRemoveImage: () => setIsDropDownOpen(false),
                defaultValues,
                containerRef
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BackgroundSizeControls,
              {
                onChange,
                style: value,
                defaultValues,
                inheritedValue: resolvedInheritedValue
              }
            )
          ] })
        }
      ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BackgroundImageControls,
        {
          onChange,
          style: value,
          inheritedValue: resolvedInheritedValue,
          defaultValues,
          onResetImage: () => {
            setIsDropDownOpen(false);
            resetBackground();
          },
          onRemoveImage: () => setIsDropDownOpen(false),
          containerRef
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/background-panel.js







const background_panel_DEFAULT_CONTROLS = {
  backgroundImage: true
};
function useHasBackgroundPanel(settings) {
  return external_wp_element_namespaceObject.Platform.OS === "web" && settings?.background?.backgroundImage;
}
function hasBackgroundSizeValue(style) {
  return style?.background?.backgroundPosition !== void 0 || style?.background?.backgroundSize !== void 0;
}
function hasBackgroundImageValue(style) {
  return !!style?.background?.backgroundImage?.id || // Supports url() string values in theme.json.
  "string" === typeof style?.background?.backgroundImage || !!style?.background?.backgroundImage?.url;
}
function BackgroundToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  headerLabel
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: headerLabel,
      resetAll,
      panelId,
      dropdownMenuProps,
      children
    }
  );
}
function background_panel_BackgroundImagePanel({
  as: Wrapper = BackgroundToolsPanel,
  value,
  onChange,
  inheritedValue,
  settings,
  panelId,
  defaultControls = background_panel_DEFAULT_CONTROLS,
  defaultValues = {},
  headerLabel = (0,external_wp_i18n_namespaceObject.__)("Background image")
}) {
  const showBackgroundImageControl = useHasBackgroundPanel(settings);
  const resetBackground = () => onChange(setImmutably(value, ["background"], {}));
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      background: {}
    };
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      headerLabel,
      children: showBackgroundImageControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        {
          hasValue: () => !!value?.background,
          label: (0,external_wp_i18n_namespaceObject.__)("Image"),
          onDeselect: resetBackground,
          isShownByDefault: defaultControls.backgroundImage,
          panelId,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BackgroundImagePanel,
            {
              value,
              onChange,
              settings,
              inheritedValue,
              defaultControls,
              defaultValues
            }
          )
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/background.js









const BACKGROUND_SUPPORT_KEY = "background";
const BACKGROUND_BLOCK_DEFAULT_VALUES = {
  backgroundSize: "cover",
  backgroundPosition: "50% 50%"
  // used only when backgroundSize is 'contain'.
};
function hasBackgroundSupport(blockName, feature = "any") {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, BACKGROUND_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === "any") {
    return !!support?.backgroundImage || !!support?.backgroundSize || !!support?.backgroundRepeat;
  }
  return !!support?.[feature];
}
function setBackgroundStyleDefaults(backgroundStyle) {
  if (!backgroundStyle || !backgroundStyle?.backgroundImage?.url) {
    return;
  }
  let backgroundStylesWithDefaults;
  if (!backgroundStyle?.backgroundSize) {
    backgroundStylesWithDefaults = {
      backgroundSize: BACKGROUND_BLOCK_DEFAULT_VALUES.backgroundSize
    };
  }
  if ("contain" === backgroundStyle?.backgroundSize && !backgroundStyle?.backgroundPosition) {
    backgroundStylesWithDefaults = {
      backgroundPosition: BACKGROUND_BLOCK_DEFAULT_VALUES.backgroundPosition
    };
  }
  return backgroundStylesWithDefaults;
}
function background_useBlockProps({ name, style }) {
  if (!hasBackgroundSupport(name) || !style?.background?.backgroundImage) {
    return;
  }
  const backgroundStyles = setBackgroundStyleDefaults(style?.background);
  if (!backgroundStyles) {
    return;
  }
  return {
    style: {
      ...backgroundStyles
    }
  };
}
function getBackgroundImageClasses(style) {
  return hasBackgroundImageValue(style) ? "has-background" : "";
}
function BackgroundInspectorControl({ children }) {
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((attributes) => {
    return {
      ...attributes,
      style: {
        ...attributes.style,
        background: void 0
      }
    };
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "background", resetAllFilter, children });
}
function background_BackgroundImagePanel({
  clientId,
  name,
  setAttributes,
  settings
}) {
  const { style, inheritedValue } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes, getSettings } = select(store);
      const _settings = getSettings();
      return {
        style: getBlockAttributes(clientId)?.style,
        /*
         * To ensure we pass down the right inherited values:
         * @TODO 1. Pass inherited value down to all block style controls,
         *   See: packages/block-editor/src/hooks/style.js
         * @TODO 2. Add support for block style variations,
         *   See implementation: packages/block-editor/src/hooks/block-style-variation.js
         */
        inheritedValue: _settings[globalStylesDataKey]?.blocks?.[name]
      };
    },
    [clientId, name]
  );
  if (!useHasBackgroundPanel(settings) || !hasBackgroundSupport(name, "backgroundImage")) {
    return null;
  }
  const onChange = (newStyle) => {
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  const updatedSettings = {
    ...settings,
    background: {
      ...settings.background,
      backgroundSize: settings?.background?.backgroundSize && hasBackgroundSupport(name, "backgroundSize")
    }
  };
  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    BACKGROUND_SUPPORT_KEY,
    "defaultControls"
  ]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    background_panel_BackgroundImagePanel,
    {
      inheritedValue,
      as: BackgroundInspectorControl,
      panelId: clientId,
      defaultValues: BACKGROUND_BLOCK_DEFAULT_VALUES,
      settings: updatedSettings,
      onChange,
      defaultControls,
      value: style
    }
  );
}
var background_default = {
  useBlockProps: background_useBlockProps,
  attributeKeys: ["style"],
  hasSupport: hasBackgroundSupport
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/lock.js

function lock_addAttribute(settings) {
  if ("type" in (settings.attributes?.lock ?? {})) {
    return settings;
  }
  settings.attributes = {
    ...settings.attributes,
    lock: {
      type: "object"
    }
  };
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)("blocks.registerBlockType", "core/lock/addAttribute", lock_addAttribute);


;// ./node_modules/@wordpress/icons/build-module/library/block-default.js


var block_default_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js





function BlockIcon({ icon, showColors = false, className, context }) {
  if (icon?.src === "block-default") {
    icon = {
      src: block_default_default
    };
  }
  const renderedIcon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Icon, { icon: icon && icon.src ? icon.src : icon, context });
  const style = showColors ? {
    backgroundColor: icon && icon.background,
    color: icon && icon.foreground
  } : {};
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "span",
    {
      style,
      className: dist_clsx("block-editor-block-icon", className, {
        "has-colors": showColors
      }),
      children: renderedIcon
    }
  );
}
var block_icon_default = (0,external_wp_element_namespaceObject.memo)(BlockIcon);


;// ./node_modules/@wordpress/block-editor/build-module/components/block-manager/checklist.js



function BlockTypesChecklist({ blockTypes, value, onItemChange }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("ul", { className: "block-editor-block-manager__checklist", children: blockTypes.map((blockType) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "li",
    {
      className: "block-editor-block-manager__checklist-item",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.CheckboxControl,
          {
            __nextHasNoMarginBottom: true,
            label: blockType.title,
            checked: value.includes(blockType.name),
            onChange: (...args) => onItemChange(blockType, ...args)
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: blockType.icon })
      ]
    },
    blockType.name
  )) });
}
var checklist_default = BlockTypesChecklist;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-manager/category.js





function BlockManagerCategory({
  title,
  blockTypes,
  selectedBlockTypes,
  onChange
}) {
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockManagerCategory);
  const toggleVisible = (0,external_wp_element_namespaceObject.useCallback)(
    (blockType, nextIsChecked) => {
      if (nextIsChecked) {
        onChange([...selectedBlockTypes, blockType]);
      } else {
        onChange(
          selectedBlockTypes.filter(
            ({ name }) => name !== blockType.name
          )
        );
      }
    },
    [selectedBlockTypes, onChange]
  );
  const toggleAllVisible = (0,external_wp_element_namespaceObject.useCallback)(
    (nextIsChecked) => {
      if (nextIsChecked) {
        onChange([
          ...selectedBlockTypes,
          ...blockTypes.filter(
            (blockType) => !selectedBlockTypes.find(
              ({ name }) => name === blockType.name
            )
          )
        ]);
      } else {
        onChange(
          selectedBlockTypes.filter(
            (selectedBlockType) => !blockTypes.find(
              ({ name }) => name === selectedBlockType.name
            )
          )
        );
      }
    },
    [blockTypes, selectedBlockTypes, onChange]
  );
  if (!blockTypes.length) {
    return null;
  }
  const checkedBlockNames = blockTypes.map(({ name }) => name).filter(
    (type) => (selectedBlockTypes ?? []).some(
      (selectedBlockType) => selectedBlockType.name === type
    )
  );
  const titleId = "block-editor-block-manager__category-title-" + instanceId;
  const isAllChecked = checkedBlockNames.length === blockTypes.length;
  const isIndeterminate = !isAllChecked && checkedBlockNames.length > 0;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      role: "group",
      "aria-labelledby": titleId,
      className: "block-editor-block-manager__category",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.CheckboxControl,
          {
            __nextHasNoMarginBottom: true,
            checked: isAllChecked,
            onChange: toggleAllVisible,
            className: "block-editor-block-manager__category-title",
            indeterminate: isIndeterminate,
            label: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { id: titleId, children: title })
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          checklist_default,
          {
            blockTypes,
            value: checkedBlockNames,
            onItemChange: toggleVisible
          }
        )
      ]
    }
  );
}
var category_category_default = BlockManagerCategory;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-manager/index.js









function BlockManager({
  blockTypes,
  selectedBlockTypes,
  onChange,
  showSelectAll = true
}) {
  const debouncedSpeak = (0,external_wp_compose_namespaceObject.useDebounce)(external_wp_a11y_namespaceObject.speak, 500);
  const [search, setSearch] = (0,external_wp_element_namespaceObject.useState)("");
  const { categories, isMatchingSearchTerm } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    return {
      categories: select(external_wp_blocks_namespaceObject.store).getCategories(),
      isMatchingSearchTerm: select(external_wp_blocks_namespaceObject.store).isMatchingSearchTerm
    };
  }, []);
  const filteredBlockTypes = blockTypes.filter((blockType) => {
    return !search || isMatchingSearchTerm(blockType, search);
  });
  const isIndeterminate = selectedBlockTypes.length > 0 && selectedBlockTypes.length !== blockTypes.length;
  const isAllChecked = blockTypes.length > 0 && selectedBlockTypes.length === blockTypes.length;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!search) {
      return;
    }
    const count = filteredBlockTypes.length;
    const resultsFoundMessage = (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %d: number of results. */
      (0,external_wp_i18n_namespaceObject._n)("%d result found.", "%d results found.", count),
      count
    );
    debouncedSpeak(resultsFoundMessage);
  }, [filteredBlockTypes?.length, search, debouncedSpeak]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { className: "block-editor-block-manager__content", spacing: 4, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.SearchControl,
      {
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Search for a block"),
        placeholder: (0,external_wp_i18n_namespaceObject.__)("Search for a block"),
        value: search,
        onChange: (nextSearch) => setSearch(nextSearch),
        className: "block-editor-block-manager__search"
      }
    ),
    showSelectAll && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.CheckboxControl,
      {
        className: "block-editor-block-manager__select-all",
        label: (0,external_wp_i18n_namespaceObject.__)("Select all"),
        checked: isAllChecked,
        onChange: () => {
          if (isAllChecked) {
            onChange([]);
          } else {
            onChange(blockTypes);
          }
        },
        indeterminate: isIndeterminate,
        __nextHasNoMarginBottom: true
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      "div",
      {
        tabIndex: "0",
        role: "region",
        "aria-label": (0,external_wp_i18n_namespaceObject.__)("Available block types"),
        className: "block-editor-block-manager__results",
        children: [
          filteredBlockTypes.length === 0 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-block-manager__no-results", children: (0,external_wp_i18n_namespaceObject.__)("No blocks found.") }),
          categories.map((category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            category_category_default,
            {
              title: category.title,
              blockTypes: filteredBlockTypes.filter(
                (blockType) => blockType.category === category.slug
              ),
              selectedBlockTypes,
              onChange
            },
            category.slug
          )),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            category_category_default,
            {
              title: (0,external_wp_i18n_namespaceObject.__)("Uncategorized"),
              blockTypes: filteredBlockTypes.filter(
                ({ category }) => !category
              ),
              selectedBlockTypes,
              onChange
            }
          )
        ]
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-allowed-blocks/modal.js







function BlockAllowedBlocksModal({
  clientId,
  blockTypes,
  selectedBlockTypes,
  onClose
}) {
  const [currentSelectedBlockTypes, setCurrentSelectedBlockTypes] = (0,external_wp_element_namespaceObject.useState)(selectedBlockTypes);
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const handleSubmit = () => {
    const isFullySelected = currentSelectedBlockTypes.length === blockTypes.length;
    const newBlockNames = currentSelectedBlockTypes.map(
      ({ name }) => name
    );
    updateBlockAttributes(clientId, {
      allowedBlocks: isFullySelected ? void 0 : newBlockNames
    });
    onClose();
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.__)("Manage allowed blocks"),
      onRequestClose: onClose,
      overlayClassName: "block-editor-block-allowed-blocks-modal",
      focusOnMount: "firstContentElement",
      size: "medium",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        external_wp_components_namespaceObject.__experimentalVStack,
        {
          as: "form",
          onSubmit: (e) => {
            e.preventDefault();
            handleSubmit();
          },
          spacing: "4",
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { children: (0,external_wp_i18n_namespaceObject.__)(
              "Select which blocks can be added inside this container."
            ) }),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BlockManager,
              {
                blockTypes,
                selectedBlockTypes: currentSelectedBlockTypes,
                onChange: (newSelectedBlockTypes) => {
                  setCurrentSelectedBlockTypes(newSelectedBlockTypes);
                }
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
              external_wp_components_namespaceObject.Flex,
              {
                className: "block-editor-block-allowed-blocks-modal__actions",
                justify: "flex-end",
                expanded: false,
                children: [
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.Button,
                    {
                      variant: "tertiary",
                      onClick: onClose,
                      __next40pxDefaultSize: true,
                      children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
                    }
                  ) }),
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.Button,
                    {
                      variant: "primary",
                      type: "submit",
                      __next40pxDefaultSize: true,
                      children: (0,external_wp_i18n_namespaceObject.__)("Apply")
                    }
                  ) })
                ]
              }
            )
          ]
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-allowed-blocks/allowed-blocks-control.js








function BlockAllowedBlocksControl({ clientId }) {
  const [isBlockControlOpened, setIsBlockControlOpened] = (0,external_wp_element_namespaceObject.useState)(false);
  const { blockTypes, selectedBlockNames } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes } = select(store);
      return {
        blockTypes: select(external_wp_blocks_namespaceObject.store).getBlockTypes(),
        selectedBlockNames: getBlockAttributes(clientId)?.allowedBlocks
      };
    },
    [clientId]
  );
  const filteredBlockTypes = blockTypes.filter(
    (blockType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "inserter", true) && (!blockType.parent || blockType.parent.includes("core/post-content"))
  );
  if (!filteredBlockTypes) {
    return null;
  }
  const selectedBlockTypes = selectedBlockNames === void 0 ? filteredBlockTypes : filteredBlockTypes.filter(
    (blockType) => selectedBlockNames.includes(blockType.name)
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-allowed-blocks-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.BaseControl,
      {
        help: (0,external_wp_i18n_namespaceObject.__)(
          "Specify which blocks are allowed inside this container."
        ),
        __nextHasNoMarginBottom: true,
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { children: (0,external_wp_i18n_namespaceObject.__)("Allowed Blocks") }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              __next40pxDefaultSize: true,
              variant: "secondary",
              onClick: () => {
                setIsBlockControlOpened(true);
              },
              className: "block-editor-block-allowed-blocks-control__button",
              children: (0,external_wp_i18n_namespaceObject.__)("Manage allowed blocks")
            }
          )
        ]
      }
    ),
    isBlockControlOpened && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockAllowedBlocksModal,
      {
        clientId,
        blockTypes: filteredBlockTypes,
        selectedBlockTypes,
        onClose: () => setIsBlockControlOpened(false)
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/allowed-blocks.js







function BlockEditAllowedBlocksControlPure({ clientId }) {
  const isContentOnly = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return select(store).getBlockEditingMode(clientId) === "contentOnly";
    },
    [clientId]
  );
  if (isContentOnly) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PrivateInspectorControlsAllowedBlocks.Fill, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockAllowedBlocksControl, { clientId }) });
}
var allowed_blocks_default = {
  edit: BlockEditAllowedBlocksControlPure,
  attributeKeys: ["allowedBlocks"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "allowedBlocks");
  }
};
function allowed_blocks_addAttribute(settings) {
  if (settings?.attributes?.allowedBlocks?.type) {
    return settings;
  }
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "allowedBlocks")) {
    settings.attributes = {
      ...settings.attributes,
      allowedBlocks: {
        type: "array"
      }
    };
  }
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/allowedBlocks/attribute",
  allowed_blocks_addAttribute
);
function addTransforms(result, source, index, results) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(result.name, "allowedBlocks")) {
    return result;
  }
  if (source.length !== 1 && results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }
  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  }
  if (results.length > 1 && source.length > 1 && results.length !== source.length) {
    return result;
  }
  if (result.attributes.allowedBlocks) {
    return result;
  }
  const sourceAllowedBlocks = source[index]?.attributes?.allowedBlocks;
  if (!sourceAllowedBlocks) {
    return result;
  }
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(result.name);
  const destinationAllowedBlocks = blockType?.allowedBlocks || [];
  if (!destinationAllowedBlocks.length) {
    return {
      ...result,
      attributes: {
        ...result.attributes,
        allowedBlocks: sourceAllowedBlocks
      }
    };
  }
  const filteredSourceAllowedBlocks = sourceAllowedBlocks.filter(
    (block) => destinationAllowedBlocks.includes(block)
  );
  return {
    ...result,
    attributes: {
      ...result.attributes,
      allowedBlocks: filteredSourceAllowedBlocks
    }
  };
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.switchToBlockType.transformedBlock",
  "core/allowedBlocks/addTransforms",
  addTransforms
);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/anchor.js








const ANCHOR_REGEX = /[\s#]/g;
const ANCHOR_SCHEMA = {
  type: "string",
  source: "attribute",
  attribute: "id",
  selector: "*"
};
function anchor_addAttribute(settings) {
  if ("type" in (settings.attributes?.anchor ?? {})) {
    return settings;
  }
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "anchor")) {
    settings.attributes = {
      ...settings.attributes,
      anchor: ANCHOR_SCHEMA
    };
  }
  return settings;
}
function BlockEditAnchorControlPure({ anchor, setAttributes }) {
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== "default") {
    return null;
  }
  const isWeb = external_wp_element_namespaceObject.Platform.OS === "web";
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "advanced", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.TextControl,
    {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      className: "html-anchor-control",
      label: (0,external_wp_i18n_namespaceObject.__)("HTML anchor"),
      help: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        (0,external_wp_i18n_namespaceObject.__)(
          "Enter a word or two \u2014 without spaces \u2014 to make a unique web address just for this block, called an \u201Canchor\u201D. Then, you\u2019ll be able to link directly to this section of your page."
        ),
        isWeb && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          " ",
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.ExternalLink,
            {
              href: (0,external_wp_i18n_namespaceObject.__)(
                "https://wordpress.org/documentation/article/page-jumps/"
              ),
              children: (0,external_wp_i18n_namespaceObject.__)("Learn more about anchors")
            }
          )
        ] })
      ] }),
      value: anchor || "",
      placeholder: !isWeb ? (0,external_wp_i18n_namespaceObject.__)("Add an anchor") : null,
      onChange: (nextValue) => {
        nextValue = nextValue.replace(ANCHOR_REGEX, "-");
        setAttributes({
          anchor: nextValue
        });
      },
      autoCapitalize: "none",
      autoComplete: "off"
    }
  ) });
}
var anchor_default = {
  addSaveProps,
  edit: BlockEditAnchorControlPure,
  attributeKeys: ["anchor"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "anchor");
  }
};
function addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "anchor")) {
    extraProps.id = attributes.anchor === "" ? null : attributes.anchor;
  }
  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)("blocks.registerBlockType", "core/anchor/attribute", anchor_addAttribute);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/aria-label.js


function aria_label_addAttribute(settings) {
  if (settings?.attributes?.ariaLabel?.type) {
    return settings;
  }
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "ariaLabel")) {
    settings.attributes = {
      ...settings.attributes,
      ariaLabel: {
        type: "string"
      }
    };
  }
  return settings;
}
function aria_label_addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "ariaLabel")) {
    extraProps["aria-label"] = attributes.ariaLabel === "" ? null : attributes.ariaLabel;
  }
  return extraProps;
}
var aria_label_default = {
  addSaveProps: aria_label_addSaveProps,
  attributeKeys: ["ariaLabel"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "ariaLabel");
  }
};
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/ariaLabel/attribute",
  aria_label_addAttribute
);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/custom-class-name.js








function custom_class_name_addAttribute(settings) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "customClassName", true)) {
    settings.attributes = {
      ...settings.attributes,
      className: {
        type: "string"
      }
    };
  }
  return settings;
}
function CustomClassNameControlsPure({ className, setAttributes }) {
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== "default") {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "advanced", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.TextControl,
    {
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      autoComplete: "off",
      label: (0,external_wp_i18n_namespaceObject.__)("Additional CSS class(es)"),
      value: className || "",
      onChange: (nextValue) => {
        setAttributes({
          className: nextValue !== "" ? nextValue : void 0
        });
      },
      help: (0,external_wp_i18n_namespaceObject.__)("Separate multiple classes with spaces.")
    }
  ) });
}
var custom_class_name_default = {
  edit: CustomClassNameControlsPure,
  addSaveProps: custom_class_name_addSaveProps,
  attributeKeys: ["className"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "customClassName", true);
  }
};
function custom_class_name_addSaveProps(extraProps, blockType, attributes) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "customClassName", true) && attributes.className) {
    extraProps.className = dist_clsx(
      extraProps.className,
      attributes.className
    );
  }
  return extraProps;
}
function custom_class_name_addTransforms(result, source, index, results) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(result.name, "customClassName", true)) {
    return result;
  }
  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }
  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  }
  if (source[index]) {
    const originClassName = source[index]?.attributes.className;
    if (originClassName && result.attributes.className === void 0) {
      return {
        ...result,
        attributes: {
          ...result.attributes,
          className: originClassName
        }
      };
    }
  }
  return result;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/editor/custom-class-name/attribute",
  custom_class_name_addAttribute
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.switchToBlockType.transformedBlock",
  "core/customClassName/addTransforms",
  custom_class_name_addTransforms
);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/generated-class-name.js


function addGeneratedClassName(extraProps, blockType) {
  if ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "className", true)) {
    if (typeof extraProps.className === "string") {
      extraProps.className = [
        .../* @__PURE__ */ new Set([
          (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(blockType.name),
          ...extraProps.className.split(" ")
        ])
      ].join(" ").trim();
    } else {
      extraProps.className = (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(blockType.name);
    }
  }
  return extraProps;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.getSaveContent.extraProps",
  "core/generated-class-name/save-props",
  addGeneratedClassName
);


;// ./node_modules/colord/index.mjs
var colord_r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(colord_r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},colord_j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof colord_j?r:new colord_j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(colord_j,y),S.push(r))})},E=function(){return new colord_j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};

;// ./node_modules/colord/plugins/names.mjs
/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}

;// ./node_modules/colord/plugins/a11y.mjs
var a11y_o=function(o){var t=o/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},a11y_t=function(t){return.2126*a11y_o(t.r)+.7152*a11y_o(t.g)+.0722*a11y_o(t.b)};/* harmony default export */ function a11y(o){o.prototype.luminance=function(){return o=a11y_t(this.rgba),void 0===(r=2)&&(r=0),void 0===n&&(n=Math.pow(10,r)),Math.round(n*o)/n+0;var o,r,n},o.prototype.contrast=function(r){void 0===r&&(r="#FFF");var n,a,i,e,v,u,d,c=r instanceof o?r:new o(r);return e=this.rgba,v=c.toRgb(),u=a11y_t(e),d=a11y_t(v),n=u>d?(u+.05)/(d+.05):(d+.05)/(u+.05),void 0===(a=2)&&(a=0),void 0===i&&(i=Math.pow(10,a)),Math.floor(i*n)/i+0},o.prototype.isReadable=function(o,t){return void 0===o&&(o="#FFF"),void 0===t&&(t={}),this.contrast(o)>=(e=void 0===(i=(r=t).size)?"normal":i,"AAA"===(a=void 0===(n=r.level)?"AA":n)&&"normal"===e?7:"AA"===a&&"large"===e?3:4.5);var r,n,a,i,e}}

;// ./node_modules/@wordpress/block-editor/build-module/components/colors/utils.js





k([names, a11y]);
const { kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
const getColorObjectByAttributeValues = (colors, definedColor, customColor) => {
  if (definedColor) {
    const colorObj = colors?.find(
      (color) => color.slug === definedColor
    );
    if (colorObj) {
      return colorObj;
    }
  }
  return {
    color: customColor
  };
};
const getColorObjectByColorValue = (colors, colorValue) => {
  return colors?.find((color) => color.color === colorValue);
};
function getColorClassName(colorContextName, colorSlug) {
  if (!colorContextName || !colorSlug) {
    return void 0;
  }
  return `has-${kebabCase(colorSlug)}-${colorContextName}`;
}
function getMostReadableColor(colors, colorValue) {
  const colordColor = w(colorValue);
  const getColorContrast = ({ color }) => colordColor.contrast(color);
  const maxContrast = Math.max(...colors.map(getColorContrast));
  return colors.find((color) => getColorContrast(color) === maxContrast).color;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/use-multiple-origin-colors-and-gradients.js



function useMultipleOriginColorsAndGradients() {
  const [
    enableCustomColors,
    customColors,
    themeColors,
    defaultColors,
    shouldDisplayDefaultColors,
    enableCustomGradients,
    customGradients,
    themeGradients,
    defaultGradients,
    shouldDisplayDefaultGradients
  ] = use_settings_useSettings(
    "color.custom",
    "color.palette.custom",
    "color.palette.theme",
    "color.palette.default",
    "color.defaultPalette",
    "color.customGradient",
    "color.gradients.custom",
    "color.gradients.theme",
    "color.gradients.default",
    "color.defaultGradients"
  );
  const colorGradientSettings = {
    disableCustomColors: !enableCustomColors,
    disableCustomGradients: !enableCustomGradients
  };
  colorGradientSettings.colors = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];
    if (themeColors && themeColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Theme",
          "Indicates this palette comes from the theme."
        ),
        slug: "theme",
        colors: themeColors
      });
    }
    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Default",
          "Indicates this palette comes from WordPress."
        ),
        slug: "default",
        colors: defaultColors
      });
    }
    if (customColors && customColors.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Custom",
          "Indicates this palette is created by the user."
        ),
        slug: "custom",
        colors: customColors
      });
    }
    return result;
  }, [
    customColors,
    themeColors,
    defaultColors,
    shouldDisplayDefaultColors
  ]);
  colorGradientSettings.gradients = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = [];
    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Theme",
          "Indicates this palette comes from the theme."
        ),
        slug: "theme",
        gradients: themeGradients
      });
    }
    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Default",
          "Indicates this palette comes from WordPress."
        ),
        slug: "default",
        gradients: defaultGradients
      });
    }
    if (customGradients && customGradients.length) {
      result.push({
        name: (0,external_wp_i18n_namespaceObject._x)(
          "Custom",
          "Indicates this palette is created by the user."
        ),
        slug: "custom",
        gradients: customGradients
      });
    }
    return result;
  }, [
    customGradients,
    themeGradients,
    defaultGradients,
    shouldDisplayDefaultGradients
  ]);
  colorGradientSettings.hasColorsOrGradients = !!colorGradientSettings.colors.length || !!colorGradientSettings.gradients.length;
  return colorGradientSettings;
}


;// ./node_modules/@wordpress/icons/build-module/library/link.js


var link_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M10 17.389H8.444A5.194 5.194 0 1 1 8.444 7H10v1.5H8.444a3.694 3.694 0 0 0 0 7.389H10v1.5ZM14 7h1.556a5.194 5.194 0 0 1 0 10.39H14v-1.5h1.556a3.694 3.694 0 0 0 0-7.39H14V7Zm-4.5 6h5v-1.5h-5V13Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/linked-button.js




function LinkedButton({ isLinked, ...props }) {
  const label = isLinked ? (0,external_wp_i18n_namespaceObject.__)("Unlink radii") : (0,external_wp_i18n_namespaceObject.__)("Link radii");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      ...props,
      className: "components-border-radius-control__linked-button",
      size: "small",
      icon: isLinked ? link_default : link_off_default,
      iconSize: 24,
      label
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/utils.js

function mode(inputArray) {
  const arr = [...inputArray];
  return arr.sort(
    (a, b) => inputArray.filter((v) => v === b).length - inputArray.filter((v) => v === a).length
  ).shift();
}
function getAllUnit(selectedUnits = {}) {
  const { flat, ...cornerUnits } = selectedUnits;
  return flat || mode(Object.values(cornerUnits).filter(Boolean)) || "px";
}
function getAllValue(values = {}) {
  if (typeof values === "string") {
    return values;
  }
  const parsedQuantitiesAndUnits = Object.values(values).map((value2) => {
    const newValue = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value2);
    if (typeof value2 === "string" && newValue[0] === void 0) {
      return [value2, ""];
    }
    return newValue;
  });
  const allValues = parsedQuantitiesAndUnits.map(
    (value2) => value2[0] ?? ""
  );
  const allUnits = parsedQuantitiesAndUnits.map((value2) => value2[1]);
  const value = allValues.every((v) => v === allValues[0]) ? allValues[0] : "";
  const unit = mode(allUnits);
  const allValue = value === 0 || value ? `${value}${unit || ""}` : void 0;
  return allValue;
}
function hasMixedValues(values = {}) {
  if (typeof values === "string") {
    return false;
  }
  if (!values || typeof values !== "object") {
    return false;
  }
  const cornerValues = Object.values(values);
  if (cornerValues.length === 0) {
    return false;
  }
  const firstValue = cornerValues[0];
  const allSame = cornerValues.every((value) => value === firstValue);
  return !allSame;
}
function hasDefinedValues(values) {
  if (!values) {
    return false;
  }
  if (typeof values === "string") {
    return true;
  }
  const filteredValues = Object.values(values).filter((value) => {
    return !!value || value === 0;
  });
  return !!filteredValues.length;
}
function isValuePreset(value) {
  if (!value?.includes) {
    return false;
  }
  return value === "0" || value.includes("var:preset|border-radius|");
}
function getPresetSlug(value) {
  if (!value) {
    return;
  }
  if (value === "0" || value === "default") {
    return value;
  }
  const slug = value.match(/var:preset\|border-radius\|(.+)/);
  return slug ? slug[1] : void 0;
}
function utils_getSliderValueFromPreset(presetValue, presets) {
  if (presetValue === void 0) {
    return 0;
  }
  const slug = parseFloat(presetValue, 10) === 0 ? "0" : getPresetSlug(presetValue);
  const sliderValue = presets.findIndex((size) => {
    return String(size.slug) === slug;
  });
  return sliderValue !== -1 ? sliderValue : NaN;
}
function utils_getCustomValueFromPreset(value, presets) {
  if (!isValuePreset(value)) {
    return value;
  }
  const slug = parseFloat(value, 10) === 0 ? "0" : getPresetSlug(value);
  const radiusSize = presets.find((size) => String(size.slug) === slug);
  return radiusSize?.size;
}
function getPresetValueFromControlValue(controlValue, controlType, presets) {
  const size = parseInt(controlValue, 10);
  if (controlType === "selectList") {
    if (size === 0) {
      return void 0;
    }
  } else if (size === 0) {
    return "0";
  }
  return `var:preset|border-radius|${presets[controlValue]?.slug}`;
}
function utils_getPresetValueFromCustomValue(value, presets) {
  if (!value || isValuePreset(value) || value === "0") {
    return value;
  }
  const spacingMatch = presets.find(
    (size) => String(size.size) === String(value)
  );
  if (spacingMatch?.slug) {
    return `var:preset|border-radius|${spacingMatch.slug}`;
  }
  return value;
}
function convertPresetsToCustomValues(values, presets) {
  if (!values || typeof values !== "object") {
    return values;
  }
  const converted = {};
  Object.keys(values).forEach((key) => {
    const value = values[key];
    if (isValuePreset(value)) {
      const customValue = utils_getCustomValueFromPreset(value, presets);
      converted[key] = customValue !== void 0 ? customValue : value;
    } else {
      converted[key] = value;
    }
  });
  return converted;
}


;// ./node_modules/@wordpress/icons/build-module/library/settings.js


var settings_settings_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m19 7.5h-7.628c-.3089-.87389-1.1423-1.5-2.122-1.5-.97966 0-1.81309.62611-2.12197 1.5h-2.12803v1.5h2.12803c.30888.87389 1.14231 1.5 2.12197 1.5.9797 0 1.8131-.62611 2.122-1.5h7.628z" }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m19 15h-2.128c-.3089-.8739-1.1423-1.5-2.122-1.5s-1.8131.6261-2.122 1.5h-7.628v1.5h7.628c.3089.8739 1.1423 1.5 2.122 1.5s1.8131-.6261 2.122-1.5h2.128z" })
] });


;// ./node_modules/@wordpress/icons/build-module/library/corner-all.js


var corner_all_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5Zm-12.5 9v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z"
  }
) });


;// ./node_modules/@wordpress/icons/build-module/library/corner-top-left.js


var corner_top_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.G, { opacity: ".25", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 5.75a.25.25 0 0 0-.25.25v3h-1.5V6c0-.966.784-1.75 1.75-1.75h3v1.5H6Z"
    }
  )
] });


;// ./node_modules/@wordpress/icons/build-module/library/corner-top-right.js


var corner_top_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.G, { opacity: ".25", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5Z"
    }
  )
] });


;// ./node_modules/@wordpress/icons/build-module/library/corner-bottom-left.js


var corner_bottom_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.G, { opacity: ".25", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.75 15v3c0 .138.112.25.25.25h3v1.5H6A1.75 1.75 0 0 1 4.25 18v-3h1.5Z"
    }
  )
] });


;// ./node_modules/@wordpress/icons/build-module/library/corner-bottom-right.js


var corner_bottom_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.G, { opacity: ".25", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M5.75 6A.25.25 0 0 1 6 5.75h3v-1.5H6A1.75 1.75 0 0 0 4.25 6v3h1.5V6ZM18 18.25h-3v1.5h3A1.75 1.75 0 0 0 19.75 18v-3h-1.5v3a.25.25 0 0 1-.25.25ZM18.25 9V6a.25.25 0 0 0-.25-.25h-3v-1.5h3c.966 0 1.75.784 1.75 1.75v3h-1.5ZM5.75 18v-3h-1.5v3c0 .966.784 1.75 1.75 1.75h3v-1.5H6a.25.25 0 0 1-.25-.25Z" }) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_primitives_namespaceObject.Path,
    {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M15 18.25h3a.25.25 0 0 0 .25-.25v-3h1.5v3A1.75 1.75 0 0 1 18 19.75h-3v-1.5Z"
    }
  )
] });


;// ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/constants.js


const constants_DEFAULT_VALUES = {
  topLeft: void 0,
  topRight: void 0,
  bottomLeft: void 0,
  bottomRight: void 0
};
const constants_RANGE_CONTROL_MAX_SIZE = 8;
const constants_EMPTY_ARRAY = [];
const CORNERS = {
  all: (0,external_wp_i18n_namespaceObject.__)("Border radius"),
  topLeft: (0,external_wp_i18n_namespaceObject.__)("Top left"),
  topRight: (0,external_wp_i18n_namespaceObject.__)("Top right"),
  bottomLeft: (0,external_wp_i18n_namespaceObject.__)("Bottom left"),
  bottomRight: (0,external_wp_i18n_namespaceObject.__)("Bottom right")
};
const constants_ICONS = {
  all: corner_all_default,
  topLeft: corner_top_left_default,
  topRight: corner_top_right_default,
  bottomLeft: corner_bottom_left_default,
  bottomRight: corner_bottom_right_default
};
const MIN_BORDER_RADIUS_VALUE = 0;
const MAX_BORDER_RADIUS_VALUES = {
  px: 100,
  em: 20,
  rem: 20
};


;// ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/single-input-control.js







function SingleInputControl({
  corner,
  onChange,
  selectedUnits,
  setSelectedUnits,
  values: valuesProp,
  units,
  presets
}) {
  const changeCornerValue = (validatedValue) => {
    if (corner === "all") {
      onChange({
        topLeft: validatedValue,
        topRight: validatedValue,
        bottomLeft: validatedValue,
        bottomRight: validatedValue
      });
    } else {
      onChange({
        ...values,
        [corner]: validatedValue
      });
    }
  };
  const onChangeValue = (next) => {
    if (!onChange) {
      return;
    }
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : void 0;
    changeCornerValue(nextValue);
  };
  const onChangeUnit = (next) => {
    const newUnits = { ...selectedUnits };
    if (corner === "all") {
      newUnits.flat = next;
      newUnits.topLeft = next;
      newUnits.topRight = next;
      newUnits.bottomLeft = next;
      newUnits.bottomRight = next;
    } else {
      newUnits[corner] = next;
    }
    setSelectedUnits(newUnits);
  };
  const values = typeof valuesProp !== "string" ? valuesProp : {
    topLeft: valuesProp,
    topRight: valuesProp,
    bottomLeft: valuesProp,
    bottomRight: valuesProp
  };
  let value;
  if (corner === "all") {
    const convertedValues = convertPresetsToCustomValues(values, presets);
    const customValue = getAllValue(convertedValues);
    value = utils_getPresetValueFromCustomValue(customValue, presets);
  } else {
    value = utils_getPresetValueFromCustomValue(values[corner], presets);
  }
  const resolvedPresetValue = isValuePreset(value) ? utils_getCustomValueFromPreset(value, presets) : value;
  const [parsedQuantity, parsedUnit] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(resolvedPresetValue);
  const computedUnit = value ? parsedUnit : selectedUnits[corner] || selectedUnits.flat || "px";
  const unitConfig = units && units.find((item) => item.value === computedUnit);
  const step = unitConfig?.step || 1;
  const [showCustomValueControl, setShowCustomValueControl] = (0,external_wp_element_namespaceObject.useState)(
    value !== void 0 && !isValuePreset(value)
  );
  const showRangeControl = presets.length <= constants_RANGE_CONTROL_MAX_SIZE;
  const presetIndex = utils_getSliderValueFromPreset(value, presets);
  const rangeTooltip = (newValue) => value === void 0 ? void 0 : presets[newValue]?.name;
  const marks = presets.slice(1, presets.length - 1).map((_newValue, index) => ({
    value: index + 1,
    label: void 0
  }));
  const hasPresets = marks.length > 0;
  let options = [];
  if (!showRangeControl) {
    options = [
      ...presets,
      {
        name: (0,external_wp_i18n_namespaceObject.__)("Custom"),
        slug: "custom",
        size: resolvedPresetValue
      }
    ].map((size, index) => ({
      key: index,
      name: size.name
    }));
  }
  const icon = constants_ICONS[corner];
  const handleSliderChange = (next) => {
    const val = next !== void 0 ? `${next}${computedUnit}` : void 0;
    changeCornerValue(val);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { children: [
    icon && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Icon,
      {
        className: "components-border-radius-control__icon",
        icon,
        size: 24
      }
    ),
    (!hasPresets || showCustomValueControl) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "components-border-radius-control__input-controls-wrapper", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tooltip, { text: CORNERS[corner], placement: "top", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "components-border-radius-control__tooltip-wrapper", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalUnitControl,
        {
          className: "components-border-radius-control__unit-control",
          "aria-label": CORNERS[corner],
          value: [parsedQuantity, computedUnit].join(
            ""
          ),
          onChange: onChangeValue,
          onUnitChange: onChangeUnit,
          size: "__unstable-large",
          min: MIN_BORDER_RADIUS_VALUE,
          units
        }
      ) }) }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Border radius"),
          hideLabelFromVision: true,
          className: "components-border-radius-control__range-control",
          value: parsedQuantity ?? "",
          min: MIN_BORDER_RADIUS_VALUE,
          max: MAX_BORDER_RADIUS_VALUES[computedUnit],
          initialPosition: 0,
          withInputField: false,
          onChange: handleSliderChange,
          step,
          __nextHasNoMarginBottom: true
        }
      )
    ] }),
    hasPresets && showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.RangeControl,
      {
        __next40pxDefaultSize: true,
        className: "components-border-radius-control__range-control",
        value: presetIndex,
        onChange: (newSize) => {
          changeCornerValue(
            getPresetValueFromControlValue(
              newSize,
              "range",
              presets
            )
          );
        },
        withInputField: false,
        "aria-valuenow": presetIndex,
        "aria-valuetext": presets[presetIndex]?.name,
        renderTooltipContent: rangeTooltip,
        min: 0,
        max: presets.length - 1,
        marks,
        label: CORNERS[corner],
        hideLabelFromVision: true,
        __nextHasNoMarginBottom: true
      }
    ),
    !showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.CustomSelectControl,
      {
        className: "components-border-radius-control__custom-select-control",
        value: options.find(
          (option) => option.key === presetIndex
        ) || options[options.length - 1],
        onChange: (selection) => {
          if (selection.selectedItem.key === options.length - 1) {
            setShowCustomValueControl(true);
          } else {
            changeCornerValue(
              getPresetValueFromControlValue(
                selection.selectedItem.key,
                "selectList",
                presets
              )
            );
          }
        },
        options,
        label: CORNERS[corner],
        hideLabelFromVision: true,
        size: "__unstable-large"
      }
    ),
    hasPresets && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        label: showCustomValueControl ? (0,external_wp_i18n_namespaceObject.__)("Use border radius preset") : (0,external_wp_i18n_namespaceObject.__)("Set custom border radius"),
        icon: settings_settings_default,
        onClick: () => {
          setShowCustomValueControl(!showCustomValueControl);
        },
        isPressed: showCustomValueControl,
        size: "small",
        className: "components-border-radius-control__custom-toggle",
        iconSize: 24
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/border-radius-control/index.js









function useBorderRadiusSizes(presets) {
  const defaultSizes = presets?.default ?? constants_EMPTY_ARRAY;
  const customSizes = presets?.custom ?? constants_EMPTY_ARRAY;
  const themeSizes = presets?.theme ?? constants_EMPTY_ARRAY;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const sizes = [
      { name: (0,external_wp_i18n_namespaceObject.__)("None"), slug: "0", size: 0 },
      ...customSizes,
      ...themeSizes,
      ...defaultSizes
    ];
    return sizes.length > constants_RANGE_CONTROL_MAX_SIZE ? [
      {
        name: (0,external_wp_i18n_namespaceObject.__)("Default"),
        slug: "default",
        size: void 0
      },
      ...sizes
    ] : sizes;
  }, [customSizes, themeSizes, defaultSizes]);
}
function BorderRadiusControl({ onChange, values, presets }) {
  const [isLinked, setIsLinked] = (0,external_wp_element_namespaceObject.useState)(
    !hasDefinedValues(values) || !hasMixedValues(values)
  );
  const options = useBorderRadiusSizes(presets);
  const [selectedUnits, setSelectedUnits] = (0,external_wp_element_namespaceObject.useState)({
    flat: typeof values === "string" ? (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values)[1] : void 0,
    topLeft: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.topLeft)[1],
    topRight: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.topRight)[1],
    bottomLeft: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(values?.bottomLeft)[1],
    bottomRight: (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(
      values?.bottomRight
    )[1]
  });
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || ["px", "em", "rem"]
  });
  const toggleLinked = () => setIsLinked(!isLinked);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "components-border-radius-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { className: "components-border-radius-control__header", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Radius") }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(LinkedButton, { onClick: toggleLinked, isLinked })
    ] }),
    isLinked ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SingleInputControl,
      {
        onChange,
        selectedUnits,
        setSelectedUnits,
        values,
        units,
        corner: "all",
        presets: options
      }
    ) }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalVStack, { children: [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ].map((corner) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SingleInputControl,
      {
        onChange,
        selectedUnits,
        setSelectedUnits,
        values: values || constants_DEFAULT_VALUES,
        units,
        corner,
        presets: options
      },
      corner
    )) })
  ] });
}


;// ./node_modules/@wordpress/icons/build-module/library/check.js


var check_check_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M16.5 7.5 10 13.9l-2.5-2.4-1 1 3.5 3.6 7.5-7.6z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/shadow.js


var shadow_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12 8c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0 6.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5zM12.8 3h-1.5v3h1.5V3zm-1.6 18h1.5v-3h-1.5v3zm6.8-9.8v1.5h3v-1.5h-3zm-12 0H3v1.5h3v-1.5zm9.7 5.6 2.1 2.1 1.1-1.1-2.1-2.1-1.1 1.1zM8.3 7.2 6.2 5.1 5.1 6.2l2.1 2.1 1.1-1.1zM5.1 17.8l1.1 1.1 2.1-2.1-1.1-1.1-2.1 2.1zM18.9 6.2l-1.1-1.1-2.1 2.1 1.1 1.1 2.1-2.1z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/shadow-panel-components.js






const shadow_panel_components_EMPTY_ARRAY = [];
function ShadowPopoverContainer({ shadow, onShadowChange, settings }) {
  const shadows = useShadowPresets(settings);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-global-styles__shadow-popover-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 4, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalHeading, { level: 5, children: (0,external_wp_i18n_namespaceObject.__)("Drop shadow") }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ShadowPresets,
      {
        presets: shadows,
        activeShadow: shadow,
        onSelect: onShadowChange
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-global-styles__clear-shadow", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        variant: "tertiary",
        onClick: () => onShadowChange(void 0),
        disabled: !shadow,
        accessibleWhenDisabled: true,
        children: (0,external_wp_i18n_namespaceObject.__)("Clear")
      }
    ) })
  ] }) });
}
function ShadowPresets({ presets, activeShadow, onSelect }) {
  return !presets ? null : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite,
    {
      role: "listbox",
      className: "block-editor-global-styles__shadow__list",
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Drop shadows"),
      children: presets.map(({ name, slug, shadow }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        ShadowIndicator,
        {
          label: name,
          isActive: shadow === activeShadow,
          type: slug === "unset" ? "unset" : "preset",
          onSelect: () => onSelect(shadow === activeShadow ? void 0 : shadow),
          shadow
        },
        slug
      ))
    }
  );
}
function ShadowIndicator({ type, label, isActive, onSelect, shadow }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tooltip, { text: label, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite.Item,
    {
      role: "option",
      "aria-label": label,
      "aria-selected": isActive,
      className: dist_clsx("block-editor-global-styles__shadow__item", {
        "is-active": isActive
      }),
      render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "button",
        {
          className: dist_clsx(
            "block-editor-global-styles__shadow-indicator",
            {
              unset: type === "unset"
            }
          ),
          onClick: onSelect,
          style: { boxShadow: shadow },
          "aria-label": label,
          children: isActive && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: check_check_default })
        }
      )
    }
  ) });
}
function ShadowPopover({ shadow, onShadowChange, settings }) {
  const popoverProps = {
    placement: "left-start",
    offset: 36,
    shift: true
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps,
      className: "block-editor-global-styles__shadow-dropdown",
      renderToggle: renderShadowToggle(shadow, onShadowChange),
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, { paddingSize: "medium", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        ShadowPopoverContainer,
        {
          shadow,
          onShadowChange,
          settings
        }
      ) })
    }
  );
}
function renderShadowToggle(shadow, onShadowChange) {
  return ({ onToggle, isOpen }) => {
    const shadowButtonRef = (0,external_wp_element_namespaceObject.useRef)(void 0);
    const toggleProps = {
      onClick: onToggle,
      className: dist_clsx(
        "block-editor-global-styles__shadow-dropdown-toggle",
        { "is-open": isOpen }
      ),
      "aria-expanded": isOpen,
      ref: shadowButtonRef
    };
    const removeButtonProps = {
      onClick: () => {
        if (isOpen) {
          onToggle();
        }
        onShadowChange(void 0);
        shadowButtonRef.current?.focus();
      },
      className: dist_clsx(
        "block-editor-global-styles__shadow-editor__remove-button",
        { "is-open": isOpen }
      ),
      label: (0,external_wp_i18n_namespaceObject.__)("Remove")
    };
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "flex-start", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          icon_default,
          {
            className: "block-editor-global-styles__toggle-icon",
            icon: shadow_default,
            size: 24
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: (0,external_wp_i18n_namespaceObject.__)("Drop shadow") })
      ] }) }),
      !!shadow && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          __next40pxDefaultSize: true,
          size: "small",
          icon: reset_default,
          ...removeButtonProps
        }
      )
    ] });
  };
}
function useShadowPresets(settings) {
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!settings?.shadow) {
      return shadow_panel_components_EMPTY_ARRAY;
    }
    const defaultPresetsEnabled = settings?.shadow?.defaultPresets;
    const {
      default: defaultShadows,
      theme: themeShadows,
      custom: customShadows
    } = settings?.shadow?.presets ?? {};
    const unsetShadow = {
      name: (0,external_wp_i18n_namespaceObject.__)("Unset"),
      slug: "unset",
      shadow: "none"
    };
    const shadowPresets = [
      ...defaultPresetsEnabled && defaultShadows || shadow_panel_components_EMPTY_ARRAY,
      ...themeShadows || shadow_panel_components_EMPTY_ARRAY,
      ...customShadows || shadow_panel_components_EMPTY_ARRAY
    ];
    if (shadowPresets.length) {
      shadowPresets.unshift(unsetShadow);
    }
    return shadowPresets;
  }, [settings]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/border-panel.js










function useHasBorderPanel(settings) {
  const controls = Object.values(useHasBorderPanelControls(settings));
  return controls.some(Boolean);
}
function useHasBorderPanelControls(settings) {
  const controls = {
    hasBorderColor: useHasBorderColorControl(settings),
    hasBorderRadius: useHasBorderRadiusControl(settings),
    hasBorderStyle: useHasBorderStyleControl(settings),
    hasBorderWidth: useHasBorderWidthControl(settings),
    hasShadow: useHasShadowControl(settings)
  };
  return controls;
}
function useHasBorderColorControl(settings) {
  return settings?.border?.color;
}
function useHasBorderRadiusControl(settings) {
  return settings?.border?.radius;
}
function useHasBorderStyleControl(settings) {
  return settings?.border?.style;
}
function useHasBorderWidthControl(settings) {
  return settings?.border?.width;
}
function useHasShadowControl(settings) {
  const shadows = useShadowPresets(settings);
  return !!settings?.shadow && shadows.length > 0;
}
function BorderToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  label
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label,
      resetAll,
      panelId,
      dropdownMenuProps,
      children
    }
  );
}
const border_panel_DEFAULT_CONTROLS = {
  radius: true,
  color: true,
  width: true,
  shadow: true
};
function BorderPanel({
  as: Wrapper = BorderToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  name,
  defaultControls = border_panel_DEFAULT_CONTROLS
}) {
  const colors = useColorsPerOrigin(settings);
  const decodeValue = (0,external_wp_element_namespaceObject.useCallback)(
    (rawValue) => getValueFromVariable({ settings }, "", rawValue),
    [settings]
  );
  const encodeColorValue = (colorValue) => {
    const allColors = colors.flatMap(
      ({ colors: originColors }) => originColors
    );
    const colorObject = allColors.find(
      ({ color }) => color === colorValue
    );
    return colorObject ? "var:preset|color|" + colorObject.slug : colorValue;
  };
  const border = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(inheritedValue?.border)) {
      const borderValue = { ...inheritedValue?.border };
      ["top", "right", "bottom", "left"].forEach((side) => {
        borderValue[side] = {
          ...borderValue[side],
          color: decodeValue(borderValue[side]?.color)
        };
      });
      return borderValue;
    }
    return {
      ...inheritedValue?.border,
      color: inheritedValue?.border?.color ? decodeValue(inheritedValue?.border?.color) : void 0
    };
  }, [inheritedValue?.border, decodeValue]);
  const setBorder = (newBorder) => onChange({ ...value, border: newBorder });
  const showBorderColor = useHasBorderColorControl(settings);
  const showBorderStyle = useHasBorderStyleControl(settings);
  const showBorderWidth = useHasBorderWidthControl(settings);
  const showBorderRadius = useHasBorderRadiusControl(settings);
  const borderRadiusValues = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (typeof inheritedValue?.border?.radius !== "object") {
      return decodeValue(inheritedValue?.border?.radius);
    }
    return {
      topLeft: decodeValue(inheritedValue?.border?.radius?.topLeft),
      topRight: decodeValue(inheritedValue?.border?.radius?.topRight),
      bottomLeft: decodeValue(
        inheritedValue?.border?.radius?.bottomLeft
      ),
      bottomRight: decodeValue(
        inheritedValue?.border?.radius?.bottomRight
      )
    };
  }, [inheritedValue?.border?.radius, decodeValue]);
  const setBorderRadius = (newBorderRadius) => setBorder({ ...border, radius: newBorderRadius });
  const hasBorderRadius = () => {
    const borderValues = value?.border?.radius;
    if (typeof borderValues === "object") {
      return Object.entries(borderValues).some(Boolean);
    }
    return !!borderValues;
  };
  const hasShadowControl = useHasShadowControl(settings);
  const shadow = decodeValue(inheritedValue?.shadow);
  const shadowPresets = settings?.shadow?.presets ?? {};
  const mergedShadowPresets = shadowPresets.custom ?? shadowPresets.theme ?? shadowPresets.default ?? [];
  const setShadow = (newValue) => {
    const slug = mergedShadowPresets?.find(
      ({ shadow: shadowName }) => shadowName === newValue
    )?.slug;
    onChange(
      setImmutably(
        value,
        ["shadow"],
        slug ? `var:preset|shadow|${slug}` : newValue || void 0
      )
    );
  };
  const hasShadow = () => !!value?.shadow;
  const resetShadow = () => setShadow(void 0);
  const resetBorder = () => {
    if (hasBorderRadius()) {
      return setBorder({ radius: value?.border?.radius });
    }
    setBorder(void 0);
  };
  const onBorderChange = (newBorder) => {
    const updatedBorder = { ...newBorder };
    if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(updatedBorder)) {
      ["top", "right", "bottom", "left"].forEach((side) => {
        if (updatedBorder[side]) {
          updatedBorder[side] = {
            ...updatedBorder[side],
            color: encodeColorValue(updatedBorder[side]?.color)
          };
        }
      });
    } else if (updatedBorder) {
      updatedBorder.color = encodeColorValue(updatedBorder.color);
    }
    setBorder({ radius: border?.radius, ...updatedBorder });
  };
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      border: void 0,
      shadow: void 0
    };
  }, []);
  const showBorderByDefault = defaultControls?.color || defaultControls?.width;
  const hasBorderControl = showBorderColor || showBorderStyle || showBorderWidth || showBorderRadius;
  const label = useBorderPanelLabel({
    blockName: name,
    hasShadowControl,
    hasBorderControl
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      label,
      children: [
        (showBorderWidth || showBorderColor) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: () => (0,external_wp_components_namespaceObject.__experimentalIsDefinedBorder)(value?.border),
            label: (0,external_wp_i18n_namespaceObject.__)("Border"),
            onDeselect: () => resetBorder(),
            isShownByDefault: showBorderByDefault,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.BorderBoxControl,
              {
                colors,
                enableAlpha: true,
                enableStyle: showBorderStyle,
                onChange: onBorderChange,
                popoverOffset: 40,
                popoverPlacement: "left-start",
                value: border,
                __experimentalIsRenderedInSidebar: true,
                size: "__unstable-large",
                hideLabelFromVision: !hasShadowControl,
                label: (0,external_wp_i18n_namespaceObject.__)("Border")
              }
            )
          }
        ),
        showBorderRadius && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: hasBorderRadius,
            label: (0,external_wp_i18n_namespaceObject.__)("Radius"),
            onDeselect: () => setBorderRadius(void 0),
            isShownByDefault: defaultControls.radius,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BorderRadiusControl,
              {
                presets: settings?.border?.radiusSizes,
                values: borderRadiusValues,
                onChange: (newValue) => {
                  setBorderRadius(newValue || void 0);
                }
              }
            )
          }
        ),
        hasShadowControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Shadow"),
            hasValue: hasShadow,
            onDeselect: resetShadow,
            isShownByDefault: defaultControls.shadow,
            panelId,
            children: [
              hasBorderControl ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Shadow") }) : null,
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                ShadowPopover,
                {
                  shadow,
                  onShadowChange: setShadow,
                  settings
                }
              )
            ]
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/border.js














const BORDER_SUPPORT_KEY = "__experimentalBorder";
const SHADOW_SUPPORT_KEY = "shadow";
const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(
    (origin) => origin.colors.some((color) => {
      if (color[property] === value) {
        matchedColor = color;
        return true;
      }
      return false;
    })
  );
  return matchedColor;
};
const getMultiOriginColor = ({ colors, namedColor, customColor }) => {
  if (namedColor) {
    const colorObject2 = getColorByProperty(colors, "slug", namedColor);
    if (colorObject2) {
      return colorObject2;
    }
  }
  if (!customColor) {
    return { color: void 0 };
  }
  const colorObject = getColorByProperty(colors, "color", customColor);
  return colorObject ? colorObject : { color: customColor };
};
function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);
  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }
  return null;
}
function styleToAttributes(style) {
  if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(style?.border)) {
    return {
      style,
      borderColor: void 0
    };
  }
  const borderColorValue = style?.border?.color;
  const borderColorSlug = borderColorValue?.startsWith("var:preset|color|") ? borderColorValue.substring("var:preset|color|".length) : void 0;
  const updatedStyle = { ...style };
  updatedStyle.border = {
    ...updatedStyle.border,
    color: borderColorSlug ? void 0 : borderColorValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    borderColor: borderColorSlug
  };
}
function attributesToStyle(attributes) {
  if ((0,external_wp_components_namespaceObject.__experimentalHasSplitBorders)(attributes.style?.border)) {
    return attributes.style;
  }
  return {
    ...attributes.style,
    border: {
      ...attributes.style?.border,
      color: attributes.borderColor ? "var:preset|color|" + attributes.borderColor : attributes.style?.border?.color
    }
  };
}
function BordersInspectorControl({ label, children, resetAllFilter }) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (attributes) => {
      const existingStyle = attributesToStyle(attributes);
      const updatedStyle = resetAllFilter(existingStyle);
      return {
        ...attributes,
        ...styleToAttributes(updatedStyle)
      };
    },
    [resetAllFilter]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inspector_controls_default,
    {
      group: "border",
      resetAllFilter: attributesResetAllFilter,
      label,
      children
    }
  );
}
function border_BorderPanel({ clientId, name, setAttributes, settings }) {
  const isEnabled = useHasBorderPanel(settings);
  function selector(select) {
    const { style: style2, borderColor: borderColor2 } = select(store).getBlockAttributes(clientId) || {};
    return { style: style2, borderColor: borderColor2 };
  }
  const { style, borderColor } = (0,external_wp_data_namespaceObject.useSelect)(selector, [clientId]);
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return attributesToStyle({ style, borderColor });
  }, [style, borderColor]);
  const onChange = (newStyle) => {
    setAttributes(styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = {
    ...(0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
      BORDER_SUPPORT_KEY,
      "__experimentalDefaultControls"
    ]),
    ...(0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
      SHADOW_SUPPORT_KEY,
      "__experimentalDefaultControls"
    ])
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BorderPanel,
    {
      as: BordersInspectorControl,
      panelId: clientId,
      settings,
      value,
      onChange,
      defaultControls
    }
  );
}
function hasBorderSupport(blockName, feature = "any") {
  if (external_wp_element_namespaceObject.Platform.OS !== "web") {
    return false;
  }
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, BORDER_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === "any") {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }
  return !!support?.[feature];
}
function hasShadowSupport(blockName) {
  return hasBlockSupport(blockName, SHADOW_SUPPORT_KEY);
}
function useBorderPanelLabel({
  blockName,
  hasBorderControl,
  hasShadowControl
} = {}) {
  const settings = useBlockSettings(blockName);
  const controls = useHasBorderPanelControls(settings);
  if (!hasBorderControl && !hasShadowControl && blockName) {
    hasBorderControl = controls?.hasBorderColor || controls?.hasBorderStyle || controls?.hasBorderWidth || controls?.hasBorderRadius;
    hasShadowControl = controls?.hasShadow;
  }
  if (hasBorderControl && hasShadowControl) {
    return (0,external_wp_i18n_namespaceObject.__)("Border & Shadow");
  }
  if (hasShadowControl) {
    return (0,external_wp_i18n_namespaceObject.__)("Shadow");
  }
  return (0,external_wp_i18n_namespaceObject.__)("Border");
}
function removeBorderAttribute(style, attribute) {
  return cleanEmptyObject({
    ...style,
    border: {
      ...style?.border,
      [attribute]: void 0
    }
  });
}
function addAttributes(settings) {
  if (!hasBorderSupport(settings, "color")) {
    return settings;
  }
  if (settings.attributes.borderColor) {
    return settings;
  }
  return {
    ...settings,
    attributes: {
      ...settings.attributes,
      borderColor: {
        type: "string"
      }
    }
  };
}
function border_addSaveProps(props, blockNameOrType, attributes) {
  if (!hasBorderSupport(blockNameOrType, "color") || shouldSkipSerialization(blockNameOrType, BORDER_SUPPORT_KEY, "color")) {
    return props;
  }
  const borderClasses = getBorderClasses(attributes);
  const newClassName = dist_clsx(props.className, borderClasses);
  props.className = newClassName ? newClassName : void 0;
  return props;
}
function getBorderClasses(attributes) {
  const { borderColor, style } = attributes;
  const borderColorClass = getColorClassName("border-color", borderColor);
  return dist_clsx({
    "has-border-color": borderColor || style?.border?.color,
    [borderColorClass]: !!borderColorClass
  });
}
function border_useBlockProps({ name, borderColor, style }) {
  const { colors } = useMultipleOriginColorsAndGradients();
  if (!hasBorderSupport(name, "color") || shouldSkipSerialization(name, BORDER_SUPPORT_KEY, "color")) {
    return {};
  }
  const { color: borderColorValue } = getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const { color: borderTopColor } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.top?.color)
  });
  const { color: borderRightColor } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.right?.color)
  });
  const { color: borderBottomColor } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.bottom?.color)
  });
  const { color: borderLeftColor } = getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style?.border?.left?.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  return border_addSaveProps(
    { style: utils_cleanEmptyObject(extraStyles) || {} },
    name,
    { borderColor, style }
  );
}
var border_default = {
  useBlockProps: border_useBlockProps,
  addSaveProps: border_addSaveProps,
  attributeKeys: ["borderColor", "style"],
  hasSupport(name) {
    return hasBorderSupport(name, "color");
  }
};
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/border/addAttributes",
  addAttributes
);


;// ./node_modules/@wordpress/block-editor/build-module/components/gradients/use-gradient.js





function __experimentalGetGradientClass(gradientSlug) {
  if (!gradientSlug) {
    return void 0;
  }
  return `has-${gradientSlug}-gradient-background`;
}
function getGradientValueBySlug(gradients, slug) {
  const gradient = gradients?.find((g) => g.slug === slug);
  return gradient && gradient.gradient;
}
function __experimentalGetGradientObjectByGradientValue(gradients, value) {
  const gradient = gradients?.find((g) => g.gradient === value);
  return gradient;
}
function getGradientSlugByValue(gradients, value) {
  const gradient = __experimentalGetGradientObjectByGradientValue(
    gradients,
    value
  );
  return gradient && gradient.slug;
}
function __experimentalUseGradient({
  gradientAttribute = "gradient",
  customGradientAttribute = "customGradient"
} = {}) {
  const { clientId } = useBlockEditContext();
  const [
    userGradientPalette,
    themeGradientPalette,
    defaultGradientPalette
  ] = use_settings_useSettings(
    "color.gradients.custom",
    "color.gradients.theme",
    "color.gradients.default"
  );
  const allGradients = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userGradientPalette || [],
      ...themeGradientPalette || [],
      ...defaultGradientPalette || []
    ],
    [userGradientPalette, themeGradientPalette, defaultGradientPalette]
  );
  const { gradient, customGradient } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes } = select(store);
      const attributes = getBlockAttributes(clientId) || {};
      return {
        customGradient: attributes[customGradientAttribute],
        gradient: attributes[gradientAttribute]
      };
    },
    [clientId, gradientAttribute, customGradientAttribute]
  );
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const setGradient = (0,external_wp_element_namespaceObject.useCallback)(
    (newGradientValue) => {
      const slug = getGradientSlugByValue(
        allGradients,
        newGradientValue
      );
      if (slug) {
        updateBlockAttributes(clientId, {
          [gradientAttribute]: slug,
          [customGradientAttribute]: void 0
        });
        return;
      }
      updateBlockAttributes(clientId, {
        [gradientAttribute]: void 0,
        [customGradientAttribute]: newGradientValue
      });
    },
    [allGradients, clientId, updateBlockAttributes]
  );
  const gradientClass = __experimentalGetGradientClass(gradient);
  let gradientValue;
  if (gradient) {
    gradientValue = getGradientValueBySlug(allGradients, gradient);
  } else {
    gradientValue = customGradient;
  }
  return { gradientClass, gradientValue, setGradient };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/control.js






const { Tabs } = unlock(external_wp_components_namespaceObject.privateApis);
const colorsAndGradientKeys = [
  "colors",
  "disableCustomColors",
  "gradients",
  "disableCustomGradients"
];
const TAB_IDS = { color: "color", gradient: "gradient" };
function ColorGradientControlInner({
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  __experimentalIsRenderedInSidebar,
  className,
  label,
  onColorChange,
  onGradientChange,
  colorValue,
  gradientValue,
  clearable,
  showTitle = true,
  enableAlpha,
  headingLevel
}) {
  const canChooseAColor = onColorChange && (colors && colors.length > 0 || !disableCustomColors);
  const canChooseAGradient = onGradientChange && (gradients && gradients.length > 0 || !disableCustomGradients);
  if (!canChooseAColor && !canChooseAGradient) {
    return null;
  }
  const tabPanels = {
    [TAB_IDS.color]: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ColorPalette,
      {
        value: colorValue,
        onChange: canChooseAGradient ? (newColor) => {
          onColorChange(newColor);
          onGradientChange();
        } : onColorChange,
        ...{ colors, disableCustomColors },
        __experimentalIsRenderedInSidebar,
        clearable,
        enableAlpha,
        headingLevel
      }
    ),
    [TAB_IDS.gradient]: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.GradientPicker,
      {
        value: gradientValue,
        onChange: canChooseAColor ? (newGradient) => {
          onGradientChange(newGradient);
          onColorChange();
        } : onGradientChange,
        ...{ gradients, disableCustomGradients },
        __experimentalIsRenderedInSidebar,
        clearable,
        headingLevel
      }
    )
  };
  const renderPanelType = (type) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-color-gradient-control__panel", children: tabPanels[type] });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.BaseControl,
    {
      __nextHasNoMarginBottom: true,
      className: dist_clsx(
        "block-editor-color-gradient-control",
        className
      ),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("fieldset", { className: "block-editor-color-gradient-control__fieldset", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 1, children: [
        showTitle && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("legend", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-color-gradient-control__color-indicator", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { children: label }) }) }),
        canChooseAColor && canChooseAGradient && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          Tabs,
          {
            defaultTabId: gradientValue ? TAB_IDS.gradient : !!canChooseAColor && TAB_IDS.color,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(Tabs.TabList, { children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Tabs.Tab, { tabId: TAB_IDS.color, children: (0,external_wp_i18n_namespaceObject.__)("Color") }),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Tabs.Tab, { tabId: TAB_IDS.gradient, children: (0,external_wp_i18n_namespaceObject.__)("Gradient") })
              ] }),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                Tabs.TabPanel,
                {
                  tabId: TAB_IDS.color,
                  className: "block-editor-color-gradient-control__panel",
                  focusable: false,
                  children: tabPanels.color
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                Tabs.TabPanel,
                {
                  tabId: TAB_IDS.gradient,
                  className: "block-editor-color-gradient-control__panel",
                  focusable: false,
                  children: tabPanels.gradient
                }
              )
            ]
          }
        ) }),
        !canChooseAGradient && renderPanelType(TAB_IDS.color),
        !canChooseAColor && renderPanelType(TAB_IDS.gradient)
      ] }) })
    }
  );
}
function ColorGradientControlSelect(props) {
  const [colors, gradients, customColors, customGradients] = use_settings_useSettings(
    "color.palette",
    "color.gradients",
    "color.custom",
    "color.customGradient"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    ColorGradientControlInner,
    {
      colors,
      gradients,
      disableCustomColors: !customColors,
      disableCustomGradients: !customGradients,
      ...props
    }
  );
}
function ColorGradientControl(props) {
  if (colorsAndGradientKeys.every((key) => props.hasOwnProperty(key))) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ColorGradientControlInner, { ...props });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ColorGradientControlSelect, { ...props });
}
var control_default = ColorGradientControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/color-panel.js











function useHasColorPanel(settings) {
  const hasTextPanel = useHasTextPanel(settings);
  const hasBackgroundPanel = useHasBackgroundColorPanel(settings);
  const hasLinkPanel = useHasLinkPanel(settings);
  const hasHeadingPanel = useHasHeadingPanel(settings);
  const hasButtonPanel = useHasButtonPanel(settings);
  const hasCaptionPanel = useHasCaptionPanel(settings);
  return hasTextPanel || hasBackgroundPanel || hasLinkPanel || hasHeadingPanel || hasButtonPanel || hasCaptionPanel;
}
function useHasTextPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.text && (colors?.length > 0 || settings?.color?.custom);
}
function useHasLinkPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.link && (colors?.length > 0 || settings?.color?.custom);
}
function useHasCaptionPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  return settings?.color?.caption && (colors?.length > 0 || settings?.color?.custom);
}
function useHasHeadingPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.heading && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function useHasButtonPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.button && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function useHasBackgroundColorPanel(settings) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  return settings?.color?.background && (colors?.length > 0 || settings?.color?.custom || gradients?.length > 0 || settings?.color?.customGradient);
}
function ColorToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Elements"),
      resetAll,
      panelId,
      hasInnerWrapper: true,
      headingLevel: 3,
      className: "color-block-support-panel",
      __experimentalFirstVisibleItemClass: "first",
      __experimentalLastVisibleItemClass: "last",
      dropdownMenuProps,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "color-block-support-panel__inner-wrapper", children })
    }
  );
}
const color_panel_DEFAULT_CONTROLS = {
  text: true,
  background: true,
  link: true,
  heading: true,
  button: true,
  caption: true
};
const popoverProps = {
  placement: "left-start",
  offset: 36,
  shift: true
};
const { Tabs: color_panel_Tabs } = unlock(external_wp_components_namespaceObject.privateApis);
const LabeledColorIndicators = ({ indicators, label }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "flex-start", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalZStack, { isLayered: false, offset: -8, children: indicators.map((indicator, index) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Flex, { expanded: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ColorIndicator, { colorValue: indicator }) }, index)) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { className: "block-editor-panel-color-gradient-settings__color-name", children: label })
] });
function ColorPanelTab({
  isGradient,
  inheritedValue,
  userValue,
  setValue,
  colorGradientControlSettings
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    control_default,
    {
      ...colorGradientControlSettings,
      showTitle: false,
      enableAlpha: true,
      __experimentalIsRenderedInSidebar: true,
      colorValue: isGradient ? void 0 : inheritedValue,
      gradientValue: isGradient ? inheritedValue : void 0,
      onColorChange: isGradient ? void 0 : setValue,
      onGradientChange: isGradient ? setValue : void 0,
      clearable: inheritedValue === userValue,
      headingLevel: 3
    }
  );
}
function ColorPanelDropdown({
  label,
  hasValue,
  resetValue,
  isShownByDefault,
  indicators,
  tabs,
  colorGradientControlSettings,
  panelId
}) {
  const currentTab = tabs.find((tab) => tab.userValue !== void 0);
  const { key: firstTabKey, ...firstTab } = tabs[0] ?? {};
  const colorGradientDropdownButtonRef = (0,external_wp_element_namespaceObject.useRef)(void 0);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      className: "block-editor-tools-panel-color-gradient-settings__item",
      hasValue,
      label,
      onDeselect: resetValue,
      isShownByDefault,
      panelId,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Dropdown,
        {
          popoverProps,
          className: "block-editor-tools-panel-color-gradient-settings__dropdown",
          renderToggle: ({ onToggle, isOpen }) => {
            const toggleProps = {
              onClick: onToggle,
              className: dist_clsx(
                "block-editor-panel-color-gradient-settings__dropdown",
                { "is-open": isOpen }
              ),
              "aria-expanded": isOpen,
              ref: colorGradientDropdownButtonRef
            };
            return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { ...toggleProps, __next40pxDefaultSize: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                LabeledColorIndicators,
                {
                  indicators,
                  label
                }
              ) }),
              hasValue() && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  label: (0,external_wp_i18n_namespaceObject.__)("Reset"),
                  className: "block-editor-panel-color-gradient-settings__reset",
                  size: "small",
                  icon: reset_default,
                  onClick: () => {
                    resetValue();
                    if (isOpen) {
                      onToggle();
                    }
                    colorGradientDropdownButtonRef.current?.focus();
                  }
                }
              )
            ] });
          },
          renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, { paddingSize: "none", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-panel-color-gradient-settings__dropdown-content", children: [
            tabs.length === 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              ColorPanelTab,
              {
                ...firstTab,
                colorGradientControlSettings
              },
              firstTabKey
            ),
            tabs.length > 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(color_panel_Tabs, { defaultTabId: currentTab?.key, children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(color_panel_Tabs.TabList, { children: tabs.map((tab) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                color_panel_Tabs.Tab,
                {
                  tabId: tab.key,
                  children: tab.label
                },
                tab.key
              )) }),
              tabs.map((tab) => {
                const { key: tabKey, ...restTabProps } = tab;
                return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  color_panel_Tabs.TabPanel,
                  {
                    tabId: tabKey,
                    focusable: false,
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                      ColorPanelTab,
                      {
                        ...restTabProps,
                        colorGradientControlSettings
                      },
                      tabKey
                    )
                  },
                  tabKey
                );
              })
            ] })
          ] }) })
        }
      )
    }
  );
}
function ColorPanel({
  as: Wrapper = ColorToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = color_panel_DEFAULT_CONTROLS,
  children
}) {
  const colors = useColorsPerOrigin(settings);
  const gradients = useGradientsPerOrigin(settings);
  const areCustomSolidsEnabled = settings?.color?.custom;
  const areCustomGradientsEnabled = settings?.color?.customGradient;
  const hasSolidColors = colors.length > 0 || areCustomSolidsEnabled;
  const hasGradientColors = gradients.length > 0 || areCustomGradientsEnabled;
  const decodeValue = (rawValue) => getValueFromVariable({ settings }, "", rawValue);
  const encodeColorValue = (colorValue) => {
    const allColors = colors.flatMap(
      ({ colors: originColors }) => originColors
    );
    const colorObject = allColors.find(
      ({ color }) => color === colorValue
    );
    return colorObject ? "var:preset|color|" + colorObject.slug : colorValue;
  };
  const encodeGradientValue = (gradientValue) => {
    const allGradients = gradients.flatMap(
      ({ gradients: originGradients }) => originGradients
    );
    const gradientObject = allGradients.find(
      ({ gradient: gradient2 }) => gradient2 === gradientValue
    );
    return gradientObject ? "var:preset|gradient|" + gradientObject.slug : gradientValue;
  };
  const showBackgroundPanel = useHasBackgroundColorPanel(settings);
  const backgroundColor = decodeValue(inheritedValue?.color?.background);
  const userBackgroundColor = decodeValue(value?.color?.background);
  const gradient = decodeValue(inheritedValue?.color?.gradient);
  const userGradient = decodeValue(value?.color?.gradient);
  const hasBackground = () => !!userBackgroundColor || !!userGradient;
  const setBackgroundColor = (newColor) => {
    const newValue = setImmutably(
      value,
      ["color", "background"],
      encodeColorValue(newColor)
    );
    newValue.color.gradient = void 0;
    onChange(newValue);
  };
  const setGradient = (newGradient) => {
    const newValue = setImmutably(
      value,
      ["color", "gradient"],
      encodeGradientValue(newGradient)
    );
    newValue.color.background = void 0;
    onChange(newValue);
  };
  const resetBackground = () => {
    const newValue = setImmutably(
      value,
      ["color", "background"],
      void 0
    );
    newValue.color.gradient = void 0;
    onChange(newValue);
  };
  const showLinkPanel = useHasLinkPanel(settings);
  const linkColor = decodeValue(
    inheritedValue?.elements?.link?.color?.text
  );
  const userLinkColor = decodeValue(value?.elements?.link?.color?.text);
  const setLinkColor = (newColor) => {
    onChange(
      setImmutably(
        value,
        ["elements", "link", "color", "text"],
        encodeColorValue(newColor)
      )
    );
  };
  const hoverLinkColor = decodeValue(
    inheritedValue?.elements?.link?.[":hover"]?.color?.text
  );
  const userHoverLinkColor = decodeValue(
    value?.elements?.link?.[":hover"]?.color?.text
  );
  const setHoverLinkColor = (newColor) => {
    onChange(
      setImmutably(
        value,
        ["elements", "link", ":hover", "color", "text"],
        encodeColorValue(newColor)
      )
    );
  };
  const hasLink = () => !!userLinkColor || !!userHoverLinkColor;
  const resetLink = () => {
    let newValue = setImmutably(
      value,
      ["elements", "link", ":hover", "color", "text"],
      void 0
    );
    newValue = setImmutably(
      newValue,
      ["elements", "link", "color", "text"],
      void 0
    );
    onChange(newValue);
  };
  const showTextPanel = useHasTextPanel(settings);
  const textColor = decodeValue(inheritedValue?.color?.text);
  const userTextColor = decodeValue(value?.color?.text);
  const hasTextColor = () => !!userTextColor;
  const setTextColor = (newColor) => {
    let changedObject = setImmutably(
      value,
      ["color", "text"],
      encodeColorValue(newColor)
    );
    if (textColor === linkColor) {
      changedObject = setImmutably(
        changedObject,
        ["elements", "link", "color", "text"],
        encodeColorValue(newColor)
      );
    }
    onChange(changedObject);
  };
  const resetTextColor = () => setTextColor(void 0);
  const elements = [
    {
      name: "caption",
      label: (0,external_wp_i18n_namespaceObject.__)("Captions"),
      showPanel: useHasCaptionPanel(settings)
    },
    {
      name: "button",
      label: (0,external_wp_i18n_namespaceObject.__)("Button"),
      showPanel: useHasButtonPanel(settings)
    },
    {
      name: "heading",
      label: (0,external_wp_i18n_namespaceObject.__)("Heading"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h1",
      label: (0,external_wp_i18n_namespaceObject.__)("H1"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h2",
      label: (0,external_wp_i18n_namespaceObject.__)("H2"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h3",
      label: (0,external_wp_i18n_namespaceObject.__)("H3"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h4",
      label: (0,external_wp_i18n_namespaceObject.__)("H4"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h5",
      label: (0,external_wp_i18n_namespaceObject.__)("H5"),
      showPanel: useHasHeadingPanel(settings)
    },
    {
      name: "h6",
      label: (0,external_wp_i18n_namespaceObject.__)("H6"),
      showPanel: useHasHeadingPanel(settings)
    }
  ];
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      color: void 0,
      elements: {
        ...previousValue?.elements,
        link: {
          ...previousValue?.elements?.link,
          color: void 0,
          ":hover": {
            color: void 0
          }
        },
        ...elements.reduce((acc, element) => {
          return {
            ...acc,
            [element.name]: {
              ...previousValue?.elements?.[element.name],
              color: void 0
            }
          };
        }, {})
      }
    };
  }, []);
  const items = [
    showTextPanel && {
      key: "text",
      label: (0,external_wp_i18n_namespaceObject.__)("Text"),
      hasValue: hasTextColor,
      resetValue: resetTextColor,
      isShownByDefault: defaultControls.text,
      indicators: [textColor],
      tabs: [
        {
          key: "text",
          label: (0,external_wp_i18n_namespaceObject.__)("Text"),
          inheritedValue: textColor,
          setValue: setTextColor,
          userValue: userTextColor
        }
      ]
    },
    showBackgroundPanel && {
      key: "background",
      label: (0,external_wp_i18n_namespaceObject.__)("Background"),
      hasValue: hasBackground,
      resetValue: resetBackground,
      isShownByDefault: defaultControls.background,
      indicators: [gradient ?? backgroundColor],
      tabs: [
        hasSolidColors && {
          key: "background",
          label: (0,external_wp_i18n_namespaceObject.__)("Color"),
          inheritedValue: backgroundColor,
          setValue: setBackgroundColor,
          userValue: userBackgroundColor
        },
        hasGradientColors && {
          key: "gradient",
          label: (0,external_wp_i18n_namespaceObject.__)("Gradient"),
          inheritedValue: gradient,
          setValue: setGradient,
          userValue: userGradient,
          isGradient: true
        }
      ].filter(Boolean)
    },
    showLinkPanel && {
      key: "link",
      label: (0,external_wp_i18n_namespaceObject.__)("Link"),
      hasValue: hasLink,
      resetValue: resetLink,
      isShownByDefault: defaultControls.link,
      indicators: [linkColor, hoverLinkColor],
      tabs: [
        {
          key: "link",
          label: (0,external_wp_i18n_namespaceObject.__)("Default"),
          inheritedValue: linkColor,
          setValue: setLinkColor,
          userValue: userLinkColor
        },
        {
          key: "hover",
          label: (0,external_wp_i18n_namespaceObject.__)("Hover"),
          inheritedValue: hoverLinkColor,
          setValue: setHoverLinkColor,
          userValue: userHoverLinkColor
        }
      ]
    }
  ].filter(Boolean);
  elements.forEach(({ name, label, showPanel }) => {
    if (!showPanel) {
      return;
    }
    const elementBackgroundColor = decodeValue(
      inheritedValue?.elements?.[name]?.color?.background
    );
    const elementGradient = decodeValue(
      inheritedValue?.elements?.[name]?.color?.gradient
    );
    const elementTextColor = decodeValue(
      inheritedValue?.elements?.[name]?.color?.text
    );
    const elementBackgroundUserColor = decodeValue(
      value?.elements?.[name]?.color?.background
    );
    const elementGradientUserColor = decodeValue(
      value?.elements?.[name]?.color?.gradient
    );
    const elementTextUserColor = decodeValue(
      value?.elements?.[name]?.color?.text
    );
    const hasElement = () => !!(elementTextUserColor || elementBackgroundUserColor || elementGradientUserColor);
    const resetElement = () => {
      const newValue = setImmutably(
        value,
        ["elements", name, "color", "background"],
        void 0
      );
      newValue.elements[name].color.gradient = void 0;
      newValue.elements[name].color.text = void 0;
      onChange(newValue);
    };
    const setElementTextColor = (newTextColor) => {
      onChange(
        setImmutably(
          value,
          ["elements", name, "color", "text"],
          encodeColorValue(newTextColor)
        )
      );
    };
    const setElementBackgroundColor = (newBackgroundColor) => {
      const newValue = setImmutably(
        value,
        ["elements", name, "color", "background"],
        encodeColorValue(newBackgroundColor)
      );
      newValue.elements[name].color.gradient = void 0;
      onChange(newValue);
    };
    const setElementGradient = (newGradient) => {
      const newValue = setImmutably(
        value,
        ["elements", name, "color", "gradient"],
        encodeGradientValue(newGradient)
      );
      newValue.elements[name].color.background = void 0;
      onChange(newValue);
    };
    const supportsTextColor = true;
    const supportsBackground = name !== "caption";
    items.push({
      key: name,
      label,
      hasValue: hasElement,
      resetValue: resetElement,
      isShownByDefault: defaultControls[name],
      indicators: supportsTextColor && supportsBackground ? [
        elementTextColor,
        elementGradient ?? elementBackgroundColor
      ] : [
        supportsTextColor ? elementTextColor : elementGradient ?? elementBackgroundColor
      ],
      tabs: [
        hasSolidColors && supportsTextColor && {
          key: "text",
          label: (0,external_wp_i18n_namespaceObject.__)("Text"),
          inheritedValue: elementTextColor,
          setValue: setElementTextColor,
          userValue: elementTextUserColor
        },
        hasSolidColors && supportsBackground && {
          key: "background",
          label: (0,external_wp_i18n_namespaceObject.__)("Background"),
          inheritedValue: elementBackgroundColor,
          setValue: setElementBackgroundColor,
          userValue: elementBackgroundUserColor
        },
        hasGradientColors && supportsBackground && {
          key: "gradient",
          label: (0,external_wp_i18n_namespaceObject.__)("Gradient"),
          inheritedValue: elementGradient,
          setValue: setElementGradient,
          userValue: elementGradientUserColor,
          isGradient: true
        }
      ].filter(Boolean)
    });
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      children: [
        items.map((item) => {
          const { key, ...restItem } = item;
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ColorPanelDropdown,
            {
              ...restItem,
              colorGradientControlSettings: {
                colors,
                disableCustomColors: !areCustomSolidsEnabled,
                gradients,
                disableCustomGradients: !areCustomGradientsEnabled
              },
              panelId
            },
            key
          );
        }),
        children
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/contrast-checker/index.js







k([names, a11y]);
function ContrastChecker({
  backgroundColor,
  fallbackBackgroundColor,
  fallbackTextColor,
  fallbackLinkColor,
  fontSize,
  // Font size value in pixels.
  isLargeText,
  textColor,
  linkColor,
  enableAlphaChecker = false
}) {
  const currentBackgroundColor = backgroundColor || fallbackBackgroundColor;
  if (!currentBackgroundColor) {
    return null;
  }
  const currentTextColor = textColor || fallbackTextColor;
  const currentLinkColor = linkColor || fallbackLinkColor;
  if (!currentTextColor && !currentLinkColor) {
    return null;
  }
  const textColors = [
    {
      color: currentTextColor,
      description: (0,external_wp_i18n_namespaceObject.__)("text color")
    },
    {
      color: currentLinkColor,
      description: (0,external_wp_i18n_namespaceObject.__)("link color")
    }
  ];
  const colordBackgroundColor = w(currentBackgroundColor);
  const backgroundColorHasTransparency = colordBackgroundColor.alpha() < 1;
  const backgroundColorBrightness = colordBackgroundColor.brightness();
  const isReadableOptions = {
    level: "AA",
    size: isLargeText || isLargeText !== false && fontSize >= 24 ? "large" : "small"
  };
  let message = "";
  let speakMessage = "";
  for (const item of textColors) {
    if (!item.color) {
      continue;
    }
    const colordTextColor = w(item.color);
    const isColordTextReadable = colordTextColor.isReadable(
      colordBackgroundColor,
      isReadableOptions
    );
    const textHasTransparency = colordTextColor.alpha() < 1;
    if (!isColordTextReadable) {
      if (backgroundColorHasTransparency || textHasTransparency) {
        continue;
      }
      message = backgroundColorBrightness < colordTextColor.brightness() ? (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s is a type of text color, e.g., "text color" or "link color".
        (0,external_wp_i18n_namespaceObject.__)(
          "This color combination may be hard for people to read. Try using a darker background color and/or a brighter %s."
        ),
        item.description
      ) : (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s is a type of text color, e.g., "text color" or "link color".
        (0,external_wp_i18n_namespaceObject.__)(
          "This color combination may be hard for people to read. Try using a brighter background color and/or a darker %s."
        ),
        item.description
      );
      speakMessage = (0,external_wp_i18n_namespaceObject.__)(
        "This color combination may be hard for people to read."
      );
      break;
    }
    if (textHasTransparency && enableAlphaChecker) {
      message = (0,external_wp_i18n_namespaceObject.__)("Transparent text may be hard for people to read.");
      speakMessage = (0,external_wp_i18n_namespaceObject.__)(
        "Transparent text may be hard for people to read."
      );
    }
  }
  if (!message) {
    return null;
  }
  (0,external_wp_a11y_namespaceObject.speak)(speakMessage);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-contrast-checker", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Notice,
    {
      spokenMessage: null,
      status: "warning",
      isDismissible: false,
      children: message
    }
  ) });
}
var contrast_checker_default = ContrastChecker;


;// ./node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js



const BlockRefs = (0,external_wp_element_namespaceObject.createContext)({ refsMap: (0,external_wp_compose_namespaceObject.observableMap)() });
BlockRefs.displayName = "BlockRefsContext";
function BlockRefsProvider({ children }) {
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => ({ refsMap: (0,external_wp_compose_namespaceObject.observableMap)() }), []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockRefs.Provider, { value, children });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js



function useBlockRefProvider(clientId) {
  const { refsMap } = (0,external_wp_element_namespaceObject.useContext)(BlockRefs);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (element) => {
      refsMap.set(clientId, element);
      return () => refsMap.delete(clientId);
    },
    [clientId]
  );
}
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useBlockElementRef(clientId, ref) {
  const { refsMap } = (0,external_wp_element_namespaceObject.useContext)(BlockRefs);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    assignRef(ref, refsMap.get(clientId));
    const unsubscribe = refsMap.subscribe(
      clientId,
      () => assignRef(ref, refsMap.get(clientId))
    );
    return () => {
      unsubscribe();
      assignRef(ref, null);
    };
  }, [refsMap, clientId, ref]);
}
function useBlockElement(clientId) {
  const [blockElement, setBlockElement] = (0,external_wp_element_namespaceObject.useState)(null);
  useBlockElementRef(clientId, setBlockElement);
  return blockElement;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/contrast-checker.js




function getComputedValue(node, property) {
  return node.ownerDocument.defaultView.getComputedStyle(node).getPropertyValue(property);
}
function getBlockElementColors(blockEl) {
  if (!blockEl) {
    return {};
  }
  const firstLinkElement = blockEl.querySelector("a");
  const linkColor = !!firstLinkElement?.innerText ? getComputedValue(firstLinkElement, "color") : void 0;
  const textColor = getComputedValue(blockEl, "color");
  let backgroundColorNode = blockEl;
  let backgroundColor = getComputedValue(
    backgroundColorNode,
    "background-color"
  );
  while (backgroundColor === "rgba(0, 0, 0, 0)" && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
    backgroundColorNode = backgroundColorNode.parentNode;
    backgroundColor = getComputedValue(
      backgroundColorNode,
      "background-color"
    );
  }
  return {
    textColor,
    backgroundColor,
    linkColor
  };
}
function contrast_checker_reducer(prevColors, newColors) {
  const hasChanged = Object.keys(newColors).some(
    (key) => prevColors[key] !== newColors[key]
  );
  return hasChanged ? newColors : prevColors;
}
function BlockColorContrastChecker({ clientId }) {
  const blockEl = useBlockElement(clientId);
  const [colors, setColors] = (0,external_wp_element_namespaceObject.useReducer)(contrast_checker_reducer, {});
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!blockEl) {
      return;
    }
    function updateColors() {
      setColors(getBlockElementColors(blockEl));
    }
    window.requestAnimationFrame(
      () => window.requestAnimationFrame(updateColors)
    );
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    contrast_checker_default,
    {
      backgroundColor: colors.backgroundColor,
      textColor: colors.textColor,
      linkColor: colors.linkColor,
      enableAlphaChecker: true
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/color.js















const COLOR_SUPPORT_KEY = "color";
const hasColorSupport = (blockNameOrType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockNameOrType, COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};
const hasLinkColorSupport = (blockType) => {
  if (external_wp_element_namespaceObject.Platform.OS !== "web") {
    return false;
  }
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.link;
};
const hasGradientSupport = (blockNameOrType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockNameOrType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.gradients;
};
const hasBackgroundColorSupport = (blockType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};
const hasTextColorSupport = (blockType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
function color_addAttributes(settings) {
  if (!hasColorSupport(settings)) {
    return settings;
  }
  if (!settings.attributes.backgroundColor) {
    Object.assign(settings.attributes, {
      backgroundColor: {
        type: "string"
      }
    });
  }
  if (!settings.attributes.textColor) {
    Object.assign(settings.attributes, {
      textColor: {
        type: "string"
      }
    });
  }
  if (hasGradientSupport(settings) && !settings.attributes.gradient) {
    Object.assign(settings.attributes, {
      gradient: {
        type: "string"
      }
    });
  }
  return settings;
}
function color_addSaveProps(props, blockNameOrType, attributes) {
  if (!hasColorSupport(blockNameOrType) || shouldSkipSerialization(blockNameOrType, COLOR_SUPPORT_KEY)) {
    return props;
  }
  const hasGradient = hasGradientSupport(blockNameOrType);
  const { backgroundColor, textColor, gradient, style } = attributes;
  const shouldSerialize = (feature) => !shouldSkipSerialization(
    blockNameOrType,
    COLOR_SUPPORT_KEY,
    feature
  );
  const textClass = shouldSerialize("text") ? getColorClassName("color", textColor) : void 0;
  const gradientClass = shouldSerialize("gradients") ? __experimentalGetGradientClass(gradient) : void 0;
  const backgroundClass = shouldSerialize("background") ? getColorClassName("background-color", backgroundColor) : void 0;
  const serializeHasBackground = shouldSerialize("background") || shouldSerialize("gradients");
  const hasBackground = backgroundColor || style?.color?.background || hasGradient && (gradient || style?.color?.gradient);
  const newClassName = dist_clsx(props.className, textClass, gradientClass, {
    // Don't apply the background class if there's a custom gradient.
    [backgroundClass]: (!hasGradient || !style?.color?.gradient) && !!backgroundClass,
    "has-text-color": shouldSerialize("text") && (textColor || style?.color?.text),
    "has-background": serializeHasBackground && hasBackground,
    "has-link-color": shouldSerialize("link") && style?.elements?.link?.color
  });
  props.className = newClassName ? newClassName : void 0;
  return props;
}
function color_styleToAttributes(style) {
  const textColorValue = style?.color?.text;
  const textColorSlug = textColorValue?.startsWith("var:preset|color|") ? textColorValue.substring("var:preset|color|".length) : void 0;
  const backgroundColorValue = style?.color?.background;
  const backgroundColorSlug = backgroundColorValue?.startsWith(
    "var:preset|color|"
  ) ? backgroundColorValue.substring("var:preset|color|".length) : void 0;
  const gradientValue = style?.color?.gradient;
  const gradientSlug = gradientValue?.startsWith("var:preset|gradient|") ? gradientValue.substring("var:preset|gradient|".length) : void 0;
  const updatedStyle = { ...style };
  updatedStyle.color = {
    ...updatedStyle.color,
    text: textColorSlug ? void 0 : textColorValue,
    background: backgroundColorSlug ? void 0 : backgroundColorValue,
    gradient: gradientSlug ? void 0 : gradientValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    textColor: textColorSlug,
    backgroundColor: backgroundColorSlug,
    gradient: gradientSlug
  };
}
function color_attributesToStyle(attributes) {
  return {
    ...attributes.style,
    color: {
      ...attributes.style?.color,
      text: attributes.textColor ? "var:preset|color|" + attributes.textColor : attributes.style?.color?.text,
      background: attributes.backgroundColor ? "var:preset|color|" + attributes.backgroundColor : attributes.style?.color?.background,
      gradient: attributes.gradient ? "var:preset|gradient|" + attributes.gradient : attributes.style?.color?.gradient
    }
  };
}
function ColorInspectorControl({ children, resetAllFilter }) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (attributes) => {
      const existingStyle = color_attributesToStyle(attributes);
      const updatedStyle = resetAllFilter(existingStyle);
      return {
        ...attributes,
        ...color_styleToAttributes(updatedStyle)
      };
    },
    [resetAllFilter]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inspector_controls_default,
    {
      group: "color",
      resetAllFilter: attributesResetAllFilter,
      children
    }
  );
}
function ColorEdit({ clientId, name, setAttributes, settings }) {
  const isEnabled = useHasColorPanel(settings);
  function selector(select) {
    const { style: style2, textColor: textColor2, backgroundColor: backgroundColor2, gradient: gradient2 } = select(store).getBlockAttributes(clientId) || {};
    return { style: style2, textColor: textColor2, backgroundColor: backgroundColor2, gradient: gradient2 };
  }
  const { style, textColor, backgroundColor, gradient } = (0,external_wp_data_namespaceObject.useSelect)(
    selector,
    [clientId]
  );
  const value = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return color_attributesToStyle({
      style,
      textColor,
      backgroundColor,
      gradient
    });
  }, [style, textColor, backgroundColor, gradient]);
  const onChange = (newStyle) => {
    setAttributes(color_styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    COLOR_SUPPORT_KEY,
    "__experimentalDefaultControls"
  ]);
  const enableContrastChecking = external_wp_element_namespaceObject.Platform.OS === "web" && !value?.color?.gradient && (settings?.color?.text || settings?.color?.link) && // Contrast checking is enabled by default.
  // Deactivating it requires `enableContrastChecker` to have
  // an explicit value of `false`.
  false !== (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    COLOR_SUPPORT_KEY,
    "enableContrastChecker"
  ]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    ColorPanel,
    {
      as: ColorInspectorControl,
      panelId: clientId,
      settings,
      value,
      onChange,
      defaultControls,
      enableContrastChecker: false !== (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
        COLOR_SUPPORT_KEY,
        "enableContrastChecker"
      ]),
      children: enableContrastChecking && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockColorContrastChecker, { clientId })
    }
  );
}
function color_useBlockProps({
  name,
  backgroundColor,
  textColor,
  gradient,
  style
}) {
  const [userPalette, themePalette, defaultPalette] = use_settings_useSettings(
    "color.palette.custom",
    "color.palette.theme",
    "color.palette.default"
  );
  const colors = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userPalette || [],
      ...themePalette || [],
      ...defaultPalette || []
    ],
    [userPalette, themePalette, defaultPalette]
  );
  if (!hasColorSupport(name) || shouldSkipSerialization(name, COLOR_SUPPORT_KEY)) {
    return {};
  }
  const extraStyles = {};
  if (textColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, "text")) {
    extraStyles.color = getColorObjectByAttributeValues(
      colors,
      textColor
    )?.color;
  }
  if (backgroundColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, "background")) {
    extraStyles.backgroundColor = getColorObjectByAttributeValues(
      colors,
      backgroundColor
    )?.color;
  }
  const saveProps = color_addSaveProps({ style: extraStyles }, name, {
    textColor,
    backgroundColor,
    gradient,
    style
  });
  const hasBackgroundValue = backgroundColor || style?.color?.background || gradient || style?.color?.gradient;
  return {
    ...saveProps,
    className: dist_clsx(
      saveProps.className,
      // Add background image classes in the editor, if not already handled by background color values.
      !hasBackgroundValue && getBackgroundImageClasses(style)
    )
  };
}
var color_default = {
  useBlockProps: color_useBlockProps,
  addSaveProps: color_addSaveProps,
  attributeKeys: ["backgroundColor", "textColor", "gradient", "style"],
  hasSupport: hasColorSupport
};
const MIGRATION_PATHS = {
  linkColor: [["style", "elements", "link", "color", "text"]],
  textColor: [["textColor"], ["style", "color", "text"]],
  backgroundColor: [
    ["backgroundColor"],
    ["style", "color", "background"]
  ],
  gradient: [["gradient"], ["style", "color", "gradient"]]
};
function color_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    linkColor: hasLinkColorSupport(destinationBlockType),
    textColor: hasTextColorSupport(destinationBlockType),
    backgroundColor: hasBackgroundColorSupport(destinationBlockType),
    gradient: hasGradientSupport(destinationBlockType)
  };
  return transformStyles(
    activeSupports,
    MIGRATION_PATHS,
    result,
    source,
    index,
    results
  );
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/color/addAttribute",
  color_addAttributes
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.switchToBlockType.transformedBlock",
  "core/color/addTransforms",
  color_addTransforms
);


;// ./node_modules/@wordpress/block-editor/build-module/components/font-family/index.js






function FontFamilyControl({
  /** Start opting into the larger default height that will become the default size in a future version. */
  __next40pxDefaultSize = false,
  /** Start opting into the new margin-free styles that will become the default in a future version. */
  __nextHasNoMarginBottom = false,
  value = "",
  onChange,
  fontFamilies,
  className,
  ...props
}) {
  const [blockLevelFontFamilies] = use_settings_useSettings("typography.fontFamilies");
  if (!fontFamilies) {
    fontFamilies = blockLevelFontFamilies;
  }
  if (!fontFamilies || fontFamilies.length === 0) {
    return null;
  }
  const options = [
    {
      key: "",
      name: (0,external_wp_i18n_namespaceObject.__)("Default")
    },
    ...fontFamilies.map(({ fontFamily, name }) => ({
      key: fontFamily,
      name: name || fontFamily,
      style: { fontFamily }
    }))
  ];
  if (!__nextHasNoMarginBottom) {
    external_wp_deprecated_default()(
      "Bottom margin styles for wp.blockEditor.FontFamilyControl",
      {
        since: "6.7",
        version: "7.0",
        hint: "Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version"
      }
    );
  }
  if (!__next40pxDefaultSize && (props.size === void 0 || props.size === "default")) {
    external_wp_deprecated_default()(
      `36px default size for wp.blockEditor.__experimentalFontFamilyControl`,
      {
        since: "6.8",
        version: "7.1",
        hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
      }
    );
  }
  const selectedValue = options.find((option) => option.key === value) ?? "";
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.CustomSelectControl,
    {
      __next40pxDefaultSize,
      __shouldNotWarnDeprecated36pxSize: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Font"),
      value: selectedValue,
      onChange: ({ selectedItem }) => onChange(selectedItem.key),
      options,
      className: dist_clsx("block-editor-font-family-control", className, {
        "is-next-has-no-margin-bottom": __nextHasNoMarginBottom
      }),
      ...props
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/font-appearance-control/index.js






const getFontAppearanceLabel = (hasFontStyles, hasFontWeights) => {
  if (!hasFontStyles) {
    return (0,external_wp_i18n_namespaceObject.__)("Font weight");
  }
  if (!hasFontWeights) {
    return (0,external_wp_i18n_namespaceObject.__)("Font style");
  }
  return (0,external_wp_i18n_namespaceObject.__)("Appearance");
};
function FontAppearanceControl(props) {
  const {
    /** Start opting into the larger default height that will become the default size in a future version. */
    __next40pxDefaultSize = false,
    onChange,
    hasFontStyles = true,
    hasFontWeights = true,
    fontFamilyFaces,
    value: { fontStyle, fontWeight },
    ...otherProps
  } = props;
  const hasStylesOrWeights = hasFontStyles || hasFontWeights;
  const label = getFontAppearanceLabel(hasFontStyles, hasFontWeights);
  const defaultOption = {
    key: "default",
    name: (0,external_wp_i18n_namespaceObject.__)("Default"),
    style: { fontStyle: void 0, fontWeight: void 0 }
  };
  const { fontStyles, fontWeights, combinedStyleAndWeightOptions } = getFontStylesAndWeights(fontFamilyFaces);
  const combineOptions = () => {
    const combinedOptions = [defaultOption];
    if (combinedStyleAndWeightOptions) {
      combinedOptions.push(...combinedStyleAndWeightOptions);
    }
    return combinedOptions;
  };
  const styleOptions = () => {
    const combinedOptions = [defaultOption];
    fontStyles.forEach(({ name, value }) => {
      combinedOptions.push({
        key: value,
        name,
        style: { fontStyle: value, fontWeight: void 0 }
      });
    });
    return combinedOptions;
  };
  const weightOptions = () => {
    const combinedOptions = [defaultOption];
    fontWeights.forEach(({ name, value }) => {
      combinedOptions.push({
        key: value,
        name,
        style: { fontStyle: void 0, fontWeight: value }
      });
    });
    return combinedOptions;
  };
  const selectOptions = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (hasFontStyles && hasFontWeights) {
      return combineOptions();
    }
    return hasFontStyles ? styleOptions() : weightOptions();
  }, [
    props.options,
    fontStyles,
    fontWeights,
    combinedStyleAndWeightOptions
  ]);
  const currentSelection = selectOptions.find(
    (option) => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight
  ) || selectOptions[0];
  const getDescribedBy = () => {
    if (!currentSelection) {
      return (0,external_wp_i18n_namespaceObject.__)("No selected font appearance");
    }
    if (!hasFontStyles) {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: Currently selected font weight.
        (0,external_wp_i18n_namespaceObject.__)("Currently selected font weight: %s"),
        currentSelection.name
      );
    }
    if (!hasFontWeights) {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: Currently selected font style.
        (0,external_wp_i18n_namespaceObject.__)("Currently selected font style: %s"),
        currentSelection.name
      );
    }
    return (0,external_wp_i18n_namespaceObject.sprintf)(
      // translators: %s: Currently selected font appearance.
      (0,external_wp_i18n_namespaceObject.__)("Currently selected font appearance: %s"),
      currentSelection.name
    );
  };
  if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
    external_wp_deprecated_default()(
      `36px default size for wp.blockEditor.__experimentalFontAppearanceControl`,
      {
        since: "6.8",
        version: "7.1",
        hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
      }
    );
  }
  return hasStylesOrWeights && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.CustomSelectControl,
    {
      ...otherProps,
      className: "components-font-appearance-control",
      __next40pxDefaultSize,
      __shouldNotWarnDeprecated36pxSize: true,
      label,
      describedBy: getDescribedBy(),
      options: selectOptions,
      value: currentSelection,
      onChange: ({ selectedItem }) => onChange(selectedItem.style)
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/utils.js
const BASE_DEFAULT_VALUE = 1.5;
const STEP = 0.01;
const SPIN_FACTOR = 10;
const RESET_VALUE = "";
function isLineHeightDefined(lineHeight) {
  return lineHeight !== void 0 && lineHeight !== RESET_VALUE;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/line-height-control/index.js





const line_height_control_LineHeightControl = ({
  /** Start opting into the larger default height that will become the default size in a future version. */
  __next40pxDefaultSize = false,
  value: lineHeight,
  onChange,
  __unstableInputWidth = "60px",
  ...otherProps
}) => {
  const isDefined = isLineHeightDefined(lineHeight);
  const adjustNextValue = (nextValue, wasTypedOrPasted) => {
    if (isDefined) {
      return nextValue;
    }
    const spin = STEP * SPIN_FACTOR;
    switch (`${nextValue}`) {
      case `${spin}`:
        return BASE_DEFAULT_VALUE + spin;
      case "0": {
        if (wasTypedOrPasted) {
          return nextValue;
        }
        return BASE_DEFAULT_VALUE - spin;
      }
      case "":
        return BASE_DEFAULT_VALUE;
      default:
        return nextValue;
    }
  };
  const stateReducer = (state, action) => {
    const wasTypedOrPasted = ["insertText", "insertFromPaste"].includes(
      action.payload.event.nativeEvent?.inputType
    );
    const value2 = adjustNextValue(state.value, wasTypedOrPasted);
    return { ...state, value: value2 };
  };
  const value = isDefined ? lineHeight : RESET_VALUE;
  const handleOnChange = (nextValue, { event }) => {
    if (nextValue === "") {
      onChange();
      return;
    }
    if (event.type === "click") {
      onChange(adjustNextValue(`${nextValue}`, false));
      return;
    }
    onChange(`${nextValue}`);
  };
  if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
    external_wp_deprecated_default()(`36px default size for wp.blockEditor.LineHeightControl`, {
      since: "6.8",
      version: "7.1",
      hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
    });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-line-height-control", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalNumberControl,
    {
      ...otherProps,
      __shouldNotWarnDeprecated36pxSize: true,
      __next40pxDefaultSize,
      __unstableInputWidth,
      __unstableStateReducer: stateReducer,
      onChange: handleOnChange,
      label: (0,external_wp_i18n_namespaceObject.__)("Line height"),
      placeholder: BASE_DEFAULT_VALUE,
      step: STEP,
      spinFactor: SPIN_FACTOR,
      value,
      min: 0,
      spinControls: "custom"
    }
  ) });
};
var line_height_control_default = line_height_control_LineHeightControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/letter-spacing-control/index.js





function LetterSpacingControl({
  __next40pxDefaultSize = false,
  value,
  onChange,
  __unstableInputWidth = "60px",
  ...otherProps
}) {
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || ["px", "em", "rem"],
    defaultValues: { px: 2, em: 0.2, rem: 0.2 }
  });
  if (!__next40pxDefaultSize && (otherProps.size === void 0 || otherProps.size === "default")) {
    external_wp_deprecated_default()(
      `36px default size for wp.blockEditor.__experimentalLetterSpacingControl`,
      {
        since: "6.8",
        version: "7.1",
        hint: "Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version."
      }
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalUnitControl,
    {
      __next40pxDefaultSize,
      __shouldNotWarnDeprecated36pxSize: true,
      ...otherProps,
      label: (0,external_wp_i18n_namespaceObject.__)("Letter spacing"),
      value,
      __unstableInputWidth,
      units,
      onChange
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/align-left.js


var align_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M13 5.5H4V4h9v1.5Zm7 7H4V11h16v1.5Zm-7 7H4V18h9v1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/align-center.js


var align_center_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7.5 5.5h9V4h-9v1.5Zm-3.5 7h16V11H4v1.5Zm3.5 7h9V18h-9v1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/align-right.js


var align_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M11.111 5.5H20V4h-8.889v1.5ZM4 12.5h16V11H4v1.5Zm7.111 7H20V18h-8.889v1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/align-justify.js


var align_justify_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4 12.8h16v-1.5H4v1.5zm0 7h12.4v-1.5H4v1.5zM4 4.3v1.5h16V4.3H4z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/text-alignment-control/index.js






const TEXT_ALIGNMENT_OPTIONS = [
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Align text left"),
    value: "left",
    icon: align_left_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Align text center"),
    value: "center",
    icon: align_center_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Align text right"),
    value: "right",
    icon: align_right_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Justify text"),
    value: "justify",
    icon: align_justify_default
  }
];
const DEFAULT_OPTIONS = ["left", "center", "right"];
function TextAlignmentControl({
  className,
  value,
  onChange,
  options = DEFAULT_OPTIONS
}) {
  const validOptions = (0,external_wp_element_namespaceObject.useMemo)(
    () => TEXT_ALIGNMENT_OPTIONS.filter(
      (option) => options.includes(option.value)
    ),
    [options]
  );
  if (!validOptions.length) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      isDeselectable: true,
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Text alignment"),
      className: dist_clsx(
        "block-editor-text-alignment-control",
        className
      ),
      value,
      onChange: (newValue) => {
        onChange(newValue === value ? void 0 : newValue);
      },
      children: validOptions.map((option) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            value: option.value,
            icon: option.icon,
            label: option.label
          },
          option.value
        );
      })
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/format-uppercase.js


var format_uppercase_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/format-lowercase.js


var format_lowercase_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/format-capitalize.js


var format_capitalize_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/text-transform-control/index.js





const TEXT_TRANSFORMS = [
  {
    label: (0,external_wp_i18n_namespaceObject.__)("None"),
    value: "none",
    icon: reset_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Uppercase"),
    value: "uppercase",
    icon: format_uppercase_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Lowercase"),
    value: "lowercase",
    icon: format_lowercase_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Capitalize"),
    value: "capitalize",
    icon: format_capitalize_default
  }
];
function TextTransformControl({ className, value, onChange }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      isDeselectable: true,
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Letter case"),
      className: dist_clsx(
        "block-editor-text-transform-control",
        className
      ),
      value,
      onChange: (newValue) => {
        onChange(newValue === value ? void 0 : newValue);
      },
      children: TEXT_TRANSFORMS.map((option) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            value: option.value,
            icon: option.icon,
            label: option.label
          },
          option.value
        );
      })
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/format-underline.js


var format_underline_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/format-strikethrough.js


var format_strikethrough_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/text-decoration-control/index.js





const TEXT_DECORATIONS = [
  {
    label: (0,external_wp_i18n_namespaceObject.__)("None"),
    value: "none",
    icon: reset_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Underline"),
    value: "underline",
    icon: format_underline_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Strikethrough"),
    value: "line-through",
    icon: format_strikethrough_default
  }
];
function TextDecorationControl({
  value,
  onChange,
  className
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      isDeselectable: true,
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Decoration"),
      className: dist_clsx(
        "block-editor-text-decoration-control",
        className
      ),
      value,
      onChange: (newValue) => {
        onChange(newValue === value ? void 0 : newValue);
      },
      children: TEXT_DECORATIONS.map((option) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            value: option.value,
            icon: option.icon,
            label: option.label
          },
          option.value
        );
      })
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/text-horizontal.js


var text_horizontal_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M8.2 14.4h3.9L13 17h1.7L11 6.5H9.3L5.6 17h1.7l.9-2.6zm2-5.5 1.4 4H8.8l1.4-4zm7.4 7.5-1.3.8.8 1.4H5.5V20h14.3l-2.2-3.6z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/text-vertical.js


var text_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M7 5.6v1.7l2.6.9v3.9L7 13v1.7L17.5 11V9.3L7 5.6zm4.2 6V8.8l4 1.4-4 1.4zm-5.7 5.6V5.5H4v14.3l3.6-2.2-.8-1.3-1.3.9z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-mode-control/index.js





const WRITING_MODES = [
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Horizontal"),
    value: "horizontal-tb",
    icon: text_horizontal_default
  },
  {
    label: (0,external_wp_i18n_namespaceObject.__)("Vertical"),
    value: (0,external_wp_i18n_namespaceObject.isRTL)() ? "vertical-lr" : "vertical-rl",
    icon: text_vertical_default
  }
];
function WritingModeControl({ className, value, onChange }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      isDeselectable: true,
      __nextHasNoMarginBottom: true,
      __next40pxDefaultSize: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Orientation"),
      className: dist_clsx("block-editor-writing-mode-control", className),
      value,
      onChange: (newValue) => {
        onChange(newValue === value ? void 0 : newValue);
      },
      children: WRITING_MODES.map((option) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
          {
            value: option.value,
            icon: option.icon,
            label: option.label
          },
          option.value
        );
      })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/typography-panel.js
















const MIN_TEXT_COLUMNS = 1;
const MAX_TEXT_COLUMNS = 6;
function useHasTypographyPanel(settings) {
  const hasFontFamily = useHasFontFamilyControl(settings);
  const hasLineHeight = useHasLineHeightControl(settings);
  const hasFontAppearance = useHasAppearanceControl(settings);
  const hasLetterSpacing = useHasLetterSpacingControl(settings);
  const hasTextAlign = useHasTextAlignmentControl(settings);
  const hasTextTransform = useHasTextTransformControl(settings);
  const hasTextDecoration = useHasTextDecorationControl(settings);
  const hasWritingMode = useHasWritingModeControl(settings);
  const hasTextColumns = useHasTextColumnsControl(settings);
  const hasFontSize = useHasFontSizeControl(settings);
  return hasFontFamily || hasLineHeight || hasFontAppearance || hasLetterSpacing || hasTextAlign || hasTextTransform || hasFontSize || hasTextDecoration || hasWritingMode || hasTextColumns;
}
function useHasFontSizeControl(settings) {
  return settings?.typography?.defaultFontSizes !== false && settings?.typography?.fontSizes?.default?.length || settings?.typography?.fontSizes?.theme?.length || settings?.typography?.fontSizes?.custom?.length || settings?.typography?.customFontSize;
}
function useHasFontFamilyControl(settings) {
  return ["default", "theme", "custom"].some(
    (key) => settings?.typography?.fontFamilies?.[key]?.length
  );
}
function useHasLineHeightControl(settings) {
  return settings?.typography?.lineHeight;
}
function useHasAppearanceControl(settings) {
  return settings?.typography?.fontStyle || settings?.typography?.fontWeight;
}
function useAppearanceControlLabel(settings) {
  if (!settings?.typography?.fontStyle) {
    return (0,external_wp_i18n_namespaceObject.__)("Font weight");
  }
  if (!settings?.typography?.fontWeight) {
    return (0,external_wp_i18n_namespaceObject.__)("Font style");
  }
  return (0,external_wp_i18n_namespaceObject.__)("Appearance");
}
function useHasLetterSpacingControl(settings) {
  return settings?.typography?.letterSpacing;
}
function useHasTextTransformControl(settings) {
  return settings?.typography?.textTransform;
}
function useHasTextAlignmentControl(settings) {
  return settings?.typography?.textAlign;
}
function useHasTextDecorationControl(settings) {
  return settings?.typography?.textDecoration;
}
function useHasWritingModeControl(settings) {
  return settings?.typography?.writingMode;
}
function useHasTextColumnsControl(settings) {
  return settings?.typography?.textColumns;
}
function getMergedFontSizes(settings) {
  const fontSizes = settings?.typography?.fontSizes;
  const defaultFontSizesEnabled = !!settings?.typography?.defaultFontSizes;
  return [
    ...fontSizes?.custom ?? [],
    ...fontSizes?.theme ?? [],
    ...defaultFontSizesEnabled ? fontSizes?.default ?? [] : []
  ];
}
function TypographyToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Typography"),
      resetAll,
      panelId,
      dropdownMenuProps,
      children
    }
  );
}
const typography_panel_DEFAULT_CONTROLS = {
  fontFamily: true,
  fontSize: true,
  fontAppearance: true,
  lineHeight: true,
  letterSpacing: true,
  textAlign: true,
  textTransform: true,
  textDecoration: true,
  writingMode: true,
  textColumns: true
};
function TypographyPanel({
  as: Wrapper = TypographyToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = typography_panel_DEFAULT_CONTROLS,
  fitText = false
}) {
  const decodeValue = (rawValue) => getValueFromVariable({ settings }, "", rawValue);
  const hasFontFamilyEnabled = useHasFontFamilyControl(settings);
  const fontFamily = decodeValue(inheritedValue?.typography?.fontFamily);
  const { fontFamilies, fontFamilyFaces } = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return getMergedFontFamiliesAndFontFamilyFaces(settings, fontFamily);
  }, [settings, fontFamily]);
  const setFontFamily = (newValue) => {
    const slug = fontFamilies?.find(
      ({ fontFamily: f }) => f === newValue
    )?.slug;
    let updatedValue = setImmutably(
      value,
      ["typography", "fontFamily"],
      slug ? `var:preset|font-family|${slug}` : newValue || void 0
    );
    const newFontFamilyFaces = fontFamilies?.find(({ fontFamily: f }) => f === newValue)?.fontFace ?? [];
    const { fontStyles, fontWeights } = getFontStylesAndWeights(newFontFamilyFaces);
    const hasFontStyle = fontStyles?.some(
      ({ value: fs }) => fs === fontStyle
    );
    const hasFontWeight = fontWeights?.some(
      ({ value: fw }) => fw?.toString() === fontWeight?.toString()
    );
    if (!hasFontStyle || !hasFontWeight) {
      const { nearestFontStyle, nearestFontWeight } = findNearestStyleAndWeight(
        newFontFamilyFaces,
        fontStyle,
        fontWeight
      );
      if (nearestFontStyle || nearestFontWeight) {
        updatedValue = {
          ...updatedValue,
          typography: {
            ...updatedValue?.typography,
            fontStyle: nearestFontStyle || void 0,
            fontWeight: nearestFontWeight || void 0
          }
        };
      } else if (fontStyle || fontWeight) {
        updatedValue = {
          ...updatedValue,
          typography: {
            ...updatedValue?.typography,
            fontStyle: void 0,
            fontWeight: void 0
          }
        };
      }
    }
    onChange(updatedValue);
  };
  const hasFontFamily = () => !!value?.typography?.fontFamily;
  const resetFontFamily = () => setFontFamily(void 0);
  const hasFontSizeEnabled = useHasFontSizeControl(settings);
  const disableCustomFontSizes = !settings?.typography?.customFontSize;
  const mergedFontSizes = getMergedFontSizes(settings);
  const fontSize = decodeValue(inheritedValue?.typography?.fontSize);
  const currentFontSizeSlug = (() => {
    const rawValue = inheritedValue?.typography?.fontSize;
    if (!rawValue || typeof rawValue !== "string") {
      return void 0;
    }
    if (rawValue.startsWith("var:preset|font-size|")) {
      return rawValue.replace("var:preset|font-size|", "");
    }
    const cssVarMatch = rawValue.match(
      /^var\(--wp--preset--font-size--([^)]+)\)$/
    );
    if (cssVarMatch) {
      return cssVarMatch[1];
    }
    return void 0;
  })();
  const setFontSize = (newValue, metadata) => {
    const actualValue = !!metadata?.slug ? `var:preset|font-size|${metadata?.slug}` : newValue;
    onChange(
      setImmutably(
        value,
        ["typography", "fontSize"],
        actualValue || void 0
      )
    );
  };
  const hasFontSize = () => !!value?.typography?.fontSize;
  const resetFontSize = () => setFontSize(void 0);
  const hasAppearanceControl = useHasAppearanceControl(settings);
  const appearanceControlLabel = useAppearanceControlLabel(settings);
  const hasFontStyles = settings?.typography?.fontStyle;
  const hasFontWeights = settings?.typography?.fontWeight;
  const fontStyle = decodeValue(inheritedValue?.typography?.fontStyle);
  const fontWeight = decodeValue(inheritedValue?.typography?.fontWeight);
  const setFontAppearance = (0,external_wp_element_namespaceObject.useCallback)(
    ({ fontStyle: newFontStyle, fontWeight: newFontWeight }) => {
      if (newFontStyle !== fontStyle || newFontWeight !== fontWeight) {
        onChange({
          ...value,
          typography: {
            ...value?.typography,
            fontStyle: newFontStyle || void 0,
            fontWeight: newFontWeight || void 0
          }
        });
      }
    },
    [fontStyle, fontWeight, onChange, value]
  );
  const hasFontAppearance = () => !!value?.typography?.fontStyle || !!value?.typography?.fontWeight;
  const resetFontAppearance = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setFontAppearance({});
  }, [setFontAppearance]);
  const hasLineHeightEnabled = useHasLineHeightControl(settings);
  const lineHeight = decodeValue(inheritedValue?.typography?.lineHeight);
  const setLineHeight = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "lineHeight"],
        newValue || void 0
      )
    );
  };
  const hasLineHeight = () => value?.typography?.lineHeight !== void 0;
  const resetLineHeight = () => setLineHeight(void 0);
  const hasLetterSpacingControl = useHasLetterSpacingControl(settings);
  const letterSpacing = decodeValue(
    inheritedValue?.typography?.letterSpacing
  );
  const setLetterSpacing = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "letterSpacing"],
        newValue || void 0
      )
    );
  };
  const hasLetterSpacing = () => !!value?.typography?.letterSpacing;
  const resetLetterSpacing = () => setLetterSpacing(void 0);
  const hasTextColumnsControl = useHasTextColumnsControl(settings);
  const textColumns = decodeValue(inheritedValue?.typography?.textColumns);
  const setTextColumns = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "textColumns"],
        newValue || void 0
      )
    );
  };
  const hasTextColumns = () => !!value?.typography?.textColumns;
  const resetTextColumns = () => setTextColumns(void 0);
  const hasTextTransformControl = useHasTextTransformControl(settings);
  const textTransform = decodeValue(
    inheritedValue?.typography?.textTransform
  );
  const setTextTransform = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "textTransform"],
        newValue || void 0
      )
    );
  };
  const hasTextTransform = () => !!value?.typography?.textTransform;
  const resetTextTransform = () => setTextTransform(void 0);
  const hasTextDecorationControl = useHasTextDecorationControl(settings);
  const textDecoration = decodeValue(
    inheritedValue?.typography?.textDecoration
  );
  const setTextDecoration = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "textDecoration"],
        newValue || void 0
      )
    );
  };
  const hasTextDecoration = () => !!value?.typography?.textDecoration;
  const resetTextDecoration = () => setTextDecoration(void 0);
  const hasWritingModeControl = useHasWritingModeControl(settings);
  const writingMode = decodeValue(inheritedValue?.typography?.writingMode);
  const setWritingMode = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "writingMode"],
        newValue || void 0
      )
    );
  };
  const hasWritingMode = () => !!value?.typography?.writingMode;
  const resetWritingMode = () => setWritingMode(void 0);
  const hasTextAlignmentControl = useHasTextAlignmentControl(settings);
  const textAlign = decodeValue(inheritedValue?.typography?.textAlign);
  const setTextAlign = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["typography", "textAlign"],
        newValue || void 0
      )
    );
  };
  const hasTextAlign = () => !!value?.typography?.textAlign;
  const resetTextAlign = () => setTextAlign(void 0);
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      typography: {}
    };
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      children: [
        hasFontFamilyEnabled && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Font"),
            hasValue: hasFontFamily,
            onDeselect: resetFontFamily,
            isShownByDefault: defaultControls.fontFamily,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              FontFamilyControl,
              {
                fontFamilies,
                value: fontFamily,
                onChange: setFontFamily,
                size: "__unstable-large",
                __nextHasNoMarginBottom: true
              }
            )
          }
        ),
        hasFontSizeEnabled && !fitText && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Size"),
            hasValue: hasFontSize,
            onDeselect: resetFontSize,
            isShownByDefault: defaultControls.fontSize,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.FontSizePicker,
              {
                value: currentFontSizeSlug || fontSize,
                valueMode: currentFontSizeSlug ? "slug" : "literal",
                onChange: setFontSize,
                fontSizes: mergedFontSizes,
                disableCustomFontSizes,
                withReset: false,
                withSlider: true,
                size: "__unstable-large"
              }
            )
          }
        ),
        hasAppearanceControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: appearanceControlLabel,
            hasValue: hasFontAppearance,
            onDeselect: resetFontAppearance,
            isShownByDefault: defaultControls.fontAppearance,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              FontAppearanceControl,
              {
                value: {
                  fontStyle,
                  fontWeight
                },
                onChange: setFontAppearance,
                hasFontStyles,
                hasFontWeights,
                fontFamilyFaces,
                size: "__unstable-large"
              }
            )
          }
        ),
        hasLineHeightEnabled && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: (0,external_wp_i18n_namespaceObject.__)("Line height"),
            hasValue: hasLineHeight,
            onDeselect: resetLineHeight,
            isShownByDefault: defaultControls.lineHeight,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              line_height_control_default,
              {
                __unstableInputWidth: "auto",
                value: lineHeight,
                onChange: setLineHeight,
                size: "__unstable-large"
              }
            )
          }
        ),
        hasLetterSpacingControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: (0,external_wp_i18n_namespaceObject.__)("Letter spacing"),
            hasValue: hasLetterSpacing,
            onDeselect: resetLetterSpacing,
            isShownByDefault: defaultControls.letterSpacing,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              LetterSpacingControl,
              {
                value: letterSpacing,
                onChange: setLetterSpacing,
                size: "__unstable-large",
                __unstableInputWidth: "auto"
              }
            )
          }
        ),
        hasTextColumnsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: (0,external_wp_i18n_namespaceObject.__)("Columns"),
            hasValue: hasTextColumns,
            onDeselect: resetTextColumns,
            isShownByDefault: defaultControls.textColumns,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalNumberControl,
              {
                label: (0,external_wp_i18n_namespaceObject.__)("Columns"),
                max: MAX_TEXT_COLUMNS,
                min: MIN_TEXT_COLUMNS,
                onChange: setTextColumns,
                size: "__unstable-large",
                spinControls: "custom",
                value: textColumns,
                initialPosition: 1
              }
            )
          }
        ),
        hasTextDecorationControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: (0,external_wp_i18n_namespaceObject.__)("Decoration"),
            hasValue: hasTextDecoration,
            onDeselect: resetTextDecoration,
            isShownByDefault: defaultControls.textDecoration,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              TextDecorationControl,
              {
                value: textDecoration,
                onChange: setTextDecoration,
                size: "__unstable-large",
                __unstableInputWidth: "auto"
              }
            )
          }
        ),
        hasWritingModeControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            className: "single-column",
            label: (0,external_wp_i18n_namespaceObject.__)("Orientation"),
            hasValue: hasWritingMode,
            onDeselect: resetWritingMode,
            isShownByDefault: defaultControls.writingMode,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              WritingModeControl,
              {
                value: writingMode,
                onChange: setWritingMode,
                size: "__unstable-large",
                __nextHasNoMarginBottom: true
              }
            )
          }
        ),
        hasTextTransformControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Letter case"),
            hasValue: hasTextTransform,
            onDeselect: resetTextTransform,
            isShownByDefault: defaultControls.textTransform,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              TextTransformControl,
              {
                value: textTransform,
                onChange: setTextTransform,
                showNone: true,
                isBlock: true,
                size: "__unstable-large",
                __nextHasNoMarginBottom: true
              }
            )
          }
        ),
        hasTextAlignmentControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Text alignment"),
            hasValue: hasTextAlign,
            onDeselect: resetTextAlign,
            isShownByDefault: defaultControls.textAlign,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              TextAlignmentControl,
              {
                value: textAlign,
                onChange: setTextAlign,
                size: "__unstable-large",
                __nextHasNoMarginBottom: true
              }
            )
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/line-height.js





const LINE_HEIGHT_SUPPORT_KEY = "typography.lineHeight";
function LineHeightEdit(props) {
  const {
    attributes: { style },
    setAttributes
  } = props;
  const onChange = (newLineHeightValue) => {
    const newStyle = {
      ...style,
      typography: {
        ...style?.typography,
        lineHeight: newLineHeightValue
      }
    };
    setAttributes({ style: cleanEmptyObject(newStyle) });
  };
  return /* @__PURE__ */ jsx(
    LineHeightControl,
    {
      __unstableInputWidth: "100%",
      value: style?.typography?.lineHeight,
      onChange,
      size: "__unstable-large"
    }
  );
}
function useIsLineHeightDisabled({ name: blockName } = {}) {
  const [isEnabled] = useSettings("typography.lineHeight");
  return !isEnabled || !hasBlockSupport(blockName, LINE_HEIGHT_SUPPORT_KEY);
}


;// external ["wp","tokenList"]
const external_wp_tokenList_namespaceObject = window["wp"]["tokenList"];
var external_wp_tokenList_default = /*#__PURE__*/__webpack_require__.n(external_wp_tokenList_namespaceObject);
;// ./node_modules/@wordpress/block-editor/build-module/hooks/font-family.js







const FONT_FAMILY_SUPPORT_KEY = "typography.__experimentalFontFamily";
const { kebabCase: font_family_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
function font_family_addAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  }
  if (!settings.attributes.fontFamily) {
    Object.assign(settings.attributes, {
      fontFamily: {
        type: "string"
      }
    });
  }
  return settings;
}
function font_family_addSaveProps(props, blockType, attributes) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, FONT_FAMILY_SUPPORT_KEY)) {
    return props;
  }
  if (shouldSkipSerialization(
    blockType,
    TYPOGRAPHY_SUPPORT_KEY,
    "fontFamily"
  )) {
    return props;
  }
  if (!attributes?.fontFamily) {
    return props;
  }
  const classes = new (external_wp_tokenList_default())(props.className);
  classes.add(`has-${font_family_kebabCase(attributes?.fontFamily)}-font-family`);
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : void 0;
  return props;
}
function font_family_useBlockProps({ name, fontFamily }) {
  return font_family_addSaveProps({}, name, { fontFamily });
}
var font_family_default = {
  useBlockProps: font_family_useBlockProps,
  addSaveProps: font_family_addSaveProps,
  attributeKeys: ["fontFamily"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, FONT_FAMILY_SUPPORT_KEY);
  }
};
function resetFontFamily({ setAttributes }) {
  setAttributes({ fontFamily: void 0 });
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/fontFamily/addAttribute",
  font_family_addAttributes
);


;// ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/utils.js


const { kebabCase: utils_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
const utils_getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
  if (fontSizeAttribute) {
    const fontSizeObject = fontSizes?.find(
      ({ slug }) => slug === fontSizeAttribute
    );
    if (fontSizeObject) {
      return fontSizeObject;
    }
  }
  return {
    size: customFontSizeAttribute
  };
};
function utils_getFontSizeObjectByValue(fontSizes, value) {
  const fontSizeObject = fontSizes?.find(({ size }) => size === value);
  if (fontSizeObject) {
    return fontSizeObject;
  }
  return {
    size: value
  };
}
function getFontSizeClass(fontSizeSlug) {
  if (!fontSizeSlug) {
    return;
  }
  return `has-${utils_kebabCase(fontSizeSlug)}-font-size`;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/font-size.js









const FONT_SIZE_SUPPORT_KEY = "typography.fontSize";
function font_size_addAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  }
  if (!settings.attributes.fontSize) {
    Object.assign(settings.attributes, {
      fontSize: {
        type: "string"
      }
    });
  }
  return settings;
}
function font_size_addSaveProps(props, blockNameOrType, attributes) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockNameOrType, FONT_SIZE_SUPPORT_KEY)) {
    return props;
  }
  if (shouldSkipSerialization(
    blockNameOrType,
    TYPOGRAPHY_SUPPORT_KEY,
    "fontSize"
  )) {
    return props;
  }
  const classes = new (external_wp_tokenList_default())(props.className);
  classes.add(getFontSizeClass(attributes.fontSize));
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : void 0;
  return props;
}
function FontSizeEdit(props) {
  const {
    attributes: { fontSize, style, fitText },
    setAttributes
  } = props;
  const [fontSizes] = useSettings("typography.fontSizes");
  if (fitText) {
    return null;
  }
  const onChange = (value, selectedItem) => {
    const fontSizeSlug = selectedItem?.slug || getFontSizeObjectByValue(fontSizes, value).slug;
    setAttributes({
      style: cleanEmptyObject({
        ...style,
        typography: {
          ...style?.typography,
          fontSize: fontSizeSlug ? void 0 : value
        }
      }),
      fontSize: fontSizeSlug
    });
  };
  const fontSizeObject = getFontSize(
    fontSizes,
    fontSize,
    style?.typography?.fontSize
  );
  const fontSizeValue = fontSizeObject?.size || style?.typography?.fontSize || fontSize;
  return /* @__PURE__ */ jsx(
    FontSizePicker,
    {
      onChange,
      value: fontSize || fontSizeValue,
      valueMode: fontSize ? "slug" : "literal",
      withReset: false,
      withSlider: true,
      size: "__unstable-large"
    }
  );
}
function useIsFontSizeDisabled({ name: blockName } = {}) {
  const [fontSizes] = useSettings("typography.fontSizes");
  const hasFontSizes = !!fontSizes?.length;
  return !hasBlockSupport(blockName, FONT_SIZE_SUPPORT_KEY) || !hasFontSizes;
}
function font_size_useBlockProps({ name, fontSize, style }) {
  const [fontSizes, fluidTypographySettings, layoutSettings] = use_settings_useSettings(
    "typography.fontSizes",
    "typography.fluid",
    "layout"
  );
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, FONT_SIZE_SUPPORT_KEY) || shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, "fontSize") || !fontSize && !style?.typography?.fontSize) {
    return;
  }
  let props;
  if (style?.typography?.fontSize) {
    props = {
      style: {
        fontSize: getTypographyFontSizeValue(
          { size: style.typography.fontSize },
          {
            typography: {
              fluid: fluidTypographySettings
            },
            layout: layoutSettings
          }
        )
      }
    };
  }
  if (fontSize) {
    props = {
      style: {
        fontSize: utils_getFontSize(
          fontSizes,
          fontSize,
          style?.typography?.fontSize
        ).size
      }
    };
  }
  if (!props) {
    return;
  }
  return font_size_addSaveProps(props, name, { fontSize });
}
var font_size_default = {
  useBlockProps: font_size_useBlockProps,
  addSaveProps: font_size_addSaveProps,
  attributeKeys: ["fontSize", "style", "fitText"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, FONT_SIZE_SUPPORT_KEY);
  }
};
const font_size_MIGRATION_PATHS = {
  fontSize: [["fontSize"], ["style", "typography", "fontSize"]]
};
function font_size_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    fontSize: (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
      destinationBlockType,
      FONT_SIZE_SUPPORT_KEY
    )
  };
  return transformStyles(
    activeSupports,
    font_size_MIGRATION_PATHS,
    result,
    source,
    index,
    results
  );
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/font/addAttribute",
  font_size_addAttributes
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.switchToBlockType.transformedBlock",
  "core/font-size/addTransforms",
  font_size_addTransforms
);


;// ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/ui.js




const DEFAULT_ALIGNMENT_CONTROLS = [
  {
    icon: align_left_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text left"),
    align: "left"
  },
  {
    icon: align_center_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text center"),
    align: "center"
  },
  {
    icon: align_right_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text right"),
    align: "right"
  }
];
const ui_POPOVER_PROPS = {
  placement: "bottom-start"
};
function AlignmentUI({
  value,
  onChange,
  alignmentControls = DEFAULT_ALIGNMENT_CONTROLS,
  label = (0,external_wp_i18n_namespaceObject.__)("Align text"),
  description = (0,external_wp_i18n_namespaceObject.__)("Change text alignment"),
  isCollapsed = true,
  isToolbar
}) {
  function applyOrUnset(align) {
    return () => onChange(value === align ? void 0 : align);
  }
  const activeAlignment = alignmentControls.find(
    (control) => control.align === value
  );
  function setIcon() {
    if (activeAlignment) {
      return activeAlignment.icon;
    }
    return (0,external_wp_i18n_namespaceObject.isRTL)() ? align_right_default : align_left_default;
  }
  const UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  const extraProps = isToolbar ? { isCollapsed } : {
    toggleProps: {
      description
    },
    popoverProps: ui_POPOVER_PROPS
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    UIComponent,
    {
      icon: setIcon(),
      label,
      controls: alignmentControls.map((control) => {
        const { align } = control;
        const isActive = value === align;
        return {
          ...control,
          isActive,
          role: isCollapsed ? "menuitemradio" : void 0,
          onClick: applyOrUnset(align)
        };
      }),
      ...extraProps
    }
  );
}
var alignment_control_ui_ui_default = AlignmentUI;


;// ./node_modules/@wordpress/block-editor/build-module/components/alignment-control/index.js


const AlignmentControl = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(alignment_control_ui_ui_default, { ...props, isToolbar: false });
};
const AlignmentToolbar = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(alignment_control_ui_ui_default, { ...props, isToolbar: true });
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/text-align.js









const TEXT_ALIGN_SUPPORT_KEY = "typography.textAlign";
const text_align_TEXT_ALIGNMENT_OPTIONS = [
  {
    icon: align_left_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text left"),
    align: "left"
  },
  {
    icon: align_center_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text center"),
    align: "center"
  },
  {
    icon: align_right_default,
    title: (0,external_wp_i18n_namespaceObject.__)("Align text right"),
    align: "right"
  }
];
const VALID_TEXT_ALIGNMENTS = ["left", "center", "right"];
const NO_TEXT_ALIGNMENTS = [];
function getValidTextAlignments(blockTextAlign) {
  if (Array.isArray(blockTextAlign)) {
    return VALID_TEXT_ALIGNMENTS.filter(
      (textAlign) => blockTextAlign.includes(textAlign)
    );
  }
  return blockTextAlign === true ? VALID_TEXT_ALIGNMENTS : NO_TEXT_ALIGNMENTS;
}
function BlockEditTextAlignmentToolbarControlsPure({
  style,
  name: blockName,
  setAttributes
}) {
  const settings = useBlockSettings(blockName);
  const hasTextAlignControl = settings?.typography?.textAlign;
  const blockEditingMode = useBlockEditingMode();
  if (!hasTextAlignControl || blockEditingMode !== "default") {
    return null;
  }
  const validTextAlignments = getValidTextAlignments(
    (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, TEXT_ALIGN_SUPPORT_KEY)
  );
  if (!validTextAlignments.length) {
    return null;
  }
  const textAlignmentControls = text_align_TEXT_ALIGNMENT_OPTIONS.filter(
    (control) => validTextAlignments.includes(control.align)
  );
  const onChange = (newTextAlignValue) => {
    const newStyle = {
      ...style,
      typography: {
        ...style?.typography,
        textAlign: newTextAlignValue
      }
    };
    setAttributes({ style: utils_cleanEmptyObject(newStyle) });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "block", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    AlignmentControl,
    {
      value: style?.typography?.textAlign,
      onChange,
      alignmentControls: textAlignmentControls
    }
  ) });
}
var text_align_default = {
  edit: BlockEditTextAlignmentToolbarControlsPure,
  useBlockProps: text_align_useBlockProps,
  addSaveProps: addAssignedTextAlign,
  attributeKeys: ["style"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, TEXT_ALIGN_SUPPORT_KEY, false);
  }
};
function text_align_useBlockProps({ name, style }) {
  if (!style?.typography?.textAlign) {
    return null;
  }
  const validTextAlignments = getValidTextAlignments(
    (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, TEXT_ALIGN_SUPPORT_KEY)
  );
  if (!validTextAlignments.length) {
    return null;
  }
  if (shouldSkipSerialization(name, TYPOGRAPHY_SUPPORT_KEY, "textAlign")) {
    return null;
  }
  const textAlign = style.typography.textAlign;
  const className = dist_clsx({
    [`has-text-align-${textAlign}`]: textAlign
  });
  return { className };
}
function addAssignedTextAlign(props, blockType, attributes) {
  if (!attributes?.style?.typography?.textAlign) {
    return props;
  }
  const { textAlign } = attributes.style.typography;
  const blockTextAlign = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, TEXT_ALIGN_SUPPORT_KEY);
  const isTextAlignValid = getValidTextAlignments(blockTextAlign).includes(textAlign);
  if (isTextAlignValid && !shouldSkipSerialization(
    blockType,
    TYPOGRAPHY_SUPPORT_KEY,
    "textAlign"
  )) {
    props.className = dist_clsx(
      `has-text-align-${textAlign}`,
      props.className
    );
  }
  return props;
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/fit-text-utils.js
function findOptimalFontSize(textElement, applyFontSize) {
  const alreadyHasScrollableHeight = textElement.scrollHeight > textElement.clientHeight;
  let minSize = 5;
  let maxSize = 2400;
  let bestSize = minSize;
  const computedStyle = window.getComputedStyle(textElement);
  let paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
  let paddingRight = parseFloat(computedStyle.paddingRight) || 0;
  const range = document.createRange();
  range.selectNodeContents(textElement);
  let referenceElement = textElement;
  const parentElement = textElement.parentElement;
  if (parentElement) {
    const parentElementComputedStyle = window.getComputedStyle(parentElement);
    if (parentElementComputedStyle?.display === "flex") {
      referenceElement = parentElement;
      paddingLeft += parseFloat(parentElementComputedStyle.paddingLeft) || 0;
      paddingRight += parseFloat(parentElementComputedStyle.paddingRight) || 0;
    }
  }
  let maxclientHeight = referenceElement.clientHeight;
  while (minSize <= maxSize) {
    const midSize = Math.floor((minSize + maxSize) / 2);
    applyFontSize(midSize);
    const rect = range.getBoundingClientRect();
    const textWidth = rect.width;
    const fitsWidth = textElement.scrollWidth <= referenceElement.clientWidth && textWidth <= referenceElement.clientWidth - paddingLeft - paddingRight;
    const fitsHeight = alreadyHasScrollableHeight || textElement.scrollHeight <= referenceElement.clientHeight || textElement.scrollHeight <= maxclientHeight;
    if (referenceElement.clientHeight > maxclientHeight) {
      maxclientHeight = referenceElement.clientHeight;
    }
    if (fitsWidth && fitsHeight) {
      bestSize = midSize;
      minSize = midSize + 1;
    } else {
      maxSize = midSize - 1;
    }
  }
  range.detach();
  return bestSize;
}
function optimizeFitText(textElement, applyFontSize) {
  if (!textElement) {
    return;
  }
  applyFontSize(0);
  const optimalSize = findOptimalFontSize(textElement, applyFontSize);
  applyFontSize(optimalSize);
  return optimalSize;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/fit-text.js




const EMPTY_OBJECT = {};



const FIT_TEXT_SUPPORT_KEY = "typography.fitText";
function fit_text_addAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, FIT_TEXT_SUPPORT_KEY)) {
    return settings;
  }
  if (settings.attributes?.fitText) {
    return settings;
  }
  return {
    ...settings,
    attributes: {
      ...settings.attributes,
      fitText: {
        type: "boolean"
      }
    }
  };
}
function useFitText({ fitText, name, clientId }) {
  const hasFitTextSupport2 = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, FIT_TEXT_SUPPORT_KEY);
  const blockElement = useBlockElement(clientId);
  const { blockAttributes, parentId, blockMode } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!clientId || !hasFitTextSupport2 || !fitText) {
        return EMPTY_OBJECT;
      }
      const _blockMode = select(store).getBlockMode(clientId);
      if (_blockMode === "html") {
        return { blockMode: _blockMode };
      }
      return {
        blockAttributes: select(store).getBlockAttributes(clientId),
        parentId: select(store).getBlockRootClientId(clientId),
        blockMode: _blockMode
      };
    },
    [clientId, hasFitTextSupport2, fitText]
  );
  const applyFitText = (0,external_wp_element_namespaceObject.useCallback)(() => {
    if (!blockElement || !hasFitTextSupport2 || !fitText) {
      return;
    }
    const styleId = `fit-text-${clientId}`;
    let styleElement = blockElement.ownerDocument.getElementById(styleId);
    if (!styleElement) {
      styleElement = blockElement.ownerDocument.createElement("style");
      styleElement.id = styleId;
      blockElement.ownerDocument.head.appendChild(styleElement);
    }
    const blockSelector = `#block-${clientId}`;
    const applyFontSize = (fontSize) => {
      if (fontSize === 0) {
        styleElement.textContent = "";
      } else {
        styleElement.textContent = `${blockSelector} { font-size: ${fontSize}px !important; }`;
      }
    };
    optimizeFitText(blockElement, applyFontSize);
  }, [blockElement, clientId, hasFitTextSupport2, fitText]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!fitText || !blockElement || !clientId || !hasFitTextSupport2 || blockMode === "html") {
      return;
    }
    const currentElement = blockElement;
    const previousVisibility = currentElement.style.visibility;
    let hideFrameId = null;
    let calculateFrameId = null;
    let showTimeoutId = null;
    hideFrameId = window.requestAnimationFrame(() => {
      currentElement.style.visibility = "hidden";
      calculateFrameId = window.requestAnimationFrame(() => {
        applyFitText();
        showTimeoutId = setTimeout(() => {
          currentElement.style.visibility = previousVisibility;
        }, 10);
      });
    });
    let resizeObserver;
    if (window.ResizeObserver && currentElement.parentElement) {
      resizeObserver = new window.ResizeObserver(applyFitText);
      resizeObserver.observe(currentElement.parentElement);
      resizeObserver.observe(currentElement);
    }
    return () => {
      if (hideFrameId !== null) {
        window.cancelAnimationFrame(hideFrameId);
      }
      if (calculateFrameId !== null) {
        window.cancelAnimationFrame(calculateFrameId);
      }
      if (showTimeoutId !== null) {
        clearTimeout(showTimeoutId);
      }
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      const styleId = `fit-text-${clientId}`;
      const styleElement = currentElement.ownerDocument.getElementById(styleId);
      if (styleElement) {
        styleElement.remove();
      }
    };
  }, [
    fitText,
    clientId,
    parentId,
    applyFitText,
    blockElement,
    hasFitTextSupport2,
    blockMode
  ]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (fitText && blockElement && hasFitTextSupport2 && blockMode !== "html") {
      const frameId = window.requestAnimationFrame(() => {
        if (blockElement) {
          applyFitText();
        }
      });
      return () => window.cancelAnimationFrame(frameId);
    }
  }, [
    blockAttributes,
    fitText,
    applyFitText,
    blockElement,
    hasFitTextSupport2,
    blockMode
  ]);
}
function fit_text_addSaveProps(props, blockType, attributes) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, FIT_TEXT_SUPPORT_KEY)) {
    return props;
  }
  const { fitText } = attributes;
  if (!fitText) {
    return props;
  }
  const className = props.className ? `${props.className} has-fit-text` : "has-fit-text";
  return {
    ...props,
    className
  };
}
function fit_text_useBlockProps({ name, fitText, clientId }) {
  useFitText({ fitText, name, clientId });
  if (!fitText || !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, FIT_TEXT_SUPPORT_KEY)) {
    return {};
  }
  return {
    className: "has-fit-text"
  };
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/fit-text/addAttribute",
  fit_text_addAttributes
);
const hasFitTextSupport = (blockNameOrType) => {
  return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockNameOrType, FIT_TEXT_SUPPORT_KEY);
};
var fit_text_default = {
  useBlockProps: fit_text_useBlockProps,
  addSaveProps: fit_text_addSaveProps,
  attributeKeys: ["fitText"],
  hasSupport: hasFitTextSupport,
  edit: () => null
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/typography.js













function omit(object, keys) {
  return Object.fromEntries(
    Object.entries(object).filter(([key]) => !keys.includes(key))
  );
}
const LETTER_SPACING_SUPPORT_KEY = "typography.__experimentalLetterSpacing";
const TEXT_TRANSFORM_SUPPORT_KEY = "typography.__experimentalTextTransform";
const TEXT_DECORATION_SUPPORT_KEY = "typography.__experimentalTextDecoration";
const TEXT_COLUMNS_SUPPORT_KEY = "typography.textColumns";
const FONT_STYLE_SUPPORT_KEY = "typography.__experimentalFontStyle";
const FONT_WEIGHT_SUPPORT_KEY = "typography.__experimentalFontWeight";
const WRITING_MODE_SUPPORT_KEY = "typography.__experimentalWritingMode";
const TYPOGRAPHY_SUPPORT_KEY = "typography";
const TYPOGRAPHY_SUPPORT_KEYS = [
  LINE_HEIGHT_SUPPORT_KEY,
  FONT_SIZE_SUPPORT_KEY,
  FONT_STYLE_SUPPORT_KEY,
  FONT_WEIGHT_SUPPORT_KEY,
  FONT_FAMILY_SUPPORT_KEY,
  TEXT_ALIGN_SUPPORT_KEY,
  TEXT_COLUMNS_SUPPORT_KEY,
  TEXT_DECORATION_SUPPORT_KEY,
  WRITING_MODE_SUPPORT_KEY,
  TEXT_TRANSFORM_SUPPORT_KEY,
  LETTER_SPACING_SUPPORT_KEY,
  FIT_TEXT_SUPPORT_KEY
];
function typography_styleToAttributes(style) {
  const updatedStyle = { ...omit(style, ["fontFamily"]) };
  const fontSizeValue = style?.typography?.fontSize;
  const fontFamilyValue = style?.typography?.fontFamily;
  const fontSizeSlug = typeof fontSizeValue === "string" && fontSizeValue?.startsWith("var:preset|font-size|") ? fontSizeValue.substring("var:preset|font-size|".length) : void 0;
  const fontFamilySlug = fontFamilyValue?.startsWith(
    "var:preset|font-family|"
  ) ? fontFamilyValue.substring("var:preset|font-family|".length) : void 0;
  updatedStyle.typography = {
    ...omit(updatedStyle.typography, ["fontFamily"]),
    fontSize: fontSizeSlug ? void 0 : fontSizeValue
  };
  return {
    style: utils_cleanEmptyObject(updatedStyle),
    fontFamily: fontFamilySlug,
    fontSize: fontSizeSlug
  };
}
function typography_attributesToStyle(attributes) {
  return {
    ...attributes.style,
    typography: {
      ...attributes.style?.typography,
      fontFamily: attributes.fontFamily ? "var:preset|font-family|" + attributes.fontFamily : void 0,
      fontSize: attributes.fontSize ? "var:preset|font-size|" + attributes.fontSize : attributes.style?.typography?.fontSize
    }
  };
}
function TypographyInspectorControl({ children, resetAllFilter }) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (attributes) => {
      const existingStyle = typography_attributesToStyle(attributes);
      const updatedStyle = resetAllFilter(existingStyle);
      return {
        ...attributes,
        ...typography_styleToAttributes(updatedStyle)
      };
    },
    [resetAllFilter]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inspector_controls_default,
    {
      group: "typography",
      resetAllFilter: attributesResetAllFilter,
      children
    }
  );
}
function typography_TypographyPanel({ clientId, name, setAttributes, settings }) {
  function selector(select) {
    const { style: style2, fontFamily: fontFamily2, fontSize: fontSize2, fitText: fitText2 } = select(store).getBlockAttributes(clientId) || {};
    return { style: style2, fontFamily: fontFamily2, fontSize: fontSize2, fitText: fitText2 };
  }
  const { style, fontFamily, fontSize, fitText } = (0,external_wp_data_namespaceObject.useSelect)(selector, [
    clientId
  ]);
  const isEnabled = useHasTypographyPanel(settings);
  const value = (0,external_wp_element_namespaceObject.useMemo)(
    () => typography_attributesToStyle({ style, fontFamily, fontSize }),
    [style, fontSize, fontFamily]
  );
  const onChange = (newStyle) => {
    setAttributes(typography_styleToAttributes(newStyle));
  };
  if (!isEnabled) {
    return null;
  }
  const defaultControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    TYPOGRAPHY_SUPPORT_KEY,
    "__experimentalDefaultControls"
  ]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    TypographyPanel,
    {
      as: TypographyInspectorControl,
      panelId: clientId,
      settings,
      value,
      onChange,
      defaultControls,
      fitText
    }
  );
}
const hasTypographySupport = (blockName) => {
  return TYPOGRAPHY_SUPPORT_KEYS.some(
    (key) => hasBlockSupport(blockName, key)
  );
};


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/hooks/use-spacing-sizes.js




const use_spacing_sizes_EMPTY_ARRAY = [];
const compare = new Intl.Collator("und", { numeric: true }).compare;
function useSpacingSizes() {
  const [
    customSpacingSizes,
    themeSpacingSizes,
    defaultSpacingSizes,
    defaultSpacingSizesEnabled
  ] = use_settings_useSettings(
    "spacing.spacingSizes.custom",
    "spacing.spacingSizes.theme",
    "spacing.spacingSizes.default",
    "spacing.defaultSpacingSizes"
  );
  const customSizes = customSpacingSizes ?? use_spacing_sizes_EMPTY_ARRAY;
  const themeSizes = themeSpacingSizes ?? use_spacing_sizes_EMPTY_ARRAY;
  const defaultSizes = defaultSpacingSizes && defaultSpacingSizesEnabled !== false ? defaultSpacingSizes : use_spacing_sizes_EMPTY_ARRAY;
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const sizes = [
      { name: (0,external_wp_i18n_namespaceObject.__)("None"), slug: "0", size: 0 },
      ...customSizes,
      ...themeSizes,
      ...defaultSizes
    ];
    if (sizes.every(({ slug }) => /^[0-9]/.test(slug))) {
      sizes.sort((a, b) => compare(a.slug, b.slug));
    }
    return sizes.length > RANGE_CONTROL_MAX_SIZE ? [
      {
        name: (0,external_wp_i18n_namespaceObject.__)("Default"),
        slug: "default",
        size: void 0
      },
      ...sizes
    ] : sizes;
  }, [customSizes, themeSizes, defaultSizes]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/spacing-input-control.js










const CUSTOM_VALUE_SETTINGS = {
  px: { max: 300, steps: 1 },
  "%": { max: 100, steps: 1 },
  vw: { max: 100, steps: 1 },
  vh: { max: 100, steps: 1 },
  em: { max: 10, steps: 0.1 },
  rm: { max: 10, steps: 0.1 },
  svw: { max: 100, steps: 1 },
  lvw: { max: 100, steps: 1 },
  dvw: { max: 100, steps: 1 },
  svh: { max: 100, steps: 1 },
  lvh: { max: 100, steps: 1 },
  dvh: { max: 100, steps: 1 },
  vi: { max: 100, steps: 1 },
  svi: { max: 100, steps: 1 },
  lvi: { max: 100, steps: 1 },
  dvi: { max: 100, steps: 1 },
  vb: { max: 100, steps: 1 },
  svb: { max: 100, steps: 1 },
  lvb: { max: 100, steps: 1 },
  dvb: { max: 100, steps: 1 },
  vmin: { max: 100, steps: 1 },
  svmin: { max: 100, steps: 1 },
  lvmin: { max: 100, steps: 1 },
  dvmin: { max: 100, steps: 1 },
  vmax: { max: 100, steps: 1 },
  svmax: { max: 100, steps: 1 },
  lvmax: { max: 100, steps: 1 },
  dvmax: { max: 100, steps: 1 }
};
function SpacingInputControl({
  icon,
  isMixed = false,
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  side,
  spacingSizes,
  type,
  value
}) {
  value = getPresetValueFromCustomValue(value, spacingSizes);
  let selectListSizes = spacingSizes;
  const showRangeControl = spacingSizes.length <= RANGE_CONTROL_MAX_SIZE;
  const disableCustomSpacingSizes = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const editorSettings = select(store).getSettings();
    return editorSettings?.disableCustomSpacingSizes;
  });
  const [showCustomValueControl, setShowCustomValueControl] = (0,external_wp_element_namespaceObject.useState)(
    !disableCustomSpacingSizes && value !== void 0 && !isValueSpacingPreset(value)
  );
  const [minValue, setMinValue] = (0,external_wp_element_namespaceObject.useState)(minimumCustomValue);
  const previousValue = (0,external_wp_compose_namespaceObject.usePrevious)(value);
  if (!!value && previousValue !== value && !isValueSpacingPreset(value) && showCustomValueControl !== true) {
    setShowCustomValueControl(true);
  }
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || ["px", "em", "rem"]
  });
  let currentValue = null;
  const showCustomValueInSelectList = !showRangeControl && !showCustomValueControl && value !== void 0 && (!isValueSpacingPreset(value) || isValueSpacingPreset(value) && isMixed);
  if (showCustomValueInSelectList) {
    selectListSizes = [
      ...spacingSizes,
      {
        name: !isMixed ? (
          // translators: %s: A custom measurement, e.g. a number followed by a unit like 12px.
          (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)("Custom (%s)"), value)
        ) : (0,external_wp_i18n_namespaceObject.__)("Mixed"),
        slug: "custom",
        size: value
      }
    ];
    currentValue = selectListSizes.length - 1;
  } else if (!isMixed) {
    currentValue = !showCustomValueControl ? getSliderValueFromPreset(value, spacingSizes) : getCustomValueFromPreset(value, spacingSizes);
  }
  const selectedUnit = (0,external_wp_element_namespaceObject.useMemo)(
    () => (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(currentValue),
    [currentValue]
  )[1] || units[0]?.value;
  const setInitialValue = () => {
    if (value === void 0) {
      onChange("0");
    }
  };
  const customTooltipContent = (newValue) => value === void 0 ? void 0 : spacingSizes[newValue]?.name;
  const customRangeValue = parseFloat(currentValue, 10);
  const getNewCustomValue = (newSize) => {
    const isNumeric = !isNaN(parseFloat(newSize));
    const nextValue = isNumeric ? newSize : void 0;
    return nextValue;
  };
  const getNewPresetValue = (newSize, controlType) => {
    const size = parseInt(newSize, 10);
    if (controlType === "selectList") {
      if (size === 0) {
        return void 0;
      }
      if (size === 1) {
        return "0";
      }
    } else if (size === 0) {
      return "0";
    }
    return `var:preset|spacing|${spacingSizes[newSize]?.slug}`;
  };
  const handleCustomValueSliderChange = (next) => {
    onChange([next, selectedUnit].join(""));
  };
  const allPlaceholder = isMixed ? (0,external_wp_i18n_namespaceObject.__)("Mixed") : null;
  const options = selectListSizes.map((size, index) => ({
    key: index,
    name: size.name
  }));
  const marks = spacingSizes.slice(1, spacingSizes.length - 1).map((_newValue, index) => ({
    value: index + 1,
    label: void 0
  }));
  const sideLabel = ALL_SIDES.includes(side) && showSideInLabel ? LABELS[side] : "";
  const typeLabel = showSideInLabel ? type?.toLowerCase() : type;
  const ariaLabel = (0,external_wp_i18n_namespaceObject.sprintf)(
    // translators: 1: The side of the block being modified (top, bottom, left etc.). 2. Type of spacing being modified (padding, margin, etc).
    (0,external_wp_i18n_namespaceObject._x)("%1$s %2$s", "spacing"),
    sideLabel,
    typeLabel
  ).trim();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { className: "spacing-sizes-control__wrapper", children: [
    icon && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Icon,
      {
        className: "spacing-sizes-control__icon",
        icon,
        size: 24
      }
    ),
    showCustomValueControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalUnitControl,
        {
          onMouseOver,
          onMouseOut,
          onFocus: onMouseOver,
          onBlur: onMouseOut,
          onChange: (newSize) => onChange(getNewCustomValue(newSize)),
          value: currentValue,
          units,
          min: minValue,
          placeholder: allPlaceholder,
          disableUnits: isMixed,
          label: ariaLabel,
          hideLabelFromVision: true,
          className: "spacing-sizes-control__custom-value-input",
          size: "__unstable-large",
          onDragStart: () => {
            if (value?.charAt(0) === "-") {
              setMinValue(0);
            }
          },
          onDrag: () => {
            if (value?.charAt(0) === "-") {
              setMinValue(0);
            }
          },
          onDragEnd: () => {
            setMinValue(minimumCustomValue);
          }
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          onMouseOver,
          onMouseOut,
          onFocus: onMouseOver,
          onBlur: onMouseOut,
          value: customRangeValue,
          min: 0,
          max: CUSTOM_VALUE_SETTINGS[selectedUnit]?.max ?? 10,
          step: CUSTOM_VALUE_SETTINGS[selectedUnit]?.steps ?? 0.1,
          withInputField: false,
          onChange: handleCustomValueSliderChange,
          className: "spacing-sizes-control__custom-value-range",
          __nextHasNoMarginBottom: true,
          label: ariaLabel,
          hideLabelFromVision: true
        }
      )
    ] }),
    showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.RangeControl,
      {
        __next40pxDefaultSize: true,
        onMouseOver,
        onMouseOut,
        className: "spacing-sizes-control__range-control",
        value: currentValue,
        onChange: (newSize) => onChange(getNewPresetValue(newSize)),
        onMouseDown: (event) => {
          if (event?.nativeEvent?.offsetX < 35) {
            setInitialValue();
          }
        },
        withInputField: false,
        "aria-valuenow": currentValue,
        "aria-valuetext": spacingSizes[currentValue]?.name,
        renderTooltipContent: customTooltipContent,
        min: 0,
        max: spacingSizes.length - 1,
        marks,
        label: ariaLabel,
        hideLabelFromVision: true,
        __nextHasNoMarginBottom: true,
        onFocus: onMouseOver,
        onBlur: onMouseOut
      }
    ),
    !showRangeControl && !showCustomValueControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.CustomSelectControl,
      {
        className: "spacing-sizes-control__custom-select-control",
        value: (
          // passing empty string as a fallback to continue using the
          // component in controlled mode
          options.find(
            (option) => option.key === currentValue
          ) || ""
        ),
        onChange: (selection) => {
          onChange(
            getNewPresetValue(
              selection.selectedItem.key,
              "selectList"
            )
          );
        },
        options,
        label: ariaLabel,
        hideLabelFromVision: true,
        size: "__unstable-large",
        onMouseOver,
        onMouseOut,
        onFocus: onMouseOver,
        onBlur: onMouseOut
      }
    ),
    !disableCustomSpacingSizes && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        label: showCustomValueControl ? (0,external_wp_i18n_namespaceObject.__)("Use size preset") : (0,external_wp_i18n_namespaceObject.__)("Set custom size"),
        icon: settings_settings_default,
        onClick: () => {
          setShowCustomValueControl(!showCustomValueControl);
        },
        isPressed: showCustomValueControl,
        size: "small",
        className: "spacing-sizes-control__custom-toggle",
        iconSize: 24
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/axial.js



const groupedSides = ["vertical", "horizontal"];
function AxialInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = (side) => (next) => {
    if (!onChange) {
      return;
    }
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(
          values[key],
          spacingSizes
        );
        return acc;
      }, {})
    };
    if (side === "vertical") {
      nextValues.top = next;
      nextValues.bottom = next;
    }
    if (side === "horizontal") {
      nextValues.left = next;
      nextValues.right = next;
    }
    onChange(nextValues);
  };
  const filteredSides = sides?.length ? groupedSides.filter((side) => hasAxisSupport(sides, side)) : groupedSides;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: filteredSides.map((side) => {
    const axisValue = side === "vertical" ? values.top : values.left;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SpacingInputControl,
      {
        icon: ICONS[side],
        label: LABELS[side],
        minimumCustomValue,
        onChange: createHandleOnChange(side),
        onMouseOut,
        onMouseOver,
        side,
        spacingSizes,
        type,
        value: axisValue,
        withInputField: false
      },
      `spacing-sizes-control-${side}`
    );
  }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/separated.js



function SeparatedInputControls({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  sides,
  spacingSizes,
  type,
  values
}) {
  const filteredSides = sides?.length ? ALL_SIDES.filter((side) => sides.includes(side)) : ALL_SIDES;
  const createHandleOnChange = (side) => (next) => {
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(
          values[key],
          spacingSizes
        );
        return acc;
      }, {})
    };
    nextValues[side] = next;
    onChange(nextValues);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: filteredSides.map((side) => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SpacingInputControl,
      {
        icon: ICONS[side],
        label: LABELS[side],
        minimumCustomValue,
        onChange: createHandleOnChange(side),
        onMouseOut,
        onMouseOver,
        side,
        spacingSizes,
        type,
        value: values[side],
        withInputField: false
      },
      `spacing-sizes-control-${side}`
    );
  }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls/single.js



function single_SingleInputControl({
  minimumCustomValue,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel,
  side,
  spacingSizes,
  type,
  values
}) {
  const createHandleOnChange = (currentSide) => (next) => {
    const nextValues = {
      ...Object.keys(values).reduce((acc, key) => {
        acc[key] = getPresetValueFromCustomValue(
          values[key],
          spacingSizes
        );
        return acc;
      }, {})
    };
    nextValues[currentSide] = next;
    onChange(nextValues);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    SpacingInputControl,
    {
      label: LABELS[side],
      minimumCustomValue,
      onChange: createHandleOnChange(side),
      onMouseOut,
      onMouseOver,
      showSideInLabel,
      side,
      spacingSizes,
      type,
      value: values[side],
      withInputField: false
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/linked-button.js




function linked_button_LinkedButton({ isLinked, ...props }) {
  const label = isLinked ? (0,external_wp_i18n_namespaceObject.__)("Unlink sides") : (0,external_wp_i18n_namespaceObject.__)("Link sides");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      ...props,
      size: "small",
      icon: isLinked ? link_default : link_off_default,
      iconSize: 24,
      label
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/index.js










function SpacingSizesControl({
  inputProps,
  label: labelProp,
  minimumCustomValue = 0,
  onChange,
  onMouseOut,
  onMouseOver,
  showSideInLabel = true,
  sides = ALL_SIDES,
  useSelect,
  values
}) {
  const spacingSizes = useSpacingSizes();
  const inputValues = values || DEFAULT_VALUES;
  const hasOneSide = sides?.length === 1;
  const hasOnlyAxialSides = sides?.includes("horizontal") && sides?.includes("vertical") && sides?.length === 2;
  const [view, setView] = (0,external_wp_element_namespaceObject.useState)(getInitialView(inputValues, sides));
  const toggleLinked = () => {
    setView(view === VIEWS.axial ? VIEWS.custom : VIEWS.axial);
  };
  const handleOnChange = (nextValue) => {
    const newValues = { ...values, ...nextValue };
    onChange(newValues);
  };
  const inputControlProps = {
    ...inputProps,
    minimumCustomValue,
    onChange: handleOnChange,
    onMouseOut,
    onMouseOver,
    sides,
    spacingSizes,
    type: labelProp,
    useSelect,
    values: inputValues
  };
  const renderControls = () => {
    if (view === VIEWS.axial) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(AxialInputControls, { ...inputControlProps });
    }
    if (view === VIEWS.custom) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(SeparatedInputControls, { ...inputControlProps });
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      single_SingleInputControl,
      {
        side: view,
        ...inputControlProps,
        showSideInLabel
      }
    );
  };
  const sideLabel = ALL_SIDES.includes(view) && showSideInLabel ? LABELS[view] : "";
  const label = (0,external_wp_i18n_namespaceObject.sprintf)(
    // translators: 1: The side of the block being modified (top, bottom, left etc.). 2. Type of spacing being modified (padding, margin, etc).
    (0,external_wp_i18n_namespaceObject._x)("%1$s %2$s", "spacing"),
    labelProp,
    sideLabel
  ).trim();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "spacing-sizes-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { className: "spacing-sizes-control__header", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.BaseControl.VisualLabel,
        {
          as: "legend",
          className: "spacing-sizes-control__label",
          children: label
        }
      ),
      !hasOneSide && !hasOnlyAxialSides && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        linked_button_LinkedButton,
        {
          label: labelProp,
          onClick: toggleLinked,
          isLinked: view === VIEWS.axial
        }
      )
    ] }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 0.5, children: renderControls() })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/height-control/index.js





const RANGE_CONTROL_CUSTOM_SETTINGS = {
  px: { max: 1e3, step: 1 },
  "%": { max: 100, step: 1 },
  vw: { max: 100, step: 1 },
  vh: { max: 100, step: 1 },
  em: { max: 50, step: 0.1 },
  rem: { max: 50, step: 0.1 },
  svw: { max: 100, step: 1 },
  lvw: { max: 100, step: 1 },
  dvw: { max: 100, step: 1 },
  svh: { max: 100, step: 1 },
  lvh: { max: 100, step: 1 },
  dvh: { max: 100, step: 1 },
  vi: { max: 100, step: 1 },
  svi: { max: 100, step: 1 },
  lvi: { max: 100, step: 1 },
  dvi: { max: 100, step: 1 },
  vb: { max: 100, step: 1 },
  svb: { max: 100, step: 1 },
  lvb: { max: 100, step: 1 },
  dvb: { max: 100, step: 1 },
  vmin: { max: 100, step: 1 },
  svmin: { max: 100, step: 1 },
  lvmin: { max: 100, step: 1 },
  dvmin: { max: 100, step: 1 },
  vmax: { max: 100, step: 1 },
  svmax: { max: 100, step: 1 },
  lvmax: { max: 100, step: 1 },
  dvmax: { max: 100, step: 1 }
};
function HeightControl({
  label = (0,external_wp_i18n_namespaceObject.__)("Height"),
  onChange,
  value
}) {
  const customRangeValue = parseFloat(value);
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || [
      "%",
      "px",
      "em",
      "rem",
      "vh",
      "vw"
    ]
  });
  const selectedUnit = (0,external_wp_element_namespaceObject.useMemo)(
    () => (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value),
    [value]
  )[1] || units[0]?.value || "px";
  const handleSliderChange = (next) => {
    onChange([next, selectedUnit].join(""));
  };
  const handleUnitChange = (newUnit) => {
    const [currentValue, currentUnit] = (0,external_wp_components_namespaceObject.__experimentalParseQuantityAndUnitFromRawValue)(value);
    if (["em", "rem"].includes(newUnit) && currentUnit === "px") {
      onChange((currentValue / 16).toFixed(2) + newUnit);
    } else if (["em", "rem"].includes(currentUnit) && newUnit === "px") {
      onChange(Math.round(currentValue * 16) + newUnit);
    } else if ([
      "%",
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax"
    ].includes(newUnit) && currentValue > 100) {
      onChange(100 + newUnit);
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-height-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.BaseControl.VisualLabel, { as: "legend", children: label }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Flex, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalUnitControl,
        {
          value,
          units,
          onChange,
          onUnitChange: handleUnitChange,
          min: 0,
          size: "__unstable-large",
          label,
          hideLabelFromVision: true
        }
      ) }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { isBlock: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalSpacer, { marginX: 2, marginBottom: 0, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          value: customRangeValue,
          min: 0,
          max: RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.max ?? 100,
          step: RANGE_CONTROL_CUSTOM_SETTINGS[selectedUnit]?.step ?? 0.1,
          withInputField: false,
          onChange: handleSliderChange,
          __nextHasNoMarginBottom: true,
          label,
          hideLabelFromVision: true
        }
      ) }) })
    ] })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/use-get-number-of-blocks-before-cell.js


function useGetNumberOfBlocksBeforeCell(gridClientId, numColumns) {
  const { getBlockOrder, getBlockAttributes } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const getNumberOfBlocksBeforeCell = (column, row) => {
    const targetIndex = (row - 1) * numColumns + column - 1;
    let count = 0;
    for (const clientId of getBlockOrder(gridClientId)) {
      const { columnStart, rowStart } = getBlockAttributes(clientId).style?.layout ?? {};
      const cellIndex = (rowStart - 1) * numColumns + columnStart - 1;
      if (cellIndex < targetIndex) {
        count++;
      }
    }
    return count;
  };
  return getNumberOfBlocksBeforeCell;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/child-layout-control/index.js








function helpText(selfStretch, parentLayout) {
  const { orientation = "horizontal" } = parentLayout;
  if (selfStretch === "fill") {
    return (0,external_wp_i18n_namespaceObject.__)("Stretch to fill available space.");
  }
  if (selfStretch === "fixed" && orientation === "horizontal") {
    return (0,external_wp_i18n_namespaceObject.__)("Specify a fixed width.");
  } else if (selfStretch === "fixed") {
    return (0,external_wp_i18n_namespaceObject.__)("Specify a fixed height.");
  }
  return (0,external_wp_i18n_namespaceObject.__)("Fit contents.");
}
function ChildLayoutControl({
  value: childLayout = {},
  onChange,
  parentLayout,
  isShownByDefault,
  panelId
}) {
  const {
    type: parentType,
    default: { type: defaultParentType = "default" } = {}
  } = parentLayout ?? {};
  const parentLayoutType = parentType || defaultParentType;
  if (parentLayoutType === "flex") {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      FlexControls,
      {
        childLayout,
        onChange,
        parentLayout,
        isShownByDefault,
        panelId
      }
    );
  } else if (parentLayoutType === "grid") {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridControls,
      {
        childLayout,
        onChange,
        parentLayout,
        isShownByDefault,
        panelId
      }
    );
  }
  return null;
}
function FlexControls({
  childLayout,
  onChange,
  parentLayout,
  isShownByDefault,
  panelId
}) {
  const { selfStretch, flexSize } = childLayout;
  const { orientation = "horizontal" } = parentLayout ?? {};
  const hasFlexValue = () => !!selfStretch;
  const flexResetLabel = orientation === "horizontal" ? (0,external_wp_i18n_namespaceObject.__)("Width") : (0,external_wp_i18n_namespaceObject.__)("Height");
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || [
      "%",
      "px",
      "em",
      "rem",
      "vh",
      "vw"
    ]
  });
  const resetFlex = () => {
    onChange({
      selfStretch: void 0,
      flexSize: void 0
    });
  };
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (selfStretch === "fixed" && !flexSize) {
      onChange({
        ...childLayout,
        selfStretch: "fit"
      });
    }
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalVStack,
    {
      as: external_wp_components_namespaceObject.__experimentalToolsPanelItem,
      spacing: 2,
      hasValue: hasFlexValue,
      label: flexResetLabel,
      onDeselect: resetFlex,
      isShownByDefault,
      panelId,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControl,
          {
            __nextHasNoMarginBottom: true,
            size: "__unstable-large",
            label: childLayoutOrientation(parentLayout),
            value: selfStretch || "fit",
            help: helpText(selfStretch, parentLayout),
            onChange: (value) => {
              const newFlexSize = value !== "fixed" ? null : flexSize;
              onChange({
                selfStretch: value,
                flexSize: newFlexSize
              });
            },
            isBlock: true,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
                {
                  value: "fit",
                  label: (0,external_wp_i18n_namespaceObject._x)(
                    "Fit",
                    "Intrinsic block width in flex layout"
                  )
                },
                "fit"
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
                {
                  value: "fill",
                  label: (0,external_wp_i18n_namespaceObject._x)(
                    "Grow",
                    "Block with expanding width in flex layout"
                  )
                },
                "fill"
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
                {
                  value: "fixed",
                  label: (0,external_wp_i18n_namespaceObject._x)(
                    "Fixed",
                    "Block with fixed width in flex layout"
                  )
                },
                "fixed"
              )
            ]
          }
        ),
        selfStretch === "fixed" && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalUnitControl,
          {
            size: "__unstable-large",
            units,
            onChange: (value) => {
              onChange({
                selfStretch,
                flexSize: value
              });
            },
            value: flexSize,
            min: 0,
            label: flexResetLabel,
            hideLabelFromVision: true
          }
        )
      ]
    }
  );
}
function childLayoutOrientation(parentLayout) {
  const { orientation = "horizontal" } = parentLayout;
  return orientation === "horizontal" ? (0,external_wp_i18n_namespaceObject.__)("Width") : (0,external_wp_i18n_namespaceObject.__)("Height");
}
function GridControls({
  childLayout,
  onChange,
  parentLayout,
  isShownByDefault,
  panelId
}) {
  const { columnStart, rowStart, columnSpan, rowSpan } = childLayout;
  const { columnCount, rowCount } = parentLayout ?? {};
  const rootClientId = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getBlockRootClientId(panelId)
  );
  const { moveBlocksToPosition, __unstableMarkNextChangeAsNotPersistent } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
    rootClientId,
    columnCount || 3
  );
  const hasStartValue = () => !!columnStart || !!rowStart;
  const hasSpanValue = () => !!columnSpan || !!rowSpan;
  const resetGridStarts = () => {
    onChange({
      columnStart: void 0,
      rowStart: void 0
    });
  };
  const resetGridSpans = () => {
    onChange({
      columnSpan: void 0,
      rowSpan: void 0
    });
  };
  const maxColumnSpan = columnCount ? columnCount - (columnStart ?? 1) + 1 : void 0;
  const maxRowSpan = window.__experimentalEnableGridInteractivity && rowCount ? rowCount - (rowStart ?? 1) + 1 : void 0;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.Flex,
      {
        as: external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        hasValue: hasSpanValue,
        label: (0,external_wp_i18n_namespaceObject.__)("Grid span"),
        onDeselect: resetGridSpans,
        isShownByDefault,
        panelId,
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalInputControl,
            {
              size: "__unstable-large",
              label: (0,external_wp_i18n_namespaceObject.__)("Column span"),
              type: "number",
              onChange: (value) => {
                const newColumnSpan = value === "" ? 1 : parseInt(value, 10);
                const constrainedValue = maxColumnSpan ? Math.min(newColumnSpan, maxColumnSpan) : newColumnSpan;
                onChange({
                  columnStart,
                  rowStart,
                  rowSpan,
                  columnSpan: constrainedValue
                });
              },
              value: columnSpan ?? 1,
              min: 1,
              max: maxColumnSpan
            }
          ) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalInputControl,
            {
              size: "__unstable-large",
              label: (0,external_wp_i18n_namespaceObject.__)("Row span"),
              type: "number",
              onChange: (value) => {
                const newRowSpan = value === "" ? 1 : parseInt(value, 10);
                const constrainedValue = maxRowSpan ? Math.min(newRowSpan, maxRowSpan) : newRowSpan;
                onChange({
                  columnStart,
                  rowStart,
                  columnSpan,
                  rowSpan: constrainedValue
                });
              },
              value: rowSpan ?? 1,
              min: 1,
              max: maxRowSpan
            }
          ) })
        ]
      }
    ),
    window.__experimentalEnableGridInteractivity && // Use Flex with an explicit width on the FlexItem instead of HStack to
    // work around an issue in webkit where inputs with a max attribute are
    // sized incorrectly.
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.Flex,
      {
        as: external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        hasValue: hasStartValue,
        label: (0,external_wp_i18n_namespaceObject.__)("Grid placement"),
        onDeselect: resetGridStarts,
        isShownByDefault: false,
        panelId,
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalInputControl,
            {
              size: "__unstable-large",
              label: (0,external_wp_i18n_namespaceObject.__)("Column"),
              type: "number",
              onChange: (value) => {
                const newColumnStart = value === "" ? 1 : parseInt(value, 10);
                onChange({
                  columnStart: newColumnStart,
                  rowStart,
                  columnSpan,
                  rowSpan
                });
                __unstableMarkNextChangeAsNotPersistent();
                moveBlocksToPosition(
                  [panelId],
                  rootClientId,
                  rootClientId,
                  getNumberOfBlocksBeforeCell(
                    newColumnStart,
                    rowStart
                  )
                );
              },
              value: columnStart ?? 1,
              min: 1,
              max: columnCount ? columnCount - (columnSpan ?? 1) + 1 : void 0
            }
          ) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { style: { width: "50%" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalInputControl,
            {
              size: "__unstable-large",
              label: (0,external_wp_i18n_namespaceObject.__)("Row"),
              type: "number",
              onChange: (value) => {
                const newRowStart = value === "" ? 1 : parseInt(value, 10);
                onChange({
                  columnStart,
                  rowStart: newRowStart,
                  columnSpan,
                  rowSpan
                });
                __unstableMarkNextChangeAsNotPersistent();
                moveBlocksToPosition(
                  [panelId],
                  rootClientId,
                  rootClientId,
                  getNumberOfBlocksBeforeCell(
                    columnStart,
                    newRowStart
                  )
                );
              },
              value: rowStart ?? 1,
              min: 1,
              max: rowCount ? rowCount - (rowSpan ?? 1) + 1 : void 0
            }
          ) })
        ]
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/aspect-ratio-tool.js




function AspectRatioTool({
  panelId,
  value,
  onChange = () => {
  },
  options,
  defaultValue = "auto",
  hasValue,
  isShownByDefault = true
}) {
  const displayValue = value ?? "auto";
  const [defaultRatios, themeRatios, showDefaultRatios] = use_settings_useSettings(
    "dimensions.aspectRatios.default",
    "dimensions.aspectRatios.theme",
    "dimensions.defaultAspectRatios"
  );
  const themeOptions = themeRatios?.map(({ name, ratio }) => ({
    label: name,
    value: ratio
  }));
  const defaultOptions = defaultRatios?.map(({ name, ratio }) => ({
    label: name,
    value: ratio
  }));
  const aspectRatioOptions = [
    {
      label: (0,external_wp_i18n_namespaceObject._x)(
        "Original",
        "Aspect ratio option for dimensions control"
      ),
      value: "auto"
    },
    ...showDefaultRatios ? defaultOptions : [],
    ...themeOptions ? themeOptions : [],
    {
      label: (0,external_wp_i18n_namespaceObject._x)("Custom", "Aspect ratio option for dimensions control"),
      value: "custom",
      disabled: true,
      hidden: true
    }
  ];
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      hasValue: hasValue ? hasValue : () => displayValue !== defaultValue,
      label: (0,external_wp_i18n_namespaceObject.__)("Aspect ratio"),
      onDeselect: () => onChange(void 0),
      isShownByDefault,
      panelId,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.SelectControl,
        {
          label: (0,external_wp_i18n_namespaceObject.__)("Aspect ratio"),
          value: displayValue,
          options: options ?? aspectRatioOptions,
          onChange,
          size: "__unstable-large",
          __nextHasNoMarginBottom: true
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/dimensions-panel.js













const AXIAL_SIDES = ["horizontal", "vertical"];
function useHasDimensionsPanel(settings) {
  const hasContentSize = useHasContentSize(settings);
  const hasWideSize = useHasWideSize(settings);
  const hasPadding = useHasPadding(settings);
  const hasMargin = useHasMargin(settings);
  const hasGap = useHasGap(settings);
  const hasMinHeight = useHasMinHeight(settings);
  const hasAspectRatio = useHasAspectRatio(settings);
  const hasChildLayout = useHasChildLayout(settings);
  return external_wp_element_namespaceObject.Platform.OS === "web" && (hasContentSize || hasWideSize || hasPadding || hasMargin || hasGap || hasMinHeight || hasAspectRatio || hasChildLayout);
}
function useHasContentSize(settings) {
  return settings?.layout?.contentSize;
}
function useHasWideSize(settings) {
  return settings?.layout?.wideSize;
}
function useHasPadding(settings) {
  return settings?.spacing?.padding;
}
function useHasMargin(settings) {
  return settings?.spacing?.margin;
}
function useHasGap(settings) {
  return settings?.spacing?.blockGap;
}
function useHasMinHeight(settings) {
  return settings?.dimensions?.minHeight;
}
function useHasAspectRatio(settings) {
  return settings?.dimensions?.aspectRatio;
}
function useHasChildLayout(settings) {
  const {
    type: parentLayoutType = "default",
    default: { type: defaultParentLayoutType = "default" } = {},
    allowSizingOnChildren = false
  } = settings?.parentLayout ?? {};
  const support = (defaultParentLayoutType === "flex" || parentLayoutType === "flex" || defaultParentLayoutType === "grid" || parentLayoutType === "grid") && allowSizingOnChildren;
  return !!settings?.layout && support;
}
function useHasSpacingPresets(settings) {
  const { defaultSpacingSizes, spacingSizes } = settings?.spacing || {};
  return defaultSpacingSizes !== false && spacingSizes?.default?.length > 0 || spacingSizes?.theme?.length > 0 || spacingSizes?.custom?.length > 0;
}
function filterValuesBySides(values, sides) {
  if (!sides || !values) {
    return values;
  }
  const filteredValues = {};
  sides.forEach((side) => {
    if (side === "vertical") {
      filteredValues.top = values.top;
      filteredValues.bottom = values.bottom;
    }
    if (side === "horizontal") {
      filteredValues.left = values.left;
      filteredValues.right = values.right;
    }
    filteredValues[side] = values?.[side];
  });
  return filteredValues;
}
function splitStyleValue(value) {
  if (value && typeof value === "string") {
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }
  return value;
}
function splitGapValue(value, isAxialGap) {
  if (!value) {
    return value;
  }
  if (typeof value === "string") {
    return isAxialGap ? { top: value, right: value, bottom: value, left: value } : { top: value };
  }
  return {
    ...value,
    right: value?.left,
    bottom: value?.top
  };
}
function DimensionsToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Dimensions"),
      resetAll,
      panelId,
      dropdownMenuProps,
      children
    }
  );
}
const dimensions_panel_DEFAULT_CONTROLS = {
  contentSize: true,
  wideSize: true,
  padding: true,
  margin: true,
  blockGap: true,
  minHeight: true,
  aspectRatio: true,
  childLayout: true
};
function DimensionsPanel({
  as: Wrapper = DimensionsToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = dimensions_panel_DEFAULT_CONTROLS,
  onVisualize = () => {
  },
  // Special case because the layout controls are not part of the dimensions panel
  // in global styles but not in block inspector.
  includeLayoutControls = false
}) {
  const { dimensions, spacing } = settings;
  const decodeValue = (rawValue) => {
    if (rawValue && typeof rawValue === "object") {
      return Object.keys(rawValue).reduce((acc, key) => {
        acc[key] = getValueFromVariable(
          { settings: { dimensions, spacing } },
          "",
          rawValue[key]
        );
        return acc;
      }, {});
    }
    return getValueFromVariable(
      { settings: { dimensions, spacing } },
      "",
      rawValue
    );
  };
  const showSpacingPresetsControl = useHasSpacingPresets(settings);
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: settings?.spacing?.units || [
      "%",
      "px",
      "em",
      "rem",
      "vw"
    ]
  });
  const minimumMargin = -Infinity;
  const [minMarginValue, setMinMarginValue] = (0,external_wp_element_namespaceObject.useState)(minimumMargin);
  const showContentSizeControl = useHasContentSize(settings) && includeLayoutControls;
  const contentSizeValue = decodeValue(inheritedValue?.layout?.contentSize);
  const setContentSizeValue = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["layout", "contentSize"],
        newValue || void 0
      )
    );
  };
  const hasUserSetContentSizeValue = () => !!value?.layout?.contentSize;
  const resetContentSizeValue = () => setContentSizeValue(void 0);
  const showWideSizeControl = useHasWideSize(settings) && includeLayoutControls;
  const wideSizeValue = decodeValue(inheritedValue?.layout?.wideSize);
  const setWideSizeValue = (newValue) => {
    onChange(
      setImmutably(
        value,
        ["layout", "wideSize"],
        newValue || void 0
      )
    );
  };
  const hasUserSetWideSizeValue = () => !!value?.layout?.wideSize;
  const resetWideSizeValue = () => setWideSizeValue(void 0);
  const showPaddingControl = useHasPadding(settings);
  const rawPadding = decodeValue(inheritedValue?.spacing?.padding);
  const paddingValues = splitStyleValue(rawPadding);
  const paddingSides = Array.isArray(settings?.spacing?.padding) ? settings?.spacing?.padding : settings?.spacing?.padding?.sides;
  const isAxialPadding = paddingSides && paddingSides.some((side) => AXIAL_SIDES.includes(side));
  const setPaddingValues = (newPaddingValues) => {
    const padding = filterValuesBySides(newPaddingValues, paddingSides);
    onChange(setImmutably(value, ["spacing", "padding"], padding));
  };
  const hasPaddingValue = () => !!value?.spacing?.padding && Object.keys(value?.spacing?.padding).length;
  const resetPaddingValue = () => setPaddingValues(void 0);
  const onMouseOverPadding = () => onVisualize("padding");
  const showMarginControl = useHasMargin(settings);
  const rawMargin = decodeValue(inheritedValue?.spacing?.margin);
  const marginValues = splitStyleValue(rawMargin);
  const marginSides = Array.isArray(settings?.spacing?.margin) ? settings?.spacing?.margin : settings?.spacing?.margin?.sides;
  const isAxialMargin = marginSides && marginSides.some((side) => AXIAL_SIDES.includes(side));
  const setMarginValues = (newMarginValues) => {
    const margin = filterValuesBySides(newMarginValues, marginSides);
    onChange(setImmutably(value, ["spacing", "margin"], margin));
  };
  const hasMarginValue = () => !!value?.spacing?.margin && Object.keys(value?.spacing?.margin).length;
  const resetMarginValue = () => setMarginValues(void 0);
  const onMouseOverMargin = () => onVisualize("margin");
  const showGapControl = useHasGap(settings);
  const gapSides = Array.isArray(settings?.spacing?.blockGap) ? settings?.spacing?.blockGap : settings?.spacing?.blockGap?.sides;
  const isAxialGap = gapSides && gapSides.some((side) => AXIAL_SIDES.includes(side));
  const gapValue = decodeValue(inheritedValue?.spacing?.blockGap);
  const gapValues = splitGapValue(gapValue, isAxialGap);
  const setGapValue = (newGapValue) => {
    onChange(
      setImmutably(value, ["spacing", "blockGap"], newGapValue)
    );
  };
  const setGapValues = (nextBoxGapValue) => {
    if (!nextBoxGapValue) {
      setGapValue(null);
    }
    if (!isAxialGap && nextBoxGapValue?.hasOwnProperty("top")) {
      setGapValue(nextBoxGapValue.top);
    } else {
      setGapValue({
        top: nextBoxGapValue?.top,
        left: nextBoxGapValue?.left
      });
    }
  };
  const resetGapValue = () => setGapValue(void 0);
  const hasGapValue = () => !!value?.spacing?.blockGap;
  const showMinHeightControl = useHasMinHeight(settings);
  const minHeightValue = decodeValue(inheritedValue?.dimensions?.minHeight);
  const setMinHeightValue = (newValue) => {
    const tempValue = setImmutably(
      value,
      ["dimensions", "minHeight"],
      newValue
    );
    onChange(
      setImmutably(
        tempValue,
        ["dimensions", "aspectRatio"],
        void 0
      )
    );
  };
  const resetMinHeightValue = () => {
    setMinHeightValue(void 0);
  };
  const hasMinHeightValue = () => !!value?.dimensions?.minHeight;
  const showAspectRatioControl = useHasAspectRatio(settings);
  const aspectRatioValue = decodeValue(
    inheritedValue?.dimensions?.aspectRatio
  );
  const setAspectRatioValue = (newValue) => {
    const tempValue = setImmutably(
      value,
      ["dimensions", "aspectRatio"],
      newValue
    );
    onChange(
      setImmutably(tempValue, ["dimensions", "minHeight"], void 0)
    );
  };
  const hasAspectRatioValue = () => !!value?.dimensions?.aspectRatio;
  const showChildLayoutControl = useHasChildLayout(settings);
  const childLayout = inheritedValue?.layout;
  const setChildLayout = (newChildLayout) => {
    onChange({
      ...value,
      layout: {
        ...newChildLayout
      }
    });
  };
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      layout: utils_cleanEmptyObject({
        ...previousValue?.layout,
        contentSize: void 0,
        wideSize: void 0,
        selfStretch: void 0,
        flexSize: void 0,
        columnStart: void 0,
        rowStart: void 0,
        columnSpan: void 0,
        rowSpan: void 0
      }),
      spacing: {
        ...previousValue?.spacing,
        padding: void 0,
        margin: void 0,
        blockGap: void 0
      },
      dimensions: {
        ...previousValue?.dimensions,
        minHeight: void 0,
        aspectRatio: void 0
      }
    };
  }, []);
  const onMouseLeaveControls = () => onVisualize(false);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      children: [
        (showContentSizeControl || showWideSizeControl) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "span-columns", children: (0,external_wp_i18n_namespaceObject.__)("Set the width of the main content area.") }),
        showContentSizeControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Content width"),
            hasValue: hasUserSetContentSizeValue,
            onDeselect: resetContentSizeValue,
            isShownByDefault: defaultControls.contentSize ?? dimensions_panel_DEFAULT_CONTROLS.contentSize,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalUnitControl,
              {
                __next40pxDefaultSize: true,
                label: (0,external_wp_i18n_namespaceObject.__)("Content width"),
                labelPosition: "top",
                value: contentSizeValue || "",
                onChange: (nextContentSize) => {
                  setContentSizeValue(nextContentSize);
                },
                units,
                prefix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: align_none_default }) })
              }
            )
          }
        ),
        showWideSizeControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Wide width"),
            hasValue: hasUserSetWideSizeValue,
            onDeselect: resetWideSizeValue,
            isShownByDefault: defaultControls.wideSize ?? dimensions_panel_DEFAULT_CONTROLS.wideSize,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalUnitControl,
              {
                __next40pxDefaultSize: true,
                label: (0,external_wp_i18n_namespaceObject.__)("Wide width"),
                labelPosition: "top",
                value: wideSizeValue || "",
                onChange: (nextWideSize) => {
                  setWideSizeValue(nextWideSize);
                },
                units,
                prefix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlPrefixWrapper, { variant: "icon", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: stretch_wide_default }) })
              }
            )
          }
        ),
        showPaddingControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: hasPaddingValue,
            label: (0,external_wp_i18n_namespaceObject.__)("Padding"),
            onDeselect: resetPaddingValue,
            isShownByDefault: defaultControls.padding ?? dimensions_panel_DEFAULT_CONTROLS.padding,
            className: dist_clsx({
              "tools-panel-item-spacing": showSpacingPresetsControl
            }),
            panelId,
            children: [
              !showSpacingPresetsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.BoxControl,
                {
                  __next40pxDefaultSize: true,
                  values: paddingValues,
                  onChange: setPaddingValues,
                  label: (0,external_wp_i18n_namespaceObject.__)("Padding"),
                  sides: paddingSides,
                  units,
                  allowReset: false,
                  splitOnAxis: isAxialPadding,
                  inputProps: {
                    onMouseOver: onMouseOverPadding,
                    onMouseOut: onMouseLeaveControls
                  }
                }
              ),
              showSpacingPresetsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                SpacingSizesControl,
                {
                  values: paddingValues,
                  onChange: setPaddingValues,
                  label: (0,external_wp_i18n_namespaceObject.__)("Padding"),
                  sides: paddingSides,
                  units,
                  allowReset: false,
                  onMouseOver: onMouseOverPadding,
                  onMouseOut: onMouseLeaveControls
                }
              )
            ]
          }
        ),
        showMarginControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: hasMarginValue,
            label: (0,external_wp_i18n_namespaceObject.__)("Margin"),
            onDeselect: resetMarginValue,
            isShownByDefault: defaultControls.margin ?? dimensions_panel_DEFAULT_CONTROLS.margin,
            className: dist_clsx({
              "tools-panel-item-spacing": showSpacingPresetsControl
            }),
            panelId,
            children: [
              !showSpacingPresetsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.BoxControl,
                {
                  __next40pxDefaultSize: true,
                  values: marginValues,
                  onChange: setMarginValues,
                  inputProps: {
                    min: minMarginValue,
                    onDragStart: () => {
                      setMinMarginValue(0);
                    },
                    onDragEnd: () => {
                      setMinMarginValue(minimumMargin);
                    },
                    onMouseOver: onMouseOverMargin,
                    onMouseOut: onMouseLeaveControls
                  },
                  label: (0,external_wp_i18n_namespaceObject.__)("Margin"),
                  sides: marginSides,
                  units,
                  allowReset: false,
                  splitOnAxis: isAxialMargin
                }
              ),
              showSpacingPresetsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                SpacingSizesControl,
                {
                  values: marginValues,
                  onChange: setMarginValues,
                  minimumCustomValue: -Infinity,
                  label: (0,external_wp_i18n_namespaceObject.__)("Margin"),
                  sides: marginSides,
                  units,
                  allowReset: false,
                  onMouseOver: onMouseOverMargin,
                  onMouseOut: onMouseLeaveControls
                }
              )
            ]
          }
        ),
        showGapControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: hasGapValue,
            label: (0,external_wp_i18n_namespaceObject.__)("Block spacing"),
            onDeselect: resetGapValue,
            isShownByDefault: defaultControls.blockGap ?? dimensions_panel_DEFAULT_CONTROLS.blockGap,
            className: dist_clsx({
              "tools-panel-item-spacing": showSpacingPresetsControl,
              "single-column": (
                // If UnitControl is used, should be single-column.
                !showSpacingPresetsControl && !isAxialGap
              )
            }),
            panelId,
            children: [
              !showSpacingPresetsControl && (isAxialGap ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.BoxControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0,external_wp_i18n_namespaceObject.__)("Block spacing"),
                  min: 0,
                  onChange: setGapValues,
                  units,
                  sides: gapSides,
                  values: gapValues,
                  allowReset: false,
                  splitOnAxis: isAxialGap
                }
              ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.__experimentalUnitControl,
                {
                  __next40pxDefaultSize: true,
                  label: (0,external_wp_i18n_namespaceObject.__)("Block spacing"),
                  min: 0,
                  onChange: setGapValue,
                  units,
                  value: gapValue
                }
              )),
              showSpacingPresetsControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                SpacingSizesControl,
                {
                  label: (0,external_wp_i18n_namespaceObject.__)("Block spacing"),
                  min: 0,
                  onChange: setGapValues,
                  showSideInLabel: false,
                  sides: isAxialGap ? gapSides : ["top"],
                  values: gapValues,
                  allowReset: false
                }
              )
            ]
          }
        ),
        showChildLayoutControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          ChildLayoutControl,
          {
            value: childLayout,
            onChange: setChildLayout,
            parentLayout: settings?.parentLayout,
            panelId,
            isShownByDefault: defaultControls.childLayout ?? dimensions_panel_DEFAULT_CONTROLS.childLayout
          }
        ),
        showMinHeightControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToolsPanelItem,
          {
            hasValue: hasMinHeightValue,
            label: (0,external_wp_i18n_namespaceObject.__)("Minimum height"),
            onDeselect: resetMinHeightValue,
            isShownByDefault: defaultControls.minHeight ?? dimensions_panel_DEFAULT_CONTROLS.minHeight,
            panelId,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              HeightControl,
              {
                label: (0,external_wp_i18n_namespaceObject.__)("Minimum height"),
                value: minHeightValue,
                onChange: setMinHeightValue
              }
            )
          }
        ),
        showAspectRatioControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          AspectRatioTool,
          {
            hasValue: hasAspectRatioValue,
            value: aspectRatioValue,
            onChange: setAspectRatioValue,
            panelId,
            isShownByDefault: defaultControls.aspectRatio ?? dimensions_panel_DEFAULT_CONTROLS.aspectRatio
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-popover/use-popover-scroll.js


const scrollContainerCache = /* @__PURE__ */ new WeakMap();
function usePopoverScroll(contentRef) {
  const effect = (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      function onWheel(event) {
        const { deltaX, deltaY, target } = event;
        const contentEl = contentRef.current;
        let scrollContainer = scrollContainerCache.get(contentEl);
        if (!scrollContainer) {
          scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(contentEl);
          scrollContainerCache.set(contentEl, scrollContainer);
        }
        const eventScrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(target);
        if (!node.contains(eventScrollContainer)) {
          scrollContainer.scrollBy(deltaX, deltaY);
        }
      }
      const options = { passive: true };
      node.addEventListener("wheel", onWheel, options);
      return () => {
        node.removeEventListener("wheel", onWheel, options);
      };
    },
    [contentRef]
  );
  return contentRef ? effect : null;
}
var use_popover_scroll_default = usePopoverScroll;


;// ./node_modules/@wordpress/block-editor/build-module/utils/dom.js
const BLOCK_SELECTOR = ".block-editor-block-list__block";
const APPENDER_SELECTOR = ".block-list-appender";
const BLOCK_APPENDER_CLASS = ".block-editor-button-block-appender";
function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}
function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest(
    [BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(",")
  );
  return parentBlock === blockElement;
}
function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }
  if (!node) {
    return;
  }
  const elementNode = (
    /** @type {Element} */
    node
  );
  const blockNode = elementNode.closest(BLOCK_SELECTOR);
  if (!blockNode) {
    return;
  }
  return blockNode.id.slice("block-".length);
}
function rectUnion(rect1, rect2) {
  const left = Math.min(rect1.left, rect2.left);
  const right = Math.max(rect1.right, rect2.right);
  const bottom = Math.max(rect1.bottom, rect2.bottom);
  const top = Math.min(rect1.top, rect2.top);
  return new window.DOMRectReadOnly(left, top, right - left, bottom - top);
}
function isElementVisible(element) {
  const viewport = element.ownerDocument.defaultView;
  if (!viewport) {
    return false;
  }
  if (element.classList.contains("components-visually-hidden")) {
    return false;
  }
  const bounds = element.getBoundingClientRect();
  if (bounds.width === 0 || bounds.height === 0) {
    return false;
  }
  if (element.checkVisibility) {
    return element.checkVisibility?.({
      opacityProperty: true,
      contentVisibilityAuto: true,
      visibilityProperty: true
    });
  }
  const style = viewport.getComputedStyle(element);
  if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0") {
    return false;
  }
  return true;
}
function isScrollable(element) {
  const style = window.getComputedStyle(element);
  return style.overflowX === "auto" || style.overflowX === "scroll" || style.overflowY === "auto" || style.overflowY === "scroll";
}
const WITH_OVERFLOW_ELEMENT_BLOCKS = ["core/navigation"];
function getElementBounds(element) {
  const viewport = element.ownerDocument.defaultView;
  if (!viewport) {
    return new window.DOMRectReadOnly();
  }
  let bounds = element.getBoundingClientRect();
  const dataType = element.getAttribute("data-type");
  if (dataType && WITH_OVERFLOW_ELEMENT_BLOCKS.includes(dataType)) {
    const stack = [element];
    let currentElement;
    while (currentElement = stack.pop()) {
      if (!isScrollable(currentElement)) {
        for (const child of currentElement.children) {
          if (isElementVisible(child)) {
            const childBounds = child.getBoundingClientRect();
            bounds = rectUnion(bounds, childBounds);
            stack.push(child);
          }
        }
      }
    }
  }
  const left = Math.max(bounds.left, 0);
  const right = Math.min(bounds.right, viewport.innerWidth);
  bounds = new window.DOMRectReadOnly(
    left,
    bounds.top,
    right - left,
    bounds.height
  );
  return bounds;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js








const MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
function BlockPopover({
  clientId,
  bottomClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  shift = true,
  ...props
}, ref) {
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(bottomClientId ?? clientId);
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([
    ref,
    use_popover_scroll_default(__unstableContentRef)
  ]);
  const [
    popoverDimensionsRecomputeCounter,
    forceRecomputePopoverDimensions
  ] = (0,external_wp_element_namespaceObject.useReducer)(
    // Module is there to make sure that the counter doesn't overflow.
    (s) => (s + 1) % MAX_POPOVER_RECOMPUTE_COUNTER,
    0
  );
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!selectedElement) {
      return;
    }
    const observer = new window.MutationObserver(
      forceRecomputePopoverDimensions
    );
    observer.observe(selectedElement, { attributes: true });
    return () => {
      observer.disconnect();
    };
  }, [selectedElement]);
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (
      // popoverDimensionsRecomputeCounter is by definition always equal or greater
      // than 0. This check is only there to satisfy the correctness of the
      // exhaustive-deps rule for the `useMemo` hook.
      popoverDimensionsRecomputeCounter < 0 || !selectedElement || bottomClientId && !lastSelectedElement
    ) {
      return void 0;
    }
    return {
      getBoundingClientRect() {
        return lastSelectedElement ? rectUnion(
          getElementBounds(selectedElement),
          getElementBounds(lastSelectedElement)
        ) : getElementBounds(selectedElement);
      },
      contextElement: selectedElement
    };
  }, [
    popoverDimensionsRecomputeCounter,
    selectedElement,
    bottomClientId,
    lastSelectedElement
  ]);
  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      ref: mergedRefs,
      animate: false,
      focusOnMount: false,
      anchor: popoverAnchor,
      __unstableSlotName: __unstablePopoverSlot,
      inline: !__unstablePopoverSlot,
      placement: "top-start",
      resize: false,
      flip: false,
      shift,
      ...props,
      className: dist_clsx("block-editor-block-popover", props.className),
      variant: "unstyled",
      children
    }
  );
}
const PrivateBlockPopover = (0,external_wp_element_namespaceObject.forwardRef)(BlockPopover);
const PublicBlockPopover = ({ clientId, bottomClientId, children, ...props }, ref) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  PrivateBlockPopover,
  {
    ...props,
    bottomClientId,
    clientId,
    __unstableContentRef: void 0,
    __unstablePopoverSlot: void 0,
    ref,
    children
  }
);
var block_popover_default = (0,external_wp_element_namespaceObject.forwardRef)(PublicBlockPopover);


;// ./node_modules/@wordpress/block-editor/build-module/components/block-popover/cover.js




function BlockPopoverCover({
  clientId,
  bottomClientId,
  children,
  shift = false,
  additionalStyles,
  ...props
}, ref) {
  bottomClientId ??= clientId;
  const selectedElement = useBlockElement(clientId);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateBlockPopover,
    {
      ref,
      clientId,
      bottomClientId,
      shift,
      ...props,
      children: selectedElement && clientId === bottomClientId ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        CoverContainer,
        {
          selectedElement,
          additionalStyles,
          children
        }
      ) : children
    }
  );
}
function CoverContainer({
  selectedElement,
  additionalStyles = {},
  children
}) {
  const [width, setWidth] = (0,external_wp_element_namespaceObject.useState)(selectedElement.offsetWidth);
  const [height, setHeight] = (0,external_wp_element_namespaceObject.useState)(selectedElement.offsetHeight);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const observer = new window.ResizeObserver(() => {
      setWidth(selectedElement.offsetWidth);
      setHeight(selectedElement.offsetHeight);
    });
    observer.observe(selectedElement, { box: "border-box" });
    return () => observer.disconnect();
  }, [selectedElement]);
  const style = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return {
      position: "absolute",
      width,
      height,
      ...additionalStyles
    };
  }, [width, height, additionalStyles]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { style, children });
}
var cover_default = (0,external_wp_element_namespaceObject.forwardRef)(BlockPopoverCover);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/spacing-visualizer.js





function SpacingVisualizer({ clientId, value, computeStyle, forceShow }) {
  const blockElement = useBlockElement(clientId);
  const [style, updateStyle] = (0,external_wp_element_namespaceObject.useReducer)(
    () => computeStyle(blockElement)
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!blockElement) {
      return;
    }
    const observer = new window.MutationObserver(updateStyle);
    observer.observe(blockElement, {
      attributes: true,
      attributeFilter: ["style", "class"]
    });
    return () => {
      observer.disconnect();
    };
  }, [blockElement]);
  const previousValueRef = (0,external_wp_element_namespaceObject.useRef)(value);
  const [isActive, setIsActive] = (0,external_wp_element_namespaceObject.useState)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (external_wp_isShallowEqual_default()(value, previousValueRef.current) || forceShow) {
      return;
    }
    setIsActive(true);
    previousValueRef.current = value;
    const timeout = setTimeout(() => {
      setIsActive(false);
    }, 400);
    return () => {
      setIsActive(false);
      clearTimeout(timeout);
    };
  }, [value, forceShow]);
  if (!isActive && !forceShow) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    cover_default,
    {
      clientId,
      __unstablePopoverSlot: "block-toolbar",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor__spacing-visualizer", style })
    }
  );
}
function getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}
function MarginVisualizer({ clientId, value, forceShow }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    SpacingVisualizer,
    {
      clientId,
      value: value?.spacing?.margin,
      computeStyle: (blockElement) => {
        const top = getComputedCSS(blockElement, "margin-top");
        const right = getComputedCSS(blockElement, "margin-right");
        const bottom = getComputedCSS(blockElement, "margin-bottom");
        const left = getComputedCSS(blockElement, "margin-left");
        return {
          borderTopWidth: top,
          borderRightWidth: right,
          borderBottomWidth: bottom,
          borderLeftWidth: left,
          top: top ? `-${top}` : 0,
          right: right ? `-${right}` : 0,
          bottom: bottom ? `-${bottom}` : 0,
          left: left ? `-${left}` : 0
        };
      },
      forceShow
    }
  );
}
function PaddingVisualizer({ clientId, value, forceShow }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    SpacingVisualizer,
    {
      clientId,
      value: value?.spacing?.padding,
      computeStyle: (blockElement) => ({
        borderTopWidth: getComputedCSS(blockElement, "padding-top"),
        borderRightWidth: getComputedCSS(
          blockElement,
          "padding-right"
        ),
        borderBottomWidth: getComputedCSS(
          blockElement,
          "padding-bottom"
        ),
        borderLeftWidth: getComputedCSS(blockElement, "padding-left")
      }),
      forceShow
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/dimensions.js












const DIMENSIONS_SUPPORT_KEY = "dimensions";
const SPACING_SUPPORT_KEY = "spacing";
const dimensions_ALL_SIDES = (/* unused pure expression or super */ null && (["top", "right", "bottom", "left"]));
const dimensions_AXIAL_SIDES = (/* unused pure expression or super */ null && (["vertical", "horizontal"]));
function useVisualizer() {
  const [property, setProperty] = (0,external_wp_element_namespaceObject.useState)(false);
  const { hideBlockInterface, showBlockInterface } = unlock(
    (0,external_wp_data_namespaceObject.useDispatch)(store)
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!property) {
      showBlockInterface();
    } else {
      hideBlockInterface();
    }
  }, [property, showBlockInterface, hideBlockInterface]);
  return [property, setProperty];
}
function DimensionsInspectorControl({ children, resetAllFilter }) {
  const attributesResetAllFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (attributes) => {
      const existingStyle = attributes.style;
      const updatedStyle = resetAllFilter(existingStyle);
      return {
        ...attributes,
        style: updatedStyle
      };
    },
    [resetAllFilter]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inspector_controls_default,
    {
      group: "dimensions",
      resetAllFilter: attributesResetAllFilter,
      children
    }
  );
}
function dimensions_DimensionsPanel({ clientId, name, setAttributes, settings }) {
  const isEnabled = useHasDimensionsPanel(settings);
  const value = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getBlockAttributes(clientId)?.style,
    [clientId]
  );
  const [visualizedProperty, setVisualizedProperty] = useVisualizer();
  const onChange = (newStyle) => {
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  if (!isEnabled) {
    return null;
  }
  const defaultDimensionsControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    DIMENSIONS_SUPPORT_KEY,
    "__experimentalDefaultControls"
  ]);
  const defaultSpacingControls = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, [
    SPACING_SUPPORT_KEY,
    "__experimentalDefaultControls"
  ]);
  const defaultControls = {
    ...defaultDimensionsControls,
    ...defaultSpacingControls
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      DimensionsPanel,
      {
        as: DimensionsInspectorControl,
        panelId: clientId,
        settings,
        value,
        onChange,
        defaultControls,
        onVisualize: setVisualizedProperty
      }
    ),
    !!settings?.spacing?.padding && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PaddingVisualizer,
      {
        forceShow: visualizedProperty === "padding",
        clientId,
        value
      }
    ),
    !!settings?.spacing?.margin && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      MarginVisualizer,
      {
        forceShow: visualizedProperty === "margin",
        clientId,
        value
      }
    )
  ] });
}
function hasDimensionsSupport(blockName, feature = "any") {
  if (external_wp_element_namespaceObject.Platform.OS !== "web") {
    return false;
  }
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, DIMENSIONS_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === "any") {
    return !!(support?.aspectRatio || !!support?.minHeight);
  }
  return !!support?.[feature];
}
var dimensions_default = {
  useBlockProps: dimensions_useBlockProps,
  attributeKeys: ["minHeight", "style"],
  hasSupport(name) {
    return hasDimensionsSupport(name, "aspectRatio");
  }
};
function dimensions_useBlockProps({ name, minHeight, style }) {
  if (!hasDimensionsSupport(name, "aspectRatio") || shouldSkipSerialization(name, DIMENSIONS_SUPPORT_KEY, "aspectRatio")) {
    return {};
  }
  const className = dist_clsx({
    "has-aspect-ratio": !!style?.dimensions?.aspectRatio
  });
  const inlineStyleOverrides = {};
  if (style?.dimensions?.aspectRatio) {
    inlineStyleOverrides.minHeight = "unset";
  } else if (minHeight || style?.dimensions?.minHeight) {
    inlineStyleOverrides.aspectRatio = "unset";
  }
  return { className, style: inlineStyleOverrides };
}
function useCustomSides() {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalUseCustomSides", {
    since: "6.3",
    version: "6.4"
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/style.js














const styleSupportKeys = [
  ...TYPOGRAPHY_SUPPORT_KEYS,
  BORDER_SUPPORT_KEY,
  COLOR_SUPPORT_KEY,
  DIMENSIONS_SUPPORT_KEY,
  BACKGROUND_SUPPORT_KEY,
  SPACING_SUPPORT_KEY,
  SHADOW_SUPPORT_KEY
];
const hasStyleSupport = (nameOrType) => styleSupportKeys.some((key) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, key));
function getInlineStyles(styles = {}) {
  const output = {};
  (0,external_wp_styleEngine_namespaceObject.getCSSRules)(styles).forEach((rule) => {
    output[rule.key] = rule.value;
  });
  return output;
}
function style_addAttribute(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  }
  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: "object"
      }
    });
  }
  return settings;
}
const skipSerializationPathsEdit = {
  [`${BORDER_SUPPORT_KEY}.__experimentalSkipSerialization`]: ["border"],
  [`${COLOR_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
    COLOR_SUPPORT_KEY
  ],
  [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
    TYPOGRAPHY_SUPPORT_KEY
  ],
  [`${DIMENSIONS_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
    DIMENSIONS_SUPPORT_KEY
  ],
  [`${SPACING_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
    SPACING_SUPPORT_KEY
  ],
  [`${SHADOW_SUPPORT_KEY}.__experimentalSkipSerialization`]: [
    SHADOW_SUPPORT_KEY
  ]
};
const skipSerializationPathsSave = {
  ...skipSerializationPathsEdit,
  [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: [
    `${DIMENSIONS_SUPPORT_KEY}.aspectRatio`
  ],
  // Skip serialization of aspect ratio in save mode.
  [`${BACKGROUND_SUPPORT_KEY}`]: [BACKGROUND_SUPPORT_KEY]
  // Skip serialization of background support in save mode.
};
const skipSerializationPathsSaveChecks = {
  [`${DIMENSIONS_SUPPORT_KEY}.aspectRatio`]: true,
  [`${BACKGROUND_SUPPORT_KEY}`]: true
};
const renamedFeatures = { gradients: "gradient" };
function omitStyle(style, paths, preserveReference = false) {
  if (!style) {
    return style;
  }
  let newStyle = style;
  if (!preserveReference) {
    newStyle = JSON.parse(JSON.stringify(style));
  }
  if (!Array.isArray(paths)) {
    paths = [paths];
  }
  paths.forEach((path) => {
    if (!Array.isArray(path)) {
      path = path.split(".");
    }
    if (path.length > 1) {
      const [firstSubpath, ...restPath] = path;
      omitStyle(newStyle[firstSubpath], [restPath], true);
    } else if (path.length === 1) {
      delete newStyle[path[0]];
    }
  });
  return newStyle;
}
function style_addSaveProps(props, blockNameOrType, attributes, skipPaths = skipSerializationPathsSave) {
  if (!hasStyleSupport(blockNameOrType)) {
    return props;
  }
  let { style } = attributes;
  Object.entries(skipPaths).forEach(([indicator, path]) => {
    const skipSerialization = skipSerializationPathsSaveChecks[indicator] || (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockNameOrType, indicator);
    if (skipSerialization === true) {
      style = omitStyle(style, path);
    }
    if (Array.isArray(skipSerialization)) {
      skipSerialization.forEach((featureName) => {
        const feature = renamedFeatures[featureName] || featureName;
        style = omitStyle(style, [[...path, feature]]);
      });
    }
  });
  props.style = {
    ...getInlineStyles(style),
    ...props.style
  };
  return props;
}
function BlockStyleControls({
  clientId,
  name,
  setAttributes,
  __unstableParentLayout
}) {
  const settings = useBlockSettings(name, __unstableParentLayout);
  const blockEditingMode = useBlockEditingMode();
  const passedProps = {
    clientId,
    name,
    setAttributes,
    settings: {
      ...settings,
      typography: {
        ...settings.typography,
        // The text alignment UI for individual blocks is rendered in
        // the block toolbar, so disable it here.
        textAlign: false
      }
    }
  };
  if (blockEditingMode !== "default") {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ColorEdit, { ...passedProps }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(background_BackgroundImagePanel, { ...passedProps }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(typography_TypographyPanel, { ...passedProps }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(border_BorderPanel, { ...passedProps }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(dimensions_DimensionsPanel, { ...passedProps })
  ] });
}
var style_default = {
  edit: BlockStyleControls,
  hasSupport: hasStyleSupport,
  addSaveProps: style_addSaveProps,
  attributeKeys: ["style"],
  useBlockProps: style_useBlockProps
};
const elementTypes = [
  { elementType: "button" },
  { elementType: "link", pseudo: [":hover"] },
  {
    elementType: "heading",
    elements: ["h1", "h2", "h3", "h4", "h5", "h6"]
  }
];
const STYLE_BLOCK_PROPS_REFERENCE = {};
function style_useBlockProps({ name, style }) {
  const blockElementsContainerIdentifier = (0,external_wp_compose_namespaceObject.useInstanceId)(
    STYLE_BLOCK_PROPS_REFERENCE,
    "wp-elements"
  );
  const baseElementSelector = `.${blockElementsContainerIdentifier}`;
  const blockElementStyles = style?.elements;
  const styles = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!blockElementStyles) {
      return;
    }
    const elementCSSRules = [];
    elementTypes.forEach(({ elementType, pseudo, elements }) => {
      const skipSerialization = shouldSkipSerialization(
        name,
        COLOR_SUPPORT_KEY,
        elementType
      );
      if (skipSerialization) {
        return;
      }
      const elementStyles = blockElementStyles?.[elementType];
      if (elementStyles) {
        const selector = scopeSelector(
          baseElementSelector,
          external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementType]
        );
        elementCSSRules.push(
          (0,external_wp_styleEngine_namespaceObject.compileCSS)(elementStyles, { selector })
        );
        if (pseudo) {
          pseudo.forEach((pseudoSelector) => {
            if (elementStyles[pseudoSelector]) {
              elementCSSRules.push(
                (0,external_wp_styleEngine_namespaceObject.compileCSS)(elementStyles[pseudoSelector], {
                  selector: scopeSelector(
                    baseElementSelector,
                    `${external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementType]}${pseudoSelector}`
                  )
                })
              );
            }
          });
        }
      }
      if (elements) {
        elements.forEach((element) => {
          if (blockElementStyles[element]) {
            elementCSSRules.push(
              (0,external_wp_styleEngine_namespaceObject.compileCSS)(blockElementStyles[element], {
                selector: scopeSelector(
                  baseElementSelector,
                  external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[element]
                )
              })
            );
          }
        });
      }
    });
    return elementCSSRules.length > 0 ? elementCSSRules.join("") : void 0;
  }, [baseElementSelector, blockElementStyles, name]);
  useStyleOverride({ css: styles });
  return style_addSaveProps(
    { className: blockElementsContainerIdentifier },
    name,
    { style },
    skipSerializationPathsEdit
  );
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/style/addAttribute",
  style_addAttribute
);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/settings.js


const hasSettingsSupport = (blockType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "__experimentalSettings", false);
function settings_addAttribute(settings) {
  if (!hasSettingsSupport(settings)) {
    return settings;
  }
  if (!settings?.attributes?.settings) {
    settings.attributes = {
      ...settings.attributes,
      settings: {
        type: "object"
      }
    };
  }
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/settings/addAttribute",
  settings_addAttribute
);

;// ./node_modules/@wordpress/icons/build-module/library/filter.js


var filter_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12 4 4 19h16L12 4zm0 3.2 5.5 10.3H12V7.2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/duotone-control/index.js






function DuotoneControl({
  id: idProp,
  colorPalette,
  duotonePalette,
  disableCustomColors,
  disableCustomDuotone,
  value,
  onChange
}) {
  let toolbarIcon;
  if (value === "unset") {
    toolbarIcon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ColorIndicator, { className: "block-editor-duotone-control__unset-indicator" });
  } else if (value) {
    toolbarIcon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.DuotoneSwatch, { values: value });
  } else {
    toolbarIcon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: filter_default });
  }
  const actionLabel = (0,external_wp_i18n_namespaceObject.__)("Apply duotone filter");
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(DuotoneControl, "duotone-control", idProp);
  const descriptionId = `${id}__description`;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps: {
        className: "block-editor-duotone-control__popover",
        headerTitle: (0,external_wp_i18n_namespaceObject.__)("Duotone")
      },
      renderToggle: ({ isOpen, onToggle }) => {
        const openOnArrowDown = (event) => {
          if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
            event.preventDefault();
            onToggle();
          }
        };
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.ToolbarButton,
          {
            showTooltip: true,
            onClick: onToggle,
            "aria-haspopup": "true",
            "aria-expanded": isOpen,
            onKeyDown: openOnArrowDown,
            label: actionLabel,
            icon: toolbarIcon
          }
        );
      },
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { label: (0,external_wp_i18n_namespaceObject.__)("Duotone"), children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)(
          "Create a two-tone color effect without losing your original image."
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.DuotonePicker,
          {
            "aria-label": actionLabel,
            "aria-describedby": descriptionId,
            colorPalette,
            duotonePalette,
            disableCustomColors,
            disableCustomDuotone,
            value,
            onChange
          }
        )
      ] })
    }
  );
}
var duotone_control_default = DuotoneControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/duotone/utils.js

function getValuesFromColors(colors = []) {
  const values = { r: [], g: [], b: [], a: [] };
  colors.forEach((color) => {
    const rgbColor = w(color).toRgb();
    values.r.push(rgbColor.r / 255);
    values.g.push(rgbColor.g / 255);
    values.b.push(rgbColor.b / 255);
    values.a.push(rgbColor.a);
  });
  return values;
}
function getDuotoneUnsetStylesheet(selector) {
  return `${selector}{filter:none}`;
}
function getDuotoneStylesheet(selector, id) {
  return `${selector}{filter:url(#${id})}`;
}
function getDuotoneFilter(id, colors) {
  const values = getValuesFromColors(colors);
  return `
<svg
	xmlns:xlink="http://www.w3.org/1999/xlink"
	viewBox="0 0 0 0"
	width="0"
	height="0"
	focusable="false"
	role="none"
	aria-hidden="true"
	style="visibility: hidden; position: absolute; left: -9999px; overflow: hidden;"
>
	<defs>
		<filter id="${id}">
			<!--
				Use sRGB instead of linearRGB so transparency looks correct.
				Use perceptual brightness to convert to grayscale.
			-->
			<feColorMatrix color-interpolation-filters="sRGB" type="matrix" values=" .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "></feColorMatrix>
			<!-- Use sRGB instead of linearRGB to be consistent with how CSS gradients work. -->
			<feComponentTransfer color-interpolation-filters="sRGB">
				<feFuncR type="table" tableValues="${values.r.join(" ")}"></feFuncR>
				<feFuncG type="table" tableValues="${values.g.join(" ")}"></feFuncG>
				<feFuncB type="table" tableValues="${values.b.join(" ")}"></feFuncB>
				<feFuncA type="table" tableValues="${values.a.join(" ")}"></feFuncA>
			</feComponentTransfer>
			<!-- Re-mask the image with the original transparency since the feColorMatrix above loses that information. -->
			<feComposite in2="SourceGraphic" operator="in"></feComposite>
		</filter>
	</defs>
</svg>`;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/get-block-css-selector.js


function getBlockCSSSelector(blockType, target = "root", options = {}) {
  if (!target) {
    return null;
  }
  const { fallback = false } = options;
  const { name, selectors, supports } = blockType;
  const hasSelectors = selectors && Object.keys(selectors).length > 0;
  const path = Array.isArray(target) ? target.join(".") : target;
  let rootSelector = null;
  if (hasSelectors && selectors.root) {
    rootSelector = selectors?.root;
  } else if (supports?.__experimentalSelector) {
    rootSelector = supports.__experimentalSelector;
  } else {
    rootSelector = ".wp-block-" + name.replace("core/", "").replace("/", "-");
  }
  if (path === "root") {
    return rootSelector;
  }
  const pathArray = Array.isArray(target) ? target : target.split(".");
  if (pathArray.length === 1) {
    const fallbackSelector = fallback ? rootSelector : null;
    if (hasSelectors) {
      const featureSelector2 = getValueFromObjectPath(selectors, `${path}.root`, null) || getValueFromObjectPath(selectors, path, null);
      return featureSelector2 || fallbackSelector;
    }
    const featureSelector = getValueFromObjectPath(
      supports,
      `${path}.__experimentalSelector`,
      null
    );
    if (!featureSelector) {
      return fallbackSelector;
    }
    return scopeSelector(rootSelector, featureSelector);
  }
  let subfeatureSelector;
  if (hasSelectors) {
    subfeatureSelector = getValueFromObjectPath(selectors, path, null);
  }
  if (subfeatureSelector) {
    return subfeatureSelector;
  }
  if (fallback) {
    return getBlockCSSSelector(blockType, pathArray[0], options);
  }
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/filters-panel.js








const filters_panel_EMPTY_ARRAY = [];
function useMultiOriginColorPresets(settings, { presetSetting, defaultSetting }) {
  const disableDefault = !settings?.color?.[defaultSetting];
  const userPresets = settings?.color?.[presetSetting]?.custom || filters_panel_EMPTY_ARRAY;
  const themePresets = settings?.color?.[presetSetting]?.theme || filters_panel_EMPTY_ARRAY;
  const defaultPresets = settings?.color?.[presetSetting]?.default || filters_panel_EMPTY_ARRAY;
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userPresets,
      ...themePresets,
      ...disableDefault ? filters_panel_EMPTY_ARRAY : defaultPresets
    ],
    [disableDefault, userPresets, themePresets, defaultPresets]
  );
}
function useHasFiltersPanel(settings) {
  return useHasDuotoneControl(settings);
}
function useHasDuotoneControl(settings) {
  return settings.color.customDuotone || settings.color.defaultDuotone || settings.color.duotone.length > 0;
}
function FiltersToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject._x)("Filters", "Name for applying graphical effects"),
      resetAll,
      panelId,
      dropdownMenuProps,
      children
    }
  );
}
const filters_panel_DEFAULT_CONTROLS = {
  duotone: true
};
const filters_panel_popoverProps = {
  placement: "left-start",
  offset: 36,
  shift: true,
  className: "block-editor-duotone-control__popover",
  headerTitle: (0,external_wp_i18n_namespaceObject.__)("Duotone")
};
const LabeledColorIndicator = ({ indicator, label }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "flex-start", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalZStack, { isLayered: false, offset: -8, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Flex, { expanded: false, children: indicator === "unset" || !indicator ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ColorIndicator, { className: "block-editor-duotone-control__unset-indicator" }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.DuotoneSwatch, { values: indicator }) }) }),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { title: label, children: label })
] });
const renderToggle = (duotone, resetDuotone) => ({ onToggle, isOpen }) => {
  const duotoneButtonRef = (0,external_wp_element_namespaceObject.useRef)(void 0);
  const toggleProps = {
    onClick: onToggle,
    className: dist_clsx(
      "block-editor-global-styles-filters-panel__dropdown-toggle",
      { "is-open": isOpen }
    ),
    "aria-expanded": isOpen,
    ref: duotoneButtonRef
  };
  const removeButtonProps = {
    onClick: () => {
      if (isOpen) {
        onToggle();
      }
      resetDuotone();
      duotoneButtonRef.current?.focus();
    },
    className: "block-editor-panel-duotone-settings__reset",
    label: (0,external_wp_i18n_namespaceObject.__)("Reset")
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      LabeledColorIndicator,
      {
        indicator: duotone,
        label: (0,external_wp_i18n_namespaceObject.__)("Duotone")
      }
    ) }),
    duotone && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        size: "small",
        icon: reset_default,
        ...removeButtonProps
      }
    )
  ] });
};
function FiltersPanel({
  as: Wrapper = FiltersToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = filters_panel_DEFAULT_CONTROLS
}) {
  const decodeValue = (rawValue) => getValueFromVariable({ settings }, "", rawValue);
  const hasDuotoneEnabled = useHasDuotoneControl(settings);
  const duotonePalette = useMultiOriginColorPresets(settings, {
    presetSetting: "duotone",
    defaultSetting: "defaultDuotone"
  });
  const colorPalette = useMultiOriginColorPresets(settings, {
    presetSetting: "palette",
    defaultSetting: "defaultPalette"
  });
  const duotone = decodeValue(inheritedValue?.filter?.duotone);
  const setDuotone = (newValue) => {
    const duotonePreset = duotonePalette.find(({ colors }) => {
      return colors === newValue;
    });
    const duotoneValue = duotonePreset ? `var:preset|duotone|${duotonePreset.slug}` : newValue;
    onChange(
      setImmutably(value, ["filter", "duotone"], duotoneValue)
    );
  };
  const hasDuotone = () => !!value?.filter?.duotone;
  const resetDuotone = () => setDuotone(void 0);
  const resetAllFilter = (0,external_wp_element_namespaceObject.useCallback)((previousValue) => {
    return {
      ...previousValue,
      filter: {
        ...previousValue.filter,
        duotone: void 0
      }
    };
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    Wrapper,
    {
      resetAllFilter,
      value,
      onChange,
      panelId,
      children: hasDuotoneEnabled && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        {
          label: (0,external_wp_i18n_namespaceObject.__)("Duotone"),
          hasValue: hasDuotone,
          onDeselect: resetDuotone,
          isShownByDefault: defaultControls.duotone,
          panelId,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Dropdown,
            {
              popoverProps: filters_panel_popoverProps,
              className: "block-editor-global-styles-filters-panel__dropdown",
              renderToggle: renderToggle(duotone, resetDuotone),
              renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, { paddingSize: "small", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { label: (0,external_wp_i18n_namespaceObject.__)("Duotone"), children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)(
                  "Create a two-tone color effect without losing your original image."
                ) }),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.DuotonePicker,
                  {
                    colorPalette,
                    duotonePalette,
                    disableCustomColors: true,
                    disableCustomDuotone: true,
                    value: duotone,
                    onChange: setDuotone
                  }
                )
              ] }) })
            }
          )
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/duotone.js















const duotone_EMPTY_ARRAY = [];
const isSafari = window?.navigator.userAgent && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome") && !window.navigator.userAgent.includes("Chromium");
k([names]);
function useMultiOriginPresets({ presetSetting, defaultSetting }) {
  const [enableDefault, userPresets, themePresets, defaultPresets] = use_settings_useSettings(
    defaultSetting,
    `${presetSetting}.custom`,
    `${presetSetting}.theme`,
    `${presetSetting}.default`
  );
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userPresets || duotone_EMPTY_ARRAY,
      ...themePresets || duotone_EMPTY_ARRAY,
      ...enableDefault && defaultPresets || duotone_EMPTY_ARRAY
    ],
    [enableDefault, userPresets, themePresets, defaultPresets]
  );
}
function getColorsFromDuotonePreset(duotone, duotonePalette) {
  if (!duotone) {
    return;
  }
  const preset = duotonePalette?.find(({ slug }) => {
    return duotone === `var:preset|duotone|${slug}`;
  });
  return preset ? preset.colors : void 0;
}
function getDuotonePresetFromColors(colors, duotonePalette) {
  if (!colors || !Array.isArray(colors)) {
    return;
  }
  const preset = duotonePalette?.find((duotonePreset) => {
    return duotonePreset?.colors?.every(
      (val, index) => val === colors[index]
    );
  });
  return preset ? `var:preset|duotone|${preset.slug}` : void 0;
}
function DuotonePanelPure({ style, setAttributes, name }) {
  const duotoneStyle = style?.color?.duotone;
  const settings = useBlockSettings(name);
  const blockEditingMode = useBlockEditingMode();
  const duotonePalette = useMultiOriginPresets({
    presetSetting: "color.duotone",
    defaultSetting: "color.defaultDuotone"
  });
  const colorPalette = useMultiOriginPresets({
    presetSetting: "color.palette",
    defaultSetting: "color.defaultPalette"
  });
  const [enableCustomColors, enableCustomDuotone] = use_settings_useSettings(
    "color.custom",
    "color.customDuotone"
  );
  const disableCustomColors = !enableCustomColors;
  const disableCustomDuotone = !enableCustomDuotone || colorPalette?.length === 0 && disableCustomColors;
  if (duotonePalette?.length === 0 && disableCustomDuotone) {
    return null;
  }
  if (blockEditingMode !== "default") {
    return null;
  }
  const duotonePresetOrColors = duotoneStyle === "unset" || Array.isArray(duotoneStyle) ? duotoneStyle : getColorsFromDuotonePreset(duotoneStyle, duotonePalette);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "filter", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      FiltersPanel,
      {
        value: { filter: { duotone: duotonePresetOrColors } },
        onChange: (newDuotone) => {
          const newStyle = {
            ...style,
            color: {
              ...newDuotone?.filter
            }
          };
          setAttributes({
            style: utils_cleanEmptyObject(newStyle)
          });
        },
        settings
      }
    ) }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "block", __experimentalShareWithChildBlocks: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      duotone_control_default,
      {
        duotonePalette,
        colorPalette,
        disableCustomDuotone,
        disableCustomColors,
        value: duotonePresetOrColors,
        onChange: (newDuotone) => {
          const maybePreset = getDuotonePresetFromColors(
            newDuotone,
            duotonePalette
          );
          const newStyle = {
            ...style,
            color: {
              ...style?.color,
              duotone: maybePreset ?? newDuotone
              // use preset or fallback to custom colors.
            }
          };
          setAttributes({
            style: utils_cleanEmptyObject(newStyle)
          });
        },
        settings
      }
    ) })
  ] });
}
var duotone_default = {
  shareWithChildBlocks: true,
  edit: DuotonePanelPure,
  useBlockProps: duotone_useBlockProps,
  attributeKeys: ["style"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "filter.duotone");
  }
};
function addDuotoneAttributes(settings) {
  if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(settings, "filter.duotone")) {
    return settings;
  }
  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: "object"
      }
    });
  }
  return settings;
}
function useDuotoneStyles({
  clientId,
  id: filterId,
  selector: duotoneSelector,
  attribute: duotoneAttr
}) {
  const duotonePalette = useMultiOriginPresets({
    presetSetting: "color.duotone",
    defaultSetting: "color.defaultDuotone"
  });
  const isCustom = Array.isArray(duotoneAttr);
  const duotonePreset = isCustom ? void 0 : getColorsFromDuotonePreset(duotoneAttr, duotonePalette);
  const isPreset = typeof duotoneAttr === "string" && duotonePreset;
  const isCSS = typeof duotoneAttr === "string" && !isPreset;
  let colors = null;
  if (isPreset) {
    colors = duotonePreset;
  } else if (isCSS) {
    colors = duotoneAttr;
  } else if (isCustom) {
    colors = duotoneAttr;
  }
  const selectors = duotoneSelector.split(",");
  const selectorsScoped = selectors.map((selectorPart) => {
    return `.${filterId}${selectorPart.trim()}`;
  });
  const selector = selectorsScoped.join(", ");
  const isValidFilter = Array.isArray(colors) || colors === "unset";
  usePrivateStyleOverride(
    isValidFilter ? {
      css: colors !== "unset" ? getDuotoneStylesheet(selector, filterId) : getDuotoneUnsetStylesheet(selector),
      __unstableType: "presets"
    } : void 0
  );
  usePrivateStyleOverride(
    isValidFilter ? {
      assets: colors !== "unset" ? getDuotoneFilter(filterId, colors) : "",
      __unstableType: "svgs"
    } : void 0
  );
  const blockElement = useBlockElement(clientId);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isValidFilter) {
      return;
    }
    if (blockElement && isSafari) {
      const display = blockElement.style.display;
      blockElement.style.setProperty("display", "inline-block");
      blockElement.offsetHeight;
      blockElement.style.setProperty("display", display);
    }
  }, [isValidFilter, blockElement, colors]);
}
const DUOTONE_BLOCK_PROPS_REFERENCE = {};
function duotone_useBlockProps({ clientId, name, style }) {
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(DUOTONE_BLOCK_PROPS_REFERENCE);
  const selector = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
    if (blockType) {
      const duotoneSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(
        blockType,
        "filter.duotone",
        false
      );
      if (!duotoneSupport) {
        return null;
      }
      const experimentalDuotone = (0,external_wp_blocks_namespaceObject.getBlockSupport)(
        blockType,
        "color.__experimentalDuotone",
        false
      );
      if (experimentalDuotone) {
        const rootSelector = getBlockCSSSelector(blockType);
        return typeof experimentalDuotone === "string" ? scopeSelector(rootSelector, experimentalDuotone) : rootSelector;
      }
      return getBlockCSSSelector(blockType, "filter.duotone", {
        fallback: true
      });
    }
  }, [name]);
  const attribute = style?.color?.duotone;
  const filterClass = `wp-duotone-${id}`;
  const shouldRender = selector && attribute;
  useDuotoneStyles({
    clientId,
    id: filterClass,
    selector,
    attribute
  });
  return {
    className: shouldRender ? filterClass : ""
  };
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/editor/duotone/add-attributes",
  addDuotoneAttributes
);


;// ./node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js




function getPositionTypeLabel(attributes) {
  const positionType = attributes?.style?.position?.type;
  if (positionType === "sticky") {
    return (0,external_wp_i18n_namespaceObject.__)("Sticky");
  }
  if (positionType === "fixed") {
    return (0,external_wp_i18n_namespaceObject.__)("Fixed");
  }
  return null;
}
function useBlockDisplayInformation(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!clientId) {
        return null;
      }
      const { getBlockName, getBlockAttributes } = select(store);
      const { getBlockType, getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
      const blockName = getBlockName(clientId);
      const blockType = getBlockType(blockName);
      if (!blockType) {
        return null;
      }
      const attributes = getBlockAttributes(clientId);
      const match = getActiveBlockVariation(blockName, attributes);
      const isSynced = (0,external_wp_blocks_namespaceObject.isReusableBlock)(blockType) || (0,external_wp_blocks_namespaceObject.isTemplatePart)(blockType);
      const syncedTitle = isSynced ? (0,external_wp_blocks_namespaceObject.__experimentalGetBlockLabel)(blockType, attributes) : void 0;
      const title = syncedTitle || blockType.title;
      const positionLabel = getPositionTypeLabel(attributes);
      const blockTypeInfo = {
        isSynced,
        title,
        icon: blockType.icon,
        description: blockType.description,
        anchor: attributes?.anchor,
        positionLabel,
        positionType: attributes?.style?.position?.type,
        name: attributes?.metadata?.name
      };
      if (!match) {
        return blockTypeInfo;
      }
      return {
        isSynced,
        title: match.title || blockType.title,
        icon: match.icon || blockType.icon,
        description: match.description || blockType.description,
        anchor: attributes?.anchor,
        positionLabel,
        positionType: attributes?.style?.position?.type,
        name: attributes?.metadata?.name
      };
    },
    [clientId]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/position.js













const POSITION_SUPPORT_KEY = "position";
const DEFAULT_OPTION = {
  key: "default",
  value: "",
  name: (0,external_wp_i18n_namespaceObject.__)("Default")
};
const STICKY_OPTION = {
  key: "sticky",
  value: "sticky",
  name: (0,external_wp_i18n_namespaceObject._x)("Sticky", "Name for the value of the CSS position property"),
  hint: (0,external_wp_i18n_namespaceObject.__)(
    "The block will stick to the top of the window instead of scrolling."
  )
};
const FIXED_OPTION = {
  key: "fixed",
  value: "fixed",
  name: (0,external_wp_i18n_namespaceObject._x)("Fixed", "Name for the value of the CSS position property"),
  hint: (0,external_wp_i18n_namespaceObject.__)("The block will not move when the page is scrolled.")
};
const POSITION_SIDES = ["top", "right", "bottom", "left"];
const VALID_POSITION_TYPES = ["sticky", "fixed"];
function getPositionCSS({ selector, style }) {
  let output = "";
  const { type: positionType } = style?.position || {};
  if (!VALID_POSITION_TYPES.includes(positionType)) {
    return output;
  }
  output += `${selector} {`;
  output += `position: ${positionType};`;
  POSITION_SIDES.forEach((side) => {
    if (style?.position?.[side] !== void 0) {
      output += `${side}: ${style.position[side]};`;
    }
  });
  if (positionType === "sticky" || positionType === "fixed") {
    output += `z-index: 10`;
  }
  output += `}`;
  return output;
}
function hasStickyPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.sticky);
}
function hasFixedPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!(true === support || support?.fixed);
}
function hasPositionSupport(blockType) {
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockType, POSITION_SUPPORT_KEY);
  return !!support;
}
function hasPositionValue(props) {
  return props.attributes.style?.position?.type !== void 0;
}
function hasStickyOrFixedPositionValue(attributes) {
  const positionType = attributes?.style?.position?.type;
  return positionType === "sticky" || positionType === "fixed";
}
function resetPosition({ attributes = {}, setAttributes }) {
  const { style = {} } = attributes;
  setAttributes({
    style: cleanEmptyObject({
      ...style,
      position: {
        ...style?.position,
        type: void 0,
        top: void 0,
        right: void 0,
        bottom: void 0,
        left: void 0
      }
    })
  });
}
function useIsPositionDisabled({ name: blockName } = {}) {
  const [allowFixed, allowSticky] = use_settings_useSettings(
    "position.fixed",
    "position.sticky"
  );
  const isDisabled = !allowFixed && !allowSticky;
  return !hasPositionSupport(blockName) || isDisabled;
}
function PositionPanelPure({
  style = {},
  clientId,
  name: blockName,
  setAttributes
}) {
  const allowFixed = hasFixedPositionSupport(blockName);
  const allowSticky = hasStickyPositionSupport(blockName);
  const value = style?.position?.type;
  const { firstParentClientId } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockParents } = select(store);
      const parents = getBlockParents(clientId);
      return { firstParentClientId: parents[parents.length - 1] };
    },
    [clientId]
  );
  const blockInformation = useBlockDisplayInformation(firstParentClientId);
  const stickyHelpText = allowSticky && value === STICKY_OPTION.value && blockInformation ? (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: the name of the parent block. */
    (0,external_wp_i18n_namespaceObject.__)(
      "The block will stick to the scrollable area of the parent %s block."
    ),
    blockInformation.title
  ) : null;
  const options = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const availableOptions = [DEFAULT_OPTION];
    if (allowSticky || value === STICKY_OPTION.value) {
      availableOptions.push(STICKY_OPTION);
    }
    if (allowFixed || value === FIXED_OPTION.value) {
      availableOptions.push(FIXED_OPTION);
    }
    return availableOptions;
  }, [allowFixed, allowSticky, value]);
  const onChangeType = (next) => {
    const placementValue = "0px";
    const newStyle = {
      ...style,
      position: {
        ...style?.position,
        type: next,
        top: next === "sticky" || next === "fixed" ? placementValue : void 0
      }
    };
    setAttributes({
      style: utils_cleanEmptyObject(newStyle)
    });
  };
  const selectedOption = value ? options.find((option) => option.value === value) || DEFAULT_OPTION : DEFAULT_OPTION;
  return external_wp_element_namespaceObject.Platform.select({
    web: options.length > 1 ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "position", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.BaseControl,
      {
        __nextHasNoMarginBottom: true,
        help: stickyHelpText,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.CustomSelectControl,
          {
            __next40pxDefaultSize: true,
            label: (0,external_wp_i18n_namespaceObject.__)("Position"),
            hideLabelFromVision: true,
            describedBy: (0,external_wp_i18n_namespaceObject.sprintf)(
              // translators: %s: Currently selected position.
              (0,external_wp_i18n_namespaceObject.__)("Currently selected position: %s"),
              selectedOption.name
            ),
            options,
            value: selectedOption,
            onChange: ({ selectedItem }) => {
              onChangeType(selectedItem.value);
            },
            size: "__unstable-large"
          }
        )
      }
    ) }) : null,
    native: null
  });
}
var position_default = {
  edit: function Edit(props) {
    const isPositionDisabled = useIsPositionDisabled(props);
    if (isPositionDisabled) {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PositionPanelPure, { ...props });
  },
  useBlockProps: position_useBlockProps,
  attributeKeys: ["style"],
  hasSupport(name) {
    return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, POSITION_SUPPORT_KEY);
  }
};
const POSITION_BLOCK_PROPS_REFERENCE = {};
function position_useBlockProps({ name, style }) {
  const hasPositionBlockSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
    name,
    POSITION_SUPPORT_KEY
  );
  const isPositionDisabled = useIsPositionDisabled({ name });
  const allowPositionStyles = hasPositionBlockSupport && !isPositionDisabled;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(POSITION_BLOCK_PROPS_REFERENCE);
  const positionSelector = `.wp-container-${id}.wp-container-${id}`;
  let css;
  if (allowPositionStyles) {
    css = getPositionCSS({
      selector: positionSelector,
      style
    }) || "";
  }
  const className = dist_clsx({
    [`wp-container-${id}`]: allowPositionStyles && !!css,
    // Only attach a container class if there is generated CSS to be attached.
    [`is-position-${style?.position?.type}`]: allowPositionStyles && !!css && !!style?.position?.type
  });
  useStyleOverride({ css });
  return { className };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/use-global-styles-output.js

















const ELEMENT_CLASS_NAMES = {
  button: "wp-element-button",
  caption: "wp-element-caption"
};
const BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS = {
  __experimentalBorder: "border",
  color: "color",
  spacing: "spacing",
  typography: "typography"
};
const { kebabCase: use_global_styles_output_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
function getPresetsDeclarations(blockPresets = {}, mergedSettings) {
  return PRESET_METADATA.reduce(
    (declarations, { path, valueKey, valueFunc, cssVarInfix }) => {
      const presetByOrigin = getValueFromObjectPath(
        blockPresets,
        path,
        []
      );
      ["default", "theme", "custom"].forEach((origin) => {
        if (presetByOrigin[origin]) {
          presetByOrigin[origin].forEach((value) => {
            if (valueKey && !valueFunc) {
              declarations.push(
                `--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(
                  value.slug
                )}: ${value[valueKey]}`
              );
            } else if (valueFunc && typeof valueFunc === "function") {
              declarations.push(
                `--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(
                  value.slug
                )}: ${valueFunc(value, mergedSettings)}`
              );
            }
          });
        }
      });
      return declarations;
    },
    []
  );
}
function getPresetsClasses(blockSelector = "*", blockPresets = {}) {
  return PRESET_METADATA.reduce(
    (declarations, { path, cssVarInfix, classes }) => {
      if (!classes) {
        return declarations;
      }
      const presetByOrigin = getValueFromObjectPath(
        blockPresets,
        path,
        []
      );
      ["default", "theme", "custom"].forEach((origin) => {
        if (presetByOrigin[origin]) {
          presetByOrigin[origin].forEach(({ slug }) => {
            classes.forEach(({ classSuffix, propertyName }) => {
              const classSelectorToUse = `.has-${use_global_styles_output_kebabCase(
                slug
              )}-${classSuffix}`;
              const selectorToUse = blockSelector.split(",").map(
                (selector) => `${selector}${classSelectorToUse}`
              ).join(",");
              const value = `var(--wp--preset--${cssVarInfix}--${use_global_styles_output_kebabCase(
                slug
              )})`;
              declarations += `${selectorToUse}{${propertyName}: ${value} !important;}`;
            });
          });
        }
      });
      return declarations;
    },
    ""
  );
}
function getPresetsSvgFilters(blockPresets = {}) {
  return PRESET_METADATA.filter(
    // Duotone are the only type of filters for now.
    (metadata) => metadata.path.at(-1) === "duotone"
  ).flatMap((metadata) => {
    const presetByOrigin = getValueFromObjectPath(
      blockPresets,
      metadata.path,
      {}
    );
    return ["default", "theme"].filter((origin) => presetByOrigin[origin]).flatMap(
      (origin) => presetByOrigin[origin].map(
        (preset) => getDuotoneFilter(
          `wp-duotone-${preset.slug}`,
          preset.colors
        )
      )
    ).join("");
  });
}
function flattenTree(input = {}, prefix, token) {
  let result = [];
  Object.keys(input).forEach((key) => {
    const newKey = prefix + use_global_styles_output_kebabCase(key.replace("/", "-"));
    const newLeaf = input[key];
    if (newLeaf instanceof Object) {
      const newPrefix = newKey + token;
      result = [...result, ...flattenTree(newLeaf, newPrefix, token)];
    } else {
      result.push(`${newKey}: ${newLeaf}`);
    }
  });
  return result;
}
function concatFeatureVariationSelectorString(featureSelector, styleVariationSelector) {
  const featureSelectors = featureSelector.split(",");
  const combinedSelectors = [];
  featureSelectors.forEach((selector) => {
    combinedSelectors.push(
      `${styleVariationSelector.trim()}${selector.trim()}`
    );
  });
  return combinedSelectors.join(", ");
}
const getFeatureDeclarations = (selectors, styles) => {
  const declarations = {};
  Object.entries(selectors).forEach(([feature, selector]) => {
    if (feature === "root" || !styles?.[feature]) {
      return;
    }
    const isShorthand = typeof selector === "string";
    if (!isShorthand) {
      Object.entries(selector).forEach(
        ([subfeature, subfeatureSelector]) => {
          if (subfeature === "root" || !styles?.[feature][subfeature]) {
            return;
          }
          const subfeatureStyles = {
            [feature]: {
              [subfeature]: styles[feature][subfeature]
            }
          };
          const newDeclarations = getStylesDeclarations(subfeatureStyles);
          declarations[subfeatureSelector] = [
            ...declarations[subfeatureSelector] || [],
            ...newDeclarations
          ];
          delete styles[feature][subfeature];
        }
      );
    }
    if (isShorthand || selector.root) {
      const featureSelector = isShorthand ? selector : selector.root;
      const featureStyles = { [feature]: styles[feature] };
      const newDeclarations = getStylesDeclarations(featureStyles);
      declarations[featureSelector] = [
        ...declarations[featureSelector] || [],
        ...newDeclarations
      ];
      delete styles[feature];
    }
  });
  return declarations;
};
function getStylesDeclarations(blockStyles = {}, selector = "", useRootPaddingAlign, tree = {}, disableRootPadding = false) {
  const isRoot = ROOT_BLOCK_SELECTOR === selector;
  const output = Object.entries(external_wp_blocks_namespaceObject.__EXPERIMENTAL_STYLE_PROPERTY).reduce(
    (declarations, [key, { value, properties, useEngine, rootOnly }]) => {
      if (rootOnly && !isRoot) {
        return declarations;
      }
      const pathToValue = value;
      if (pathToValue[0] === "elements" || useEngine) {
        return declarations;
      }
      const styleValue = getValueFromObjectPath(
        blockStyles,
        pathToValue
      );
      if (key === "--wp--style--root--padding" && (typeof styleValue === "string" || !useRootPaddingAlign)) {
        return declarations;
      }
      if (properties && typeof styleValue !== "string") {
        Object.entries(properties).forEach((entry) => {
          const [name, prop] = entry;
          if (!getValueFromObjectPath(styleValue, [prop], false)) {
            return;
          }
          const cssProperty = name.startsWith("--") ? name : use_global_styles_output_kebabCase(name);
          declarations.push(
            `${cssProperty}: ${(0,external_wp_styleEngine_namespaceObject.getCSSValueFromRawStyle)(
              getValueFromObjectPath(styleValue, [prop])
            )}`
          );
        });
      } else if (getValueFromObjectPath(blockStyles, pathToValue, false)) {
        const cssProperty = key.startsWith("--") ? key : use_global_styles_output_kebabCase(key);
        declarations.push(
          `${cssProperty}: ${(0,external_wp_styleEngine_namespaceObject.getCSSValueFromRawStyle)(
            getValueFromObjectPath(blockStyles, pathToValue)
          )}`
        );
      }
      return declarations;
    },
    []
  );
  if (!!blockStyles.background) {
    if (blockStyles.background?.backgroundImage) {
      blockStyles.background.backgroundImage = getResolvedValue(
        blockStyles.background.backgroundImage,
        tree
      );
    }
    if (!isRoot && !!blockStyles.background?.backgroundImage?.id) {
      blockStyles = {
        ...blockStyles,
        background: {
          ...blockStyles.background,
          ...setBackgroundStyleDefaults(blockStyles.background)
        }
      };
    }
  }
  const extraRules = (0,external_wp_styleEngine_namespaceObject.getCSSRules)(blockStyles);
  extraRules.forEach((rule) => {
    if (isRoot && (useRootPaddingAlign || disableRootPadding) && rule.key.startsWith("padding")) {
      return;
    }
    const cssProperty = rule.key.startsWith("--") ? rule.key : use_global_styles_output_kebabCase(rule.key);
    let ruleValue = getResolvedValue(rule.value, tree, null);
    if (cssProperty === "font-size") {
      ruleValue = getTypographyFontSizeValue(
        { size: ruleValue },
        tree?.settings
      );
    }
    if (cssProperty === "aspect-ratio") {
      output.push("min-height: unset");
    }
    output.push(`${cssProperty}: ${ruleValue}`);
  });
  return output;
}
function getLayoutStyles({
  layoutDefinitions = LAYOUT_DEFINITIONS,
  style,
  selector,
  hasBlockGapSupport,
  hasFallbackGapSupport,
  fallbackGapValue
}) {
  let ruleset = "";
  let gapValue = hasBlockGapSupport ? getGapCSSValue(style?.spacing?.blockGap) : "";
  if (hasFallbackGapSupport) {
    if (selector === ROOT_BLOCK_SELECTOR) {
      gapValue = !gapValue ? "0.5em" : gapValue;
    } else if (!hasBlockGapSupport && fallbackGapValue) {
      gapValue = fallbackGapValue;
    }
  }
  if (gapValue && layoutDefinitions) {
    Object.values(layoutDefinitions).forEach(
      ({ className, name, spacingStyles }) => {
        if (!hasBlockGapSupport && "flex" !== name && "grid" !== name) {
          return;
        }
        if (spacingStyles?.length) {
          spacingStyles.forEach((spacingStyle) => {
            const declarations = [];
            if (spacingStyle.rules) {
              Object.entries(spacingStyle.rules).forEach(
                ([cssProperty, cssValue]) => {
                  declarations.push(
                    `${cssProperty}: ${cssValue ? cssValue : gapValue}`
                  );
                }
              );
            }
            if (declarations.length) {
              let combinedSelector = "";
              if (!hasBlockGapSupport) {
                combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:where(.${className}${spacingStyle?.selector || ""})` : `:where(${selector}.${className}${spacingStyle?.selector || ""})`;
              } else {
                combinedSelector = selector === ROOT_BLOCK_SELECTOR ? `:root :where(.${className})${spacingStyle?.selector || ""}` : `:root :where(${selector}-${className})${spacingStyle?.selector || ""}`;
              }
              ruleset += `${combinedSelector} { ${declarations.join(
                "; "
              )}; }`;
            }
          });
        }
      }
    );
    if (selector === ROOT_BLOCK_SELECTOR && hasBlockGapSupport) {
      ruleset += `${ROOT_CSS_PROPERTIES_SELECTOR} { --wp--style--block-gap: ${gapValue}; }`;
    }
  }
  if (selector === ROOT_BLOCK_SELECTOR && layoutDefinitions) {
    const validDisplayModes = ["block", "flex", "grid"];
    Object.values(layoutDefinitions).forEach(
      ({ className, displayMode, baseStyles }) => {
        if (displayMode && validDisplayModes.includes(displayMode)) {
          ruleset += `${selector} .${className} { display:${displayMode}; }`;
        }
        if (baseStyles?.length) {
          baseStyles.forEach((baseStyle) => {
            const declarations = [];
            if (baseStyle.rules) {
              Object.entries(baseStyle.rules).forEach(
                ([cssProperty, cssValue]) => {
                  declarations.push(
                    `${cssProperty}: ${cssValue}`
                  );
                }
              );
            }
            if (declarations.length) {
              const combinedSelector = `.${className}${baseStyle?.selector || ""}`;
              ruleset += `${combinedSelector} { ${declarations.join(
                "; "
              )}; }`;
            }
          });
        }
      }
    );
  }
  return ruleset;
}
const STYLE_KEYS = [
  "border",
  "color",
  "dimensions",
  "spacing",
  "typography",
  "filter",
  "outline",
  "shadow",
  "background"
];
function pickStyleKeys(treeToPickFrom) {
  if (!treeToPickFrom) {
    return {};
  }
  const entries = Object.entries(treeToPickFrom);
  const pickedEntries = entries.filter(
    ([key]) => STYLE_KEYS.includes(key)
  );
  const clonedEntries = pickedEntries.map(([key, style]) => [
    key,
    JSON.parse(JSON.stringify(style))
  ]);
  return Object.fromEntries(clonedEntries);
}
const getNodesWithStyles = (tree, blockSelectors) => {
  const nodes = [];
  if (!tree?.styles) {
    return nodes;
  }
  const styles = pickStyleKeys(tree.styles);
  if (styles) {
    nodes.push({
      styles,
      selector: ROOT_BLOCK_SELECTOR,
      // Root selector (body) styles should not be wrapped in `:root where()` to keep
      // specificity at (0,0,1) and maintain backwards compatibility.
      skipSelectorWrapper: true
    });
  }
  Object.entries(external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS).forEach(([name, selector]) => {
    if (tree.styles?.elements?.[name]) {
      nodes.push({
        styles: tree.styles?.elements?.[name],
        selector,
        // Top level elements that don't use a class name should not receive the
        // `:root :where()` wrapper to maintain backwards compatibility.
        skipSelectorWrapper: !ELEMENT_CLASS_NAMES[name]
      });
    }
  });
  Object.entries(tree.styles?.blocks ?? {}).forEach(
    ([blockName, node]) => {
      const blockStyles = pickStyleKeys(node);
      if (node?.variations) {
        const variations = {};
        Object.entries(node.variations).forEach(
          ([variationName, variation]) => {
            variations[variationName] = pickStyleKeys(variation);
            if (variation?.css) {
              variations[variationName].css = variation.css;
            }
            const variationSelector = blockSelectors[blockName]?.styleVariationSelectors?.[variationName];
            Object.entries(variation?.elements ?? {}).forEach(
              ([element, elementStyles]) => {
                if (elementStyles && external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[element]) {
                  nodes.push({
                    styles: elementStyles,
                    selector: scopeSelector(
                      variationSelector,
                      external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[element]
                    )
                  });
                }
              }
            );
            Object.entries(variation?.blocks ?? {}).forEach(
              ([
                variationBlockName,
                variationBlockStyles
              ]) => {
                const variationBlockSelector = scopeSelector(
                  variationSelector,
                  blockSelectors[variationBlockName]?.selector
                );
                const variationDuotoneSelector = scopeSelector(
                  variationSelector,
                  blockSelectors[variationBlockName]?.duotoneSelector
                );
                const variationFeatureSelectors = scopeFeatureSelectors(
                  variationSelector,
                  blockSelectors[variationBlockName]?.featureSelectors
                );
                const variationBlockStyleNodes = pickStyleKeys(variationBlockStyles);
                if (variationBlockStyles?.css) {
                  variationBlockStyleNodes.css = variationBlockStyles.css;
                }
                nodes.push({
                  selector: variationBlockSelector,
                  duotoneSelector: variationDuotoneSelector,
                  featureSelectors: variationFeatureSelectors,
                  fallbackGapValue: blockSelectors[variationBlockName]?.fallbackGapValue,
                  hasLayoutSupport: blockSelectors[variationBlockName]?.hasLayoutSupport,
                  styles: variationBlockStyleNodes
                });
                Object.entries(
                  variationBlockStyles.elements ?? {}
                ).forEach(
                  ([
                    variationBlockElement,
                    variationBlockElementStyles
                  ]) => {
                    if (variationBlockElementStyles && external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[variationBlockElement]) {
                      nodes.push({
                        styles: variationBlockElementStyles,
                        selector: scopeSelector(
                          variationBlockSelector,
                          external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[variationBlockElement]
                        )
                      });
                    }
                  }
                );
              }
            );
          }
        );
        blockStyles.variations = variations;
      }
      if (blockSelectors?.[blockName]?.selector) {
        nodes.push({
          duotoneSelector: blockSelectors[blockName].duotoneSelector,
          fallbackGapValue: blockSelectors[blockName].fallbackGapValue,
          hasLayoutSupport: blockSelectors[blockName].hasLayoutSupport,
          selector: blockSelectors[blockName].selector,
          styles: blockStyles,
          featureSelectors: blockSelectors[blockName].featureSelectors,
          styleVariationSelectors: blockSelectors[blockName].styleVariationSelectors
        });
      }
      Object.entries(node?.elements ?? {}).forEach(
        ([elementName, value]) => {
          if (value && blockSelectors?.[blockName] && external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementName]) {
            nodes.push({
              styles: value,
              selector: blockSelectors[blockName]?.selector.split(",").map((sel) => {
                const elementSelectors = external_wp_blocks_namespaceObject.__EXPERIMENTAL_ELEMENTS[elementName].split(",");
                return elementSelectors.map(
                  (elementSelector) => sel + " " + elementSelector
                );
              }).join(",")
            });
          }
        }
      );
    }
  );
  return nodes;
};
const getNodesWithSettings = (tree, blockSelectors) => {
  const nodes = [];
  if (!tree?.settings) {
    return nodes;
  }
  const pickPresets = (treeToPickFrom) => {
    let presets2 = {};
    PRESET_METADATA.forEach(({ path }) => {
      const value = getValueFromObjectPath(treeToPickFrom, path, false);
      if (value !== false) {
        presets2 = setImmutably(presets2, path, value);
      }
    });
    return presets2;
  };
  const presets = pickPresets(tree.settings);
  const custom = tree.settings?.custom;
  if (Object.keys(presets).length > 0 || custom) {
    nodes.push({
      presets,
      custom,
      selector: ROOT_CSS_PROPERTIES_SELECTOR
    });
  }
  Object.entries(tree.settings?.blocks ?? {}).forEach(
    ([blockName, node]) => {
      const blockPresets = pickPresets(node);
      const blockCustom = node.custom;
      if (Object.keys(blockPresets).length > 0 || blockCustom) {
        nodes.push({
          presets: blockPresets,
          custom: blockCustom,
          selector: blockSelectors[blockName]?.selector
        });
      }
    }
  );
  return nodes;
};
const toCustomProperties = (tree, blockSelectors) => {
  const settings = getNodesWithSettings(tree, blockSelectors);
  let ruleset = "";
  settings.forEach(({ presets, custom, selector }) => {
    const declarations = getPresetsDeclarations(presets, tree?.settings);
    const customProps = flattenTree(custom, "--wp--custom--", "--");
    if (customProps.length > 0) {
      declarations.push(...customProps);
    }
    if (declarations.length > 0) {
      ruleset += `${selector}{${declarations.join(";")};}`;
    }
  });
  return ruleset;
};
const toStyles = (tree, blockSelectors, hasBlockGapSupport, hasFallbackGapSupport, disableLayoutStyles = false, disableRootPadding = false, styleOptions = void 0) => {
  const options = {
    blockGap: true,
    blockStyles: true,
    layoutStyles: true,
    marginReset: true,
    presets: true,
    rootPadding: true,
    variationStyles: false,
    ...styleOptions
  };
  const nodesWithStyles = getNodesWithStyles(tree, blockSelectors);
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  const useRootPaddingAlign = tree?.settings?.useRootPaddingAwareAlignments;
  const { contentSize, wideSize } = tree?.settings?.layout || {};
  const hasBodyStyles = options.marginReset || options.rootPadding || options.layoutStyles;
  let ruleset = "";
  if (options.presets && (contentSize || wideSize)) {
    ruleset += `${ROOT_CSS_PROPERTIES_SELECTOR} {`;
    ruleset = contentSize ? ruleset + ` --wp--style--global--content-size: ${contentSize};` : ruleset;
    ruleset = wideSize ? ruleset + ` --wp--style--global--wide-size: ${wideSize};` : ruleset;
    ruleset += "}";
  }
  if (hasBodyStyles) {
    ruleset += ":where(body) {margin: 0;";
    if (options.rootPadding && useRootPaddingAlign) {
      ruleset += `padding-right: 0; padding-left: 0; padding-top: var(--wp--style--root--padding-top); padding-bottom: var(--wp--style--root--padding-bottom) }
				.has-global-padding { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }
				.has-global-padding > .alignfull { margin-right: calc(var(--wp--style--root--padding-right) * -1); margin-left: calc(var(--wp--style--root--padding-left) * -1); }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) { padding-right: 0; padding-left: 0; }
				.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) > .alignfull { margin-left: 0; margin-right: 0;
				`;
    }
    ruleset += "}";
  }
  if (options.blockStyles) {
    nodesWithStyles.forEach(
      ({
        selector,
        duotoneSelector,
        styles,
        fallbackGapValue,
        hasLayoutSupport,
        featureSelectors,
        styleVariationSelectors,
        skipSelectorWrapper
      }) => {
        if (featureSelectors) {
          const featureDeclarations = getFeatureDeclarations(
            featureSelectors,
            styles
          );
          Object.entries(featureDeclarations).forEach(
            ([cssSelector, declarations]) => {
              if (declarations.length) {
                const rules = declarations.join(";");
                ruleset += `:root :where(${cssSelector}){${rules};}`;
              }
            }
          );
        }
        if (duotoneSelector) {
          const duotoneStyles = {};
          if (styles?.filter) {
            duotoneStyles.filter = styles.filter;
            delete styles.filter;
          }
          const duotoneDeclarations = getStylesDeclarations(duotoneStyles);
          if (duotoneDeclarations.length) {
            ruleset += `${duotoneSelector}{${duotoneDeclarations.join(
              ";"
            )};}`;
          }
        }
        if (!disableLayoutStyles && (ROOT_BLOCK_SELECTOR === selector || hasLayoutSupport)) {
          ruleset += getLayoutStyles({
            style: styles,
            selector,
            hasBlockGapSupport,
            hasFallbackGapSupport,
            fallbackGapValue
          });
        }
        const styleDeclarations = getStylesDeclarations(
          styles,
          selector,
          useRootPaddingAlign,
          tree,
          disableRootPadding
        );
        if (styleDeclarations?.length) {
          const generalSelector = skipSelectorWrapper ? selector : `:root :where(${selector})`;
          ruleset += `${generalSelector}{${styleDeclarations.join(
            ";"
          )};}`;
        }
        if (styles?.css) {
          ruleset += processCSSNesting(
            styles.css,
            `:root :where(${selector})`
          );
        }
        if (options.variationStyles && styleVariationSelectors) {
          Object.entries(styleVariationSelectors).forEach(
            ([styleVariationName, styleVariationSelector]) => {
              const styleVariations = styles?.variations?.[styleVariationName];
              if (styleVariations) {
                if (featureSelectors) {
                  const featureDeclarations = getFeatureDeclarations(
                    featureSelectors,
                    styleVariations
                  );
                  Object.entries(
                    featureDeclarations
                  ).forEach(
                    ([baseSelector, declarations]) => {
                      if (declarations.length) {
                        const cssSelector = concatFeatureVariationSelectorString(
                          baseSelector,
                          styleVariationSelector
                        );
                        const rules = declarations.join(";");
                        ruleset += `:root :where(${cssSelector}){${rules};}`;
                      }
                    }
                  );
                }
                const styleVariationDeclarations = getStylesDeclarations(
                  styleVariations,
                  styleVariationSelector,
                  useRootPaddingAlign,
                  tree
                );
                if (styleVariationDeclarations.length) {
                  ruleset += `:root :where(${styleVariationSelector}){${styleVariationDeclarations.join(
                    ";"
                  )};}`;
                }
                if (styleVariations?.css) {
                  ruleset += processCSSNesting(
                    styleVariations.css,
                    `:root :where(${styleVariationSelector})`
                  );
                }
              }
            }
          );
        }
        const pseudoSelectorStyles = Object.entries(styles).filter(
          ([key]) => key.startsWith(":")
        );
        if (pseudoSelectorStyles?.length) {
          pseudoSelectorStyles.forEach(
            ([pseudoKey, pseudoStyle]) => {
              const pseudoDeclarations = getStylesDeclarations(pseudoStyle);
              if (!pseudoDeclarations?.length) {
                return;
              }
              const _selector = selector.split(",").map((sel) => sel + pseudoKey).join(",");
              const pseudoRule = `:root :where(${_selector}){${pseudoDeclarations.join(
                ";"
              )};}`;
              ruleset += pseudoRule;
            }
          );
        }
      }
    );
  }
  if (options.layoutStyles) {
    ruleset = ruleset + ".wp-site-blocks > .alignleft { float: left; margin-right: 2em; }";
    ruleset = ruleset + ".wp-site-blocks > .alignright { float: right; margin-left: 2em; }";
    ruleset = ruleset + ".wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }";
  }
  if (options.blockGap && hasBlockGapSupport) {
    const gapValue = getGapCSSValue(tree?.styles?.spacing?.blockGap) || "0.5em";
    ruleset = ruleset + `:root :where(.wp-site-blocks) > * { margin-block-start: ${gapValue}; margin-block-end: 0; }`;
    ruleset = ruleset + ":root :where(.wp-site-blocks) > :first-child { margin-block-start: 0; }";
    ruleset = ruleset + ":root :where(.wp-site-blocks) > :last-child { margin-block-end: 0; }";
  }
  if (options.presets) {
    nodesWithSettings.forEach(({ selector, presets }) => {
      if (ROOT_BLOCK_SELECTOR === selector || ROOT_CSS_PROPERTIES_SELECTOR === selector) {
        selector = "";
      }
      const classes = getPresetsClasses(selector, presets);
      if (classes.length > 0) {
        ruleset += classes;
      }
    });
  }
  return ruleset;
};
function toSvgFilters(tree, blockSelectors) {
  const nodesWithSettings = getNodesWithSettings(tree, blockSelectors);
  return nodesWithSettings.flatMap(({ presets }) => {
    return getPresetsSvgFilters(presets);
  });
}
const getSelectorsConfig = (blockType, rootSelector) => {
  if (blockType?.selectors && Object.keys(blockType.selectors).length > 0) {
    return blockType.selectors;
  }
  const config = { root: rootSelector };
  Object.entries(BLOCK_SUPPORT_FEATURE_LEVEL_SELECTORS).forEach(
    ([featureKey, featureName]) => {
      const featureSelector = getBlockCSSSelector(
        blockType,
        featureKey
      );
      if (featureSelector) {
        config[featureName] = featureSelector;
      }
    }
  );
  return config;
};
const getBlockSelectors = (blockTypes, getBlockStyles, variationInstanceId) => {
  const result = {};
  blockTypes.forEach((blockType) => {
    const name = blockType.name;
    const selector = getBlockCSSSelector(blockType);
    let duotoneSelector = getBlockCSSSelector(
      blockType,
      "filter.duotone"
    );
    if (!duotoneSelector) {
      const rootSelector = getBlockCSSSelector(blockType);
      const duotoneSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(
        blockType,
        "color.__experimentalDuotone",
        false
      );
      duotoneSelector = duotoneSupport && scopeSelector(rootSelector, duotoneSupport);
    }
    const hasLayoutSupport = !!blockType?.supports?.layout || !!blockType?.supports?.__experimentalLayout;
    const fallbackGapValue = blockType?.supports?.spacing?.blockGap?.__experimentalDefault;
    const blockStyleVariations = getBlockStyles(name);
    const styleVariationSelectors = {};
    blockStyleVariations?.forEach((variation) => {
      const variationSuffix = variationInstanceId ? `-${variationInstanceId}` : "";
      const variationName = `${variation.name}${variationSuffix}`;
      const styleVariationSelector = getBlockStyleVariationSelector(
        variationName,
        selector
      );
      styleVariationSelectors[variationName] = styleVariationSelector;
    });
    const featureSelectors = getSelectorsConfig(blockType, selector);
    result[name] = {
      duotoneSelector,
      fallbackGapValue,
      featureSelectors: Object.keys(featureSelectors).length ? featureSelectors : void 0,
      hasLayoutSupport,
      name,
      selector,
      styleVariationSelectors: blockStyleVariations?.length ? styleVariationSelectors : void 0
    };
  });
  return result;
};
function updateConfigWithSeparator(config) {
  const needsSeparatorStyleUpdate = config.styles?.blocks?.["core/separator"] && config.styles?.blocks?.["core/separator"].color?.background && !config.styles?.blocks?.["core/separator"].color?.text && !config.styles?.blocks?.["core/separator"].border?.color;
  if (needsSeparatorStyleUpdate) {
    return {
      ...config,
      styles: {
        ...config.styles,
        blocks: {
          ...config.styles.blocks,
          "core/separator": {
            ...config.styles.blocks["core/separator"],
            color: {
              ...config.styles.blocks["core/separator"].color,
              text: config.styles?.blocks["core/separator"].color.background
            }
          }
        }
      }
    };
  }
  return config;
}
function processCSSNesting(css, blockSelector) {
  let processedCSS = "";
  if (!css || css.trim() === "") {
    return processedCSS;
  }
  const parts = css.split("&");
  parts.forEach((part) => {
    if (!part || part.trim() === "") {
      return;
    }
    const isRootCss = !part.includes("{");
    if (isRootCss) {
      processedCSS += `:root :where(${blockSelector}){${part.trim()}}`;
    } else {
      const splitPart = part.replace("}", "").split("{");
      if (splitPart.length !== 2) {
        return;
      }
      const [nestedSelector, cssValue] = splitPart;
      const matches = nestedSelector.match(/([>+~\s]*::[a-zA-Z-]+)/);
      const pseudoPart = matches ? matches[1] : "";
      const withoutPseudoElement = matches ? nestedSelector.replace(pseudoPart, "").trim() : nestedSelector.trim();
      let combinedSelector;
      if (withoutPseudoElement === "") {
        combinedSelector = blockSelector;
      } else {
        combinedSelector = nestedSelector.startsWith(" ") ? scopeSelector(blockSelector, withoutPseudoElement) : appendToSelector(blockSelector, withoutPseudoElement);
      }
      processedCSS += `:root :where(${combinedSelector})${pseudoPart}{${cssValue.trim()}}`;
    }
  });
  return processedCSS;
}
function useGlobalStylesOutputWithConfig(mergedConfig = {}, disableRootPadding) {
  const [blockGap] = useGlobalSetting("spacing.blockGap");
  const hasBlockGapSupport = blockGap !== null;
  const hasFallbackGapSupport = !hasBlockGapSupport;
  const disableLayoutStyles = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    return !!getSettings().disableLayoutStyles;
  });
  const { getBlockStyles } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!mergedConfig?.styles || !mergedConfig?.settings) {
      return [];
    }
    const updatedConfig = updateConfigWithSeparator(mergedConfig);
    const blockSelectors = getBlockSelectors(
      (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
      getBlockStyles
    );
    const customProperties = toCustomProperties(
      updatedConfig,
      blockSelectors
    );
    const globalStyles = toStyles(
      updatedConfig,
      blockSelectors,
      hasBlockGapSupport,
      hasFallbackGapSupport,
      disableLayoutStyles,
      disableRootPadding
    );
    const svgs = toSvgFilters(updatedConfig, blockSelectors);
    const styles = [
      {
        css: customProperties,
        isGlobalStyles: true
      },
      {
        css: globalStyles,
        isGlobalStyles: true
      },
      // Load custom CSS in own stylesheet so that any invalid CSS entered in the input won't break all the global styles in the editor.
      {
        css: updatedConfig.styles.css ?? "",
        isGlobalStyles: true
      },
      {
        assets: svgs,
        __unstableType: "svg",
        isGlobalStyles: true
      }
    ];
    (0,external_wp_blocks_namespaceObject.getBlockTypes)().forEach((blockType) => {
      if (updatedConfig.styles.blocks[blockType.name]?.css) {
        const selector = blockSelectors[blockType.name].selector;
        styles.push({
          css: processCSSNesting(
            updatedConfig.styles.blocks[blockType.name]?.css,
            selector
          ),
          isGlobalStyles: true
        });
      }
    });
    return [styles, updatedConfig.settings];
  }, [
    hasBlockGapSupport,
    hasFallbackGapSupport,
    mergedConfig,
    disableLayoutStyles,
    disableRootPadding,
    getBlockStyles
  ]);
}
function useGlobalStylesOutput(disableRootPadding = false) {
  const { merged: mergedConfig } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  return useGlobalStylesOutputWithConfig(mergedConfig, disableRootPadding);
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/block-style-variation.js










const VARIATION_PREFIX = "is-style-";
function getVariationMatches(className) {
  if (!className) {
    return [];
  }
  return className.split(/\s+/).reduce((matches, name) => {
    if (name.startsWith(VARIATION_PREFIX)) {
      const match = name.slice(VARIATION_PREFIX.length);
      if (match !== "default") {
        matches.push(match);
      }
    }
    return matches;
  }, []);
}
function getVariationNameFromClass(className, registeredStyles = []) {
  const matches = getVariationMatches(className);
  if (!matches) {
    return null;
  }
  for (const variation of matches) {
    if (registeredStyles.some((style) => style.name === variation)) {
      return variation;
    }
  }
  return null;
}
function OverrideStyles({ override }) {
  usePrivateStyleOverride(override);
}
function __unstableBlockStyleVariationOverridesWithConfig({ config }) {
  const { getBlockStyles, overrides } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => ({
      getBlockStyles: select(external_wp_blocks_namespaceObject.store).getBlockStyles,
      overrides: unlock(select(store)).getStyleOverrides()
    }),
    []
  );
  const { getBlockName } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const overridesWithConfig = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!overrides?.length) {
      return;
    }
    const newOverrides = [];
    const overriddenClientIds = [];
    for (const [, override] of overrides) {
      if (override?.variation && override?.clientId && /*
       * Because this component overwrites existing style overrides,
       * filter out any overrides that are already present in the store.
       */
      !overriddenClientIds.includes(override.clientId)) {
        const blockName = getBlockName(override.clientId);
        const configStyles = config?.styles?.blocks?.[blockName]?.variations?.[override.variation];
        if (configStyles) {
          const variationConfig = {
            settings: config?.settings,
            // The variation style data is all that is needed to generate
            // the styles for the current application to a block. The variation
            // name is updated to match the instance specific class name.
            styles: {
              blocks: {
                [blockName]: {
                  variations: {
                    [`${override.variation}-${override.clientId}`]: configStyles
                  }
                }
              }
            }
          };
          const blockSelectors = getBlockSelectors(
            (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
            getBlockStyles,
            override.clientId
          );
          const hasBlockGapSupport = false;
          const hasFallbackGapSupport = true;
          const disableLayoutStyles = true;
          const disableRootPadding = true;
          const variationStyles = toStyles(
            variationConfig,
            blockSelectors,
            hasBlockGapSupport,
            hasFallbackGapSupport,
            disableLayoutStyles,
            disableRootPadding,
            {
              blockGap: false,
              blockStyles: true,
              layoutStyles: false,
              marginReset: false,
              presets: false,
              rootPadding: false,
              variationStyles: true
            }
          );
          newOverrides.push({
            id: `${override.variation}-${override.clientId}`,
            css: variationStyles,
            __unstableType: "variation",
            variation: override.variation,
            // The clientId will be stored with the override and used to ensure
            // the order of overrides matches the order of blocks so that the
            // correct CSS cascade is maintained.
            clientId: override.clientId
          });
          overriddenClientIds.push(override.clientId);
        }
      }
    }
    return newOverrides;
  }, [config, overrides, getBlockStyles, getBlockName]);
  if (!overridesWithConfig || !overridesWithConfig.length) {
    return;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: overridesWithConfig.map((override) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(OverrideStyles, { override }, override.id)) });
}
function getVariationStylesWithRefValues(globalStyles, name, variation) {
  if (!globalStyles?.styles?.blocks?.[name]?.variations?.[variation]) {
    return;
  }
  const replaceRefs = (variationStyles) => {
    Object.keys(variationStyles).forEach((key) => {
      const value = variationStyles[key];
      if (typeof value === "object" && value !== null) {
        if (value.ref !== void 0) {
          if (typeof value.ref !== "string" || value.ref.trim() === "") {
            delete variationStyles[key];
          } else {
            const refValue = getValueFromObjectPath(
              globalStyles,
              value.ref
            );
            if (refValue) {
              variationStyles[key] = refValue;
            } else {
              delete variationStyles[key];
            }
          }
        } else {
          replaceRefs(value);
          if (Object.keys(value).length === 0) {
            delete variationStyles[key];
          }
        }
      }
    });
  };
  const styles = JSON.parse(
    JSON.stringify(
      globalStyles.styles.blocks[name].variations[variation]
    )
  );
  replaceRefs(styles);
  return styles;
}
function useBlockStyleVariation(name, variation, clientId) {
  const { merged: mergedConfig } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const { globalSettings, globalStyles } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const settings = select(store).getSettings();
    return {
      globalSettings: settings.__experimentalFeatures,
      globalStyles: settings[globalStylesDataKey]
    };
  }, []);
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const variationStyles = getVariationStylesWithRefValues(
      {
        settings: mergedConfig?.settings ?? globalSettings,
        styles: mergedConfig?.styles ?? globalStyles
      },
      name,
      variation
    );
    return {
      settings: mergedConfig?.settings ?? globalSettings,
      // The variation style data is all that is needed to generate
      // the styles for the current application to a block. The variation
      // name is updated to match the instance specific class name.
      styles: {
        blocks: {
          [name]: {
            variations: {
              [`${variation}-${clientId}`]: variationStyles
            }
          }
        }
      }
    };
  }, [
    mergedConfig,
    globalSettings,
    globalStyles,
    variation,
    clientId,
    name
  ]);
}
function block_style_variation_useBlockProps({ name, className, clientId }) {
  const { getBlockStyles } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const registeredStyles = getBlockStyles(name);
  const variation = getVariationNameFromClass(className, registeredStyles);
  const variationClass = `${VARIATION_PREFIX}${variation}-${clientId}`;
  const { settings, styles } = useBlockStyleVariation(
    name,
    variation,
    clientId
  );
  const variationStyles = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!variation) {
      return;
    }
    const variationConfig = { settings, styles };
    const blockSelectors = getBlockSelectors(
      (0,external_wp_blocks_namespaceObject.getBlockTypes)(),
      getBlockStyles,
      clientId
    );
    const hasBlockGapSupport = false;
    const hasFallbackGapSupport = true;
    const disableLayoutStyles = true;
    const disableRootPadding = true;
    return toStyles(
      variationConfig,
      blockSelectors,
      hasBlockGapSupport,
      hasFallbackGapSupport,
      disableLayoutStyles,
      disableRootPadding,
      {
        blockGap: false,
        blockStyles: true,
        layoutStyles: false,
        marginReset: false,
        presets: false,
        rootPadding: false,
        variationStyles: true
      }
    );
  }, [variation, settings, styles, getBlockStyles, clientId]);
  usePrivateStyleOverride({
    id: `variation-${clientId}`,
    css: variationStyles,
    __unstableType: "variation",
    variation,
    // The clientId will be stored with the override and used to ensure
    // the order of overrides matches the order of blocks so that the
    // correct CSS cascade is maintained.
    clientId
  });
  return variation ? { className: variationClass } : {};
}
var block_style_variation_default = {
  hasSupport: () => true,
  attributeKeys: ["className"],
  isMatch: ({ className }) => getVariationMatches(className).length > 0,
  useBlockProps: block_style_variation_useBlockProps
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/layout.js
















const layoutBlockSupportKey = "layout";
const { kebabCase: layout_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
function hasLayoutBlockSupport(blockName) {
  return (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "layout") || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "__experimentalLayout");
}
function useLayoutClasses(blockAttributes = {}, blockName = "") {
  const { layout } = blockAttributes;
  const { default: defaultBlockLayout } = (0,external_wp_blocks_namespaceObject.getBlockSupport)(blockName, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || defaultBlockLayout || {};
  const layoutClassnames = [];
  if (LAYOUT_DEFINITIONS[usedLayout?.type || "default"]?.className) {
    const baseClassName = LAYOUT_DEFINITIONS[usedLayout?.type || "default"]?.className;
    const splitBlockName = blockName.split("/");
    const fullBlockName = splitBlockName[0] === "core" ? splitBlockName.pop() : splitBlockName.join("-");
    const compoundClassName = `wp-block-${fullBlockName}-${baseClassName}`;
    layoutClassnames.push(baseClassName, compoundClassName);
  }
  const hasGlobalPadding = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return (usedLayout?.inherit || usedLayout?.contentSize || usedLayout?.type === "constrained") && select(store).getSettings().__experimentalFeatures?.useRootPaddingAwareAlignments;
    },
    [usedLayout?.contentSize, usedLayout?.inherit, usedLayout?.type]
  );
  if (hasGlobalPadding) {
    layoutClassnames.push("has-global-padding");
  }
  if (usedLayout?.orientation) {
    layoutClassnames.push(`is-${layout_kebabCase(usedLayout.orientation)}`);
  }
  if (usedLayout?.justifyContent) {
    layoutClassnames.push(
      `is-content-justification-${layout_kebabCase(
        usedLayout.justifyContent
      )}`
    );
  }
  if (usedLayout?.flexWrap && usedLayout.flexWrap === "nowrap") {
    layoutClassnames.push("is-nowrap");
  }
  return layoutClassnames;
}
function useLayoutStyles(blockAttributes = {}, blockName, selector) {
  const { layout = {}, style = {} } = blockAttributes;
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || {};
  const fullLayoutType = getLayoutType(usedLayout?.type || "default");
  const [blockGapSupport] = use_settings_useSettings("spacing.blockGap");
  const hasBlockGapSupport = blockGapSupport !== null;
  return fullLayoutType?.getLayoutStyle?.({
    blockName,
    selector,
    layout,
    style,
    hasBlockGapSupport
  });
}
function LayoutPanelPure({
  layout,
  setAttributes,
  name: blockName,
  clientId
}) {
  const settings = useBlockSettings(blockName);
  const { layout: layoutSettings } = settings;
  const { themeSupportsLayout } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    return {
      themeSupportsLayout: getSettings().supportsLayout
    };
  }, []);
  const blockEditingMode = useBlockEditingMode();
  if (blockEditingMode !== "default") {
    return null;
  }
  const layoutBlockSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(
    blockName,
    layoutBlockSupportKey,
    {}
  );
  const blockSupportAndThemeSettings = {
    ...layoutSettings,
    ...layoutBlockSupport
  };
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = blockSupportAndThemeSettings;
  if (!allowEditing) {
    return null;
  }
  const blockSupportAndLayout = {
    ...layoutBlockSupport,
    ...layout
  };
  const { type, default: { type: defaultType = "default" } = {} } = blockSupportAndLayout;
  const blockLayoutType = type || defaultType;
  const showInheritToggle = !!(allowInheriting && (!blockLayoutType || blockLayoutType === "default" || blockLayoutType === "constrained" || blockSupportAndLayout.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const { inherit = false, contentSize = null } = usedLayout;
  if ((blockLayoutType === "default" || blockLayoutType === "constrained") && !themeSupportsLayout) {
    return null;
  }
  const layoutType = getLayoutType(blockLayoutType);
  const constrainedType = getLayoutType("constrained");
  const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
  const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;
  const onChangeType = (newType) => setAttributes({ layout: { type: newType } });
  const onChangeLayout = (newLayout) => setAttributes({ layout: newLayout });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.PanelBody, { title: (0,external_wp_i18n_namespaceObject.__)("Layout"), children: [
      showInheritToggle && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ToggleControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Inner blocks use content width"),
          checked: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings,
          onChange: () => setAttributes({
            layout: {
              type: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings ? "default" : "constrained"
            }
          }),
          help: layoutType?.name === "constrained" || hasContentSizeOrLegacySettings ? (0,external_wp_i18n_namespaceObject.__)(
            "Nested blocks use content width with options for full and wide widths."
          ) : (0,external_wp_i18n_namespaceObject.__)(
            "Nested blocks will fill the width of this container."
          )
        }
      ) }),
      !inherit && allowSwitching && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        LayoutTypeSwitcher,
        {
          type: blockLayoutType,
          onChange: onChangeType
        }
      ),
      layoutType && layoutType.name !== "default" && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        layoutType.inspectorControls,
        {
          layout: usedLayout,
          onChange: onChangeLayout,
          layoutBlockSupport: blockSupportAndThemeSettings,
          name: blockName,
          clientId
        }
      ),
      constrainedType && displayControlsForLegacyLayouts && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        constrainedType.inspectorControls,
        {
          layout: usedLayout,
          onChange: onChangeLayout,
          layoutBlockSupport: blockSupportAndThemeSettings,
          name: blockName,
          clientId
        }
      )
    ] }) }),
    !inherit && layoutType && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      layoutType.toolBarControls,
      {
        layout: usedLayout,
        onChange: onChangeLayout,
        layoutBlockSupport,
        name: blockName,
        clientId
      }
    )
  ] });
}
var layout_default = {
  shareWithChildBlocks: true,
  edit: LayoutPanelPure,
  attributeKeys: ["layout"],
  hasSupport(name) {
    return hasLayoutBlockSupport(name);
  }
};
function LayoutTypeSwitcher({ type, onChange }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      __next40pxDefaultSize: true,
      isBlock: true,
      label: (0,external_wp_i18n_namespaceObject.__)("Layout type"),
      __nextHasNoMarginBottom: true,
      hideLabelFromVision: true,
      isAdaptiveWidth: true,
      value: type,
      onChange,
      children: getLayoutTypes().map(({ name, label }) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
          {
            value: name,
            label
          },
          name
        );
      })
    }
  );
}
function layout_addAttribute(settings) {
  if ("type" in (settings.attributes?.layout ?? {})) {
    return settings;
  }
  if (hasLayoutBlockSupport(settings)) {
    settings.attributes = {
      ...settings.attributes,
      layout: {
        type: "object"
      }
    };
  }
  return settings;
}
function BlockWithLayoutStyles({
  block: BlockListBlock,
  props,
  blockGapSupport,
  layoutClasses
}) {
  const { name, attributes } = props;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockListBlock);
  const { layout } = attributes;
  const { default: defaultBlockLayout } = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? { ...layout, type: "constrained" } : layout || defaultBlockLayout || {};
  const selectorPrefix = `wp-container-${layout_kebabCase(name)}-is-layout-`;
  const selector = `.${selectorPrefix}${id}`;
  const hasBlockGapSupport = blockGapSupport !== null;
  const fullLayoutType = getLayoutType(usedLayout?.type || "default");
  const css = fullLayoutType?.getLayoutStyle?.({
    blockName: name,
    selector,
    layout: usedLayout,
    style: attributes?.style,
    hasBlockGapSupport
  });
  const layoutClassNames = dist_clsx(
    {
      [`${selectorPrefix}${id}`]: !!css
      // Only attach a container class if there is generated CSS to be attached.
    },
    layoutClasses
  );
  useStyleOverride({ css });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockListBlock,
    {
      ...props,
      __unstableLayoutClassNames: layoutClassNames
    }
  );
}
const withLayoutStyles = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (BlockListBlock) => (props) => {
    const { clientId, name, attributes } = props;
    const blockSupportsLayout = hasLayoutBlockSupport(name);
    const layoutClasses = useLayoutClasses(attributes, name);
    const extraProps = (0,external_wp_data_namespaceObject.useSelect)(
      (select) => {
        if (!blockSupportsLayout) {
          return;
        }
        const { getSettings, getBlockSettings } = unlock(
          select(store)
        );
        const { disableLayoutStyles } = getSettings();
        if (disableLayoutStyles) {
          return;
        }
        const [blockGapSupport] = getBlockSettings(
          clientId,
          "spacing.blockGap"
        );
        return { blockGapSupport };
      },
      [blockSupportsLayout, clientId]
    );
    if (!extraProps) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockListBlock,
        {
          ...props,
          __unstableLayoutClassNames: blockSupportsLayout ? layoutClasses : void 0
        }
      );
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockWithLayoutStyles,
      {
        block: BlockListBlock,
        props,
        layoutClasses,
        ...extraProps
      }
    );
  },
  "withLayoutStyles"
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/layout/addAttribute",
  layout_addAttribute
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "editor.BlockListBlock",
  "core/editor/layout/with-layout-styles",
  withLayoutStyles
);


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/utils.js
function range(start, length) {
  return Array.from({ length }, (_, i) => start + i);
}
class GridRect {
  constructor({
    columnStart,
    rowStart,
    columnEnd,
    rowEnd,
    columnSpan,
    rowSpan
  } = {}) {
    this.columnStart = columnStart ?? 1;
    this.rowStart = rowStart ?? 1;
    if (columnSpan !== void 0) {
      this.columnEnd = this.columnStart + columnSpan - 1;
    } else {
      this.columnEnd = columnEnd ?? this.columnStart;
    }
    if (rowSpan !== void 0) {
      this.rowEnd = this.rowStart + rowSpan - 1;
    } else {
      this.rowEnd = rowEnd ?? this.rowStart;
    }
  }
  get columnSpan() {
    return this.columnEnd - this.columnStart + 1;
  }
  get rowSpan() {
    return this.rowEnd - this.rowStart + 1;
  }
  contains(column, row) {
    return column >= this.columnStart && column <= this.columnEnd && row >= this.rowStart && row <= this.rowEnd;
  }
  containsRect(rect) {
    return this.contains(rect.columnStart, rect.rowStart) && this.contains(rect.columnEnd, rect.rowEnd);
  }
  intersectsRect(rect) {
    return this.columnStart <= rect.columnEnd && this.columnEnd >= rect.columnStart && this.rowStart <= rect.rowEnd && this.rowEnd >= rect.rowStart;
  }
}
function utils_getComputedCSS(element, property) {
  return element.ownerDocument.defaultView.getComputedStyle(element).getPropertyValue(property);
}
function getGridTracks(template, gap) {
  const tracks = [];
  for (const size of template.split(" ")) {
    const previousTrack = tracks[tracks.length - 1];
    const start = previousTrack ? previousTrack.end + gap : 0;
    const end = start + parseFloat(size);
    tracks.push({ start, end });
  }
  return tracks;
}
function getClosestTrack(tracks, position, edge = "start") {
  return tracks.reduce(
    (closest, track, index) => Math.abs(track[edge] - position) < Math.abs(tracks[closest][edge] - position) ? index : closest,
    0
  );
}
function getGridRect(gridElement, rect) {
  const columnGap = parseFloat(utils_getComputedCSS(gridElement, "column-gap"));
  const rowGap = parseFloat(utils_getComputedCSS(gridElement, "row-gap"));
  const gridColumnTracks = getGridTracks(
    utils_getComputedCSS(gridElement, "grid-template-columns"),
    columnGap
  );
  const gridRowTracks = getGridTracks(
    utils_getComputedCSS(gridElement, "grid-template-rows"),
    rowGap
  );
  const columnStart = getClosestTrack(gridColumnTracks, rect.left) + 1;
  const rowStart = getClosestTrack(gridRowTracks, rect.top) + 1;
  const columnEnd = getClosestTrack(gridColumnTracks, rect.right, "end") + 1;
  const rowEnd = getClosestTrack(gridRowTracks, rect.bottom, "end") + 1;
  return new GridRect({
    columnStart,
    columnEnd,
    rowStart,
    rowEnd
  });
}
function getGridItemRect(gridItemElement) {
  return getGridRect(
    gridItemElement.parentElement,
    new window.DOMRect(
      gridItemElement.offsetLeft,
      gridItemElement.offsetTop,
      gridItemElement.offsetWidth,
      gridItemElement.offsetHeight
    )
  );
}
function getGridInfo(gridElement) {
  const gridTemplateColumns = utils_getComputedCSS(
    gridElement,
    "grid-template-columns"
  );
  const gridTemplateRows = utils_getComputedCSS(
    gridElement,
    "grid-template-rows"
  );
  const borderTopWidth = utils_getComputedCSS(gridElement, "border-top-width");
  const borderRightWidth = utils_getComputedCSS(
    gridElement,
    "border-right-width"
  );
  const borderBottomWidth = utils_getComputedCSS(
    gridElement,
    "border-bottom-width"
  );
  const borderLeftWidth = utils_getComputedCSS(gridElement, "border-left-width");
  const paddingTop = utils_getComputedCSS(gridElement, "padding-top");
  const paddingRight = utils_getComputedCSS(gridElement, "padding-right");
  const paddingBottom = utils_getComputedCSS(gridElement, "padding-bottom");
  const paddingLeft = utils_getComputedCSS(gridElement, "padding-left");
  const numColumns = gridTemplateColumns.split(" ").length;
  const numRows = gridTemplateRows.split(" ").length;
  const numItems = numColumns * numRows;
  return {
    numColumns,
    numRows,
    numItems,
    currentColor: utils_getComputedCSS(gridElement, "color"),
    style: {
      gridTemplateColumns,
      gridTemplateRows,
      gap: utils_getComputedCSS(gridElement, "gap"),
      inset: `
				calc(${paddingTop} + ${borderTopWidth})
				calc(${paddingRight} + ${borderRightWidth})
				calc(${paddingBottom} + ${borderBottomWidth})
				calc(${paddingLeft} + ${borderLeftWidth})
			`
    }
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js




const globalTips = [
  (0,external_wp_element_namespaceObject.createInterpolateElement)(
    (0,external_wp_i18n_namespaceObject.__)(
      "While writing, you can press <kbd>/</kbd> to quickly insert new blocks."
    ),
    { kbd: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("kbd", {}) }
  ),
  (0,external_wp_element_namespaceObject.createInterpolateElement)(
    (0,external_wp_i18n_namespaceObject.__)(
      "Indent a list by pressing <kbd>space</kbd> at the beginning of a line."
    ),
    { kbd: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("kbd", {}) }
  ),
  (0,external_wp_element_namespaceObject.createInterpolateElement)(
    (0,external_wp_i18n_namespaceObject.__)(
      "Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line."
    ),
    { kbd: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("kbd", {}) }
  ),
  (0,external_wp_i18n_namespaceObject.__)("Drag files into the editor to automatically insert media blocks."),
  (0,external_wp_i18n_namespaceObject.__)("Change a block's type by pressing the block icon on the toolbar.")
];
function Tips() {
  const [randomIndex] = (0,external_wp_element_namespaceObject.useState)(
    // Disable Reason: I'm not generating an HTML id.
    // eslint-disable-next-line no-restricted-syntax
    Math.floor(Math.random() * globalTips.length)
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tip, { children: globalTips[randomIndex] });
}
var tips_default = Tips;


;// ./node_modules/@wordpress/icons/build-module/library/chevron-right.js


var chevron_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/chevron-left.js


var chevron_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-card/index.js










const { Badge } = unlock(external_wp_components_namespaceObject.privateApis);
function BlockCard({
  title,
  icon,
  description,
  blockType,
  className,
  name,
  allowParentNavigation,
  children
}) {
  if (blockType) {
    external_wp_deprecated_default()("`blockType` property in `BlockCard component`", {
      since: "5.7",
      alternative: "`title, icon and description` properties"
    });
    ({ title, icon, description } = blockType);
  }
  const parentNavBlockClientId = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!allowParentNavigation) {
        return;
      }
      const { getSelectedBlockClientId, getBlockParentsByBlockName } = select(store);
      const _selectedBlockClientId = getSelectedBlockClientId();
      return getBlockParentsByBlockName(
        _selectedBlockClientId,
        "core/navigation",
        true
      )[0];
    },
    [allowParentNavigation]
  );
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: dist_clsx("block-editor-block-card", className), children: [
    allowParentNavigation && parentNavBlockClientId && // This is only used by the Navigation block for now. It's not ideal having Navigation block specific code here.
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        onClick: () => selectBlock(parentNavBlockClientId),
        label: (0,external_wp_i18n_namespaceObject.__)("Go to parent Navigation block"),
        style: (
          // TODO: This style override is also used in ToolsPanelHeader.
          // It should be supported out-of-the-box by Button.
          { minWidth: 24, padding: 0 }
        ),
        icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right_default : chevron_left_default,
        size: "small"
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon, showColors: true }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 1, children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("h2", { className: "block-editor-block-card__title", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-block-card__name", children: !!name?.length ? name : title }),
        !!name?.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Badge, { children: title })
      ] }),
      description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { className: "block-editor-block-card__description", children: description }),
      children
    ] })
  ] });
}
var block_card_default = BlockCard;


;// ./node_modules/@wordpress/upload-media/build-module/store/types.js
var Type = /* @__PURE__ */ ((Type2) => {
  Type2["Unknown"] = "REDUX_UNKNOWN";
  Type2["Add"] = "ADD_ITEM";
  Type2["Prepare"] = "PREPARE_ITEM";
  Type2["Cancel"] = "CANCEL_ITEM";
  Type2["Remove"] = "REMOVE_ITEM";
  Type2["PauseItem"] = "PAUSE_ITEM";
  Type2["ResumeItem"] = "RESUME_ITEM";
  Type2["PauseQueue"] = "PAUSE_QUEUE";
  Type2["ResumeQueue"] = "RESUME_QUEUE";
  Type2["OperationStart"] = "OPERATION_START";
  Type2["OperationFinish"] = "OPERATION_FINISH";
  Type2["AddOperations"] = "ADD_OPERATIONS";
  Type2["CacheBlobUrl"] = "CACHE_BLOB_URL";
  Type2["RevokeBlobUrls"] = "REVOKE_BLOB_URLS";
  Type2["UpdateSettings"] = "UPDATE_SETTINGS";
  return Type2;
})(Type || {});
var ItemStatus = /* @__PURE__ */ ((ItemStatus2) => {
  ItemStatus2["Processing"] = "PROCESSING";
  ItemStatus2["Paused"] = "PAUSED";
  return ItemStatus2;
})(ItemStatus || {});
var OperationType = /* @__PURE__ */ ((OperationType2) => {
  OperationType2["Prepare"] = "PREPARE";
  OperationType2["Upload"] = "UPLOAD";
  return OperationType2;
})(OperationType || {});


;// ./node_modules/@wordpress/upload-media/build-module/store/reducer.js

const reducer_noop = () => {
};
const DEFAULT_STATE = {
  queue: [],
  queueStatus: "active",
  blobUrls: {},
  settings: {
    mediaUpload: reducer_noop
  }
};
function reducer_reducer(state = DEFAULT_STATE, action = { type: Type.Unknown }) {
  switch (action.type) {
    case Type.PauseQueue: {
      return {
        ...state,
        queueStatus: "paused"
      };
    }
    case Type.ResumeQueue: {
      return {
        ...state,
        queueStatus: "active"
      };
    }
    case Type.Add:
      return {
        ...state,
        queue: [...state.queue, action.item]
      };
    case Type.Cancel:
      return {
        ...state,
        queue: state.queue.map(
          (item) => item.id === action.id ? {
            ...item,
            error: action.error
          } : item
        )
      };
    case Type.Remove:
      return {
        ...state,
        queue: state.queue.filter((item) => item.id !== action.id)
      };
    case Type.OperationStart: {
      return {
        ...state,
        queue: state.queue.map(
          (item) => item.id === action.id ? {
            ...item,
            currentOperation: action.operation
          } : item
        )
      };
    }
    case Type.AddOperations:
      return {
        ...state,
        queue: state.queue.map((item) => {
          if (item.id !== action.id) {
            return item;
          }
          return {
            ...item,
            operations: [
              ...item.operations || [],
              ...action.operations
            ]
          };
        })
      };
    case Type.OperationFinish:
      return {
        ...state,
        queue: state.queue.map((item) => {
          if (item.id !== action.id) {
            return item;
          }
          const operations = item.operations ? item.operations.slice(1) : [];
          const attachment = item.attachment || action.item.attachment ? {
            ...item.attachment,
            ...action.item.attachment
          } : void 0;
          return {
            ...item,
            currentOperation: void 0,
            operations,
            ...action.item,
            attachment,
            additionalData: {
              ...item.additionalData,
              ...action.item.additionalData
            }
          };
        })
      };
    case Type.CacheBlobUrl: {
      const blobUrls = state.blobUrls[action.id] || [];
      return {
        ...state,
        blobUrls: {
          ...state.blobUrls,
          [action.id]: [...blobUrls, action.blobUrl]
        }
      };
    }
    case Type.RevokeBlobUrls: {
      const newBlobUrls = { ...state.blobUrls };
      delete newBlobUrls[action.id];
      return {
        ...state,
        blobUrls: newBlobUrls
      };
    }
    case Type.UpdateSettings: {
      return {
        ...state,
        settings: {
          ...state.settings,
          ...action.settings
        }
      };
    }
  }
  return state;
}
var reducer_reducer_default = reducer_reducer;


;// ./node_modules/@wordpress/upload-media/build-module/store/selectors.js
function getItems(state) {
  return state.queue;
}
function isUploading(state) {
  return state.queue.length >= 1;
}
function isUploadingByUrl(state, url) {
  return state.queue.some(
    (item) => item.attachment?.url === url || item.sourceUrl === url
  );
}
function isUploadingById(state, attachmentId) {
  return state.queue.some(
    (item) => item.attachment?.id === attachmentId || item.sourceAttachmentId === attachmentId
  );
}
function selectors_getSettings(state) {
  return state.settings;
}


;// ./node_modules/@wordpress/upload-media/build-module/store/private-selectors.js

function getAllItems(state) {
  return state.queue;
}
function getItem(state, id) {
  return state.queue.find((item) => item.id === id);
}
function isBatchUploaded(state, batchId) {
  const batchItems = state.queue.filter(
    (item) => batchId === item.batchId
  );
  return batchItems.length === 0;
}
function isUploadingToPost(state, postOrAttachmentId) {
  return state.queue.some(
    (item) => item.currentOperation === OperationType.Upload && item.additionalData.post === postOrAttachmentId
  );
}
function getPausedUploadForPost(state, postOrAttachmentId) {
  return state.queue.find(
    (item) => item.status === ItemStatus.Paused && item.additionalData.post === postOrAttachmentId
  );
}
function isPaused(state) {
  return state.queueStatus === "paused";
}
function getBlobUrls(state, id) {
  return state.blobUrls[id] || [];
}


;// ./node_modules/@wordpress/upload-media/node_modules/uuid/dist/esm-browser/native.js
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const esm_browser_native = ({
  randomUUID
});
;// ./node_modules/@wordpress/upload-media/node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
;// ./node_modules/@wordpress/upload-media/node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_browser_stringify = ((/* unused pure expression or super */ null && (stringify)));
;// ./node_modules/@wordpress/upload-media/node_modules/uuid/dist/esm-browser/v4.js




function v4(options, buf, offset) {
  if (esm_browser_native.randomUUID && !buf && !options) {
    return esm_browser_native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

/* harmony default export */ const esm_browser_v4 = (v4);
;// ./node_modules/@wordpress/upload-media/build-module/upload-error.js
class UploadError extends Error {
  code;
  file;
  constructor({ code, message, file, cause }) {
    super(message, { cause });
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.file = file;
  }
}


;// ./node_modules/@wordpress/upload-media/build-module/validate-mime-type.js


function validateMimeType(file, allowedTypes) {
  if (!allowedTypes) {
    return;
  }
  const isAllowedType = allowedTypes.some((allowedType) => {
    if (allowedType.includes("/")) {
      return allowedType === file.type;
    }
    return file.type.startsWith(`${allowedType}/`);
  });
  if (file.type && !isAllowedType) {
    throw new UploadError({
      code: "MIME_TYPE_NOT_SUPPORTED",
      message: (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: file name.
        (0,external_wp_i18n_namespaceObject.__)("%s: Sorry, this file type is not supported here."),
        file.name
      ),
      file
    });
  }
}


;// ./node_modules/@wordpress/upload-media/build-module/get-mime-types-array.js
function getMimeTypesArray(wpMimeTypesObject) {
  if (!wpMimeTypesObject) {
    return null;
  }
  return Object.entries(wpMimeTypesObject).flatMap(
    ([extensionsString, mime]) => {
      const [type] = mime.split("/");
      const extensions = extensionsString.split("|");
      return [
        mime,
        ...extensions.map(
          (extension) => `${type}/${extension}`
        )
      ];
    }
  );
}


;// ./node_modules/@wordpress/upload-media/build-module/validate-mime-type-for-user.js



function validateMimeTypeForUser(file, wpAllowedMimeTypes) {
  const allowedMimeTypesForUser = getMimeTypesArray(wpAllowedMimeTypes);
  if (!allowedMimeTypesForUser) {
    return;
  }
  const isAllowedMimeTypeForUser = allowedMimeTypesForUser.includes(
    file.type
  );
  if (file.type && !isAllowedMimeTypeForUser) {
    throw new UploadError({
      code: "MIME_TYPE_NOT_ALLOWED_FOR_USER",
      message: (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: file name.
        (0,external_wp_i18n_namespaceObject.__)(
          "%s: Sorry, you are not allowed to upload this file type."
        ),
        file.name
      ),
      file
    });
  }
}


;// ./node_modules/@wordpress/upload-media/build-module/validate-file-size.js


function validateFileSize(file, maxUploadFileSize) {
  if (file.size <= 0) {
    throw new UploadError({
      code: "EMPTY_FILE",
      message: (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: file name.
        (0,external_wp_i18n_namespaceObject.__)("%s: This file is empty."),
        file.name
      ),
      file
    });
  }
  if (maxUploadFileSize && file.size > maxUploadFileSize) {
    throw new UploadError({
      code: "SIZE_ABOVE_LIMIT",
      message: (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %s: file name.
        (0,external_wp_i18n_namespaceObject.__)(
          "%s: This file exceeds the maximum upload size for this site."
        ),
        file.name
      ),
      file
    });
  }
}


;// ./node_modules/@wordpress/upload-media/build-module/store/actions.js





function addItems({
  files,
  onChange,
  onSuccess,
  onError,
  onBatchSuccess,
  additionalData,
  allowedTypes
}) {
  return async ({ select, dispatch }) => {
    const batchId = esm_browser_v4();
    for (const file of files) {
      try {
        validateMimeType(file, allowedTypes);
        validateMimeTypeForUser(
          file,
          select.getSettings().allowedMimeTypes
        );
      } catch (error) {
        onError?.(error);
        continue;
      }
      try {
        validateFileSize(
          file,
          select.getSettings().maxUploadFileSize
        );
      } catch (error) {
        onError?.(error);
        continue;
      }
      dispatch.addItem({
        file,
        batchId,
        onChange,
        onSuccess,
        onBatchSuccess,
        onError,
        additionalData
      });
    }
  };
}
function cancelItem(id, error, silent = false) {
  return async ({ select, dispatch }) => {
    const item = select.getItem(id);
    if (!item) {
      return;
    }
    item.abortController?.abort();
    if (!silent) {
      const { onError } = item;
      onError?.(error ?? new Error("Upload cancelled"));
      if (!onError && error) {
        console.error("Upload cancelled", error);
      }
    }
    dispatch({
      type: Type.Cancel,
      id,
      error
    });
    dispatch.removeItem(id);
    dispatch.revokeBlobUrls(id);
    if (item.batchId && select.isBatchUploaded(item.batchId)) {
      item.onBatchSuccess?.();
    }
  };
}


;// ./node_modules/@wordpress/upload-media/build-module/utils.js


function convertBlobToFile(fileOrBlob) {
  if (fileOrBlob instanceof File) {
    return fileOrBlob;
  }
  const ext = fileOrBlob.type.split("/")[1];
  const mediaType = "application/pdf" === fileOrBlob.type ? "document" : fileOrBlob.type.split("/")[0];
  return new File([fileOrBlob], `${mediaType}.${ext}`, {
    type: fileOrBlob.type
  });
}
function renameFile(file, name) {
  return new File([file], name, {
    type: file.type,
    lastModified: file.lastModified
  });
}
function cloneFile(file) {
  return renameFile(file, file.name);
}
function getFileExtension(file) {
  return file.includes(".") ? file.split(".").pop() || null : null;
}
function getFileBasename(name) {
  return name.includes(".") ? name.split(".").slice(0, -1).join(".") : name;
}
function getFileNameFromUrl(url) {
  return getFilename(url) || _x("unnamed", "file name");
}


;// ./node_modules/@wordpress/upload-media/build-module/stub-file.js
class StubFile extends File {
  constructor(fileName = "stub-file") {
    super([], fileName);
  }
}


;// ./node_modules/@wordpress/upload-media/build-module/store/private-actions.js





function addItem({
  file: fileOrBlob,
  batchId,
  onChange,
  onSuccess,
  onBatchSuccess,
  onError,
  additionalData = {},
  sourceUrl,
  sourceAttachmentId,
  abortController,
  operations
}) {
  return async ({ dispatch }) => {
    const itemId = esm_browser_v4();
    const file = convertBlobToFile(fileOrBlob);
    let blobUrl;
    if (!(file instanceof StubFile)) {
      blobUrl = (0,external_wp_blob_namespaceObject.createBlobURL)(file);
      dispatch({
        type: Type.CacheBlobUrl,
        id: itemId,
        blobUrl
      });
    }
    dispatch({
      type: Type.Add,
      item: {
        id: itemId,
        batchId,
        status: ItemStatus.Processing,
        sourceFile: cloneFile(file),
        file,
        attachment: {
          url: blobUrl
        },
        additionalData: {
          convert_format: false,
          ...additionalData
        },
        onChange,
        onSuccess,
        onBatchSuccess,
        onError,
        sourceUrl,
        sourceAttachmentId,
        abortController: abortController || new AbortController(),
        operations: Array.isArray(operations) ? operations : [OperationType.Prepare]
      }
    });
    dispatch.processItem(itemId);
  };
}
function processItem(id) {
  return async ({ select, dispatch }) => {
    if (select.isPaused()) {
      return;
    }
    const item = select.getItem(id);
    const { attachment, onChange, onSuccess, onBatchSuccess, batchId } = item;
    const operation = Array.isArray(item.operations?.[0]) ? item.operations[0][0] : item.operations?.[0];
    if (attachment) {
      onChange?.([attachment]);
    }
    if (!operation) {
      if (attachment) {
        onSuccess?.([attachment]);
      }
      dispatch.revokeBlobUrls(id);
      if (batchId && select.isBatchUploaded(batchId)) {
        onBatchSuccess?.();
      }
      return;
    }
    if (!operation) {
      return;
    }
    dispatch({
      type: Type.OperationStart,
      id,
      operation
    });
    switch (operation) {
      case OperationType.Prepare:
        dispatch.prepareItem(item.id);
        break;
      case OperationType.Upload:
        dispatch.uploadItem(id);
        break;
    }
  };
}
function pauseQueue() {
  return {
    type: Type.PauseQueue
  };
}
function resumeQueue() {
  return async ({ select, dispatch }) => {
    dispatch({
      type: Type.ResumeQueue
    });
    for (const item of select.getAllItems()) {
      dispatch.processItem(item.id);
    }
  };
}
function removeItem(id) {
  return async ({ select, dispatch }) => {
    const item = select.getItem(id);
    if (!item) {
      return;
    }
    dispatch({
      type: Type.Remove,
      id
    });
  };
}
function finishOperation(id, updates) {
  return async ({ dispatch }) => {
    dispatch({
      type: Type.OperationFinish,
      id,
      item: updates
    });
    dispatch.processItem(id);
  };
}
function prepareItem(id) {
  return async ({ dispatch }) => {
    const operations = [OperationType.Upload];
    dispatch({
      type: Type.AddOperations,
      id,
      operations
    });
    dispatch.finishOperation(id, {});
  };
}
function uploadItem(id) {
  return async ({ select, dispatch }) => {
    const item = select.getItem(id);
    select.getSettings().mediaUpload({
      filesList: [item.file],
      additionalData: item.additionalData,
      signal: item.abortController?.signal,
      onFileChange: ([attachment]) => {
        if (!(0,external_wp_blob_namespaceObject.isBlobURL)(attachment.url)) {
          dispatch.finishOperation(id, {
            attachment
          });
        }
      },
      onSuccess: ([attachment]) => {
        dispatch.finishOperation(id, {
          attachment
        });
      },
      onError: (error) => {
        dispatch.cancelItem(id, error);
      }
    });
  };
}
function revokeBlobUrls(id) {
  return async ({ select, dispatch }) => {
    const blobUrls = select.getBlobUrls(id);
    for (const blobUrl of blobUrls) {
      (0,external_wp_blob_namespaceObject.revokeBlobURL)(blobUrl);
    }
    dispatch({
      type: Type.RevokeBlobUrls,
      id
    });
  };
}
function private_actions_updateSettings(settings) {
  return {
    type: Type.UpdateSettings,
    settings
  };
}


;// ./node_modules/@wordpress/upload-media/build-module/lock-unlock.js

const { lock: lock_unlock_lock, unlock: lock_unlock_unlock } = (0,external_wp_privateApis_namespaceObject.__dangerousOptInToUnstableAPIsOnlyForCoreModules)(
  "I acknowledge private features are not for use in themes or plugins and doing so will break in the next version of WordPress.",
  "@wordpress/upload-media"
);


;// ./node_modules/@wordpress/upload-media/build-module/store/constants.js
const constants_STORE_NAME = "core/upload-media";


;// ./node_modules/@wordpress/upload-media/build-module/store/index.js








const store_storeConfig = {
  reducer: reducer_reducer_default,
  selectors: store_selectors_namespaceObject,
  actions: store_actions_namespaceObject
};
const store_store = (0,external_wp_data_namespaceObject.createReduxStore)(constants_STORE_NAME, {
  reducer: reducer_reducer_default,
  selectors: store_selectors_namespaceObject,
  actions: store_actions_namespaceObject
});
(0,external_wp_data_namespaceObject.register)(store_store);
lock_unlock_unlock(store_store).registerPrivateActions(store_private_actions_namespaceObject);
lock_unlock_unlock(store_store).registerPrivateSelectors(store_private_selectors_namespaceObject);


;// ./node_modules/@wordpress/upload-media/build-module/components/provider/with-registry-provider.js






function getSubRegistry(subRegistries, registry, useSubRegistry) {
  if (!useSubRegistry) {
    return registry;
  }
  let subRegistry = subRegistries.get(registry);
  if (!subRegistry) {
    subRegistry = (0,external_wp_data_namespaceObject.createRegistry)({}, registry);
    subRegistry.registerStore(constants_STORE_NAME, store_storeConfig);
    subRegistries.set(registry, subRegistry);
  }
  return subRegistry;
}
const withRegistryProvider = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (WrappedComponent) => ({ useSubRegistry = true, ...props }) => {
    const registry = (0,external_wp_data_namespaceObject.useRegistry)();
    const [subRegistries] = (0,external_wp_element_namespaceObject.useState)(() => /* @__PURE__ */ new WeakMap());
    const subRegistry = getSubRegistry(
      subRegistries,
      registry,
      useSubRegistry
    );
    if (subRegistry === registry) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { registry, ...props });
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_data_namespaceObject.RegistryProvider, { value: subRegistry, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { registry: subRegistry, ...props }) });
  },
  "withRegistryProvider"
);
var with_registry_provider_default = withRegistryProvider;


;// ./node_modules/@wordpress/upload-media/build-module/components/provider/index.js






const MediaUploadProvider = with_registry_provider_default((props) => {
  const { children, settings } = props;
  const { updateSettings } = lock_unlock_unlock((0,external_wp_data_namespaceObject.useDispatch)(store_store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    updateSettings(settings);
  }, [settings, updateSettings]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children });
});
var provider_default = MediaUploadProvider;


;// ./node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js






function with_registry_provider_getSubRegistry(subRegistries, registry, useSubRegistry) {
  if (!useSubRegistry) {
    return registry;
  }
  let subRegistry = subRegistries.get(registry);
  if (!subRegistry) {
    subRegistry = (0,external_wp_data_namespaceObject.createRegistry)({}, registry);
    subRegistry.registerStore(STORE_NAME, storeConfig);
    subRegistries.set(registry, subRegistry);
  }
  return subRegistry;
}
const with_registry_provider_withRegistryProvider = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (WrappedComponent) => ({ useSubRegistry = true, ...props }) => {
    const registry = (0,external_wp_data_namespaceObject.useRegistry)();
    const [subRegistries] = (0,external_wp_element_namespaceObject.useState)(() => /* @__PURE__ */ new WeakMap());
    const subRegistry = with_registry_provider_getSubRegistry(
      subRegistries,
      registry,
      useSubRegistry
    );
    if (subRegistry === registry) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { registry, ...props });
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_data_namespaceObject.RegistryProvider, { value: subRegistry, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { registry: subRegistry, ...props }) });
  },
  "withRegistryProvider"
);
var with_registry_provider_with_registry_provider_default = with_registry_provider_withRegistryProvider;


;// ./node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js




const use_block_sync_noop = () => {
};
function useBlockSync({
  clientId = null,
  value: controlledBlocks,
  selection: controlledSelection,
  onChange = use_block_sync_noop,
  onInput = use_block_sync_noop
}) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    resetBlocks,
    resetSelection,
    replaceInnerBlocks,
    setHasControlledInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = registry.dispatch(store);
  const { getBlockName, getBlocks, getSelectionStart, getSelectionEnd } = registry.select(store);
  const isControlled = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return !clientId || select(store).areInnerBlocksControlled(clientId);
    },
    [clientId]
  );
  const pendingChangesRef = (0,external_wp_element_namespaceObject.useRef)({ incoming: null, outgoing: [] });
  const subscribedRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const setControlledBlocks = () => {
    if (!controlledBlocks) {
      return;
    }
    __unstableMarkNextChangeAsNotPersistent();
    if (clientId) {
      registry.batch(() => {
        setHasControlledInnerBlocks(clientId, true);
        const storeBlocks = controlledBlocks.map(
          (block) => (0,external_wp_blocks_namespaceObject.cloneBlock)(block)
        );
        if (subscribedRef.current) {
          pendingChangesRef.current.incoming = storeBlocks;
        }
        __unstableMarkNextChangeAsNotPersistent();
        replaceInnerBlocks(clientId, storeBlocks);
      });
    } else {
      if (subscribedRef.current) {
        pendingChangesRef.current.incoming = controlledBlocks;
      }
      resetBlocks(controlledBlocks);
    }
  };
  const unsetControlledBlocks = () => {
    __unstableMarkNextChangeAsNotPersistent();
    if (clientId) {
      setHasControlledInnerBlocks(clientId, false);
      __unstableMarkNextChangeAsNotPersistent();
      replaceInnerBlocks(clientId, []);
    } else {
      resetBlocks([]);
    }
  };
  const onInputRef = (0,external_wp_element_namespaceObject.useRef)(onInput);
  const onChangeRef = (0,external_wp_element_namespaceObject.useRef)(onChange);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    onInputRef.current = onInput;
    onChangeRef.current = onChange;
  }, [onInput, onChange]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (pendingChangesRef.current.outgoing.includes(controlledBlocks)) {
      if (pendingChangesRef.current.outgoing[pendingChangesRef.current.outgoing.length - 1] === controlledBlocks) {
        pendingChangesRef.current.outgoing = [];
      }
    } else if (getBlocks(clientId) !== controlledBlocks) {
      pendingChangesRef.current.outgoing = [];
      setControlledBlocks();
      if (controlledSelection) {
        resetSelection(
          controlledSelection.selectionStart,
          controlledSelection.selectionEnd,
          controlledSelection.initialPosition
        );
      }
    }
  }, [controlledBlocks, clientId]);
  const isMountedRef = (0,external_wp_element_namespaceObject.useRef)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isMountedRef.current) {
      isMountedRef.current = true;
      return;
    }
    if (!isControlled) {
      pendingChangesRef.current.outgoing = [];
      setControlledBlocks();
    }
  }, [isControlled]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const {
      getSelectedBlocksInitialCaretPosition,
      isLastBlockChangePersistent,
      __unstableIsLastBlockChangeIgnored,
      areInnerBlocksControlled
    } = registry.select(store);
    let blocks = getBlocks(clientId);
    let isPersistent = isLastBlockChangePersistent();
    let previousAreBlocksDifferent = false;
    subscribedRef.current = true;
    const unsubscribe = registry.subscribe(() => {
      if (clientId !== null && getBlockName(clientId) === null) {
        return;
      }
      const isStillControlled = !clientId || areInnerBlocksControlled(clientId);
      if (!isStillControlled) {
        return;
      }
      const newIsPersistent = isLastBlockChangePersistent();
      const newBlocks = getBlocks(clientId);
      const areBlocksDifferent = newBlocks !== blocks;
      blocks = newBlocks;
      if (areBlocksDifferent && (pendingChangesRef.current.incoming || __unstableIsLastBlockChangeIgnored())) {
        pendingChangesRef.current.incoming = null;
        isPersistent = newIsPersistent;
        return;
      }
      const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;
      if (areBlocksDifferent || didPersistenceChange) {
        isPersistent = newIsPersistent;
        pendingChangesRef.current.outgoing.push(blocks);
        const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
        updateParent(blocks, {
          selection: {
            selectionStart: getSelectionStart(),
            selectionEnd: getSelectionEnd(),
            initialPosition: getSelectedBlocksInitialCaretPosition()
          }
        });
      }
      previousAreBlocksDifferent = areBlocksDifferent;
    }, store);
    return () => {
      subscribedRef.current = false;
      unsubscribe();
    };
  }, [registry, clientId]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      unsetControlledBlocks();
    };
  }, []);
}


;// external ["wp","keyboardShortcuts"]
const external_wp_keyboardShortcuts_namespaceObject = window["wp"]["keyboardShortcuts"];
;// ./node_modules/@wordpress/block-editor/build-module/components/keyboard-shortcuts/index.js




function KeyboardShortcuts() {
  return null;
}
function KeyboardShortcutsRegister() {
  const { registerShortcut } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_keyboardShortcuts_namespaceObject.store);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    registerShortcut({
      name: "core/block-editor/copy",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Copy the selected block(s)."),
      keyCombination: {
        modifier: "primary",
        character: "c"
      }
    });
    registerShortcut({
      name: "core/block-editor/cut",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Cut the selected block(s)."),
      keyCombination: {
        modifier: "primary",
        character: "x"
      }
    });
    registerShortcut({
      name: "core/block-editor/paste",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Paste the selected block(s)."),
      keyCombination: {
        modifier: "primary",
        character: "v"
      }
    });
    registerShortcut({
      name: "core/block-editor/duplicate",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Duplicate the selected block(s)."),
      keyCombination: {
        modifier: "primaryShift",
        character: "d"
      }
    });
    registerShortcut({
      name: "core/block-editor/remove",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Remove the selected block(s)."),
      keyCombination: {
        modifier: "access",
        character: "z"
      }
    });
    registerShortcut({
      name: "core/block-editor/paste-styles",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)(
        "Paste the copied style to the selected block(s)."
      ),
      keyCombination: {
        modifier: "primaryAlt",
        character: "v"
      }
    });
    registerShortcut({
      name: "core/block-editor/insert-before",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)(
        "Insert a new block before the selected block(s)."
      ),
      keyCombination: {
        modifier: "primaryAlt",
        character: "t"
      }
    });
    registerShortcut({
      name: "core/block-editor/insert-after",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)(
        "Insert a new block after the selected block(s)."
      ),
      keyCombination: {
        modifier: "primaryAlt",
        character: "y"
      }
    });
    registerShortcut({
      name: "core/block-editor/delete-multi-selection",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Delete selection."),
      keyCombination: {
        character: "del"
      },
      aliases: [
        {
          character: "backspace"
        }
      ]
    });
    registerShortcut({
      name: "core/block-editor/select-all",
      category: "selection",
      description: (0,external_wp_i18n_namespaceObject.__)(
        "Select all text when typing. Press again to select all blocks."
      ),
      keyCombination: {
        modifier: "primary",
        character: "a"
      }
    });
    registerShortcut({
      name: "core/block-editor/unselect",
      category: "selection",
      description: (0,external_wp_i18n_namespaceObject.__)("Clear selection."),
      keyCombination: {
        character: "escape"
      }
    });
    registerShortcut({
      name: "core/block-editor/multi-text-selection",
      category: "selection",
      description: (0,external_wp_i18n_namespaceObject.__)("Select text across multiple blocks."),
      keyCombination: {
        modifier: "shift",
        character: "arrow"
      }
    });
    registerShortcut({
      name: "core/block-editor/focus-toolbar",
      category: "global",
      description: (0,external_wp_i18n_namespaceObject.__)("Navigate to the nearest toolbar."),
      keyCombination: {
        modifier: "alt",
        character: "F10"
      }
    });
    registerShortcut({
      name: "core/block-editor/move-up",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Move the selected block(s) up."),
      keyCombination: {
        modifier: "secondary",
        character: "t"
      }
    });
    registerShortcut({
      name: "core/block-editor/move-down",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Move the selected block(s) down."),
      keyCombination: {
        modifier: "secondary",
        character: "y"
      }
    });
    registerShortcut({
      name: "core/block-editor/collapse-list-view",
      category: "list-view",
      description: (0,external_wp_i18n_namespaceObject.__)("Collapse all other items."),
      keyCombination: {
        modifier: "alt",
        character: "l"
      }
    });
    registerShortcut({
      name: "core/block-editor/group",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)(
        "Create a group block from the selected multiple blocks."
      ),
      keyCombination: {
        modifier: "primary",
        character: "g"
      }
    });
    registerShortcut({
      name: "core/block-editor/toggle-block-visibility",
      category: "block",
      description: (0,external_wp_i18n_namespaceObject.__)("Show or hide the selected block(s)."),
      keyCombination: {
        modifier: "primaryShift",
        character: "h"
      }
    });
  }, [registerShortcut]);
  return null;
}
KeyboardShortcuts.Register = KeyboardShortcutsRegister;
var keyboard_shortcuts_default = KeyboardShortcuts;


;// ./node_modules/@wordpress/block-editor/build-module/components/provider/use-media-upload-settings.js

function useMediaUploadSettings(settings = {}) {
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      mediaUpload: settings.mediaUpload,
      mediaSideload: settings.mediaSideload,
      maxUploadFileSize: settings.maxUploadFileSize,
      allowedMimeTypes: settings.allowedMimeTypes
    }),
    [settings]
  );
}
var use_media_upload_settings_default = useMediaUploadSettings;


;// ./node_modules/@wordpress/block-editor/build-module/components/provider/index.js












const provider_noop = () => {
};
function mediaUpload(registry, {
  allowedTypes,
  additionalData = {},
  filesList,
  onError = provider_noop,
  onFileChange,
  onSuccess,
  onBatchSuccess
}) {
  void registry.dispatch(store_store).addItems({
    files: filesList,
    onChange: onFileChange,
    onSuccess,
    onBatchSuccess,
    onError: ({ message }) => onError(message),
    additionalData,
    allowedTypes
  });
}
const ExperimentalBlockEditorProvider = with_registry_provider_with_registry_provider_default(
  (props) => {
    const {
      settings: _settings,
      registry,
      stripExperimentalSettings = false
    } = props;
    const mediaUploadSettings = use_media_upload_settings_default(_settings);
    let settings = _settings;
    if (window.__experimentalMediaProcessing && _settings.mediaUpload) {
      settings = (0,external_wp_element_namespaceObject.useMemo)(
        () => ({
          ..._settings,
          mediaUpload: mediaUpload.bind(null, registry)
        }),
        [_settings, registry]
      );
    }
    const { __experimentalUpdateSettings } = unlock(
      (0,external_wp_data_namespaceObject.useDispatch)(store)
    );
    (0,external_wp_element_namespaceObject.useEffect)(() => {
      __experimentalUpdateSettings(
        {
          ...settings,
          __internalIsInitialized: true
        },
        {
          stripExperimentalSettings,
          reset: true
        }
      );
    }, [
      settings,
      stripExperimentalSettings,
      __experimentalUpdateSettings
    ]);
    useBlockSync(props);
    const children = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.SlotFillProvider, { passthrough: true, children: [
      !settings?.isPreviewMode && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(keyboard_shortcuts_default.Register, {}),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockRefsProvider, { children: props.children })
    ] });
    if (window.__experimentalMediaProcessing) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        provider_default,
        {
          settings: mediaUploadSettings,
          useSubRegistry: false,
          children
        }
      );
    }
    return children;
  }
);
const BlockEditorProvider = (props) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ExperimentalBlockEditorProvider, { ...props, stripExperimentalSettings: true, children: props.children });
};
var provider_provider_default = BlockEditorProvider;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-context/index.js


const block_context_Context = (0,external_wp_element_namespaceObject.createContext)({});
block_context_Context.displayName = "BlockContext";
function BlockContextProvider({ value, children }) {
  const context = (0,external_wp_element_namespaceObject.useContext)(block_context_Context);
  const nextValue = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({ ...context, ...value }),
    [context, value]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_context_Context.Provider, { value: nextValue, children });
}
var block_context_default = block_context_Context;


;// ./node_modules/@wordpress/block-editor/build-module/utils/block-bindings.js



const DEFAULT_ATTRIBUTE = "__default";
const PATTERN_OVERRIDES_SOURCE = "core/pattern-overrides";
function isObjectEmpty(object) {
  return !object || Object.keys(object).length === 0;
}
function hasPatternOverridesDefaultBinding(bindings) {
  return bindings?.[DEFAULT_ATTRIBUTE]?.source === PATTERN_OVERRIDES_SOURCE;
}
function replacePatternOverridesDefaultBinding(bindings, supportedAttributes) {
  if (hasPatternOverridesDefaultBinding(bindings)) {
    const bindingsWithDefaults = {};
    for (const attributeName of supportedAttributes) {
      const bindingSource = bindings[attributeName] ? bindings[attributeName] : { source: PATTERN_OVERRIDES_SOURCE };
      bindingsWithDefaults[attributeName] = bindingSource;
    }
    return bindingsWithDefaults;
  }
  return bindings;
}
function useBlockBindingsUtils(clientId) {
  const { clientId: contextClientId } = useBlockEditContext();
  const blockClientId = clientId || contextClientId;
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { getBlockAttributes } = (0,external_wp_data_namespaceObject.useRegistry)().select(store);
  const updateBlockBindings = (bindings) => {
    const { metadata: { bindings: currentBindings, ...metadata } = {} } = getBlockAttributes(blockClientId);
    const newBindings = { ...currentBindings };
    Object.entries(bindings).forEach(([attribute, binding]) => {
      if (!binding && newBindings[attribute]) {
        delete newBindings[attribute];
        return;
      }
      newBindings[attribute] = binding;
    });
    const newMetadata = {
      ...metadata,
      bindings: newBindings
    };
    if (isObjectEmpty(newMetadata.bindings)) {
      delete newMetadata.bindings;
    }
    updateBlockAttributes(blockClientId, {
      metadata: isObjectEmpty(newMetadata) ? void 0 : newMetadata
    });
  };
  const removeAllBlockBindings = () => {
    const { metadata: { bindings, ...metadata } = {} } = getBlockAttributes(blockClientId);
    updateBlockAttributes(blockClientId, {
      metadata: isObjectEmpty(metadata) ? void 0 : metadata
    });
  };
  return { updateBlockBindings, removeAllBlockBindings };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/private-block-context.js

const PrivateBlockContext = (0,external_wp_element_namespaceObject.createContext)({});
PrivateBlockContext.displayName = "PrivateBlockContext";


;// ./node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js











const DEFAULT_BLOCK_CONTEXT = {};
const Edit = (props) => {
  const { name } = props;
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  if (!blockType) {
    return null;
  }
  const Component = blockType.edit || blockType.save;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Component, { ...props });
};
const EditWithFilters = (0,external_wp_components_namespaceObject.withFilters)("editor.BlockEdit")(Edit);
const EditWithGeneratedProps = (props) => {
  const { name, clientId, attributes, setAttributes } = props;
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context_default);
  const registeredSources = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(external_wp_blocks_namespaceObject.store)).getAllBlockBindingsSources(),
    []
  );
  const { bindableAttributes } = (0,external_wp_element_namespaceObject.useContext)(PrivateBlockContext);
  const { blockBindings, context, hasPatternOverrides } = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const computedContext = blockType?.usesContext ? Object.fromEntries(
      Object.entries(blockContext).filter(
        ([key]) => blockType.usesContext.includes(key)
      )
    ) : DEFAULT_BLOCK_CONTEXT;
    if (attributes?.metadata?.bindings) {
      Object.values(attributes?.metadata?.bindings || {}).forEach(
        (binding) => {
          registeredSources[binding?.source]?.usesContext?.forEach(
            (key) => {
              computedContext[key] = blockContext[key];
            }
          );
        }
      );
    }
    return {
      blockBindings: replacePatternOverridesDefaultBinding(
        attributes?.metadata?.bindings,
        bindableAttributes
      ),
      context: computedContext,
      hasPatternOverrides: hasPatternOverridesDefaultBinding(
        attributes?.metadata?.bindings
      )
    };
  }, [
    name,
    blockType?.usesContext,
    blockContext,
    attributes?.metadata?.bindings,
    registeredSources
  ]);
  const computedAttributes = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!blockBindings) {
        return attributes;
      }
      const attributesFromSources = {};
      const blockBindingsBySource = /* @__PURE__ */ new Map();
      for (const [attributeName, binding] of Object.entries(
        blockBindings
      )) {
        const { source: sourceName, args: sourceArgs } = binding;
        const source = registeredSources[sourceName];
        if (!source || !bindableAttributes?.includes(attributeName)) {
          continue;
        }
        blockBindingsBySource.set(source, {
          ...blockBindingsBySource.get(source),
          [attributeName]: {
            args: sourceArgs
          }
        });
      }
      if (blockBindingsBySource.size) {
        for (const [source, bindings] of blockBindingsBySource) {
          let values = {};
          if (!source.getValues) {
            Object.keys(bindings).forEach((attr) => {
              values[attr] = source.label;
            });
          } else {
            values = source.getValues({
              select,
              context,
              clientId,
              bindings
            });
          }
          for (const [attributeName, value] of Object.entries(
            values
          )) {
            if (attributeName === "url" && (!value || !isURLLike(value))) {
              attributesFromSources[attributeName] = null;
            } else {
              attributesFromSources[attributeName] = value;
            }
          }
        }
      }
      return {
        ...attributes,
        ...attributesFromSources
      };
    },
    [
      attributes,
      bindableAttributes,
      blockBindings,
      clientId,
      context,
      name,
      registeredSources
    ]
  );
  const setBoundAttributes = (0,external_wp_element_namespaceObject.useCallback)(
    (nextAttributes) => {
      if (!blockBindings) {
        setAttributes(nextAttributes);
        return;
      }
      registry.batch(() => {
        const keptAttributes = { ...nextAttributes };
        const blockBindingsBySource = /* @__PURE__ */ new Map();
        for (const [attributeName, newValue] of Object.entries(
          keptAttributes
        )) {
          if (!blockBindings[attributeName] || !bindableAttributes?.includes(attributeName)) {
            continue;
          }
          const binding = blockBindings[attributeName];
          const source = registeredSources[binding?.source];
          if (!source?.setValues) {
            continue;
          }
          blockBindingsBySource.set(source, {
            ...blockBindingsBySource.get(source),
            [attributeName]: {
              args: binding.args,
              newValue
            }
          });
          delete keptAttributes[attributeName];
        }
        if (blockBindingsBySource.size) {
          for (const [
            source,
            bindings
          ] of blockBindingsBySource) {
            source.setValues({
              select: registry.select,
              dispatch: registry.dispatch,
              context,
              clientId,
              bindings
            });
          }
        }
        const hasParentPattern = !!context["pattern/overrides"];
        if (
          // Don't update non-connected attributes if the block is using pattern overrides
          // and the editing is happening while overriding the pattern (not editing the original).
          !(hasPatternOverrides && hasParentPattern) && Object.keys(keptAttributes).length
        ) {
          if (hasPatternOverrides) {
            delete keptAttributes.caption;
            delete keptAttributes.href;
          }
          setAttributes(keptAttributes);
        }
      });
    },
    [
      bindableAttributes,
      blockBindings,
      clientId,
      context,
      hasPatternOverrides,
      setAttributes,
      registeredSources,
      name,
      registry
    ]
  );
  if (!blockType) {
    return null;
  }
  if (blockType.apiVersion > 1) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      EditWithFilters,
      {
        ...props,
        attributes: computedAttributes,
        context,
        setAttributes: setBoundAttributes
      }
    );
  }
  const generatedClassName = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "className", true) ? (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(name) : null;
  const className = dist_clsx(
    generatedClassName,
    attributes?.className,
    props.className
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    EditWithFilters,
    {
      ...props,
      attributes: computedAttributes,
      className,
      context,
      setAttributes: setBoundAttributes
    }
  );
};
var edit_default = EditWithGeneratedProps;


;// ./node_modules/@wordpress/icons/build-module/library/more-vertical.js


var more_vertical_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/warning/index.js





function Warning({ className, actions, children, secondaryActions }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { style: { display: "contents", all: "initial" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: dist_clsx(className, "block-editor-warning"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-warning__contents", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-warning__message", children }),
    (actions?.length > 0 || secondaryActions) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-warning__actions", children: [
      actions?.length > 0 && actions.map((action, i) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "span",
        {
          className: "block-editor-warning__action",
          children: action
        },
        i
      )),
      secondaryActions && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.DropdownMenu,
        {
          className: "block-editor-warning__secondary",
          icon: more_vertical_default,
          label: (0,external_wp_i18n_namespaceObject.__)("More options"),
          popoverProps: {
            placement: "bottom-end",
            className: "block-editor-warning__dropdown"
          },
          noIcons: true,
          children: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: secondaryActions.map(
            (item, pos) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.MenuItem,
              {
                onClick: item.onClick,
                children: item.title
              },
              pos
            )
          ) })
        }
      )
    ] })
  ] }) }) });
}
var warning_default = Warning;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-edit/multiple-usage-warning.js







function MultipleUsageWarning({
  originalBlockClientId,
  name,
  onReplace
}) {
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    warning_default,
    {
      actions: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            variant: "secondary",
            onClick: () => selectBlock(originalBlockClientId),
            children: (0,external_wp_i18n_namespaceObject.__)("Find original")
          },
          "find-original"
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            variant: "secondary",
            onClick: () => onReplace([]),
            children: (0,external_wp_i18n_namespaceObject.__)("Remove")
          },
          "remove"
        )
      ],
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("strong", { children: [
          blockType?.title,
          ": "
        ] }),
        (0,external_wp_i18n_namespaceObject.__)("This block can only be used once.")
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js







function BlockEdit({
  mayDisplayControls,
  mayDisplayParentControls,
  blockEditingMode,
  isPreviewMode,
  // The remaining props are passed through the BlockEdit filters and are thus
  // public API!
  ...props
}) {
  const {
    name,
    isSelected,
    clientId,
    attributes = {},
    __unstableLayoutClassNames
  } = props;
  const { layout = null, metadata = {} } = attributes;
  const { bindings } = metadata;
  const layoutSupport = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "layout", false) || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(name, "__experimentalLayout", false);
  const { originalBlockClientId } = (0,external_wp_element_namespaceObject.useContext)(PrivateBlockContext);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    Provider,
    {
      value: (0,external_wp_element_namespaceObject.useMemo)(
        () => ({
          name,
          isSelected,
          clientId,
          layout: layoutSupport ? layout : null,
          __unstableLayoutClassNames,
          // We use symbols in favour of an __unstable prefix to avoid
          // usage outside of the package (this context is exposed).
          [mayDisplayControlsKey]: mayDisplayControls,
          [mayDisplayParentControlsKey]: mayDisplayParentControls,
          [blockEditingModeKey]: blockEditingMode,
          [blockBindingsKey]: bindings,
          [isPreviewModeKey]: isPreviewMode
        }),
        [
          name,
          isSelected,
          clientId,
          layoutSupport,
          layout,
          __unstableLayoutClassNames,
          mayDisplayControls,
          mayDisplayParentControls,
          blockEditingMode,
          bindings,
          isPreviewMode
        ]
      ),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(edit_default, { ...props }),
        originalBlockClientId && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          MultipleUsageWarning,
          {
            originalBlockClientId,
            name,
            onReplace: props.onReplace
          }
        )
      ]
    }
  );
}


// EXTERNAL MODULE: ./node_modules/diff/lib/diff/character.js
var character = __webpack_require__(8021);
;// ./node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js




function BlockView({
  title,
  rawContent,
  renderedContent,
  action,
  actionText,
  className
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-compare__content", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("h2", { className: "block-editor-block-compare__heading", children: title }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-compare__html", children: rawContent }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-compare__preview edit-post-visual-editor", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_element_namespaceObject.RawHTML, { children: (0,external_wp_dom_namespaceObject.safeHTML)(renderedContent) }) })
    ] }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-compare__action", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        variant: "secondary",
        tabIndex: "0",
        onClick: action,
        children: actionText
      }
    ) })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js






function BlockCompare({
  block,
  onKeep,
  onConvert,
  convertor,
  convertButtonText
}) {
  function getDifference(originalContent, newContent) {
    const difference2 = (0,character/* diffChars */.JJ)(originalContent, newContent);
    return difference2.map((item, pos) => {
      const classes = dist_clsx({
        "block-editor-block-compare__added": item.added,
        "block-editor-block-compare__removed": item.removed
      });
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: classes, children: item.value }, pos);
    });
  }
  function getConvertedContent(convertedBlock) {
    const newBlocks = Array.isArray(convertedBlock) ? convertedBlock : [convertedBlock];
    const newContent = newBlocks.map(
      (item) => (0,external_wp_blocks_namespaceObject.getSaveContent)(item.name, item.attributes, item.innerBlocks)
    );
    return newContent.join("");
  }
  const converted = getConvertedContent(convertor(block));
  const difference = getDifference(block.originalContent, converted);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-compare__wrapper", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockView,
      {
        title: (0,external_wp_i18n_namespaceObject.__)("Current"),
        className: "block-editor-block-compare__current",
        action: onKeep,
        actionText: (0,external_wp_i18n_namespaceObject.__)("Convert to HTML"),
        rawContent: block.originalContent,
        renderedContent: block.originalContent
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockView,
      {
        title: (0,external_wp_i18n_namespaceObject.__)("After Conversion"),
        className: "block-editor-block-compare__converted",
        action: onConvert,
        actionText: convertButtonText,
        rawContent: difference,
        renderedContent: converted
      }
    )
  ] });
}
var block_compare_default = BlockCompare;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js









const blockToBlocks = (block) => (0,external_wp_blocks_namespaceObject.rawHandler)({
  HTML: block.originalContent
});
function BlockInvalidWarning({ clientId }) {
  const { block, canInsertHTMLBlock, canInsertClassicBlock } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { canInsertBlockType, getBlock, getBlockRootClientId } = select(store);
      const rootClientId = getBlockRootClientId(clientId);
      return {
        block: getBlock(clientId),
        canInsertHTMLBlock: canInsertBlockType(
          "core/html",
          rootClientId
        ),
        canInsertClassicBlock: canInsertBlockType(
          "core/freeform",
          rootClientId
        )
      };
    },
    [clientId]
  );
  const { replaceBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const [compare, setCompare] = (0,external_wp_element_namespaceObject.useState)(false);
  const onCompareClose = (0,external_wp_element_namespaceObject.useCallback)(() => setCompare(false), []);
  const convert = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      toClassic() {
        const classicBlock = (0,external_wp_blocks_namespaceObject.createBlock)("core/freeform", {
          content: block.originalContent
        });
        return replaceBlock(block.clientId, classicBlock);
      },
      toHTML() {
        const htmlBlock = (0,external_wp_blocks_namespaceObject.createBlock)("core/html", {
          content: block.originalContent
        });
        return replaceBlock(block.clientId, htmlBlock);
      },
      toBlocks() {
        const newBlocks = blockToBlocks(block);
        return replaceBlock(block.clientId, newBlocks);
      },
      toRecoveredBlock() {
        const recoveredBlock = (0,external_wp_blocks_namespaceObject.createBlock)(
          block.name,
          block.attributes,
          block.innerBlocks
        );
        return replaceBlock(block.clientId, recoveredBlock);
      }
    }),
    [block, replaceBlock]
  );
  const secondaryActions = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      {
        // translators: Button to fix block content
        title: (0,external_wp_i18n_namespaceObject._x)("Resolve", "imperative verb"),
        onClick: () => setCompare(true)
      },
      canInsertHTMLBlock && {
        title: (0,external_wp_i18n_namespaceObject.__)("Convert to HTML"),
        onClick: convert.toHTML
      },
      canInsertClassicBlock && {
        title: (0,external_wp_i18n_namespaceObject.__)("Convert to Classic Block"),
        onClick: convert.toClassic
      }
    ].filter(Boolean),
    [canInsertHTMLBlock, canInsertClassicBlock, convert]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      warning_default,
      {
        actions: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              __next40pxDefaultSize: true,
              onClick: convert.toRecoveredBlock,
              variant: "primary",
              children: (0,external_wp_i18n_namespaceObject.__)("Attempt recovery")
            },
            "recover"
          )
        ],
        secondaryActions,
        children: (0,external_wp_i18n_namespaceObject.__)("Block contains unexpected or invalid content.")
      }
    ),
    compare && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Modal,
      {
        title: (
          // translators: Dialog title to fix block content
          (0,external_wp_i18n_namespaceObject.__)("Resolve Block")
        ),
        onRequestClose: onCompareClose,
        className: "block-editor-block-compare",
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          block_compare_default,
          {
            block,
            onKeep: convert.toHTML,
            onConvert: convert.toBlocks,
            convertor: blockToBlocks,
            convertButtonText: (0,external_wp_i18n_namespaceObject.__)("Convert to Blocks")
          }
        )
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js



const warning = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(warning_default, { className: "block-editor-block-list__block-crash-warning", children: (0,external_wp_i18n_namespaceObject.__)("This block has encountered an error and cannot be previewed.") });
var block_crash_warning_default = () => warning;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js

class BlockCrashBoundary extends external_wp_element_namespaceObject.Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false
    };
  }
  componentDidCatch() {
    this.setState({
      hasError: true
    });
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}
var block_crash_boundary_default = BlockCrashBoundary;


// EXTERNAL MODULE: ./node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__(4132);
;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js






function BlockHTML({ clientId }) {
  const [html, setHtml] = (0,external_wp_element_namespaceObject.useState)("");
  const block = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getBlock(clientId),
    [clientId]
  );
  const { updateBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onChange = () => {
    const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(block.name);
    if (!blockType) {
      return;
    }
    const attributes = (0,external_wp_blocks_namespaceObject.getBlockAttributes)(
      blockType,
      html,
      block.attributes
    );
    const content = html ? html : (0,external_wp_blocks_namespaceObject.getSaveContent)(blockType, attributes);
    const [isValid] = html ? (0,external_wp_blocks_namespaceObject.validateBlock)({
      ...block,
      attributes,
      originalContent: content
    }) : [true];
    updateBlock(clientId, {
      attributes,
      originalContent: content,
      isValid
    });
    if (!html) {
      setHtml(content);
    }
  };
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setHtml((0,external_wp_blocks_namespaceObject.getBlockContent)(block));
  }, [block]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    lib/* default */.A,
    {
      className: "block-editor-block-list__block-html-textarea",
      value: html,
      onBlur: onChange,
      onChange: (event) => setHtml(event.target.value)
    }
  );
}
var block_html_default = BlockHTML;


;// ./node_modules/@react-spring/rafz/dist/esm/index.js
var esm_f=esm_l(),esm_n=e=>esm_c(e,esm_f),esm_m=esm_l();esm_n.write=e=>esm_c(e,esm_m);var esm_d=esm_l();esm_n.onStart=e=>esm_c(e,esm_d);var esm_h=esm_l();esm_n.onFrame=e=>esm_c(e,esm_h);var esm_p=esm_l();esm_n.onFinish=e=>esm_c(e,esm_p);var esm_i=[];esm_n.setTimeout=(e,t)=>{let a=esm_n.now()+t,o=()=>{let F=esm_i.findIndex(z=>z.cancel==o);~F&&esm_i.splice(F,1),esm_u-=~F?1:0},s={time:a,handler:e,cancel:o};return esm_i.splice(esm_w(a),0,s),esm_u+=1,esm_v(),s};var esm_w=e=>~(~esm_i.findIndex(t=>t.time>e)||~esm_i.length);esm_n.cancel=e=>{esm_d.delete(e),esm_h.delete(e),esm_p.delete(e),esm_f.delete(e),esm_m.delete(e)};esm_n.sync=e=>{T=!0,esm_n.batchedUpdates(e),T=!1};esm_n.throttle=e=>{let t;function a(){try{e(...t)}finally{t=null}}function o(...s){t=s,esm_n.onStart(a)}return o.handler=e,o.cancel=()=>{esm_d.delete(a),t=null},o};var esm_y=typeof window<"u"?window.requestAnimationFrame:()=>{};esm_n.use=e=>esm_y=e;esm_n.now=typeof performance<"u"?()=>performance.now():Date.now;esm_n.batchedUpdates=e=>e();esm_n.catch=console.error;esm_n.frameLoop="always";esm_n.advance=()=>{esm_n.frameLoop!=="demand"?console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"):esm_x()};var esm_r=-1,esm_u=0,T=!1;function esm_c(e,t){T?(t.delete(e),e(0)):(t.add(e),esm_v())}function esm_v(){esm_r<0&&(esm_r=0,esm_n.frameLoop!=="demand"&&esm_y(esm_b))}function esm_R(){esm_r=-1}function esm_b(){~esm_r&&(esm_y(esm_b),esm_n.batchedUpdates(esm_x))}function esm_x(){let e=esm_r;esm_r=esm_n.now();let t=esm_w(esm_r);if(t&&(Q(esm_i.splice(0,t),a=>a.handler()),esm_u-=t),!esm_u){esm_R();return}esm_d.flush(),esm_f.flush(e?Math.min(64,esm_r-e):16.667),esm_h.flush(),esm_m.flush(),esm_p.flush()}function esm_l(){let e=new Set,t=e;return{add(a){esm_u+=t==e&&!e.has(a)?1:0,e.add(a)},delete(a){return esm_u-=t==e&&e.has(a)?1:0,e.delete(a)},flush(a){t.size&&(e=new Set,esm_u-=t.size,Q(t,o=>o(a)&&e.add(o)),esm_u+=e.size,t=e)}}}function Q(e,t){e.forEach(a=>{try{t(a)}catch(o){esm_n.catch(o)}})}var esm_S={count(){return esm_u},isRunning(){return esm_r>=0},clear(){esm_r=-1,esm_i=[],esm_d=esm_l(),esm_f=esm_l(),esm_h=esm_l(),esm_m=esm_l(),esm_p=esm_l(),esm_u=0}};

;// ./node_modules/@react-spring/shared/dist/esm/index.js
var ze=Object.defineProperty;var Le=(e,t)=>{for(var r in t)ze(e,r,{get:t[r],enumerable:!0})};var dist_esm_p={};Le(dist_esm_p,{assign:()=>U,colors:()=>dist_esm_c,createStringInterpolator:()=>esm_k,skipAnimation:()=>ee,to:()=>J,willAdvance:()=>dist_esm_S});function Y(){}var mt=(e,t,r)=>Object.defineProperty(e,t,{value:r,writable:!0,configurable:!0}),dist_esm_l={arr:Array.isArray,obj:e=>!!e&&e.constructor.name==="Object",fun:e=>typeof e=="function",str:e=>typeof e=="string",num:e=>typeof e=="number",und:e=>e===void 0};function bt(e,t){if(dist_esm_l.arr(e)){if(!dist_esm_l.arr(t)||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}return e===t}var esm_Ve=(e,t)=>e.forEach(t);function xt(e,t,r){if(dist_esm_l.arr(e)){for(let n=0;n<e.length;n++)t.call(r,e[n],`${n}`);return}for(let n in e)e.hasOwnProperty(n)&&t.call(r,e[n],n)}var ht=e=>dist_esm_l.und(e)?[]:dist_esm_l.arr(e)?e:[e];function Pe(e,t){if(e.size){let r=Array.from(e);e.clear(),esm_Ve(r,t)}}var yt=(e,...t)=>Pe(e,r=>r(...t)),dist_esm_h=()=>typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent);var esm_k,J,dist_esm_c=null,ee=!1,dist_esm_S=Y,U=e=>{e.to&&(J=e.to),e.now&&(esm_n.now=e.now),e.colors!==void 0&&(dist_esm_c=e.colors),e.skipAnimation!=null&&(ee=e.skipAnimation),e.createStringInterpolator&&(esm_k=e.createStringInterpolator),e.requestAnimationFrame&&esm_n.use(e.requestAnimationFrame),e.batchedUpdates&&(esm_n.batchedUpdates=e.batchedUpdates),e.willAdvance&&(dist_esm_S=e.willAdvance),e.frameLoop&&(esm_n.frameLoop=e.frameLoop)};var esm_E=new Set,dist_esm_u=[],esm_H=[],A=0,qe={get idle(){return!esm_E.size&&!dist_esm_u.length},start(e){A>e.priority?(esm_E.add(e),esm_n.onStart($e)):(te(e),esm_n(B))},advance:B,sort(e){if(A)esm_n.onFrame(()=>qe.sort(e));else{let t=dist_esm_u.indexOf(e);~t&&(dist_esm_u.splice(t,1),re(e))}},clear(){dist_esm_u=[],esm_E.clear()}};function $e(){esm_E.forEach(te),esm_E.clear(),esm_n(B)}function te(e){dist_esm_u.includes(e)||re(e)}function re(e){dist_esm_u.splice(Ge(dist_esm_u,t=>t.priority>e.priority),0,e)}function B(e){let t=esm_H;for(let r=0;r<dist_esm_u.length;r++){let n=dist_esm_u[r];A=n.priority,n.idle||(dist_esm_S(n),n.advance(e),n.idle||t.push(n))}return A=0,esm_H=dist_esm_u,esm_H.length=0,dist_esm_u=t,dist_esm_u.length>0}function Ge(e,t){let r=e.findIndex(t);return r<0?e.length:r}var ne=(e,t,r)=>Math.min(Math.max(r,e),t);var It={transparent:0,aliceblue:4042850303,antiquewhite:4209760255,aqua:16777215,aquamarine:2147472639,azure:4043309055,beige:4126530815,bisque:4293182719,black:255,blanchedalmond:4293643775,blue:65535,blueviolet:2318131967,brown:2771004159,burlywood:3736635391,burntsienna:3934150143,cadetblue:1604231423,chartreuse:2147418367,chocolate:3530104575,coral:4286533887,cornflowerblue:1687547391,cornsilk:4294499583,crimson:3692313855,cyan:16777215,darkblue:35839,darkcyan:9145343,darkgoldenrod:3095792639,darkgray:2846468607,darkgreen:6553855,darkgrey:2846468607,darkkhaki:3182914559,darkmagenta:2332068863,darkolivegreen:1433087999,darkorange:4287365375,darkorchid:2570243327,darkred:2332033279,darksalmon:3918953215,darkseagreen:2411499519,darkslateblue:1211993087,darkslategray:793726975,darkslategrey:793726975,darkturquoise:13554175,darkviolet:2483082239,deeppink:4279538687,deepskyblue:12582911,dimgray:1768516095,dimgrey:1768516095,dodgerblue:512819199,firebrick:2988581631,floralwhite:4294635775,forestgreen:579543807,fuchsia:4278255615,gainsboro:3705462015,ghostwhite:4177068031,gold:4292280575,goldenrod:3668254975,gray:2155905279,green:8388863,greenyellow:2919182335,grey:2155905279,honeydew:4043305215,hotpink:4285117695,indianred:3445382399,indigo:1258324735,ivory:4294963455,khaki:4041641215,lavender:3873897215,lavenderblush:4293981695,lawngreen:2096890111,lemonchiffon:4294626815,lightblue:2916673279,lightcoral:4034953471,lightcyan:3774873599,lightgoldenrodyellow:4210742015,lightgray:3553874943,lightgreen:2431553791,lightgrey:3553874943,lightpink:4290167295,lightsalmon:4288707327,lightseagreen:548580095,lightskyblue:2278488831,lightslategray:2005441023,lightslategrey:2005441023,lightsteelblue:2965692159,lightyellow:4294959359,lime:16711935,limegreen:852308735,linen:4210091775,magenta:4278255615,maroon:2147483903,mediumaquamarine:1724754687,mediumblue:52735,mediumorchid:3126187007,mediumpurple:2473647103,mediumseagreen:1018393087,mediumslateblue:2070474495,mediumspringgreen:16423679,mediumturquoise:1221709055,mediumvioletred:3340076543,midnightblue:421097727,mintcream:4127193855,mistyrose:4293190143,moccasin:4293178879,navajowhite:4292783615,navy:33023,oldlace:4260751103,olive:2155872511,olivedrab:1804477439,orange:4289003775,orangered:4282712319,orchid:3664828159,palegoldenrod:4008225535,palegreen:2566625535,paleturquoise:2951671551,palevioletred:3681588223,papayawhip:4293907967,peachpuff:4292524543,peru:3448061951,pink:4290825215,plum:3718307327,powderblue:2967529215,purple:2147516671,rebeccapurple:1714657791,red:4278190335,rosybrown:3163525119,royalblue:1097458175,saddlebrown:2336560127,salmon:4202722047,sandybrown:4104413439,seagreen:780883967,seashell:4294307583,sienna:2689740287,silver:3233857791,skyblue:2278484991,slateblue:1784335871,slategray:1887473919,slategrey:1887473919,snow:4294638335,springgreen:16744447,steelblue:1182971135,tan:3535047935,teal:8421631,thistle:3636451583,tomato:4284696575,turquoise:1088475391,violet:4001558271,wheat:4125012991,white:4294967295,whitesmoke:4126537215,yellow:4294902015,yellowgreen:2597139199};var dist_esm_d="[-+]?\\d*\\.?\\d+",esm_M=dist_esm_d+"%";function C(...e){return"\\(\\s*("+e.join(")\\s*,\\s*(")+")\\s*\\)"}var oe=new RegExp("rgb"+C(dist_esm_d,dist_esm_d,dist_esm_d)),fe=new RegExp("rgba"+C(dist_esm_d,dist_esm_d,dist_esm_d,dist_esm_d)),ae=new RegExp("hsl"+C(dist_esm_d,esm_M,esm_M)),ie=new RegExp("hsla"+C(dist_esm_d,esm_M,esm_M,dist_esm_d)),se=/^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,ue=/^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,le=/^#([0-9a-fA-F]{6})$/,esm_ce=/^#([0-9a-fA-F]{8})$/;function be(e){let t;return typeof e=="number"?e>>>0===e&&e>=0&&e<=4294967295?e:null:(t=le.exec(e))?parseInt(t[1]+"ff",16)>>>0:dist_esm_c&&dist_esm_c[e]!==void 0?dist_esm_c[e]:(t=oe.exec(e))?(dist_esm_y(t[1])<<24|dist_esm_y(t[2])<<16|dist_esm_y(t[3])<<8|255)>>>0:(t=fe.exec(e))?(dist_esm_y(t[1])<<24|dist_esm_y(t[2])<<16|dist_esm_y(t[3])<<8|me(t[4]))>>>0:(t=se.exec(e))?parseInt(t[1]+t[1]+t[2]+t[2]+t[3]+t[3]+"ff",16)>>>0:(t=esm_ce.exec(e))?parseInt(t[1],16)>>>0:(t=ue.exec(e))?parseInt(t[1]+t[1]+t[2]+t[2]+t[3]+t[3]+t[4]+t[4],16)>>>0:(t=ae.exec(e))?(de(esm_pe(t[1]),esm_z(t[2]),esm_z(t[3]))|255)>>>0:(t=ie.exec(e))?(de(esm_pe(t[1]),esm_z(t[2]),esm_z(t[3]))|me(t[4]))>>>0:null}function esm_j(e,t,r){return r<0&&(r+=1),r>1&&(r-=1),r<1/6?e+(t-e)*6*r:r<1/2?t:r<2/3?e+(t-e)*(2/3-r)*6:e}function de(e,t,r){let n=r<.5?r*(1+t):r+t-r*t,f=2*r-n,o=esm_j(f,n,e+1/3),i=esm_j(f,n,e),s=esm_j(f,n,e-1/3);return Math.round(o*255)<<24|Math.round(i*255)<<16|Math.round(s*255)<<8}function dist_esm_y(e){let t=parseInt(e,10);return t<0?0:t>255?255:t}function esm_pe(e){return(parseFloat(e)%360+360)%360/360}function me(e){let t=parseFloat(e);return t<0?0:t>1?255:Math.round(t*255)}function esm_z(e){let t=parseFloat(e);return t<0?0:t>100?1:t/100}function D(e){let t=be(e);if(t===null)return e;t=t||0;let r=(t&4278190080)>>>24,n=(t&16711680)>>>16,f=(t&65280)>>>8,o=(t&255)/255;return`rgba(${r}, ${n}, ${f}, ${o})`}var W=(e,t,r)=>{if(dist_esm_l.fun(e))return e;if(dist_esm_l.arr(e))return W({range:e,output:t,extrapolate:r});if(dist_esm_l.str(e.output[0]))return esm_k(e);let n=e,f=n.output,o=n.range||[0,1],i=n.extrapolateLeft||n.extrapolate||"extend",s=n.extrapolateRight||n.extrapolate||"extend",x=n.easing||(a=>a);return a=>{let F=He(a,o);return Ue(a,o[F],o[F+1],f[F],f[F+1],x,i,s,n.map)}};function Ue(e,t,r,n,f,o,i,s,x){let a=x?x(e):e;if(a<t){if(i==="identity")return a;i==="clamp"&&(a=t)}if(a>r){if(s==="identity")return a;s==="clamp"&&(a=r)}return n===f?n:t===r?e<=t?n:f:(t===-1/0?a=-a:r===1/0?a=a-t:a=(a-t)/(r-t),a=o(a),n===-1/0?a=-a:f===1/0?a=a+n:a=a*(f-n)+n,a)}function He(e,t){for(var r=1;r<t.length-1&&!(t[r]>=e);++r);return r-1}var Be=(e,t="end")=>r=>{r=t==="end"?Math.min(r,.999):Math.max(r,.001);let n=r*e,f=t==="end"?Math.floor(n):Math.ceil(n);return ne(0,1,f/e)},P=1.70158,L=P*1.525,xe=P+1,he=2*Math.PI/3,ye=2*Math.PI/4.5,V=e=>e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375,Lt={linear:e=>e,easeInQuad:e=>e*e,easeOutQuad:e=>1-(1-e)*(1-e),easeInOutQuad:e=>e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2,easeInCubic:e=>e*e*e,easeOutCubic:e=>1-Math.pow(1-e,3),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeInQuart:e=>e*e*e*e,easeOutQuart:e=>1-Math.pow(1-e,4),easeInOutQuart:e=>e<.5?8*e*e*e*e:1-Math.pow(-2*e+2,4)/2,easeInQuint:e=>e*e*e*e*e,easeOutQuint:e=>1-Math.pow(1-e,5),easeInOutQuint:e=>e<.5?16*e*e*e*e*e:1-Math.pow(-2*e+2,5)/2,easeInSine:e=>1-Math.cos(e*Math.PI/2),easeOutSine:e=>Math.sin(e*Math.PI/2),easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,easeInExpo:e=>e===0?0:Math.pow(2,10*e-10),easeOutExpo:e=>e===1?1:1-Math.pow(2,-10*e),easeInOutExpo:e=>e===0?0:e===1?1:e<.5?Math.pow(2,20*e-10)/2:(2-Math.pow(2,-20*e+10))/2,easeInCirc:e=>1-Math.sqrt(1-Math.pow(e,2)),easeOutCirc:e=>Math.sqrt(1-Math.pow(e-1,2)),easeInOutCirc:e=>e<.5?(1-Math.sqrt(1-Math.pow(2*e,2)))/2:(Math.sqrt(1-Math.pow(-2*e+2,2))+1)/2,easeInBack:e=>xe*e*e*e-P*e*e,easeOutBack:e=>1+xe*Math.pow(e-1,3)+P*Math.pow(e-1,2),easeInOutBack:e=>e<.5?Math.pow(2*e,2)*((L+1)*2*e-L)/2:(Math.pow(2*e-2,2)*((L+1)*(e*2-2)+L)+2)/2,easeInElastic:e=>e===0?0:e===1?1:-Math.pow(2,10*e-10)*Math.sin((e*10-10.75)*he),easeOutElastic:e=>e===0?0:e===1?1:Math.pow(2,-10*e)*Math.sin((e*10-.75)*he)+1,easeInOutElastic:e=>e===0?0:e===1?1:e<.5?-(Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*ye))/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*ye)/2+1,easeInBounce:e=>1-V(1-e),easeOutBounce:V,easeInOutBounce:e=>e<.5?(1-V(1-2*e))/2:(1+V(2*e-1))/2,steps:Be};var esm_g=Symbol.for("FluidValue.get"),dist_esm_m=Symbol.for("FluidValue.observers");var Pt=e=>Boolean(e&&e[esm_g]),ve=e=>e&&e[esm_g]?e[esm_g]():e,esm_qt=e=>e[dist_esm_m]||null;function je(e,t){e.eventObserved?e.eventObserved(t):e(t)}function $t(e,t){let r=e[dist_esm_m];r&&r.forEach(n=>{je(n,t)})}var esm_ge=class{[esm_g];[dist_esm_m];constructor(t){if(!t&&!(t=this.get))throw Error("Unknown getter");De(this,t)}},De=(e,t)=>Ee(e,esm_g,t);function Gt(e,t){if(e[esm_g]){let r=e[dist_esm_m];r||Ee(e,dist_esm_m,r=new Set),r.has(t)||(r.add(t),e.observerAdded&&e.observerAdded(r.size,t))}return t}function Qt(e,t){let r=e[dist_esm_m];if(r&&r.has(t)){let n=r.size-1;n?r.delete(t):e[dist_esm_m]=null,e.observerRemoved&&e.observerRemoved(n,t)}}var Ee=(e,t,r)=>Object.defineProperty(e,t,{value:r,writable:!0,configurable:!0});var O=/[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,esm_Oe=/(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,K=new RegExp(`(${O.source})(%|[a-z]+)`,"i"),we=/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,dist_esm_b=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;var esm_N=e=>{let[t,r]=We(e);if(!t||dist_esm_h())return e;let n=window.getComputedStyle(document.documentElement).getPropertyValue(t);if(n)return n.trim();if(r&&r.startsWith("--")){let f=window.getComputedStyle(document.documentElement).getPropertyValue(r);return f||e}else{if(r&&dist_esm_b.test(r))return esm_N(r);if(r)return r}return e},We=e=>{let t=dist_esm_b.exec(e);if(!t)return[,];let[,r,n]=t;return[r,n]};var _,esm_Ke=(e,t,r,n,f)=>`rgba(${Math.round(t)}, ${Math.round(r)}, ${Math.round(n)}, ${f})`,Xt=e=>{_||(_=dist_esm_c?new RegExp(`(${Object.keys(dist_esm_c).join("|")})(?!\\w)`,"g"):/^\b$/);let t=e.output.map(o=>ve(o).replace(dist_esm_b,esm_N).replace(esm_Oe,D).replace(_,D)),r=t.map(o=>o.match(O).map(Number)),f=r[0].map((o,i)=>r.map(s=>{if(!(i in s))throw Error('The arity of each "output" value must be equal');return s[i]})).map(o=>W({...e,output:o}));return o=>{let i=!K.test(t[0])&&t.find(x=>K.test(x))?.replace(O,""),s=0;return t[0].replace(O,()=>`${f[s++](o)}${i||""}`).replace(we,esm_Ke)}};var Z="react-spring: ",Te=e=>{let t=e,r=!1;if(typeof t!="function")throw new TypeError(`${Z}once requires a function parameter`);return(...n)=>{r||(t(...n),r=!0)}},Ne=Te(console.warn);function Jt(){Ne(`${Z}The "interpolate" function is deprecated in v9 (use "to" instead)`)}var _e=Te(console.warn);function er(){_e(`${Z}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)}function esm_or(e){return dist_esm_l.str(e)&&(e[0]=="#"||/\d/.test(e)||!dist_esm_h()&&dist_esm_b.test(e)||e in(dist_esm_c||{}))}var dist_esm_v,q=new WeakMap,Ze=e=>e.forEach(({target:t,contentRect:r})=>q.get(t)?.forEach(n=>n(r)));function Fe(e,t){dist_esm_v||typeof ResizeObserver<"u"&&(dist_esm_v=new ResizeObserver(Ze));let r=q.get(t);return r||(r=new Set,q.set(t,r)),r.add(e),dist_esm_v&&dist_esm_v.observe(t),()=>{let n=q.get(t);!n||(n.delete(e),!n.size&&dist_esm_v&&dist_esm_v.unobserve(t))}}var esm_$=new Set,dist_esm_w,esm_Xe=()=>{let e=()=>{esm_$.forEach(t=>t({width:window.innerWidth,height:window.innerHeight}))};return window.addEventListener("resize",e),()=>{window.removeEventListener("resize",e)}},Ie=e=>(esm_$.add(e),dist_esm_w||(dist_esm_w=esm_Xe()),()=>{esm_$.delete(e),!esm_$.size&&dist_esm_w&&(dist_esm_w(),dist_esm_w=void 0)});var ke=(e,{container:t=document.documentElement}={})=>t===document.documentElement?Ie(e):Fe(e,t);var Se=(e,t,r)=>t-e===0?1:(r-e)/(t-e);var esm_Ye={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}},esm_G=class{callback;container;info;constructor(t,r){this.callback=t,this.container=r,this.info={time:0,x:this.createAxis(),y:this.createAxis()}}createAxis=()=>({current:0,progress:0,scrollLength:0});updateAxis=t=>{let r=this.info[t],{length:n,position:f}=esm_Ye[t];r.current=this.container[`scroll${f}`],r.scrollLength=this.container["scroll"+n]-this.container["client"+n],r.progress=Se(0,r.scrollLength,r.current)};update=()=>{this.updateAxis("x"),this.updateAxis("y")};sendEvent=()=>{this.callback(this.info)};advance=()=>{this.update(),this.sendEvent()}};var esm_T=new WeakMap,Ae=new WeakMap,X=new WeakMap,Me=e=>e===document.documentElement?window:e,yr=(e,{container:t=document.documentElement}={})=>{let r=X.get(t);r||(r=new Set,X.set(t,r));let n=new esm_G(e,t);if(r.add(n),!esm_T.has(t)){let o=()=>(r?.forEach(s=>s.advance()),!0);esm_T.set(t,o);let i=Me(t);window.addEventListener("resize",o,{passive:!0}),t!==document.documentElement&&Ae.set(t,ke(o,{container:t})),i.addEventListener("scroll",o,{passive:!0})}let f=esm_T.get(t);return Re(f),()=>{Re.cancel(f);let o=X.get(t);if(!o||(o.delete(n),o.size))return;let i=esm_T.get(t);esm_T.delete(t),i&&(Me(t).removeEventListener("scroll",i),window.removeEventListener("resize",i),Ae.get(t)?.())}};function Er(e){let t=Je(null);return t.current===null&&(t.current=e()),t.current}var esm_Q=dist_esm_h()?external_React_.useEffect:external_React_.useLayoutEffect;var Ce=()=>{let e=(0,external_React_.useRef)(!1);return esm_Q(()=>(e.current=!0,()=>{e.current=!1}),[]),e};function Mr(){let e=(0,external_React_.useState)()[1],t=Ce();return()=>{t.current&&e(Math.random())}}function Lr(e,t){let[r]=(0,external_React_.useState)(()=>({inputs:t,result:e()})),n=(0,external_React_.useRef)(),f=n.current,o=f;return o?Boolean(t&&o.inputs&&it(t,o.inputs))||(o={inputs:t,result:e()}):o=r,(0,external_React_.useEffect)(()=>{n.current=o,f==r&&(r.inputs=r.result=void 0)},[o]),o.result}function it(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}var $r=e=>(0,external_React_.useEffect)(e,ut),ut=[];function Ur(e){let t=ct();return lt(()=>{t.current=e}),t.current}var Wr=()=>{let[e,t]=dt(null);return esm_Q(()=>{let r=window.matchMedia("(prefers-reduced-motion)"),n=f=>{t(f.matches),U({skipAnimation:f.matches})};return n(r),r.addEventListener("change",n),()=>{r.removeEventListener("change",n)}},[]),e};

;// ./node_modules/@react-spring/animated/dist/esm/index.js
var animated_dist_esm_h=Symbol.for("Animated:node"),animated_dist_esm_v=e=>!!e&&e[animated_dist_esm_h]===e,dist_esm_k=e=>e&&e[animated_dist_esm_h],esm_D=(e,t)=>mt(e,animated_dist_esm_h,t),F=e=>e&&e[animated_dist_esm_h]&&e[animated_dist_esm_h].getPayload(),animated_dist_esm_c=class{payload;constructor(){esm_D(this,this)}getPayload(){return this.payload||[]}};var animated_dist_esm_l=class extends animated_dist_esm_c{constructor(r){super();this._value=r;dist_esm_l.num(this._value)&&(this.lastPosition=this._value)}done=!0;elapsedTime;lastPosition;lastVelocity;v0;durationProgress=0;static create(r){return new animated_dist_esm_l(r)}getPayload(){return[this]}getValue(){return this._value}setValue(r,n){return dist_esm_l.num(r)&&(this.lastPosition=r,n&&(r=Math.round(r/n)*n,this.done&&(this.lastPosition=r))),this._value===r?!1:(this._value=r,!0)}reset(){let{done:r}=this;this.done=!1,dist_esm_l.num(this._value)&&(this.elapsedTime=0,this.durationProgress=0,this.lastPosition=this._value,r&&(this.lastVelocity=null),this.v0=null)}};var animated_dist_esm_d=class extends animated_dist_esm_l{_string=null;_toString;constructor(t){super(0),this._toString=W({output:[t,t]})}static create(t){return new animated_dist_esm_d(t)}getValue(){let t=this._string;return t??(this._string=this._toString(this._value))}setValue(t){if(dist_esm_l.str(t)){if(t==this._string)return!1;this._string=t,this._value=1}else if(super.setValue(t))this._string=null;else return!1;return!0}reset(t){t&&(this._toString=W({output:[this.getValue(),t]})),this._value=0,super.reset()}};var dist_esm_f={dependencies:null};var animated_dist_esm_u=class extends animated_dist_esm_c{constructor(r){super();this.source=r;this.setValue(r)}getValue(r){let n={};return xt(this.source,(a,i)=>{animated_dist_esm_v(a)?n[i]=a.getValue(r):Pt(a)?n[i]=ve(a):r||(n[i]=a)}),n}setValue(r){this.source=r,this.payload=this._makePayload(r)}reset(){this.payload&&esm_Ve(this.payload,r=>r.reset())}_makePayload(r){if(r){let n=new Set;return xt(r,this._addToPayload,n),Array.from(n)}}_addToPayload(r){dist_esm_f.dependencies&&Pt(r)&&dist_esm_f.dependencies.add(r);let n=F(r);n&&esm_Ve(n,a=>this.add(a))}};var animated_dist_esm_y=class extends animated_dist_esm_u{constructor(t){super(t)}static create(t){return new animated_dist_esm_y(t)}getValue(){return this.source.map(t=>t.getValue())}setValue(t){let r=this.getPayload();return t.length==r.length?r.map((n,a)=>n.setValue(t[a])).some(Boolean):(super.setValue(t.map(dist_esm_z)),!0)}};function dist_esm_z(e){return(esm_or(e)?animated_dist_esm_d:animated_dist_esm_l).create(e)}function esm_Le(e){let t=dist_esm_k(e);return t?t.constructor:dist_esm_l.arr(e)?animated_dist_esm_y:esm_or(e)?animated_dist_esm_d:animated_dist_esm_l}var dist_esm_x=(e,t)=>{let r=!dist_esm_l.fun(e)||e.prototype&&e.prototype.isReactComponent;return (0,external_React_.forwardRef)((n,a)=>{let i=(0,external_React_.useRef)(null),o=r&&(0,external_React_.useCallback)(s=>{i.current=esm_ae(a,s)},[a]),[m,T]=esm_ne(n,t),W=Mr(),P=()=>{let s=i.current;if(r&&!s)return;(s?t.applyAnimatedValues(s,m.getValue(!0)):!1)===!1&&W()},_=new animated_dist_esm_b(P,T),p=(0,external_React_.useRef)();esm_Q(()=>(p.current=_,esm_Ve(T,s=>Gt(s,_)),()=>{p.current&&(esm_Ve(p.current.deps,s=>Qt(s,p.current)),esm_n.cancel(p.current.update))})),(0,external_React_.useEffect)(P,[]),$r(()=>()=>{let s=p.current;esm_Ve(s.deps,S=>Qt(S,s))});let $=t.getComponentProps(m.getValue());return external_React_.createElement(e,{...$,ref:o})})},animated_dist_esm_b=class{constructor(t,r){this.update=t;this.deps=r}eventObserved(t){t.type=="change"&&esm_n.write(this.update)}};function esm_ne(e,t){let r=new Set;return dist_esm_f.dependencies=r,e.style&&(e={...e,style:t.createAnimatedStyle(e.style)}),e=new animated_dist_esm_u(e),dist_esm_f.dependencies=null,[e,r]}function esm_ae(e,t){return e&&(dist_esm_l.fun(e)?e(t):e.current=t),t}var dist_esm_j=Symbol.for("AnimatedComponent"),dist_esm_Ke=(e,{applyAnimatedValues:t=()=>!1,createAnimatedStyle:r=a=>new animated_dist_esm_u(a),getComponentProps:n=a=>a}={})=>{let a={applyAnimatedValues:t,createAnimatedStyle:r,getComponentProps:n},i=o=>{let m=esm_I(o)||"Anonymous";return dist_esm_l.str(o)?o=i[o]||(i[o]=dist_esm_x(o,a)):o=o[dist_esm_j]||(o[dist_esm_j]=dist_esm_x(o,a)),o.displayName=`Animated(${m})`,o};return xt(e,(o,m)=>{dist_esm_l.arr(e)&&(m=esm_I(o)),i[m]=i(o)}),{animated:i}},esm_I=e=>dist_esm_l.str(e)?e:e&&dist_esm_l.str(e.displayName)?e.displayName:dist_esm_l.fun(e)&&e.name||null;

;// ./node_modules/@react-spring/core/dist/esm/index.js
function dist_esm_I(t,...e){return dist_esm_l.fun(t)?t(...e):t}var esm_te=(t,e)=>t===!0||!!(e&&t&&(dist_esm_l.fun(t)?t(e):ht(t).includes(e))),et=(t,e)=>dist_esm_l.obj(t)?e&&t[e]:t;var esm_ke=(t,e)=>t.default===!0?t[e]:t.default?t.default[e]:void 0,nn=t=>t,dist_esm_ne=(t,e=nn)=>{let n=rn;t.default&&t.default!==!0&&(t=t.default,n=Object.keys(t));let r={};for(let o of n){let s=e(t[o],o);dist_esm_l.und(s)||(r[o]=s)}return r},rn=["config","onProps","onStart","onChange","onPause","onResume","onRest"],on={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};function sn(t){let e={},n=0;if(xt(t,(r,o)=>{on[o]||(e[o]=r,n++)}),n)return e}function esm_de(t){let e=sn(t);if(e){let n={to:e};return xt(t,(r,o)=>o in e||(n[o]=r)),n}return{...t}}function esm_me(t){return t=ve(t),dist_esm_l.arr(t)?t.map(esm_me):esm_or(t)?dist_esm_p.createStringInterpolator({range:[0,1],output:[t,t]})(1):t}function esm_Ue(t){for(let e in t)return!0;return!1}function esm_Ee(t){return dist_esm_l.fun(t)||dist_esm_l.arr(t)&&dist_esm_l.obj(t[0])}function esm_xe(t,e){t.ref?.delete(t),e?.delete(t)}function esm_he(t,e){e&&t.ref!==e&&(t.ref?.delete(t),e.add(t),t.ref=e)}function wr(t,e,n=1e3){an(()=>{if(e){let r=0;ge(t,(o,s)=>{let a=o.current;if(a.length){let i=n*e[s];isNaN(i)?i=r:r=i,ge(a,u=>{ge(u.queue,p=>{let f=p.delay;p.delay=d=>i+dist_esm_I(f||0,d)})}),o.start()}})}else{let r=Promise.resolve();ge(t,o=>{let s=o.current;if(s.length){let a=s.map(i=>{let u=i.queue;return i.queue=[],u});r=r.then(()=>(ge(s,(i,u)=>ge(a[u]||[],p=>i.queue.push(p))),Promise.all(o.start())))}})}})}var esm_mt={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,friction:120}};var tt={...esm_mt.default,mass:1,damping:1,easing:Lt.linear,clamp:!1},esm_we=class{tension;friction;frequency;damping;mass;velocity=0;restVelocity;precision;progress;duration;easing;clamp;bounce;decay;round;constructor(){Object.assign(this,tt)}};function gt(t,e,n){n&&(n={...n},esm_ht(n,e),e={...n,...e}),esm_ht(t,e),Object.assign(t,e);for(let a in tt)t[a]==null&&(t[a]=tt[a]);let{mass:r,frequency:o,damping:s}=t;return dist_esm_l.und(o)||(o<.01&&(o=.01),s<0&&(s=0),t.tension=Math.pow(2*Math.PI/o,2)*r,t.friction=4*Math.PI*s*r/o),t}function esm_ht(t,e){if(!dist_esm_l.und(e.decay))t.duration=void 0;else{let n=!dist_esm_l.und(e.tension)||!dist_esm_l.und(e.friction);(n||!dist_esm_l.und(e.frequency)||!dist_esm_l.und(e.damping)||!dist_esm_l.und(e.mass))&&(t.duration=void 0,t.decay=void 0),n&&(t.frequency=void 0)}}var esm_yt=[],dist_esm_Le=class{changed=!1;values=esm_yt;toValues=null;fromValues=esm_yt;to;from;config=new esm_we;immediate=!1};function esm_Me(t,{key:e,props:n,defaultProps:r,state:o,actions:s}){return new Promise((a,i)=>{let u,p,f=esm_te(n.cancel??r?.cancel,e);if(f)b();else{dist_esm_l.und(n.pause)||(o.paused=esm_te(n.pause,e));let c=r?.pause;c!==!0&&(c=o.paused||esm_te(c,e)),u=dist_esm_I(n.delay||0,e),c?(o.resumeQueue.add(m),s.pause()):(s.resume(),m())}function d(){o.resumeQueue.add(m),o.timeouts.delete(p),p.cancel(),u=p.time-esm_n.now()}function m(){u>0&&!dist_esm_p.skipAnimation?(o.delayed=!0,p=esm_n.setTimeout(b,u),o.pauseQueue.add(d),o.timeouts.add(p)):b()}function b(){o.delayed&&(o.delayed=!1),o.pauseQueue.delete(d),o.timeouts.delete(p),t<=(o.cancelId||0)&&(f=!0);try{s.start({...n,callId:t,cancel:f},a)}catch(c){i(c)}}})}var esm_be=(t,e)=>e.length==1?e[0]:e.some(n=>n.cancelled)?esm_q(t.get()):e.every(n=>n.noop)?nt(t.get()):dist_esm_E(t.get(),e.every(n=>n.finished)),nt=t=>({value:t,noop:!0,finished:!0,cancelled:!1}),dist_esm_E=(t,e,n=!1)=>({value:t,finished:e,cancelled:n}),esm_q=t=>({value:t,cancelled:!0,finished:!1});function esm_De(t,e,n,r){let{callId:o,parentId:s,onRest:a}=e,{asyncTo:i,promise:u}=n;return!s&&t===i&&!e.reset?u:n.promise=(async()=>{n.asyncId=o,n.asyncTo=t;let p=dist_esm_ne(e,(l,h)=>h==="onRest"?void 0:l),f,d,m=new Promise((l,h)=>(f=l,d=h)),b=l=>{let h=o<=(n.cancelId||0)&&esm_q(r)||o!==n.asyncId&&dist_esm_E(r,!1);if(h)throw l.result=h,d(l),l},c=(l,h)=>{let g=new esm_Ae,x=new esm_Ne;return(async()=>{if(dist_esm_p.skipAnimation)throw esm_oe(n),x.result=dist_esm_E(r,!1),d(x),x;b(g);let S=dist_esm_l.obj(l)?{...l}:{...h,to:l};S.parentId=o,xt(p,(V,_)=>{dist_esm_l.und(S[_])&&(S[_]=V)});let A=await r.start(S);return b(g),n.paused&&await new Promise(V=>{n.resumeQueue.add(V)}),A})()},P;if(dist_esm_p.skipAnimation)return esm_oe(n),dist_esm_E(r,!1);try{let l;dist_esm_l.arr(t)?l=(async h=>{for(let g of h)await c(g)})(t):l=Promise.resolve(t(c,r.stop.bind(r))),await Promise.all([l.then(f),m]),P=dist_esm_E(r.get(),!0,!1)}catch(l){if(l instanceof esm_Ae)P=l.result;else if(l instanceof esm_Ne)P=l.result;else throw l}finally{o==n.asyncId&&(n.asyncId=s,n.asyncTo=s?i:void 0,n.promise=s?u:void 0)}return dist_esm_l.fun(a)&&esm_n.batchedUpdates(()=>{a(P,r,r.item)}),P})()}function esm_oe(t,e){Pe(t.timeouts,n=>n.cancel()),t.pauseQueue.clear(),t.resumeQueue.clear(),t.asyncId=t.asyncTo=t.promise=void 0,e&&(t.cancelId=e)}var esm_Ae=class extends Error{result;constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.")}},esm_Ne=class extends Error{result;constructor(){super("SkipAnimationSignal")}};var esm_Re=t=>t instanceof esm_X,Sn=1,esm_X=class extends esm_ge{id=Sn++;_priority=0;get priority(){return this._priority}set priority(e){this._priority!=e&&(this._priority=e,this._onPriorityChange(e))}get(){let e=dist_esm_k(this);return e&&e.getValue()}to(...e){return dist_esm_p.to(this,e)}interpolate(...e){return Jt(),dist_esm_p.to(this,e)}toJSON(){return this.get()}observerAdded(e){e==1&&this._attach()}observerRemoved(e){e==0&&this._detach()}_attach(){}_detach(){}_onChange(e,n=!1){$t(this,{type:"change",parent:this,value:e,idle:n})}_onPriorityChange(e){this.idle||qe.sort(this),$t(this,{type:"priority",parent:this,priority:e})}};var esm_se=Symbol.for("SpringPhase"),esm_bt=1,rt=2,ot=4,esm_qe=t=>(t[esm_se]&esm_bt)>0,dist_esm_Q=t=>(t[esm_se]&rt)>0,esm_ye=t=>(t[esm_se]&ot)>0,st=(t,e)=>e?t[esm_se]|=rt|esm_bt:t[esm_se]&=~rt,esm_it=(t,e)=>e?t[esm_se]|=ot:t[esm_se]&=~ot;var esm_ue=class extends esm_X{key;animation=new dist_esm_Le;queue;defaultProps={};_state={paused:!1,delayed:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};_pendingCalls=new Set;_lastCallId=0;_lastToId=0;_memoizedDuration=0;constructor(e,n){if(super(),!dist_esm_l.und(e)||!dist_esm_l.und(n)){let r=dist_esm_l.obj(e)?{...e}:{...n,from:e};dist_esm_l.und(r.default)&&(r.default=!0),this.start(r)}}get idle(){return!(dist_esm_Q(this)||this._state.asyncTo)||esm_ye(this)}get goal(){return ve(this.animation.to)}get velocity(){let e=dist_esm_k(this);return e instanceof animated_dist_esm_l?e.lastVelocity||0:e.getPayload().map(n=>n.lastVelocity||0)}get hasAnimated(){return esm_qe(this)}get isAnimating(){return dist_esm_Q(this)}get isPaused(){return esm_ye(this)}get isDelayed(){return this._state.delayed}advance(e){let n=!0,r=!1,o=this.animation,{config:s,toValues:a}=o,i=F(o.to);!i&&Pt(o.to)&&(a=ht(ve(o.to))),o.values.forEach((f,d)=>{if(f.done)return;let m=f.constructor==animated_dist_esm_d?1:i?i[d].lastPosition:a[d],b=o.immediate,c=m;if(!b){if(c=f.lastPosition,s.tension<=0){f.done=!0;return}let P=f.elapsedTime+=e,l=o.fromValues[d],h=f.v0!=null?f.v0:f.v0=dist_esm_l.arr(s.velocity)?s.velocity[d]:s.velocity,g,x=s.precision||(l==m?.005:Math.min(1,Math.abs(m-l)*.001));if(dist_esm_l.und(s.duration))if(s.decay){let S=s.decay===!0?.998:s.decay,A=Math.exp(-(1-S)*P);c=l+h/(1-S)*(1-A),b=Math.abs(f.lastPosition-c)<=x,g=h*A}else{g=f.lastVelocity==null?h:f.lastVelocity;let S=s.restVelocity||x/10,A=s.clamp?0:s.bounce,V=!dist_esm_l.und(A),_=l==m?f.v0>0:l<m,v,w=!1,C=1,$=Math.ceil(e/C);for(let L=0;L<$&&(v=Math.abs(g)>S,!(!v&&(b=Math.abs(m-c)<=x,b)));++L){V&&(w=c==m||c>m==_,w&&(g=-g*A,c=m));let N=-s.tension*1e-6*(c-m),y=-s.friction*.001*g,T=(N+y)/s.mass;g=g+T*C,c=c+g*C}}else{let S=1;s.duration>0&&(this._memoizedDuration!==s.duration&&(this._memoizedDuration=s.duration,f.durationProgress>0&&(f.elapsedTime=s.duration*f.durationProgress,P=f.elapsedTime+=e)),S=(s.progress||0)+P/this._memoizedDuration,S=S>1?1:S<0?0:S,f.durationProgress=S),c=l+s.easing(S)*(m-l),g=(c-f.lastPosition)/e,b=S==1}f.lastVelocity=g,Number.isNaN(c)&&(console.warn("Got NaN while animating:",this),b=!0)}i&&!i[d].done&&(b=!1),b?f.done=!0:n=!1,f.setValue(c,s.round)&&(r=!0)});let u=dist_esm_k(this),p=u.getValue();if(n){let f=ve(o.to);(p!==f||r)&&!s.decay?(u.setValue(f),this._onChange(f)):r&&s.decay&&this._onChange(p),this._stop()}else r&&this._onChange(p)}set(e){return esm_n.batchedUpdates(()=>{this._stop(),this._focus(e),this._set(e)}),this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(dist_esm_Q(this)){let{to:e,config:n}=this.animation;esm_n.batchedUpdates(()=>{this._onStart(),n.decay||this._set(e,!1),this._stop()})}return this}update(e){return(this.queue||(this.queue=[])).push(e),this}start(e,n){let r;return dist_esm_l.und(e)?(r=this.queue||[],this.queue=[]):r=[dist_esm_l.obj(e)?e:{...n,to:e}],Promise.all(r.map(o=>this._update(o))).then(o=>esm_be(this,o))}stop(e){let{to:n}=this.animation;return this._focus(this.get()),esm_oe(this._state,e&&this._lastCallId),esm_n.batchedUpdates(()=>this._stop(n,e)),this}reset(){this._update({reset:!0})}eventObserved(e){e.type=="change"?this._start():e.type=="priority"&&(this.priority=e.priority+1)}_prepareNode(e){let n=this.key||"",{to:r,from:o}=e;r=dist_esm_l.obj(r)?r[n]:r,(r==null||esm_Ee(r))&&(r=void 0),o=dist_esm_l.obj(o)?o[n]:o,o==null&&(o=void 0);let s={to:r,from:o};return esm_qe(this)||(e.reverse&&([r,o]=[o,r]),o=ve(o),dist_esm_l.und(o)?dist_esm_k(this)||this._set(r):this._set(o)),s}_update({...e},n){let{key:r,defaultProps:o}=this;e.default&&Object.assign(o,dist_esm_ne(e,(i,u)=>/^on/.test(u)?et(i,r):i)),_t(this,e,"onProps"),esm_Ie(this,"onProps",e,this);let s=this._prepareNode(e);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");let a=this._state;return esm_Me(++this._lastCallId,{key:r,props:e,defaultProps:o,state:a,actions:{pause:()=>{esm_ye(this)||(esm_it(this,!0),yt(a.pauseQueue),esm_Ie(this,"onPause",dist_esm_E(this,esm_Ce(this,this.animation.to)),this))},resume:()=>{esm_ye(this)&&(esm_it(this,!1),dist_esm_Q(this)&&this._resume(),yt(a.resumeQueue),esm_Ie(this,"onResume",dist_esm_E(this,esm_Ce(this,this.animation.to)),this))},start:this._merge.bind(this,s)}}).then(i=>{if(e.loop&&i.finished&&!(n&&i.noop)){let u=at(e);if(u)return this._update(u,!0)}return i})}_merge(e,n,r){if(n.cancel)return this.stop(!0),r(esm_q(this));let o=!dist_esm_l.und(e.to),s=!dist_esm_l.und(e.from);if(o||s)if(n.callId>this._lastToId)this._lastToId=n.callId;else return r(esm_q(this));let{key:a,defaultProps:i,animation:u}=this,{to:p,from:f}=u,{to:d=p,from:m=f}=e;s&&!o&&(!n.default||dist_esm_l.und(d))&&(d=m),n.reverse&&([d,m]=[m,d]);let b=!bt(m,f);b&&(u.from=m),m=ve(m);let c=!bt(d,p);c&&this._focus(d);let P=esm_Ee(n.to),{config:l}=u,{decay:h,velocity:g}=l;(o||s)&&(l.velocity=0),n.config&&!P&&gt(l,dist_esm_I(n.config,a),n.config!==i.config?dist_esm_I(i.config,a):void 0);let x=dist_esm_k(this);if(!x||dist_esm_l.und(d))return r(dist_esm_E(this,!0));let S=dist_esm_l.und(n.reset)?s&&!n.default:!dist_esm_l.und(m)&&esm_te(n.reset,a),A=S?m:this.get(),V=esm_me(d),_=dist_esm_l.num(V)||dist_esm_l.arr(V)||esm_or(V),v=!P&&(!_||esm_te(i.immediate||n.immediate,a));if(c){let L=esm_Le(d);if(L!==x.constructor)if(v)x=this._set(V);else throw Error(`Cannot animate between ${x.constructor.name} and ${L.name}, as the "to" prop suggests`)}let w=x.constructor,C=Pt(d),$=!1;if(!C){let L=S||!esm_qe(this)&&b;(c||L)&&($=bt(esm_me(A),V),C=!$),(!bt(u.immediate,v)&&!v||!bt(l.decay,h)||!bt(l.velocity,g))&&(C=!0)}if($&&dist_esm_Q(this)&&(u.changed&&!S?C=!0:C||this._stop(p)),!P&&((C||Pt(p))&&(u.values=x.getPayload(),u.toValues=Pt(d)?null:w==animated_dist_esm_d?[1]:ht(V)),u.immediate!=v&&(u.immediate=v,!v&&!S&&this._set(p)),C)){let{onRest:L}=u;esm_Ve(_n,y=>_t(this,n,y));let N=dist_esm_E(this,esm_Ce(this,p));yt(this._pendingCalls,N),this._pendingCalls.add(r),u.changed&&esm_n.batchedUpdates(()=>{u.changed=!S,L?.(N,this),S?dist_esm_I(i.onRest,N):u.onStart?.(N,this)})}S&&this._set(A),P?r(esm_De(n.to,n,this._state,this)):C?this._start():dist_esm_Q(this)&&!c?this._pendingCalls.add(r):r(nt(A))}_focus(e){let n=this.animation;e!==n.to&&(esm_qt(this)&&this._detach(),n.to=e,esm_qt(this)&&this._attach())}_attach(){let e=0,{to:n}=this.animation;Pt(n)&&(Gt(n,this),esm_Re(n)&&(e=n.priority+1)),this.priority=e}_detach(){let{to:e}=this.animation;Pt(e)&&Qt(e,this)}_set(e,n=!0){let r=ve(e);if(!dist_esm_l.und(r)){let o=dist_esm_k(this);if(!o||!bt(r,o.getValue())){let s=esm_Le(r);!o||o.constructor!=s?esm_D(this,s.create(r)):o.setValue(r),o&&esm_n.batchedUpdates(()=>{this._onChange(r,n)})}}return dist_esm_k(this)}_onStart(){let e=this.animation;e.changed||(e.changed=!0,esm_Ie(this,"onStart",dist_esm_E(this,esm_Ce(this,e.to)),this))}_onChange(e,n){n||(this._onStart(),dist_esm_I(this.animation.onChange,e,this)),dist_esm_I(this.defaultProps.onChange,e,this),super._onChange(e,n)}_start(){let e=this.animation;dist_esm_k(this).reset(ve(e.to)),e.immediate||(e.fromValues=e.values.map(n=>n.lastPosition)),dist_esm_Q(this)||(st(this,!0),esm_ye(this)||this._resume())}_resume(){dist_esm_p.skipAnimation?this.finish():qe.start(this)}_stop(e,n){if(dist_esm_Q(this)){st(this,!1);let r=this.animation;esm_Ve(r.values,s=>{s.done=!0}),r.toValues&&(r.onChange=r.onPause=r.onResume=void 0),$t(this,{type:"idle",parent:this});let o=n?esm_q(this.get()):dist_esm_E(this.get(),esm_Ce(this,e??r.to));yt(this._pendingCalls,o),r.changed&&(r.changed=!1,esm_Ie(this,"onRest",o,this))}}};function esm_Ce(t,e){let n=esm_me(e),r=esm_me(t.get());return bt(r,n)}function at(t,e=t.loop,n=t.to){let r=dist_esm_I(e);if(r){let o=r!==!0&&esm_de(r),s=(o||t).reverse,a=!o||o.reset;return esm_Pe({...t,loop:e,default:!1,pause:void 0,to:!s||esm_Ee(n)?n:void 0,from:a?t.from:void 0,reset:a,...o})}}function esm_Pe(t){let{to:e,from:n}=t=esm_de(t),r=new Set;return dist_esm_l.obj(e)&&Vt(e,r),dist_esm_l.obj(n)&&Vt(n,r),t.keys=r.size?Array.from(r):null,t}function Ot(t){let e=esm_Pe(t);return R.und(e.default)&&(e.default=dist_esm_ne(e)),e}function Vt(t,e){xt(t,(n,r)=>n!=null&&e.add(r))}var _n=["onStart","onRest","onChange","onPause","onResume"];function _t(t,e,n){t.animation[n]=e[n]!==esm_ke(e,n)?et(e[n],t.key):void 0}function esm_Ie(t,e,...n){t.animation[e]?.(...n),t.defaultProps[e]?.(...n)}var Fn=["onStart","onChange","onRest"],kn=1,esm_le=class{id=kn++;springs={};queue=[];ref;_flush;_initialProps;_lastAsyncId=0;_active=new Set;_changed=new Set;_started=!1;_item;_state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};_events={onStart:new Map,onChange:new Map,onRest:new Map};constructor(e,n){this._onFrame=this._onFrame.bind(this),n&&(this._flush=n),e&&this.start({default:!0,...e})}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every(e=>e.idle&&!e.isDelayed&&!e.isPaused)}get item(){return this._item}set item(e){this._item=e}get(){let e={};return this.each((n,r)=>e[r]=n.get()),e}set(e){for(let n in e){let r=e[n];dist_esm_l.und(r)||this.springs[n].set(r)}}update(e){return e&&this.queue.push(esm_Pe(e)),this}start(e){let{queue:n}=this;return e?n=ht(e).map(esm_Pe):this.queue=[],this._flush?this._flush(this,n):(jt(this,n),esm_ze(this,n))}stop(e,n){if(e!==!!e&&(n=e),n){let r=this.springs;esm_Ve(ht(n),o=>r[o].stop(!!e))}else esm_oe(this._state,this._lastAsyncId),this.each(r=>r.stop(!!e));return this}pause(e){if(dist_esm_l.und(e))this.start({pause:!0});else{let n=this.springs;esm_Ve(ht(e),r=>n[r].pause())}return this}resume(e){if(dist_esm_l.und(e))this.start({pause:!1});else{let n=this.springs;esm_Ve(ht(e),r=>n[r].resume())}return this}each(e){xt(this.springs,e)}_onFrame(){let{onStart:e,onChange:n,onRest:r}=this._events,o=this._active.size>0,s=this._changed.size>0;(o&&!this._started||s&&!this._started)&&(this._started=!0,Pe(e,([u,p])=>{p.value=this.get(),u(p,this,this._item)}));let a=!o&&this._started,i=s||a&&r.size?this.get():null;s&&n.size&&Pe(n,([u,p])=>{p.value=i,u(p,this,this._item)}),a&&(this._started=!1,Pe(r,([u,p])=>{p.value=i,u(p,this,this._item)}))}eventObserved(e){if(e.type=="change")this._changed.add(e.parent),e.idle||this._active.add(e.parent);else if(e.type=="idle")this._active.delete(e.parent);else return;esm_n.onFrame(this._onFrame)}};function esm_ze(t,e){return Promise.all(e.map(n=>wt(t,n))).then(n=>esm_be(t,n))}async function wt(t,e,n){let{keys:r,to:o,from:s,loop:a,onRest:i,onResolve:u}=e,p=dist_esm_l.obj(e.default)&&e.default;a&&(e.loop=!1),o===!1&&(e.to=null),s===!1&&(e.from=null);let f=dist_esm_l.arr(o)||dist_esm_l.fun(o)?o:void 0;f?(e.to=void 0,e.onRest=void 0,p&&(p.onRest=void 0)):esm_Ve(Fn,P=>{let l=e[P];if(dist_esm_l.fun(l)){let h=t._events[P];e[P]=({finished:g,cancelled:x})=>{let S=h.get(l);S?(g||(S.finished=!1),x&&(S.cancelled=!0)):h.set(l,{value:null,finished:g||!1,cancelled:x||!1})},p&&(p[P]=e[P])}});let d=t._state;e.pause===!d.paused?(d.paused=e.pause,yt(e.pause?d.pauseQueue:d.resumeQueue)):d.paused&&(e.pause=!0);let m=(r||Object.keys(t.springs)).map(P=>t.springs[P].start(e)),b=e.cancel===!0||esm_ke(e,"cancel")===!0;(f||b&&d.asyncId)&&m.push(esm_Me(++t._lastAsyncId,{props:e,state:d,actions:{pause:Y,resume:Y,start(P,l){b?(esm_oe(d,t._lastAsyncId),l(esm_q(t))):(P.onRest=i,l(esm_De(f,P,d,t)))}}})),d.paused&&await new Promise(P=>{d.resumeQueue.add(P)});let c=esm_be(t,await Promise.all(m));if(a&&c.finished&&!(n&&c.noop)){let P=at(e,a,o);if(P)return jt(t,[P]),wt(t,P,!0)}return u&&esm_n.batchedUpdates(()=>u(c,t,t.item)),c}function esm_e(t,e){let n={...t.springs};return e&&pe(Ve(e),r=>{z.und(r.keys)&&(r=esm_Pe(r)),z.obj(r.to)||(r={...r,to:void 0}),Mt(n,r,o=>esm_Lt(o))}),pt(t,n),n}function pt(t,e){Ut(e,(n,r)=>{t.springs[r]||(t.springs[r]=n,Et(n,t))})}function esm_Lt(t,e){let n=new esm_ue;return n.key=t,e&&Gt(n,e),n}function Mt(t,e,n){e.keys&&esm_Ve(e.keys,r=>{(t[r]||(t[r]=n(r)))._prepareNode(e)})}function jt(t,e){esm_Ve(e,n=>{Mt(t.springs,n,r=>esm_Lt(r,t))})}var dist_esm_H=({children:t,...e})=>{let n=(0,external_React_.useContext)(esm_Ge),r=e.pause||!!n.pause,o=e.immediate||!!n.immediate;e=Lr(()=>({pause:r,immediate:o}),[r,o]);let{Provider:s}=esm_Ge;return external_React_.createElement(s,{value:e},t)},esm_Ge=wn(dist_esm_H,{});dist_esm_H.Provider=esm_Ge.Provider;dist_esm_H.Consumer=esm_Ge.Consumer;function wn(t,e){return Object.assign(t,external_React_.createContext(e)),t.Provider._context=t,t.Consumer._context=t,t}var esm_fe=()=>{let t=[],e=function(r){Ln();let o=[];return ce(t,(s,a)=>{if(Ke.und(r))o.push(s.start());else{let i=n(r,s,a);i&&o.push(s.start(i))}}),o};e.current=t,e.add=function(r){t.includes(r)||t.push(r)},e.delete=function(r){let o=t.indexOf(r);~o&&t.splice(o,1)},e.pause=function(){return ce(t,r=>r.pause(...arguments)),this},e.resume=function(){return ce(t,r=>r.resume(...arguments)),this},e.set=function(r){ce(t,(o,s)=>{let a=Ke.fun(r)?r(s,o):r;a&&o.set(a)})},e.start=function(r){let o=[];return ce(t,(s,a)=>{if(Ke.und(r))o.push(s.start());else{let i=this._getProps(r,s,a);i&&o.push(s.start(i))}}),o},e.stop=function(){return ce(t,r=>r.stop(...arguments)),this},e.update=function(r){return ce(t,(o,s)=>o.update(this._getProps(r,o,s))),this};let n=function(r,o,s){return Ke.fun(r)?r(s,o):r};return e._getProps=n,e};function esm_He(t,e,n){let r=jn.fun(e)&&e;r&&!n&&(n=[]);let o=Xe(()=>r||arguments.length==3?esm_fe():void 0,[]),s=Nt(0),a=Dn(),i=Xe(()=>({ctrls:[],queue:[],flush(h,g){let x=esm_e(h,g);return s.current>0&&!i.queue.length&&!Object.keys(x).some(A=>!h.springs[A])?esm_ze(h,g):new Promise(A=>{pt(h,x),i.queue.push(()=>{A(esm_ze(h,g))}),a()})}}),[]),u=Nt([...i.ctrls]),p=[],f=Dt(t)||0;Xe(()=>{Ye(u.current.slice(t,f),h=>{esm_xe(h,o),h.stop(!0)}),u.current.length=t,d(f,t)},[t]),Xe(()=>{d(0,Math.min(f,t))},n);function d(h,g){for(let x=h;x<g;x++){let S=u.current[x]||(u.current[x]=new esm_le(null,i.flush)),A=r?r(x,S):e[x];A&&(p[x]=Ot(A))}}let m=u.current.map((h,g)=>esm_e(h,p[g])),b=Mn(dist_esm_H),c=Dt(b),P=b!==c&&esm_Ue(b);qn(()=>{s.current++,i.ctrls=u.current;let{queue:h}=i;h.length&&(i.queue=[],Ye(h,g=>g())),Ye(u.current,(g,x)=>{o?.add(g),P&&g.start({default:b});let S=p[x];S&&(esm_he(g,S.ref),g.ref?g.queue.push(S):g.start(S))})}),Nn(()=>()=>{Ye(i.ctrls,h=>h.stop(!0))});let l=m.map(h=>({...h}));return o?[l,o]:l}function esm_J(t,e){let n=Qn.fun(t),[[r],o]=esm_He(1,n?t:[t],n?e||[]:e);return n||arguments.length==2?[r,o]:r}var Gn=()=>esm_fe(),Xo=()=>zn(Gn)[0];var Wo=(t,e)=>{let n=Bn(()=>new esm_ue(t,e));return Kn(()=>()=>{n.stop()}),n};function esm_Qt(t,e,n){let r=qt.fun(e)&&e;r&&!n&&(n=[]);let o=!0,s,a=esm_He(t,(i,u)=>{let p=r?r(i,u):e;return s=p.ref,o=o&&p.reverse,p},n||[{}]);if(Yn(()=>{Xn(a[1].current,(i,u)=>{let p=a[1].current[u+(o?1:-1)];if(esm_he(i,s),i.ref){p&&i.update({to:p.springs});return}p?i.start({to:p.springs}):i.start()})},n),r||arguments.length==3){let i=s??a[1];return i._getProps=(u,p,f)=>{let d=qt.fun(u)?u(f,p):u;if(d){let m=i.current[f+(d.reverse?1:-1)];return m&&(d.to=m.springs),d}},a}return a[0]}function esm_Gt(t,e,n){let r=G.fun(e)&&e,{reset:o,sort:s,trail:a=0,expires:i=!0,exitBeforeEnter:u=!1,onDestroyed:p,ref:f,config:d}=r?r():e,m=Jn(()=>r||arguments.length==3?esm_fe():void 0,[]),b=zt(t),c=[],P=lt(null),l=o?null:P.current;Je(()=>{P.current=c}),$n(()=>(j(c,y=>{m?.add(y.ctrl),y.ctrl.ref=m}),()=>{j(P.current,y=>{y.expired&&clearTimeout(y.expirationId),esm_xe(y.ctrl,m),y.ctrl.stop(!0)})}));let h=tr(b,r?r():e,l),g=o&&P.current||[];Je(()=>j(g,({ctrl:y,item:T,key:F})=>{esm_xe(y,m),dist_esm_I(p,T,F)}));let x=[];if(l&&j(l,(y,T)=>{y.expired?(clearTimeout(y.expirationId),g.push(y)):(T=x[T]=h.indexOf(y.key),~T&&(c[T]=y))}),j(b,(y,T)=>{c[T]||(c[T]={key:h[T],item:y,phase:"mount",ctrl:new esm_le},c[T].ctrl.item=y)}),x.length){let y=-1,{leave:T}=r?r():e;j(x,(F,k)=>{let O=l[k];~F?(y=c.indexOf(O),c[y]={...O,item:b[F]}):T&&c.splice(++y,0,O)})}G.fun(s)&&c.sort((y,T)=>s(y.item,T.item));let S=-a,A=Wn(),V=dist_esm_ne(e),_=new Map,v=lt(new Map),w=lt(!1);j(c,(y,T)=>{let F=y.key,k=y.phase,O=r?r():e,U,D,Jt=dist_esm_I(O.delay||0,F);if(k=="mount")U=O.enter,D="enter";else{let M=h.indexOf(F)<0;if(k!="leave")if(M)U=O.leave,D="leave";else if(U=O.update)D="update";else return;else if(!M)U=O.enter,D="enter";else return}if(U=dist_esm_I(U,y.item,T),U=G.obj(U)?esm_de(U):{to:U},!U.config){let M=d||V.config;U.config=dist_esm_I(M,y.item,T,D)}S+=a;let Z={...V,delay:Jt+S,ref:f,immediate:O.immediate,reset:!1,...U};if(D=="enter"&&G.und(Z.from)){let M=r?r():e,Te=G.und(M.initial)||l?M.from:M.initial;Z.from=dist_esm_I(Te,y.item,T)}let{onResolve:Wt}=Z;Z.onResolve=M=>{dist_esm_I(Wt,M);let Te=P.current,B=Te.find(Fe=>Fe.key===F);if(!!B&&!(M.cancelled&&B.phase!="update")&&B.ctrl.idle){let Fe=Te.every(ee=>ee.ctrl.idle);if(B.phase=="leave"){let ee=dist_esm_I(i,B.item);if(ee!==!1){let Ze=ee===!0?0:ee;if(B.expired=!0,!Fe&&Ze>0){Ze<=2147483647&&(B.expirationId=setTimeout(A,Ze));return}}}Fe&&Te.some(ee=>ee.expired)&&(v.current.delete(B),u&&(w.current=!0),A())}};let ft=esm_e(y.ctrl,Z);D==="leave"&&u?v.current.set(y,{phase:D,springs:ft,payload:Z}):_.set(y,{phase:D,springs:ft,payload:Z})});let C=Hn(dist_esm_H),$=Zn(C),L=C!==$&&esm_Ue(C);Je(()=>{L&&j(c,y=>{y.ctrl.start({default:C})})},[C]),j(_,(y,T)=>{if(v.current.size){let F=c.findIndex(k=>k.key===T.key);c.splice(F,1)}}),Je(()=>{j(v.current.size?v.current:_,({phase:y,payload:T},F)=>{let{ctrl:k}=F;F.phase=y,m?.add(k),L&&y=="enter"&&k.start({default:C}),T&&(esm_he(k,T.ref),(k.ref||m)&&!w.current?k.update(T):(k.start(T),w.current&&(w.current=!1)))})},o?void 0:n);let N=y=>Oe.createElement(Oe.Fragment,null,c.map((T,F)=>{let{springs:k}=_.get(T)||T.ctrl,O=y({...k},T.item,T,F);return O&&O.type?Oe.createElement(O.type,{...O.props,key:G.str(T.key)||G.num(T.key)?T.key:T.ctrl.id,ref:O.ref}):O}));return m?[N,m]:N}var esm_er=1;function tr(t,{key:e,keys:n=e},r){if(n===null){let o=new Set;return t.map(s=>{let a=r&&r.find(i=>i.item===s&&i.phase!=="leave"&&!o.has(i));return a?(o.add(a),a.key):esm_er++})}return G.und(n)?t:G.fun(n)?t.map(n):zt(n)}var hs=({container:t,...e}={})=>{let[n,r]=esm_J(()=>({scrollX:0,scrollY:0,scrollXProgress:0,scrollYProgress:0,...e}),[]);return or(()=>{let o=rr(({x:s,y:a})=>{r.start({scrollX:s.current,scrollXProgress:s.progress,scrollY:a.current,scrollYProgress:a.progress})},{container:t?.current||void 0});return()=>{nr(Object.values(n),s=>s.stop()),o()}},[]),n};var Ps=({container:t,...e})=>{let[n,r]=esm_J(()=>({width:0,height:0,...e}),[]);return ar(()=>{let o=sr(({width:s,height:a})=>{r.start({width:s,height:a,immediate:n.width.get()===0||n.height.get()===0})},{container:t?.current||void 0});return()=>{ir(Object.values(n),s=>s.stop()),o()}},[]),n};var cr={any:0,all:1};function Cs(t,e){let[n,r]=pr(!1),o=ur(),s=Bt.fun(t)&&t,a=s?s():{},{to:i={},from:u={},...p}=a,f=s?e:t,[d,m]=esm_J(()=>({from:u,...p}),[]);return lr(()=>{let b=o.current,{root:c,once:P,amount:l="any",...h}=f??{};if(!b||P&&n||typeof IntersectionObserver>"u")return;let g=new WeakMap,x=()=>(i&&m.start(i),r(!0),P?void 0:()=>{u&&m.start(u),r(!1)}),S=V=>{V.forEach(_=>{let v=g.get(_.target);if(_.isIntersecting!==Boolean(v))if(_.isIntersecting){let w=x();Bt.fun(w)?g.set(_.target,w):A.unobserve(_.target)}else v&&(v(),g.delete(_.target))})},A=new IntersectionObserver(S,{root:c&&c.current||void 0,threshold:typeof l=="number"||Array.isArray(l)?l:cr[l],...h});return A.observe(b),()=>A.unobserve(b)},[f]),s?[o,d]:[o,n]}function qs({children:t,...e}){return t(esm_J(e))}function Bs({items:t,children:e,...n}){let r=esm_Qt(t.length,n);return t.map((o,s)=>{let a=e(o,s);return fr.fun(a)?a(r[s]):a})}function Ys({items:t,children:e,...n}){return esm_Gt(t,n)(e)}var esm_W=class extends esm_X{constructor(n,r){super();this.source=n;this.calc=W(...r);let o=this._get(),s=esm_Le(o);esm_D(this,s.create(o))}key;idle=!0;calc;_active=new Set;advance(n){let r=this._get(),o=this.get();bt(r,o)||(dist_esm_k(this).setValue(r),this._onChange(r,this.idle)),!this.idle&&Yt(this._active)&&esm_ct(this)}_get(){let n=dist_esm_l.arr(this.source)?this.source.map(ve):ht(ve(this.source));return this.calc(...n)}_start(){this.idle&&!Yt(this._active)&&(this.idle=!1,esm_Ve(F(this),n=>{n.done=!1}),dist_esm_p.skipAnimation?(esm_n.batchedUpdates(()=>this.advance()),esm_ct(this)):qe.start(this))}_attach(){let n=1;esm_Ve(ht(this.source),r=>{Pt(r)&&Gt(r,this),esm_Re(r)&&(r.idle||this._active.add(r),n=Math.max(n,r.priority+1))}),this.priority=n,this._start()}_detach(){esm_Ve(ht(this.source),n=>{Pt(n)&&Qt(n,this)}),this._active.clear(),esm_ct(this)}eventObserved(n){n.type=="change"?n.idle?this.advance():(this._active.add(n.parent),this._start()):n.type=="idle"?this._active.delete(n.parent):n.type=="priority"&&(this.priority=ht(this.source).reduce((r,o)=>Math.max(r,(esm_Re(o)?o.priority:0)+1),0))}};function vr(t){return t.idle!==!1}function Yt(t){return!t.size||Array.from(t).every(vr)}function esm_ct(t){t.idle||(t.idle=!0,esm_Ve(F(t),e=>{e.done=!0}),$t(t,{type:"idle",parent:t}))}var ui=(t,...e)=>new esm_W(t,e),pi=(t,...e)=>(Cr(),new esm_W(t,e));dist_esm_p.assign({createStringInterpolator:Xt,to:(t,e)=>new esm_W(t,e)});var di=qe.advance;

;// external "ReactDOM"
const external_ReactDOM_namespaceObject = window["ReactDOM"];
;// ./node_modules/@react-spring/web/dist/esm/index.js
var web_dist_esm_k=/^--/;function web_dist_esm_I(t,e){return e==null||typeof e=="boolean"||e===""?"":typeof e=="number"&&e!==0&&!web_dist_esm_k.test(t)&&!(web_dist_esm_c.hasOwnProperty(t)&&web_dist_esm_c[t])?e+"px":(""+e).trim()}var web_dist_esm_v={};function esm_V(t,e){if(!t.nodeType||!t.setAttribute)return!1;let r=t.nodeName==="filter"||t.parentNode&&t.parentNode.nodeName==="filter",{style:i,children:s,scrollTop:u,scrollLeft:l,viewBox:a,...n}=e,d=Object.values(n),m=Object.keys(n).map(o=>r||t.hasAttribute(o)?o:web_dist_esm_v[o]||(web_dist_esm_v[o]=o.replace(/([A-Z])/g,p=>"-"+p.toLowerCase())));s!==void 0&&(t.textContent=s);for(let o in i)if(i.hasOwnProperty(o)){let p=web_dist_esm_I(o,i[o]);web_dist_esm_k.test(o)?t.style.setProperty(o,p):t.style[o]=p}m.forEach((o,p)=>{t.setAttribute(o,d[p])}),u!==void 0&&(t.scrollTop=u),l!==void 0&&(t.scrollLeft=l),a!==void 0&&t.setAttribute("viewBox",a)}var web_dist_esm_c={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},esm_F=(t,e)=>t+e.charAt(0).toUpperCase()+e.substring(1),esm_L=["Webkit","Ms","Moz","O"];web_dist_esm_c=Object.keys(web_dist_esm_c).reduce((t,e)=>(esm_L.forEach(r=>t[esm_F(r,e)]=t[e]),t),web_dist_esm_c);var esm_=/^(matrix|translate|scale|rotate|skew)/,dist_esm_$=/^(translate)/,dist_esm_G=/^(rotate|skew)/,web_dist_esm_y=(t,e)=>dist_esm_l.num(t)&&t!==0?t+e:t,web_dist_esm_h=(t,e)=>dist_esm_l.arr(t)?t.every(r=>web_dist_esm_h(r,e)):dist_esm_l.num(t)?t===e:parseFloat(t)===e,dist_esm_g=class extends animated_dist_esm_u{constructor({x:e,y:r,z:i,...s}){let u=[],l=[];(e||r||i)&&(u.push([e||0,r||0,i||0]),l.push(a=>[`translate3d(${a.map(n=>web_dist_esm_y(n,"px")).join(",")})`,web_dist_esm_h(a,0)])),xt(s,(a,n)=>{if(n==="transform")u.push([a||""]),l.push(d=>[d,d===""]);else if(esm_.test(n)){if(delete s[n],dist_esm_l.und(a))return;let d=dist_esm_$.test(n)?"px":dist_esm_G.test(n)?"deg":"";u.push(ht(a)),l.push(n==="rotate3d"?([m,o,p,O])=>[`rotate3d(${m},${o},${p},${web_dist_esm_y(O,d)})`,web_dist_esm_h(O,0)]:m=>[`${n}(${m.map(o=>web_dist_esm_y(o,d)).join(",")})`,web_dist_esm_h(m,n.startsWith("scale")?1:0)])}}),u.length&&(s.transform=new web_dist_esm_x(u,l)),super(s)}},web_dist_esm_x=class extends esm_ge{constructor(r,i){super();this.inputs=r;this.transforms=i}_value=null;get(){return this._value||(this._value=this._get())}_get(){let r="",i=!0;return esm_Ve(this.inputs,(s,u)=>{let l=ve(s[0]),[a,n]=this.transforms[u](dist_esm_l.arr(l)?l:s.map(ve));r+=" "+a,i=i&&n}),i?"none":r}observerAdded(r){r==1&&esm_Ve(this.inputs,i=>esm_Ve(i,s=>Pt(s)&&Gt(s,this)))}observerRemoved(r){r==0&&esm_Ve(this.inputs,i=>esm_Ve(i,s=>Pt(s)&&Qt(s,this)))}eventObserved(r){r.type=="change"&&(this._value=null),$t(this,r)}};var esm_C=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"];dist_esm_p.assign({batchedUpdates:external_ReactDOM_namespaceObject.unstable_batchedUpdates,createStringInterpolator:Xt,colors:It});var dist_esm_q=dist_esm_Ke(esm_C,{applyAnimatedValues:esm_V,createAnimatedStyle:t=>new dist_esm_g(t),getComponentProps:({scrollTop:t,scrollLeft:e,...r})=>r}),dist_esm_it=dist_esm_q.animated;

;// ./node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js





const BLOCK_ANIMATION_THRESHOLD = 200;
function getAbsolutePosition(element) {
  return {
    top: element.offsetTop,
    left: element.offsetLeft
  };
}
function useMovingAnimation({ triggerAnimationOnChange, clientId }) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const {
    isTyping,
    getGlobalBlockCount,
    isBlockSelected,
    isFirstMultiSelectedBlock,
    isBlockMultiSelected,
    isAncestorMultiSelected,
    isDraggingBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { previous, prevRect } = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      previous: ref.current && getAbsolutePosition(ref.current),
      prevRect: ref.current && ref.current.getBoundingClientRect()
    }),
    [triggerAnimationOnChange]
  );
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previous || !ref.current) {
      return;
    }
    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(ref.current);
    const isSelected = isBlockSelected(clientId);
    const adjustScrolling = isSelected || isFirstMultiSelectedBlock(clientId);
    const isDragging = isDraggingBlocks();
    function preserveScrollPosition() {
      if (isDragging) {
        return;
      }
      if (adjustScrolling && prevRect) {
        const blockRect = ref.current.getBoundingClientRect();
        const diff = blockRect.top - prevRect.top;
        if (diff) {
          scrollContainer.scrollTop += diff;
        }
      }
    }
    const disableAnimation = window.matchMedia("(prefers-reduced-motion: reduce)").matches || isTyping() || getGlobalBlockCount() > BLOCK_ANIMATION_THRESHOLD;
    if (disableAnimation) {
      preserveScrollPosition();
      return;
    }
    const isPartOfSelection = isSelected || isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    if (isPartOfSelection && isDragging) {
      return;
    }
    const zIndex = isPartOfSelection ? "1" : "";
    const controller = new esm_le({
      x: 0,
      y: 0,
      config: { mass: 5, tension: 2e3, friction: 200 },
      onChange({ value }) {
        if (!ref.current) {
          return;
        }
        let { x: x2, y: y2 } = value;
        x2 = Math.round(x2);
        y2 = Math.round(y2);
        const finishedMoving = x2 === 0 && y2 === 0;
        ref.current.style.transformOrigin = "center center";
        ref.current.style.transform = finishedMoving ? null : `translate3d(${x2}px,${y2}px,0)`;
        ref.current.style.zIndex = zIndex;
        preserveScrollPosition();
      }
    });
    ref.current.style.transform = void 0;
    const destination = getAbsolutePosition(ref.current);
    const x = Math.round(previous.left - destination.left);
    const y = Math.round(previous.top - destination.top);
    controller.start({ x: 0, y: 0, from: { x, y } });
    return () => {
      controller.stop();
      controller.set({ x: 0, y: 0 });
    };
  }, [
    previous,
    prevRect,
    clientId,
    isTyping,
    getGlobalBlockCount,
    isBlockSelected,
    isFirstMultiSelectedBlock,
    isBlockMultiSelected,
    isAncestorMultiSelected,
    isDraggingBlocks
  ]);
  return ref;
}
var use_moving_animation_default = useMovingAnimation;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js






function useFocusFirstElement({ clientId, initialPosition }) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const { isBlockSelected, isMultiSelecting, isZoomOut } = unlock(
    (0,external_wp_data_namespaceObject.useSelect)(store)
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isBlockSelected(clientId) || isMultiSelecting() || isZoomOut()) {
      return;
    }
    if (initialPosition === void 0 || initialPosition === null) {
      return;
    }
    if (!ref.current) {
      return;
    }
    const { ownerDocument } = ref.current;
    if (isInsideRootBlock(ref.current, ownerDocument.activeElement)) {
      return;
    }
    const textInputs = external_wp_dom_namespaceObject.focus.tabbable.find(ref.current).filter((node) => (0,external_wp_dom_namespaceObject.isTextField)(node));
    const isReverse = -1 === initialPosition;
    const target = textInputs[isReverse ? textInputs.length - 1 : 0] || ref.current;
    if (!isInsideRootBlock(ref.current, target)) {
      ref.current.focus();
      return;
    }
    if (!ref.current.getAttribute("contenteditable")) {
      const focusElement = external_wp_dom_namespaceObject.focus.tabbable.findNext(ref.current);
      if (focusElement && isInsideRootBlock(ref.current, focusElement) && (0,external_wp_dom_namespaceObject.isFormElement)(focusElement)) {
        focusElement.focus();
        return;
      }
    }
    (0,external_wp_dom_namespaceObject.placeCaretAtHorizontalEdge)(target, isReverse);
  }, [initialPosition, clientId]);
  return ref;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js

function listener(event) {
  if (event.defaultPrevented) {
    return;
  }
  event.preventDefault();
  event.currentTarget.classList.toggle(
    "is-hovered",
    event.type === "mouseover"
  );
}
function useIsHovered() {
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    node.addEventListener("mouseout", listener);
    node.addEventListener("mouseover", listener);
    return () => {
      node.removeEventListener("mouseout", listener);
      node.removeEventListener("mouseover", listener);
      node.classList.remove("is-hovered");
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js




function useFocusHandler(clientId) {
  const { isBlockSelected } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { selectBlock, selectionChange } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      function onFocus(event) {
        if (node.parentElement.closest('[contenteditable="true"]')) {
          return;
        }
        if (isBlockSelected(clientId)) {
          if (!event.target.isContentEditable) {
            selectionChange(clientId);
          }
          return;
        }
        if (!isInsideRootBlock(node, event.target)) {
          return;
        }
        selectBlock(clientId);
      }
      node.addEventListener("focusin", onFocus);
      return () => {
        node.removeEventListener("focusin", onFocus);
      };
    },
    [isBlockSelected, selectBlock]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js






function isColorTransparent(color) {
  return !color || color === "transparent" || color === "rgba(0, 0, 0, 0)";
}
function useEventHandlers({ clientId, isSelected }) {
  const { getBlockRootClientId, isZoomOut, hasMultiSelection } = unlock(
    (0,external_wp_data_namespaceObject.useSelect)(store)
  );
  const {
    insertAfterBlock,
    removeBlock,
    resetZoomLevel,
    startDraggingBlocks,
    stopDraggingBlocks
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (!isSelected) {
        return;
      }
      function onKeyDown(event) {
        const { keyCode, target } = event;
        if (keyCode !== external_wp_keycodes_namespaceObject.ENTER && keyCode !== external_wp_keycodes_namespaceObject.BACKSPACE && keyCode !== external_wp_keycodes_namespaceObject.DELETE) {
          return;
        }
        if (target !== node || (0,external_wp_dom_namespaceObject.isTextField)(target)) {
          return;
        }
        event.preventDefault();
        if (keyCode === external_wp_keycodes_namespaceObject.ENTER && isZoomOut()) {
          resetZoomLevel();
        } else if (keyCode === external_wp_keycodes_namespaceObject.ENTER) {
          insertAfterBlock(clientId);
        } else {
          removeBlock(clientId);
        }
      }
      function onDragStart(event) {
        if (node !== event.target || node.isContentEditable || node.ownerDocument.activeElement !== node || hasMultiSelection()) {
          event.preventDefault();
          return;
        }
        const data = JSON.stringify({
          type: "block",
          srcClientIds: [clientId],
          srcRootClientId: getBlockRootClientId(clientId)
        });
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.clearData();
        event.dataTransfer.setData("wp-blocks", data);
        const { ownerDocument } = node;
        const { defaultView } = ownerDocument;
        const selection = defaultView.getSelection();
        selection.removeAllRanges();
        const dragElement = ownerDocument.createElement("div");
        dragElement.style.width = "1px";
        dragElement.style.height = "1px";
        dragElement.style.position = "fixed";
        dragElement.style.visibility = "hidden";
        ownerDocument.body.appendChild(dragElement);
        event.dataTransfer.setDragImage(dragElement, 0, 0);
        const rect = node.getBoundingClientRect();
        const clone = node.cloneNode(true);
        clone.style.visibility = "hidden";
        clone.style.display = "none";
        const id = node.id;
        node.id = null;
        let _scale = 1;
        {
          let parentElement = node;
          while (parentElement = parentElement.parentElement) {
            const { scale } = defaultView.getComputedStyle(parentElement);
            if (scale && scale !== "none") {
              _scale = parseFloat(scale);
              break;
            }
          }
        }
        const inverted = 1 / _scale;
        node.after(clone);
        const originalNodeProperties = {};
        for (const property of [
          "transform",
          "transformOrigin",
          "transition",
          "zIndex",
          "position",
          "top",
          "left",
          "pointerEvents",
          "opacity",
          "backgroundColor"
        ]) {
          originalNodeProperties[property] = node.style[property];
        }
        const originScrollTop = defaultView.scrollY;
        const originScrollLeft = defaultView.scrollX;
        const originClientX = event.clientX;
        const originClientY = event.clientY;
        node.style.position = "relative";
        node.style.top = `${0}px`;
        node.style.left = `${0}px`;
        const originX = event.clientX - rect.left;
        const originY = event.clientY - rect.top;
        const dragScale = rect.height > 200 ? 200 / rect.height : 1;
        node.style.zIndex = "1000";
        node.style.transformOrigin = `${originX * inverted}px ${originY * inverted}px`;
        node.style.transition = "transform 0.2s ease-out";
        node.style.transform = `scale(${dragScale})`;
        node.style.opacity = "0.9";
        if (isColorTransparent(
          defaultView.getComputedStyle(node).backgroundColor
        )) {
          let bgColor = "transparent";
          let parentElement = node;
          while (parentElement = parentElement.parentElement) {
            const { backgroundColor } = defaultView.getComputedStyle(parentElement);
            if (!isColorTransparent(backgroundColor)) {
              bgColor = backgroundColor;
              break;
            }
          }
          node.style.backgroundColor = bgColor;
        }
        let hasStarted = false;
        function over(e) {
          if (!hasStarted) {
            hasStarted = true;
            node.style.pointerEvents = "none";
          }
          const scrollTop = defaultView.scrollY;
          const scrollLeft = defaultView.scrollX;
          node.style.top = `${(e.clientY - originClientY + scrollTop - originScrollTop) * inverted}px`;
          node.style.left = `${(e.clientX - originClientX + scrollLeft - originScrollLeft) * inverted}px`;
        }
        function end() {
          ownerDocument.removeEventListener("dragover", over);
          ownerDocument.removeEventListener("dragend", end);
          ownerDocument.removeEventListener("drop", end);
          ownerDocument.removeEventListener("scroll", over);
          for (const [property, value] of Object.entries(
            originalNodeProperties
          )) {
            node.style[property] = value;
          }
          clone.remove();
          node.id = id;
          dragElement.remove();
          stopDraggingBlocks();
          document.body.classList.remove(
            "is-dragging-components-draggable"
          );
          ownerDocument.documentElement.classList.remove(
            "is-dragging"
          );
        }
        ownerDocument.addEventListener("dragover", over);
        ownerDocument.addEventListener("dragend", end);
        ownerDocument.addEventListener("drop", end);
        ownerDocument.addEventListener("scroll", over);
        startDraggingBlocks([clientId]);
        document.body.classList.add(
          "is-dragging-components-draggable"
        );
        ownerDocument.documentElement.classList.add("is-dragging");
      }
      node.addEventListener("keydown", onKeyDown);
      node.addEventListener("dragstart", onDragStart);
      return () => {
        node.removeEventListener("keydown", onKeyDown);
        node.removeEventListener("dragstart", onDragStart);
      };
    },
    [
      clientId,
      isSelected,
      getBlockRootClientId,
      insertAfterBlock,
      removeBlock,
      isZoomOut,
      resetZoomLevel,
      hasMultiSelection,
      startDraggingBlocks,
      stopDraggingBlocks
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js



function useIntersectionObserver() {
  const observer = (0,external_wp_element_namespaceObject.useContext)(block_list_IntersectionObserver);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (observer) {
        observer.observe(node);
        return () => {
          observer.unobserve(node);
        };
      }
    },
    [observer]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-scroll-into-view.js

function useScrollIntoView({ isSelected }) {
  const prefersReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (isSelected) {
        const { ownerDocument } = node;
        const { defaultView } = ownerDocument;
        if (!defaultView.IntersectionObserver) {
          return;
        }
        const observer = new defaultView.IntersectionObserver(
          (entries) => {
            if (!entries[0].isIntersecting) {
              node.scrollIntoView({
                behavior: prefersReducedMotion ? "instant" : "smooth"
              });
            }
            observer.disconnect();
          }
        );
        observer.observe(node);
        return () => {
          observer.disconnect();
        };
      }
    },
    [isSelected]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/use-flash-editable-blocks/index.js




function useFlashEditableBlocks({
  clientId = "",
  isEnabled = true
} = {}) {
  const { getEnabledClientIdsTree } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (element) => {
      if (!isEnabled) {
        return;
      }
      const flashEditableBlocks = () => {
        getEnabledClientIdsTree(clientId).forEach(
          ({ clientId: id }) => {
            const block = element.querySelector(
              `[data-block="${id}"]`
            );
            if (!block) {
              return;
            }
            block.classList.remove("has-editable-outline");
            block.offsetWidth;
            block.classList.add("has-editable-outline");
          }
        );
      };
      const handleClick = (event) => {
        const shouldFlash = event.target === element || event.target.classList.contains("is-root-container");
        if (!shouldFlash) {
          return;
        }
        if (event.defaultPrevented) {
          return;
        }
        event.preventDefault();
        flashEditableBlocks();
      };
      element.addEventListener("click", handleClick);
      return () => element.removeEventListener("click", handleClick);
    },
    [isEnabled]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-firefox-draggable-compatibility.js

const nodesByDocument = /* @__PURE__ */ new Map();
function add(doc, node) {
  let set = nodesByDocument.get(doc);
  if (!set) {
    set = /* @__PURE__ */ new Set();
    nodesByDocument.set(doc, set);
    doc.addEventListener("pointerdown", down);
  }
  set.add(node);
}
function remove(doc, node) {
  const set = nodesByDocument.get(doc);
  if (set) {
    set.delete(node);
    restore(node);
    if (set.size === 0) {
      nodesByDocument.delete(doc);
      doc.removeEventListener("pointerdown", down);
    }
  }
}
function restore(node) {
  const prevDraggable = node.getAttribute("data-draggable");
  if (prevDraggable) {
    node.removeAttribute("data-draggable");
    if (prevDraggable === "true" && !node.getAttribute("draggable")) {
      node.setAttribute("draggable", "true");
    }
  }
}
function down(event) {
  const { target } = event;
  const { ownerDocument, isContentEditable, tagName } = target;
  const isInputOrTextArea = ["INPUT", "TEXTAREA"].includes(tagName);
  const nodes = nodesByDocument.get(ownerDocument);
  if (isContentEditable || isInputOrTextArea) {
    for (const node of nodes) {
      if (node.getAttribute("draggable") === "true" && node.contains(target)) {
        node.removeAttribute("draggable");
        node.setAttribute("data-draggable", "true");
      }
    }
  } else {
    for (const node of nodes) {
      restore(node);
    }
  }
}
function useFirefoxDraggableCompatibility() {
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    add(node.ownerDocument, node);
    return () => {
      remove(node.ownerDocument, node);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js


















function use_block_props_useBlockProps(props = {}, { __unstableIsHtml } = {}) {
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned,
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isSelected,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    blockEditingMode,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isEditingDisabled,
    hasEditableOutline,
    isTemporarilyEditingAsBlocks,
    defaultClassName,
    isSectionBlock,
    canMove,
    isBlockHidden
  } = (0,external_wp_element_namespaceObject.useContext)(PrivateBlockContext);
  const blockLabel = (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)("Block: %s"), blockTitle);
  const htmlSuffix = mode === "html" && !__unstableIsHtml ? "-visual" : "";
  const ffDragRef = useFirefoxDraggableCompatibility();
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([
    props.ref,
    useFocusFirstElement({ clientId, initialPosition }),
    useBlockRefProvider(clientId),
    useFocusHandler(clientId),
    useEventHandlers({ clientId, isSelected }),
    useIsHovered(),
    useIntersectionObserver(),
    use_moving_animation_default({ triggerAnimationOnChange: index, clientId }),
    (0,external_wp_compose_namespaceObject.useDisabled)({ isDisabled: !hasOverlay }),
    useFlashEditableBlocks({
      clientId,
      isEnabled: isSectionBlock
    }),
    useScrollIntoView({ isSelected }),
    canMove ? ffDragRef : void 0
  ]);
  const blockEditContext = useBlockEditContext();
  const hasBlockBindings = !!blockEditContext[blockBindingsKey];
  const bindingsStyle = hasBlockBindings ? {
    "--wp-admin-theme-color": "var(--wp-block-synced-color)",
    "--wp-admin-theme-color--rgb": "var(--wp-block-synced-color--rgb)"
  } : {};
  if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
    external_wp_warning_default()(
      `Block type "${name}" must support API version 2 or higher to work correctly with "useBlockProps" method.`
    );
  }
  let hasNegativeMargin = false;
  if (wrapperProps?.style?.marginTop?.charAt(0) === "-" || wrapperProps?.style?.marginBottom?.charAt(0) === "-" || wrapperProps?.style?.marginLeft?.charAt(0) === "-" || wrapperProps?.style?.marginRight?.charAt(0) === "-") {
    hasNegativeMargin = true;
  }
  return {
    tabIndex: blockEditingMode === "disabled" ? -1 : 0,
    draggable: canMove && !hasChildSelected ? true : void 0,
    ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    role: "document",
    "aria-label": blockLabel,
    "data-block": clientId,
    "data-type": name,
    "data-title": blockTitle,
    inert: isSubtreeDisabled ? "true" : void 0,
    className: dist_clsx(
      "block-editor-block-list__block",
      {
        // The wp-block className is important for editor styles.
        "wp-block": !isAligned,
        "has-block-overlay": hasOverlay,
        "is-selected": isSelected,
        "is-highlighted": isHighlighted,
        "is-multi-selected": isMultiSelected,
        "is-partially-selected": isPartiallySelected,
        "is-reusable": isReusable,
        "is-dragging": isDragging,
        "has-child-selected": hasChildSelected,
        "is-editing-disabled": isEditingDisabled,
        "has-editable-outline": hasEditableOutline,
        "has-negative-margin": hasNegativeMargin,
        "is-content-locked-temporarily-editing-as-blocks": isTemporarilyEditingAsBlocks,
        "is-block-hidden": isBlockHidden
      },
      className,
      props.className,
      wrapperProps.className,
      defaultClassName
    ),
    style: { ...wrapperProps.style, ...props.style, ...bindingsStyle }
  };
}
use_block_props_useBlockProps.save = external_wp_blocks_namespaceObject.__unstableGetBlockProps;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/block.js


















function mergeWrapperProps(propsA, propsB) {
  const newProps = {
    ...propsA,
    ...propsB
  };
  if (propsA?.hasOwnProperty("className") && propsB?.hasOwnProperty("className")) {
    newProps.className = dist_clsx(propsA.className, propsB.className);
  }
  if (propsA?.hasOwnProperty("style") && propsB?.hasOwnProperty("style")) {
    newProps.style = { ...propsA.style, ...propsB.style };
  }
  return newProps;
}
function Block({ children, isHtml, ...props }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ...use_block_props_useBlockProps(props, { __unstableIsHtml: isHtml }), children });
}
function BlockListBlock({
  block: { __unstableBlockSource },
  mode,
  isLocked,
  canRemove,
  clientId,
  isSelected,
  isSelectionEnabled,
  className,
  __unstableLayoutClassNames: layoutClassNames,
  name,
  isValid,
  attributes,
  wrapperProps,
  setAttributes,
  onReplace,
  onRemove,
  onInsertBlocksAfter,
  onMerge,
  toggleSelection
}) {
  const {
    mayDisplayControls,
    mayDisplayParentControls,
    themeSupportsLayout,
    ...context
  } = (0,external_wp_element_namespaceObject.useContext)(PrivateBlockContext);
  const parentLayout = useLayout() || {};
  let blockEdit = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockEdit,
    {
      name,
      isSelected,
      attributes,
      setAttributes,
      insertBlocksAfter: isLocked ? void 0 : onInsertBlocksAfter,
      onReplace: canRemove ? onReplace : void 0,
      onRemove: canRemove ? onRemove : void 0,
      mergeBlocks: canRemove ? onMerge : void 0,
      clientId,
      isSelectionEnabled,
      toggleSelection,
      __unstableLayoutClassNames: layoutClassNames,
      __unstableParentLayout: Object.keys(parentLayout).length ? parentLayout : void 0,
      mayDisplayControls,
      mayDisplayParentControls,
      blockEditingMode: context.blockEditingMode,
      isPreviewMode: context.isPreviewMode
    }
  );
  const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(name);
  if (blockType?.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(
      wrapperProps,
      blockType.getEditWrapperProps(attributes)
    );
  }
  const isAligned = wrapperProps && !!wrapperProps["data-align"] && !themeSupportsLayout;
  const isSticky = className?.includes("is-position-sticky");
  if (isAligned) {
    blockEdit = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        className: dist_clsx("wp-block", isSticky && className),
        "data-align": wrapperProps["data-align"],
        children: blockEdit
      }
    );
  }
  let block;
  if (!isValid) {
    const saveContent = __unstableBlockSource ? (0,external_wp_blocks_namespaceObject.serializeRawBlock)(__unstableBlockSource) : (0,external_wp_blocks_namespaceObject.getSaveContent)(blockType, attributes);
    block = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(Block, { className: "has-warning", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockInvalidWarning, { clientId }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_element_namespaceObject.RawHTML, { children: (0,external_wp_dom_namespaceObject.safeHTML)(saveContent) })
    ] });
  } else if (mode === "html") {
    block = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { style: { display: "none" }, children: blockEdit }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Block, { isHtml: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_html_default, { clientId }) })
    ] });
  } else if (blockType?.apiVersion > 1) {
    block = blockEdit;
  } else {
    block = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Block, { children: blockEdit });
  }
  const { "data-align": dataAlign, ...restWrapperProps } = wrapperProps ?? {};
  const updatedWrapperProps = {
    ...restWrapperProps,
    className: dist_clsx(
      restWrapperProps.className,
      dataAlign && themeSupportsLayout && `align${dataAlign}`,
      !(dataAlign && isSticky) && className
    )
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateBlockContext.Provider,
    {
      value: {
        wrapperProps: updatedWrapperProps,
        isAligned,
        ...context
      },
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_crash_boundary_default,
        {
          fallback: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Block, { className: "has-warning", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_crash_warning_default, {}) }),
          children: block
        }
      )
    }
  );
}
const applyWithDispatch = (0,external_wp_data_namespaceObject.withDispatch)((dispatch, ownProps, registry) => {
  const {
    updateBlockAttributes,
    insertBlocks,
    mergeBlocks,
    replaceBlocks,
    toggleSelection,
    __unstableMarkLastChangeAsPersistent,
    moveBlocksToPosition,
    removeBlock,
    selectBlock
  } = dispatch(store);
  return {
    setAttributes(nextAttributes) {
      const { getMultiSelectedBlockClientIds } = registry.select(store);
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      const { clientId, attributes } = ownProps;
      const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      const newAttributes = typeof nextAttributes === "function" ? nextAttributes(attributes) : nextAttributes;
      updateBlockAttributes(clientIds, newAttributes);
    },
    onInsertBlocks(blocks, index) {
      const { rootClientId } = ownProps;
      insertBlocks(blocks, index, rootClientId);
    },
    onInsertBlocksAfter(blocks) {
      const { clientId, rootClientId } = ownProps;
      const { getBlockIndex } = registry.select(store);
      const index = getBlockIndex(clientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },
    onMerge(forward) {
      const { clientId, rootClientId } = ownProps;
      const {
        getPreviousBlockClientId,
        getNextBlockClientId,
        getBlock,
        getBlockAttributes,
        getBlockName,
        getBlockOrder,
        getBlockIndex,
        getBlockRootClientId,
        canInsertBlockType
      } = registry.select(store);
      function switchToDefaultOrRemove() {
        const block = getBlock(clientId);
        const defaultBlockName = (0,external_wp_blocks_namespaceObject.getDefaultBlockName)();
        const defaultBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(defaultBlockName);
        if (getBlockName(clientId) !== defaultBlockName) {
          const replacement = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
            block,
            defaultBlockName
          );
          if (replacement && replacement.length) {
            replaceBlocks(clientId, replacement);
          }
        } else if ((0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(block)) {
          const nextBlockClientId = getNextBlockClientId(clientId);
          if (nextBlockClientId) {
            registry.batch(() => {
              removeBlock(clientId);
              selectBlock(nextBlockClientId);
            });
          }
        } else if (defaultBlockType.merge) {
          const attributes = defaultBlockType.merge(
            {},
            block.attributes
          );
          replaceBlocks(
            [clientId],
            [(0,external_wp_blocks_namespaceObject.createBlock)(defaultBlockName, attributes)]
          );
        }
      }
      function moveFirstItemUp(_clientId, changeSelection = true) {
        const wrapperBlockName = getBlockName(_clientId);
        const wrapperBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(wrapperBlockName);
        const isTextualWrapper = wrapperBlockType.category === "text";
        const targetRootClientId = getBlockRootClientId(_clientId);
        const blockOrder = getBlockOrder(_clientId);
        const [firstClientId] = blockOrder;
        if (blockOrder.length === 1 && (0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(getBlock(firstClientId))) {
          removeBlock(_clientId);
        } else if (isTextualWrapper) {
          registry.batch(() => {
            if (canInsertBlockType(
              getBlockName(firstClientId),
              targetRootClientId
            )) {
              moveBlocksToPosition(
                [firstClientId],
                _clientId,
                targetRootClientId,
                getBlockIndex(_clientId)
              );
            } else {
              const replacement = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
                getBlock(firstClientId),
                (0,external_wp_blocks_namespaceObject.getDefaultBlockName)()
              );
              if (replacement && replacement.length && replacement.every(
                (block) => canInsertBlockType(
                  block.name,
                  targetRootClientId
                )
              )) {
                insertBlocks(
                  replacement,
                  getBlockIndex(_clientId),
                  targetRootClientId,
                  changeSelection
                );
                removeBlock(firstClientId, false);
              } else {
                switchToDefaultOrRemove();
              }
            }
            if (!getBlockOrder(_clientId).length && (0,external_wp_blocks_namespaceObject.isUnmodifiedBlock)(getBlock(_clientId))) {
              removeBlock(_clientId, false);
            }
          });
        } else {
          switchToDefaultOrRemove();
        }
      }
      if (forward) {
        if (rootClientId) {
          const nextRootClientId = getNextBlockClientId(rootClientId);
          if (nextRootClientId) {
            if (getBlockName(rootClientId) === getBlockName(nextRootClientId)) {
              const rootAttributes = getBlockAttributes(rootClientId);
              const previousRootAttributes = getBlockAttributes(nextRootClientId);
              if (Object.keys(rootAttributes).every(
                (key) => rootAttributes[key] === previousRootAttributes[key]
              )) {
                registry.batch(() => {
                  moveBlocksToPosition(
                    getBlockOrder(nextRootClientId),
                    nextRootClientId,
                    rootClientId
                  );
                  removeBlock(nextRootClientId, false);
                });
                return;
              }
            } else {
              mergeBlocks(rootClientId, nextRootClientId);
              return;
            }
          }
        }
        const nextBlockClientId = getNextBlockClientId(clientId);
        if (!nextBlockClientId) {
          return;
        }
        if (getBlockOrder(nextBlockClientId).length) {
          moveFirstItemUp(nextBlockClientId, false);
        } else {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        const previousBlockClientId = getPreviousBlockClientId(clientId);
        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        } else if (rootClientId) {
          const previousRootClientId = getPreviousBlockClientId(rootClientId);
          if (previousRootClientId && getBlockName(rootClientId) === getBlockName(previousRootClientId)) {
            const rootAttributes = getBlockAttributes(rootClientId);
            const previousRootAttributes = getBlockAttributes(previousRootClientId);
            if (Object.keys(rootAttributes).every(
              (key) => rootAttributes[key] === previousRootAttributes[key]
            )) {
              registry.batch(() => {
                moveBlocksToPosition(
                  getBlockOrder(rootClientId),
                  rootClientId,
                  previousRootClientId
                );
                removeBlock(rootClientId, false);
              });
              return;
            }
          }
          moveFirstItemUp(rootClientId);
        } else {
          switchToDefaultOrRemove();
        }
      }
    },
    onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !(0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }
      const replacementBlocks = blocks?.length === 1 && Array.isArray(blocks[0]) ? blocks[0] : blocks;
      replaceBlocks(
        [ownProps.clientId],
        replacementBlocks,
        indexToSelect,
        initialPosition
      );
    },
    onRemove() {
      removeBlock(ownProps.clientId);
    },
    toggleSelection(selectionEnabled) {
      toggleSelection(selectionEnabled);
    }
  };
});
BlockListBlock = (0,external_wp_compose_namespaceObject.compose)(
  applyWithDispatch,
  (0,external_wp_components_namespaceObject.withFilters)("editor.BlockListBlock")
)(BlockListBlock);
function BlockListBlockProvider(props) {
  const { clientId, rootClientId } = props;
  const selectedProps = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        isBlockSelected,
        getBlockMode,
        isSelectionEnabled: isSelectionEnabled2,
        getTemplateLock,
        isSectionBlock: _isSectionBlock,
        getBlockWithoutAttributes,
        getBlockAttributes,
        canRemoveBlock,
        canMoveBlock,
        getSettings,
        getTemporarilyEditingAsBlocks,
        getBlockEditingMode,
        getBlockName,
        isFirstMultiSelectedBlock,
        getMultiSelectedBlockClientIds,
        hasSelectedInnerBlock,
        getBlocksByName,
        getBlockIndex,
        isBlockMultiSelected,
        isBlockSubtreeDisabled,
        isBlockHighlighted,
        __unstableIsFullySelected,
        __unstableSelectionHasUnmergeableBlock,
        isBlockBeingDragged,
        isDragging: isDragging2,
        __unstableHasActiveBlockOverlayActive,
        getSelectedBlocksInitialCaretPosition
      } = unlock(select(store));
      const blockWithoutAttributes2 = getBlockWithoutAttributes(clientId);
      if (!blockWithoutAttributes2) {
        return;
      }
      const {
        hasBlockSupport: _hasBlockSupport,
        getActiveBlockVariation
      } = select(external_wp_blocks_namespaceObject.store);
      const attributes2 = getBlockAttributes(clientId);
      const { name: blockName, isValid: isValid2 } = blockWithoutAttributes2;
      const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
      const {
        supportsLayout,
        isPreviewMode: isPreviewMode2,
        __experimentalBlockBindingsSupportedAttributes
      } = getSettings();
      const bindableAttributes2 = __experimentalBlockBindingsSupportedAttributes?.[blockName];
      const hasLightBlockWrapper = blockType?.apiVersion > 1;
      const previewContext = {
        isPreviewMode: isPreviewMode2,
        blockWithoutAttributes: blockWithoutAttributes2,
        name: blockName,
        attributes: attributes2,
        isValid: isValid2,
        themeSupportsLayout: supportsLayout,
        index: getBlockIndex(clientId),
        isReusable: (0,external_wp_blocks_namespaceObject.isReusableBlock)(blockType),
        className: hasLightBlockWrapper ? attributes2.className : void 0,
        defaultClassName: hasLightBlockWrapper ? (0,external_wp_blocks_namespaceObject.getBlockDefaultClassName)(blockName) : void 0,
        blockTitle: blockType?.title,
        isBlockHidden: attributes2?.metadata?.blockVisibility === false,
        bindableAttributes: bindableAttributes2
      };
      if (isPreviewMode2) {
        return previewContext;
      }
      const { isBlockHidden: _isBlockHidden } = unlock(
        select(store)
      );
      const _isSelected = isBlockSelected(clientId);
      const canRemove2 = canRemoveBlock(clientId);
      const canMove2 = canMoveBlock(clientId);
      const match = getActiveBlockVariation(blockName, attributes2);
      const isMultiSelected2 = isBlockMultiSelected(clientId);
      const checkDeep = true;
      const isAncestorOfSelectedBlock = hasSelectedInnerBlock(
        clientId,
        checkDeep
      );
      const blockEditingMode2 = getBlockEditingMode(clientId);
      const multiple = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "multiple", true);
      const blocksWithSameName = multiple ? [] : getBlocksByName(blockName);
      const isInvalid = blocksWithSameName.length && blocksWithSameName[0] !== clientId;
      return {
        ...previewContext,
        mode: getBlockMode(clientId),
        isSelectionEnabled: isSelectionEnabled2(),
        isLocked: !!getTemplateLock(rootClientId),
        isSectionBlock: _isSectionBlock(clientId),
        canRemove: canRemove2,
        canMove: canMove2,
        isSelected: _isSelected,
        isTemporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks() === clientId,
        blockEditingMode: blockEditingMode2,
        mayDisplayControls: _isSelected || isFirstMultiSelectedBlock(clientId) && getMultiSelectedBlockClientIds().every(
          (id) => getBlockName(id) === blockName
        ),
        mayDisplayParentControls: _hasBlockSupport(
          getBlockName(clientId),
          "__experimentalExposeControlsToChildren",
          false
        ) && hasSelectedInnerBlock(clientId),
        blockApiVersion: blockType?.apiVersion || 1,
        blockTitle: match?.title || blockType?.title,
        isSubtreeDisabled: blockEditingMode2 === "disabled" && isBlockSubtreeDisabled(clientId),
        hasOverlay: __unstableHasActiveBlockOverlayActive(clientId) && !isDragging2(),
        initialPosition: _isSelected ? getSelectedBlocksInitialCaretPosition() : void 0,
        isHighlighted: isBlockHighlighted(clientId),
        isMultiSelected: isMultiSelected2,
        isPartiallySelected: isMultiSelected2 && !__unstableIsFullySelected() && !__unstableSelectionHasUnmergeableBlock(),
        isDragging: isBlockBeingDragged(clientId),
        hasChildSelected: isAncestorOfSelectedBlock,
        isEditingDisabled: blockEditingMode2 === "disabled",
        hasEditableOutline: blockEditingMode2 !== "disabled" && getBlockEditingMode(rootClientId) === "disabled",
        originalBlockClientId: isInvalid ? blocksWithSameName[0] : false,
        isBlockHidden: _isBlockHidden(clientId)
      };
    },
    [clientId, rootClientId]
  );
  const {
    isPreviewMode,
    // Fill values that end up as a public API and may not be defined in
    // preview mode.
    mode = "visual",
    isSelectionEnabled = false,
    isLocked = false,
    canRemove = false,
    canMove = false,
    blockWithoutAttributes,
    name,
    attributes,
    isValid,
    isSelected = false,
    themeSupportsLayout,
    isTemporarilyEditingAsBlocks,
    blockEditingMode,
    mayDisplayControls,
    mayDisplayParentControls,
    index,
    blockApiVersion,
    blockTitle,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isSectionBlock,
    isEditingDisabled,
    hasEditableOutline,
    className,
    defaultClassName,
    originalBlockClientId,
    isBlockHidden,
    bindableAttributes
  } = selectedProps;
  const block = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({ ...blockWithoutAttributes, attributes }),
    [blockWithoutAttributes, attributes]
  );
  if (!selectedProps) {
    return null;
  }
  const privateContext = {
    isPreviewMode,
    clientId,
    className,
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isSelected,
    isSubtreeDisabled,
    hasOverlay,
    initialPosition,
    blockEditingMode,
    isHighlighted,
    isMultiSelected,
    isPartiallySelected,
    isReusable,
    isDragging,
    hasChildSelected,
    isSectionBlock,
    isEditingDisabled,
    hasEditableOutline,
    isTemporarilyEditingAsBlocks,
    defaultClassName,
    mayDisplayControls,
    mayDisplayParentControls,
    originalBlockClientId,
    themeSupportsLayout,
    canMove,
    isBlockHidden,
    bindableAttributes
  };
  if (isBlockHidden && !isSelected && !isMultiSelected && !hasChildSelected) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PrivateBlockContext.Provider, { value: privateContext, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockListBlock,
    {
      ...props,
      ...{
        mode,
        isSelectionEnabled,
        isLocked,
        canRemove,
        canMove,
        // Users of the editor.BlockListBlock filter used to be able
        // to access the block prop. Ideally these blocks would rely
        // on the clientId prop only. This is kept for backward
        // compatibility reasons.
        block,
        name,
        attributes,
        isValid,
        isSelected
      }
    }
  ) });
}
var block_default = (0,external_wp_element_namespaceObject.memo)(BlockListBlockProvider);


;// external ["wp","htmlEntities"]
const external_wp_htmlEntities_namespaceObject = window["wp"]["htmlEntities"];
;// ./node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js








const ZWNBSP = "\uFEFF";
function DefaultBlockAppender({ rootClientId }) {
  const { showPrompt, isLocked, placeholder, isManualGrid } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockCount,
        getSettings,
        getTemplateLock,
        getBlockAttributes
      } = select(store);
      const isEmpty = !getBlockCount(rootClientId);
      const { bodyPlaceholder } = getSettings();
      return {
        showPrompt: isEmpty,
        isLocked: !!getTemplateLock(rootClientId),
        placeholder: bodyPlaceholder,
        isManualGrid: getBlockAttributes(rootClientId)?.layout?.isManualPlacement
      };
    },
    [rootClientId]
  );
  const { insertDefaultBlock, startTyping } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  if (isLocked || isManualGrid) {
    return null;
  }
  const value = (0,external_wp_htmlEntities_namespaceObject.decodeEntities)(placeholder) || (0,external_wp_i18n_namespaceObject.__)("Type / to choose a block");
  const onAppend = () => {
    insertDefaultBlock(void 0, rootClientId);
    startTyping();
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      "data-root-client-id": rootClientId || "",
      className: dist_clsx("block-editor-default-block-appender", {
        "has-visible-prompt": showPrompt
      }),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "p",
          {
            tabIndex: "0",
            role: "button",
            "aria-label": (0,external_wp_i18n_namespaceObject.__)("Add default block"),
            className: "block-editor-default-block-appender__content",
            onKeyDown: (event) => {
              if (external_wp_keycodes_namespaceObject.ENTER === event.keyCode || external_wp_keycodes_namespaceObject.SPACE === event.keyCode) {
                onAppend();
              }
            },
            onClick: () => onAppend(),
            onFocus: () => {
              if (showPrompt) {
                onAppend();
              }
            },
            children: showPrompt ? value : ZWNBSP
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          inserter_default,
          {
            rootClientId,
            position: "bottom right",
            isAppender: true,
            __experimentalIsQuick: true
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js







function DefaultAppender({ rootClientId }) {
  const canInsertDefaultBlock = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).canInsertBlockType(
      (0,external_wp_blocks_namespaceObject.getDefaultBlockName)(),
      rootClientId
    )
  );
  if (canInsertDefaultBlock) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(DefaultBlockAppender, { rootClientId });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    button_block_appender_default,
    {
      rootClientId,
      className: "block-list-appender__toggle"
    }
  );
}
function BlockListAppender({
  rootClientId,
  CustomAppender,
  className,
  tagName: TagName = "div"
}) {
  const isDragOver = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockInsertionPoint,
        isBlockInsertionPointVisible,
        getBlockCount
      } = select(store);
      const insertionPoint = getBlockInsertionPoint();
      return isBlockInsertionPointVisible() && rootClientId === insertionPoint?.rootClientId && getBlockCount(rootClientId) === 0;
    },
    [rootClientId]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    TagName,
    {
      tabIndex: -1,
      className: dist_clsx("block-list-appender wp-block", className, {
        "is-drag-over": isDragOver
      }),
      contentEditable: false,
      "data-block": true,
      children: CustomAppender ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(CustomAppender, {}) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(DefaultAppender, { rootClientId })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-popover/inbetween.js









const inbetween_MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
function BlockPopoverInbetween({
  previousClientId,
  nextClientId,
  children,
  __unstablePopoverSlot,
  __unstableContentRef,
  operation = "insert",
  nearestSide = "right",
  ...props
}) {
  const [popoverRecomputeCounter, forcePopoverRecompute] = (0,external_wp_element_namespaceObject.useReducer)(
    // Module is there to make sure that the counter doesn't overflow.
    (s) => (s + 1) % inbetween_MAX_POPOVER_RECOMPUTE_COUNTER,
    0
  );
  const { orientation, rootClientId, isVisible } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockListSettings,
        getBlockRootClientId,
        isBlockVisible
      } = select(store);
      const _rootClientId = getBlockRootClientId(
        previousClientId ?? nextClientId
      );
      return {
        orientation: getBlockListSettings(_rootClientId)?.orientation || "vertical",
        rootClientId: _rootClientId,
        isVisible: isBlockVisible(previousClientId) && isBlockVisible(nextClientId)
      };
    },
    [previousClientId, nextClientId]
  );
  const previousElement = useBlockElement(previousClientId);
  const nextElement = useBlockElement(nextClientId);
  const isVertical = orientation === "vertical";
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (
      // popoverRecomputeCounter is by definition always equal or greater than 0.
      // This check is only there to satisfy the correctness of the
      // exhaustive-deps rule for the `useMemo` hook.
      popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible
    ) {
      return void 0;
    }
    const contextElement = operation === "group" ? nextElement || previousElement : previousElement || nextElement;
    return {
      contextElement,
      getBoundingClientRect() {
        const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
        const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        if (operation === "group") {
          const targetRect = nextRect || previousRect;
          top = targetRect.top;
          width = 0;
          height = targetRect.bottom - targetRect.top;
          left = nearestSide === "left" ? targetRect.left - 2 : targetRect.right - 2;
        } else if (isVertical) {
          top = previousRect ? previousRect.bottom : nextRect.top;
          width = previousRect ? previousRect.width : nextRect.width;
          height = nextRect && previousRect ? nextRect.top - previousRect.bottom : 0;
          left = previousRect ? previousRect.left : nextRect.left;
        } else {
          top = previousRect ? previousRect.top : nextRect.top;
          height = previousRect ? previousRect.height : nextRect.height;
          if ((0,external_wp_i18n_namespaceObject.isRTL)()) {
            left = nextRect ? nextRect.right : previousRect.left;
            width = previousRect && nextRect ? previousRect.left - nextRect.right : 0;
          } else {
            left = previousRect ? previousRect.right : nextRect.left;
            width = previousRect && nextRect ? nextRect.left - previousRect.right : 0;
          }
          width = Math.max(width, 0);
        }
        return new window.DOMRect(left, top, width, height);
      }
    };
  }, [
    previousElement,
    nextElement,
    popoverRecomputeCounter,
    isVertical,
    isVisible,
    operation,
    nearestSide
  ]);
  const popoverScrollRef = use_popover_scroll_default(__unstableContentRef);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }
    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(previousElement, { attributes: true });
    return () => {
      observer.disconnect();
    };
  }, [previousElement]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!nextElement) {
      return;
    }
    const observer = new window.MutationObserver(forcePopoverRecompute);
    observer.observe(nextElement, { attributes: true });
    return () => {
      observer.disconnect();
    };
  }, [nextElement]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previousElement) {
      return;
    }
    previousElement.ownerDocument.defaultView.addEventListener(
      "resize",
      forcePopoverRecompute
    );
    return () => {
      previousElement.ownerDocument.defaultView?.removeEventListener(
        "resize",
        forcePopoverRecompute
      );
    };
  }, [previousElement]);
  if (!previousElement && !nextElement || !isVisible) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      ref: popoverScrollRef,
      animate: false,
      anchor: popoverAnchor,
      focusOnMount: false,
      __unstableSlotName: __unstablePopoverSlot,
      inline: !__unstablePopoverSlot,
      ...props,
      className: dist_clsx(
        "block-editor-block-popover",
        "block-editor-block-popover__inbetween",
        props.className
      ),
      resize: false,
      flip: false,
      placement: "overlay",
      variant: "unstyled",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-popover__inbetween-container", children })
    },
    nextClientId + "--" + rootClientId
  );
}
var inbetween_default = BlockPopoverInbetween;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-popover/drop-zone.js






const animateVariants = {
  hide: { opacity: 0, scaleY: 0.75 },
  show: { opacity: 1, scaleY: 1 },
  exit: { opacity: 0, scaleY: 0.9 }
};
function BlockDropZonePopover({
  __unstablePopoverSlot,
  __unstableContentRef
}) {
  const { clientId } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getBlockOrder, getBlockInsertionPoint } = select(store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    if (!order.length) {
      return {};
    }
    return {
      clientId: order[insertionPoint.index]
    };
  }, []);
  const reducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    cover_default,
    {
      clientId,
      __unstablePopoverSlot,
      __unstableContentRef,
      className: "block-editor-block-popover__drop-zone",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__unstableMotion.div,
        {
          "data-testid": "block-popover-drop-zone",
          initial: reducedMotion ? animateVariants.show : animateVariants.hide,
          animate: animateVariants.show,
          exit: reducedMotion ? animateVariants.show : animateVariants.exit,
          className: "block-editor-block-popover__drop-zone-foreground"
        }
      )
    }
  );
}
var drop_zone_default = BlockDropZonePopover;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js











const InsertionPointOpenRef = (0,external_wp_element_namespaceObject.createContext)();
InsertionPointOpenRef.displayName = "InsertionPointOpenRefContext";
function InbetweenInsertionPointPopover({
  __unstablePopoverSlot,
  __unstableContentRef,
  operation = "insert",
  nearestSide = "right"
}) {
  const { selectBlock, hideInsertionPoint } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const openRef = (0,external_wp_element_namespaceObject.useContext)(InsertionPointOpenRef);
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown,
    isDistractionFree,
    isZoomOutMode
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId,
      getSettings,
      isZoomOut
    } = unlock(select(store));
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    if (!order.length) {
      return {};
    }
    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];
    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }
    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }
    const settings = getSettings();
    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: getBlockListSettings(insertionPoint.rootClientId)?.orientation || "vertical",
      rootClientId: insertionPoint.rootClientId,
      isDistractionFree: settings.isDistractionFree,
      isInserterShown: insertionPoint?.__unstableWithInserter,
      isZoomOutMode: isZoomOut()
    };
  }, []);
  const { getBlockEditingMode } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const disableMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  function onClick(event) {
    if (event.target === ref.current && nextClientId && getBlockEditingMode(nextClientId) !== "disabled") {
      selectBlock(nextClientId, -1);
    }
  }
  function maybeHideInserterPoint(event) {
    if (event.target === ref.current && !openRef.current) {
      hideInsertionPoint();
    }
  }
  function onFocus(event) {
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  }
  const maybeResetOpenRef = (0,external_wp_element_namespaceObject.useCallback)(
    (node) => {
      if (!node && openRef.current) {
        openRef.current = false;
      }
    },
    [openRef]
  );
  const lineVariants = {
    // Initial position starts from the center and invisible.
    start: {
      opacity: 0,
      scale: 0
    },
    // The line expands to fill the container. If the inserter is visible it
    // is delayed so it appears orchestrated.
    rest: {
      opacity: 1,
      scale: 1,
      transition: { delay: isInserterShown ? 0.5 : 0, type: "tween" }
    },
    hover: {
      opacity: 1,
      scale: 1,
      transition: { delay: 0.5, type: "tween" }
    }
  };
  const inserterVariants = {
    start: {
      scale: disableMotion ? 1 : 0
    },
    rest: {
      scale: 1,
      transition: { delay: 0.4, type: "tween" }
    }
  };
  if (isDistractionFree) {
    return null;
  }
  if (isZoomOutMode && operation !== "insert") {
    return null;
  }
  const orientationClassname = orientation === "horizontal" || operation === "group" ? "is-horizontal" : "is-vertical";
  const className = dist_clsx(
    "block-editor-block-list__insertion-point",
    orientationClassname
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inbetween_default,
    {
      previousClientId,
      nextClientId,
      __unstablePopoverSlot,
      __unstableContentRef,
      operation,
      nearestSide,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        external_wp_components_namespaceObject.__unstableMotion.div,
        {
          layout: !disableMotion,
          initial: disableMotion ? "rest" : "start",
          animate: "rest",
          whileHover: "hover",
          whileTap: "pressed",
          exit: "start",
          ref,
          tabIndex: -1,
          onClick,
          onFocus,
          className: dist_clsx(className, {
            "is-with-inserter": isInserterShown
          }),
          onHoverEnd: maybeHideInserterPoint,
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__unstableMotion.div,
              {
                variants: lineVariants,
                className: "block-editor-block-list__insertion-point-indicator",
                "data-testid": "block-list-insertion-point-indicator"
              }
            ),
            isInserterShown && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__unstableMotion.div,
              {
                variants: inserterVariants,
                className: dist_clsx(
                  "block-editor-block-list__insertion-point-inserter"
                ),
                children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  inserter_default,
                  {
                    ref: maybeResetOpenRef,
                    position: "bottom center",
                    clientId: nextClientId,
                    rootClientId,
                    __experimentalIsQuick: true,
                    onToggle: (isOpen) => {
                      openRef.current = isOpen;
                    },
                    onSelectOrClose: () => {
                      openRef.current = false;
                    }
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
function InsertionPoint(props) {
  const { insertionPoint, isVisible, isBlockListEmpty } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockInsertionPoint,
        isBlockInsertionPointVisible,
        getBlockCount
      } = select(store);
      const blockInsertionPoint = getBlockInsertionPoint();
      return {
        insertionPoint: blockInsertionPoint,
        isVisible: isBlockInsertionPointVisible(),
        isBlockListEmpty: getBlockCount(blockInsertionPoint?.rootClientId) === 0
      };
    },
    []
  );
  if (!isVisible || // Don't render the insertion point if the block list is empty.
  // The insertion point will be represented by the appender instead.
  isBlockListEmpty) {
    return null;
  }
  return insertionPoint.operation === "replace" ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    drop_zone_default,
    {
      ...props
    },
    `${insertionPoint.rootClientId}-${insertionPoint.index}`
  ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    InbetweenInsertionPointPopover,
    {
      operation: insertionPoint.operation,
      nearestSide: insertionPoint.nearestSide,
      ...props
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js







function useInBetweenInserter() {
  const openRef = (0,external_wp_element_namespaceObject.useContext)(InsertionPointOpenRef);
  const isInBetweenInserterDisabled = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings().isDistractionFree || unlock(select(store)).isZoomOut(),
    []
  );
  const {
    getBlockListSettings,
    getBlockIndex,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getSettings,
    getTemplateLock,
    __unstableIsWithinBlockOverlay,
    getBlockEditingMode,
    getBlockName,
    getBlockAttributes,
    getParentSectionBlock
  } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  const { showInsertionPoint, hideInsertionPoint } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (isInBetweenInserterDisabled) {
        return;
      }
      function onMouseMove(event) {
        if (openRef === void 0 || openRef.current) {
          return;
        }
        if (event.target.nodeType === event.target.TEXT_NODE) {
          return;
        }
        if (isMultiSelecting()) {
          return;
        }
        if (!event.target.classList.contains(
          "block-editor-block-list__layout"
        )) {
          hideInsertionPoint();
          return;
        }
        let rootClientId;
        if (!event.target.classList.contains("is-root-container")) {
          const blockElement = !!event.target.getAttribute(
            "data-block"
          ) ? event.target : event.target.closest("[data-block]");
          rootClientId = blockElement.getAttribute("data-block");
        }
        if (getTemplateLock(rootClientId) || getBlockEditingMode(rootClientId) === "disabled" || getBlockName(rootClientId) === "core/block" || rootClientId && getBlockAttributes(rootClientId).layout?.isManualPlacement) {
          return;
        }
        const blockListSettings = getBlockListSettings(rootClientId);
        const orientation = blockListSettings?.orientation || "vertical";
        const captureToolbars = !!blockListSettings?.__experimentalCaptureToolbars;
        const offsetTop = event.clientY;
        const offsetLeft = event.clientX;
        const children = Array.from(event.target.children);
        let element = children.find((blockEl) => {
          const blockElRect = blockEl.getBoundingClientRect();
          return blockEl.classList.contains("wp-block") && orientation === "vertical" && blockElRect.top > offsetTop || blockEl.classList.contains("wp-block") && orientation === "horizontal" && ((0,external_wp_i18n_namespaceObject.isRTL)() ? blockElRect.right < offsetLeft : blockElRect.left > offsetLeft);
        });
        if (!element) {
          hideInsertionPoint();
          return;
        }
        if (!element.id) {
          element = element.firstElementChild;
          if (!element) {
            hideInsertionPoint();
            return;
          }
        }
        const clientId = element.id.slice("block-".length);
        if (!clientId || __unstableIsWithinBlockOverlay(clientId) || !!getParentSectionBlock(clientId)) {
          return;
        }
        if (getSelectedBlockClientIds().includes(clientId) && orientation === "vertical" && !captureToolbars && !getSettings().hasFixedToolbar) {
          return;
        }
        const elementRect = element.getBoundingClientRect();
        if (orientation === "horizontal" && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === "vertical" && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
          hideInsertionPoint();
          return;
        }
        const index = getBlockIndex(clientId);
        if (index === 0) {
          hideInsertionPoint();
          return;
        }
        showInsertionPoint(rootClientId, index, {
          __unstableWithInserter: true
        });
      }
      node.addEventListener("mousemove", onMouseMove);
      return () => {
        node.removeEventListener("mousemove", onMouseMove);
      };
    },
    [
      openRef,
      getBlockListSettings,
      getBlockIndex,
      isMultiSelecting,
      showInsertionPoint,
      hideInsertionPoint,
      getSelectedBlockClientIds,
      isInBetweenInserterDisabled
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js




function useBlockSelectionClearer() {
  const { getSettings, hasSelectedBlock, hasMultiSelection } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { clearSelectedBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { clearBlockSelection: isEnabled } = getSettings();
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (!isEnabled) {
        return;
      }
      function onMouseDown(event) {
        if (!hasSelectedBlock() && !hasMultiSelection()) {
          return;
        }
        if (event.target !== node) {
          return;
        }
        clearSelectedBlock();
      }
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.removeEventListener("mousedown", onMouseDown);
      };
    },
    [hasSelectedBlock, hasMultiSelection, clearSelectedBlock, isEnabled]
  );
}
function BlockSelectionClearer(props) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ref: useBlockSelectionClearer(), ...props });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js




function ButtonBlockAppender({
  showSeparator,
  isFloating,
  onAddBlock,
  isToggle
}) {
  const { clientId } = useBlockEditContext();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    button_block_appender_default,
    {
      className: dist_clsx({
        "block-list-appender__toggle": isToggle
      }),
      rootClientId: clientId,
      showSeparator,
      isFloating,
      onAddBlock
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js



function default_block_appender_DefaultBlockAppender() {
  const { clientId } = useBlockEditContext();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(DefaultBlockAppender, { rootClientId: clientId });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js






const pendingSettingsUpdates = /* @__PURE__ */ new WeakMap();
function createShallowMemo() {
  let value;
  return (newValue) => {
    if (value === void 0 || !external_wp_isShallowEqual_default()(value, newValue)) {
      value = newValue;
    }
    return value;
  };
}
function useShallowMemo(value) {
  const [memo] = (0,external_wp_element_namespaceObject.useState)(createShallowMemo);
  return memo(value);
}
function useNestedSettingsUpdate(clientId, parentLock, allowedBlocks, prioritizedInserterBlocks, defaultBlock, directInsert, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const _allowedBlocks = useShallowMemo(allowedBlocks);
  const _prioritizedInserterBlocks = useShallowMemo(
    prioritizedInserterBlocks
  );
  const _templateLock = templateLock === void 0 || parentLock === "contentOnly" ? parentLock : templateLock;
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      prioritizedInserterBlocks: _prioritizedInserterBlocks,
      templateLock: _templateLock
    };
    if (captureToolbars !== void 0) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    }
    if (orientation !== void 0) {
      newSettings.orientation = orientation;
    } else {
      const layoutType = getLayoutType(layout?.type);
      newSettings.orientation = layoutType.getOrientation(layout);
    }
    if (__experimentalDefaultBlock !== void 0) {
      external_wp_deprecated_default()("__experimentalDefaultBlock", {
        alternative: "defaultBlock",
        since: "6.3",
        version: "6.4"
      });
      newSettings.defaultBlock = __experimentalDefaultBlock;
    }
    if (defaultBlock !== void 0) {
      newSettings.defaultBlock = defaultBlock;
    }
    if (__experimentalDirectInsert !== void 0) {
      external_wp_deprecated_default()("__experimentalDirectInsert", {
        alternative: "directInsert",
        since: "6.3",
        version: "6.4"
      });
      newSettings.directInsert = __experimentalDirectInsert;
    }
    if (directInsert !== void 0) {
      newSettings.directInsert = directInsert;
    }
    if (newSettings.directInsert !== void 0 && typeof newSettings.directInsert !== "boolean") {
      external_wp_deprecated_default()("Using `Function` as a `directInsert` argument", {
        alternative: "`boolean` values",
        since: "6.5"
      });
    }
    if (!pendingSettingsUpdates.get(registry)) {
      pendingSettingsUpdates.set(registry, {});
    }
    pendingSettingsUpdates.get(registry)[clientId] = newSettings;
    window.queueMicrotask(() => {
      const settings = pendingSettingsUpdates.get(registry);
      if (Object.keys(settings).length) {
        const { updateBlockListSettings } = registry.dispatch(store);
        updateBlockListSettings(settings);
        pendingSettingsUpdates.set(registry, {});
      }
    });
  }, [
    clientId,
    _allowedBlocks,
    _prioritizedInserterBlocks,
    _templateLock,
    defaultBlock,
    directInsert,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    captureToolbars,
    orientation,
    layout,
    registry
  ]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js





function useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const existingTemplateRef = (0,external_wp_element_namespaceObject.useRef)(null);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    let isCancelled = false;
    const {
      getBlocks,
      getSelectedBlocksInitialCaretPosition,
      isBlockSelected
    } = registry.select(store);
    const { replaceInnerBlocks, __unstableMarkNextChangeAsNotPersistent } = registry.dispatch(store);
    window.queueMicrotask(() => {
      if (isCancelled) {
        return;
      }
      const currentInnerBlocks = getBlocks(clientId);
      const shouldApplyTemplate = currentInnerBlocks.length === 0 || templateLock === "all" || templateLock === "contentOnly";
      const hasTemplateChanged = !es6_default()(
        template,
        existingTemplateRef.current
      );
      if (!shouldApplyTemplate || !hasTemplateChanged) {
        return;
      }
      existingTemplateRef.current = template;
      const nextBlocks = (0,external_wp_blocks_namespaceObject.synchronizeBlocksWithTemplate)(
        currentInnerBlocks,
        template
      );
      if (!es6_default()(nextBlocks, currentInnerBlocks)) {
        __unstableMarkNextChangeAsNotPersistent();
        replaceInnerBlocks(
          clientId,
          nextBlocks,
          currentInnerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0 && isBlockSelected(clientId),
          // This ensures the "initialPosition" doesn't change when applying the template
          // If we're supposed to focus the block, we'll focus the first inner block
          // otherwise, we won't apply any auto-focus.
          // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
          getSelectedBlocksInitialCaretPosition()
        );
      }
    });
    return () => {
      isCancelled = true;
    };
  }, [
    template,
    templateLock,
    clientId,
    registry,
    templateInsertUpdatesSelection
  ]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-block-context.js



function useBlockContext(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const block = select(store).getBlock(clientId);
      if (!block) {
        return void 0;
      }
      const blockType = select(external_wp_blocks_namespaceObject.store).getBlockType(block.name);
      if (!blockType) {
        return void 0;
      }
      if (Object.keys(blockType.providesContext).length === 0) {
        return void 0;
      }
      return Object.fromEntries(
        Object.entries(blockType.providesContext).map(
          ([contextName, attributeName]) => [
            contextName,
            block.attributes[attributeName]
          ]
        )
      );
    },
    [clientId]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js





function parseDropEvent(event) {
  let result = {
    srcRootClientId: null,
    srcClientIds: null,
    srcIndex: null,
    type: null,
    blocks: null
  };
  if (!event.dataTransfer) {
    return result;
  }
  try {
    result = Object.assign(
      result,
      JSON.parse(event.dataTransfer.getData("wp-blocks"))
    );
  } catch (err) {
    return result;
  }
  return result;
}
function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock, operation, getBlock) {
  return (event) => {
    const {
      srcRootClientId: sourceRootClientId,
      srcClientIds: sourceClientIds,
      type: dropType,
      blocks
    } = parseDropEvent(event);
    if (dropType === "inserter") {
      clearSelectedBlock();
      const blocksToInsert = blocks.map(
        (block) => (0,external_wp_blocks_namespaceObject.cloneBlock)(block)
      );
      insertOrReplaceBlocks(blocksToInsert, true, null);
    }
    if (dropType === "block") {
      const sourceBlockIndex = getBlockIndex(sourceClientIds[0]);
      if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
        return;
      }
      if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants(sourceClientIds).some(
        (id) => id === targetRootClientId
      )) {
        return;
      }
      if (operation === "group") {
        const blocksToInsert = sourceClientIds.map(
          (clientId) => getBlock(clientId)
        );
        insertOrReplaceBlocks(
          blocksToInsert,
          true,
          null,
          sourceClientIds
        );
        return;
      }
      const isAtSameLevel = sourceRootClientId === targetRootClientId;
      const draggedBlockCount = sourceClientIds.length;
      const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
      moveBlocks(sourceClientIds, sourceRootClientId, insertIndex);
    }
  };
}
function onFilesDrop(targetRootClientId, getSettings, updateBlockAttributes, canInsertBlockType, insertOrReplaceBlocks) {
  return (files) => {
    if (!getSettings().mediaUpload) {
      return;
    }
    const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(
      (0,external_wp_blocks_namespaceObject.getBlockTransforms)("from"),
      (transform) => transform.type === "files" && canInsertBlockType(transform.blockName, targetRootClientId) && transform.isMatch(files)
    );
    if (transformation) {
      const blocks = transformation.transform(
        files,
        updateBlockAttributes
      );
      insertOrReplaceBlocks(blocks);
    }
  };
}
function onHTMLDrop(insertOrReplaceBlocks) {
  return (HTML) => {
    const blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({ HTML, mode: "BLOCKS" });
    if (blocks.length) {
      insertOrReplaceBlocks(blocks);
    }
  };
}
function useOnBlockDrop(targetRootClientId, targetBlockIndex, options = {}) {
  const { operation = "insert", nearestSide = "right" } = options;
  const {
    canInsertBlockType,
    getBlockIndex,
    getClientIdsOfDescendants,
    getBlockOrder,
    getBlocksByClientId,
    getSettings,
    getBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const {
    insertBlocks,
    moveBlocksToPosition,
    updateBlockAttributes,
    clearSelectedBlock,
    replaceBlocks,
    removeBlocks
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const insertOrReplaceBlocks = (0,external_wp_element_namespaceObject.useCallback)(
    (blocks, updateSelection = true, initialPosition = 0, clientIdsToReplace = []) => {
      if (!Array.isArray(blocks)) {
        blocks = [blocks];
      }
      const clientIds = getBlockOrder(targetRootClientId);
      const clientId = clientIds[targetBlockIndex];
      if (operation === "replace") {
        replaceBlocks(clientId, blocks, void 0, initialPosition);
      } else if (operation === "group") {
        const targetBlock = getBlock(clientId);
        if (nearestSide === "left") {
          blocks.push(targetBlock);
        } else {
          blocks.unshift(targetBlock);
        }
        const groupInnerBlocks = blocks.map((block) => {
          return (0,external_wp_blocks_namespaceObject.createBlock)(
            block.name,
            block.attributes,
            block.innerBlocks
          );
        });
        const areAllImages = blocks.every((block) => {
          return block.name === "core/image";
        });
        const galleryBlock = canInsertBlockType(
          "core/gallery",
          targetRootClientId
        );
        const wrappedBlocks = (0,external_wp_blocks_namespaceObject.createBlock)(
          areAllImages && galleryBlock ? "core/gallery" : getGroupingBlockName(),
          {
            layout: {
              type: "flex",
              flexWrap: areAllImages && galleryBlock ? null : "nowrap"
            }
          },
          groupInnerBlocks
        );
        replaceBlocks(
          [clientId, ...clientIdsToReplace],
          wrappedBlocks,
          void 0,
          initialPosition
        );
      } else {
        insertBlocks(
          blocks,
          targetBlockIndex,
          targetRootClientId,
          updateSelection,
          initialPosition
        );
      }
    },
    [
      getBlockOrder,
      targetRootClientId,
      targetBlockIndex,
      operation,
      replaceBlocks,
      getBlock,
      nearestSide,
      canInsertBlockType,
      getGroupingBlockName,
      insertBlocks
    ]
  );
  const moveBlocks = (0,external_wp_element_namespaceObject.useCallback)(
    (sourceClientIds, sourceRootClientId, insertIndex) => {
      if (operation === "replace") {
        const sourceBlocks = getBlocksByClientId(sourceClientIds);
        const targetBlockClientIds = getBlockOrder(targetRootClientId);
        const targetBlockClientId = targetBlockClientIds[targetBlockIndex];
        registry.batch(() => {
          removeBlocks(sourceClientIds, false);
          replaceBlocks(
            targetBlockClientId,
            sourceBlocks,
            void 0,
            0
          );
        });
      } else {
        moveBlocksToPosition(
          sourceClientIds,
          sourceRootClientId,
          targetRootClientId,
          insertIndex
        );
      }
    },
    [
      operation,
      getBlockOrder,
      getBlocksByClientId,
      moveBlocksToPosition,
      registry,
      removeBlocks,
      replaceBlocks,
      targetBlockIndex,
      targetRootClientId
    ]
  );
  const _onDrop = onBlockDrop(
    targetRootClientId,
    targetBlockIndex,
    getBlockIndex,
    getClientIdsOfDescendants,
    moveBlocks,
    insertOrReplaceBlocks,
    clearSelectedBlock,
    operation,
    getBlock
  );
  const _onFilesDrop = onFilesDrop(
    targetRootClientId,
    getSettings,
    updateBlockAttributes,
    canInsertBlockType,
    insertOrReplaceBlocks
  );
  const _onHTMLDrop = onHTMLDrop(insertOrReplaceBlocks);
  return (event) => {
    const files = (0,external_wp_dom_namespaceObject.getFilesFromDataTransfer)(event.dataTransfer);
    const html = event.dataTransfer.getData("text/html");
    if (html) {
      _onHTMLDrop(html);
    } else if (files.length) {
      _onFilesDrop(files);
    } else {
      _onDrop(event);
    }
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/math.js
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === "top" || edge === "bottom";
  const { x, y } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge];
  let edgeLateralPosition;
  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }
  return Math.sqrt(
    (pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2
  );
}
function getDistanceToNearestEdge(point, rect, allowedEdges = ["top", "bottom", "left", "right"]) {
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach((edge) => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);
    if (candidateDistance === void 0 || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}
function isPointContainedByRect(point, rect) {
  return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
}
function isPointWithinTopAndBottomBoundariesOfRect(point, rect) {
  return rect.top <= point.y && rect.bottom >= point.y;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js









const THRESHOLD_DISTANCE = 30;
const MINIMUM_HEIGHT_FOR_THRESHOLD = 120;
const MINIMUM_WIDTH_FOR_THRESHOLD = 120;
function getDropTargetPosition(blocksData, position, orientation = "vertical", options = {}) {
  const allowedEdges = orientation === "horizontal" ? ["left", "right"] : ["top", "bottom"];
  let nearestIndex = 0;
  let insertPosition = "before";
  let minDistance = Infinity;
  let targetBlockIndex = null;
  let nearestSide = "right";
  const {
    dropZoneElement,
    parentBlockOrientation,
    rootBlockIndex = 0
  } = options;
  if (dropZoneElement && parentBlockOrientation !== "horizontal") {
    const rect = dropZoneElement.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, [
      "top",
      "bottom"
    ]);
    if (rect.height > MINIMUM_HEIGHT_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
      if (edge === "top") {
        return [rootBlockIndex, "before"];
      }
      if (edge === "bottom") {
        return [rootBlockIndex + 1, "after"];
      }
    }
  }
  const isRightToLeft = (0,external_wp_i18n_namespaceObject.isRTL)();
  if (dropZoneElement && parentBlockOrientation === "horizontal") {
    const rect = dropZoneElement.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, [
      "left",
      "right"
    ]);
    if (rect.width > MINIMUM_WIDTH_FOR_THRESHOLD && distance < THRESHOLD_DISTANCE) {
      if (isRightToLeft && edge === "right" || !isRightToLeft && edge === "left") {
        return [rootBlockIndex, "before"];
      }
      if (isRightToLeft && edge === "left" || !isRightToLeft && edge === "right") {
        return [rootBlockIndex + 1, "after"];
      }
    }
  }
  blocksData.forEach(
    ({
      isUnmodifiedDefaultBlock,
      getBoundingClientRect,
      blockIndex,
      blockOrientation
    }) => {
      const rect = getBoundingClientRect();
      if (!rect) {
        return;
      }
      let [distance, edge] = getDistanceToNearestEdge(
        position,
        rect,
        allowedEdges
      );
      const [sideDistance, sideEdge] = getDistanceToNearestEdge(
        position,
        rect,
        ["left", "right"]
      );
      const isPointInsideRect = isPointContainedByRect(position, rect);
      if (isUnmodifiedDefaultBlock && isPointInsideRect) {
        distance = 0;
      } else if (orientation === "vertical" && blockOrientation !== "horizontal" && (isPointInsideRect && sideDistance < THRESHOLD_DISTANCE || !isPointInsideRect && isPointWithinTopAndBottomBoundariesOfRect(
        position,
        rect
      ))) {
        targetBlockIndex = blockIndex;
        nearestSide = sideEdge;
      }
      if (distance < minDistance) {
        insertPosition = edge === "bottom" || !isRightToLeft && edge === "right" || isRightToLeft && edge === "left" ? "after" : "before";
        minDistance = distance;
        nearestIndex = blockIndex;
      }
    }
  );
  const adjacentIndex = nearestIndex + (insertPosition === "after" ? 1 : -1);
  const isNearestBlockUnmodifiedDefaultBlock = !!blocksData[nearestIndex]?.isUnmodifiedDefaultBlock;
  const isAdjacentBlockUnmodifiedDefaultBlock = !!blocksData[adjacentIndex]?.isUnmodifiedDefaultBlock;
  if (targetBlockIndex !== null) {
    return [targetBlockIndex, "group", nearestSide];
  }
  if (!isNearestBlockUnmodifiedDefaultBlock && !isAdjacentBlockUnmodifiedDefaultBlock) {
    const insertionIndex = insertPosition === "after" ? nearestIndex + 1 : nearestIndex;
    return [insertionIndex, "insert"];
  }
  return [
    isNearestBlockUnmodifiedDefaultBlock ? nearestIndex : adjacentIndex,
    "replace"
  ];
}
function isDropTargetValid(getBlockType, allowedBlocks, draggedBlockNames, targetBlockName) {
  let areBlocksAllowed = true;
  if (allowedBlocks) {
    const allowedBlockNames = allowedBlocks?.map(({ name }) => name);
    areBlocksAllowed = draggedBlockNames.every(
      (name) => allowedBlockNames?.includes(name)
    );
  }
  const draggedBlockTypes = draggedBlockNames.map(
    (name) => getBlockType(name)
  );
  const targetMatchesDraggedBlockParents = draggedBlockTypes.every(
    (block) => {
      const [allowedParentName] = block?.parent || [];
      if (!allowedParentName) {
        return true;
      }
      return allowedParentName === targetBlockName;
    }
  );
  return areBlocksAllowed && targetMatchesDraggedBlockParents;
}
function isInsertionPoint(targetToCheck, ownerDocument) {
  const { defaultView } = ownerDocument;
  return !!(defaultView && targetToCheck instanceof defaultView.HTMLElement && targetToCheck.closest("[data-is-insertion-point]"));
}
function useBlockDropZone({
  dropZoneElement,
  // An undefined value represents a top-level block. Default to an empty
  // string for this so that `targetRootClientId` can be easily compared to
  // values returned by the `getRootBlockClientId` selector, which also uses
  // an empty string to represent top-level blocks.
  rootClientId: targetRootClientId = "",
  parentClientId: parentBlockClientId = "",
  isDisabled = false
} = {}) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const [dropTarget, setDropTarget] = (0,external_wp_element_namespaceObject.useState)({
    index: null,
    operation: "insert"
  });
  const { getBlockType, getBlockVariations, getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const {
    canInsertBlockType,
    getBlockListSettings,
    getBlocks,
    getBlockIndex,
    getDraggedBlockClientIds,
    getBlockNamesByClientId,
    getAllowedBlocks,
    isDragging,
    isGroupable,
    isZoomOut,
    getSectionRootClientId,
    getBlockParents
  } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  const {
    showInsertionPoint,
    hideInsertionPoint,
    startDragging,
    stopDragging
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const onBlockDrop = useOnBlockDrop(
    dropTarget.operation === "before" || dropTarget.operation === "after" ? parentBlockClientId : targetRootClientId,
    dropTarget.index,
    {
      operation: dropTarget.operation,
      nearestSide: dropTarget.nearestSide
    }
  );
  const throttled = (0,external_wp_compose_namespaceObject.useThrottle)(
    (0,external_wp_element_namespaceObject.useCallback)(
      (event, ownerDocument) => {
        if (!isDragging()) {
          startDragging();
        }
        const draggedBlockClientIds = getDraggedBlockClientIds();
        const targetParents = [
          targetRootClientId,
          ...getBlockParents(targetRootClientId, true)
        ];
        const isTargetWithinDraggedBlocks = draggedBlockClientIds.some(
          (clientId) => targetParents.includes(clientId)
        );
        if (isTargetWithinDraggedBlocks) {
          return;
        }
        const allowedBlocks = getAllowedBlocks(targetRootClientId);
        const targetBlockName = getBlockNamesByClientId([
          targetRootClientId
        ])[0];
        const draggedBlockNames = getBlockNamesByClientId(
          draggedBlockClientIds
        );
        const isBlockDroppingAllowed = isDropTargetValid(
          getBlockType,
          allowedBlocks,
          draggedBlockNames,
          targetBlockName
        );
        if (!isBlockDroppingAllowed) {
          return;
        }
        const sectionRootClientId = getSectionRootClientId();
        if (isZoomOut() && sectionRootClientId !== targetRootClientId) {
          return;
        }
        const blocks = getBlocks(targetRootClientId).filter((block) => {
          return !((0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "visibility", true) && block.attributes?.metadata?.blockVisibility === false);
        });
        if (blocks.length === 0) {
          registry.batch(() => {
            setDropTarget({
              index: 0,
              operation: "insert"
            });
            showInsertionPoint(targetRootClientId, 0, {
              operation: "insert"
            });
          });
          return;
        }
        const blocksData = blocks.map((block) => {
          const clientId = block.clientId;
          return {
            isUnmodifiedDefaultBlock: (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(block),
            getBoundingClientRect: () => {
              const blockElement = ownerDocument.getElementById(
                `block-${clientId}`
              );
              return blockElement ? blockElement.getBoundingClientRect() : null;
            },
            blockIndex: getBlockIndex(clientId),
            blockOrientation: getBlockListSettings(clientId)?.orientation
          };
        });
        const dropTargetPosition = getDropTargetPosition(
          blocksData,
          { x: event.clientX, y: event.clientY },
          getBlockListSettings(targetRootClientId)?.orientation,
          {
            dropZoneElement,
            parentBlockClientId,
            parentBlockOrientation: parentBlockClientId ? getBlockListSettings(parentBlockClientId)?.orientation : void 0,
            rootBlockIndex: getBlockIndex(targetRootClientId)
          }
        );
        const [targetIndex, operation, nearestSide] = dropTargetPosition;
        const isTargetIndexEmptyDefaultBlock = blocksData[targetIndex]?.isUnmodifiedDefaultBlock;
        if (isZoomOut() && !isTargetIndexEmptyDefaultBlock && operation !== "insert") {
          return;
        }
        if (operation === "group") {
          const targetBlock = blocks[targetIndex];
          const areAllImages = [
            targetBlock.name,
            ...draggedBlockNames
          ].every((name) => name === "core/image");
          const canInsertGalleryBlock = canInsertBlockType(
            "core/gallery",
            targetRootClientId
          );
          const areGroupableBlocks = isGroupable([
            targetBlock.clientId,
            getDraggedBlockClientIds()
          ]);
          const groupBlockVariations = getBlockVariations(
            getGroupingBlockName(),
            "block"
          );
          const canInsertRow = groupBlockVariations && groupBlockVariations.find(
            ({ name }) => name === "group-row"
          );
          if (areAllImages && !canInsertGalleryBlock && (!areGroupableBlocks || !canInsertRow)) {
            return;
          }
          if (!areAllImages && (!areGroupableBlocks || !canInsertRow)) {
            return;
          }
        }
        registry.batch(() => {
          setDropTarget({
            index: targetIndex,
            operation,
            nearestSide
          });
          const insertionPointClientId = [
            "before",
            "after"
          ].includes(operation) ? parentBlockClientId : targetRootClientId;
          showInsertionPoint(insertionPointClientId, targetIndex, {
            operation,
            nearestSide
          });
        });
      },
      [
        isDragging,
        getAllowedBlocks,
        targetRootClientId,
        getBlockNamesByClientId,
        getDraggedBlockClientIds,
        getBlockType,
        getSectionRootClientId,
        isZoomOut,
        getBlocks,
        getBlockListSettings,
        dropZoneElement,
        parentBlockClientId,
        getBlockIndex,
        registry,
        startDragging,
        showInsertionPoint,
        canInsertBlockType,
        isGroupable,
        getBlockVariations,
        getGroupingBlockName
      ]
    ),
    200
  );
  return (0,external_wp_compose_namespaceObject.__experimentalUseDropZone)({
    dropZoneElement,
    isDisabled,
    onDrop: onBlockDrop,
    onDragOver(event) {
      throttled(event, event.currentTarget.ownerDocument);
    },
    onDragLeave(event) {
      const { ownerDocument } = event.currentTarget;
      if (isInsertionPoint(event.relatedTarget, ownerDocument) || isInsertionPoint(event.target, ownerDocument)) {
        return;
      }
      throttled.cancel();
      hideInsertionPoint();
    },
    onDragEnd() {
      throttled.cancel();
      stopDragging();
      hideInsertionPoint();
    }
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js


















const inner_blocks_EMPTY_OBJECT = {};
function BlockContext({ children, clientId }) {
  const context = useBlockContext(clientId);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockContextProvider, { value: context, children });
}
const BlockListItemsMemo = (0,external_wp_element_namespaceObject.memo)(BlockListItems);
function UncontrolledInnerBlocks(props) {
  const {
    clientId,
    allowedBlocks,
    prioritizedInserterBlocks,
    defaultBlock,
    directInsert,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    template,
    templateLock,
    wrapperRef,
    templateInsertUpdatesSelection,
    __experimentalCaptureToolbars: captureToolbars,
    __experimentalAppenderTagName,
    renderAppender,
    orientation,
    placeholder,
    layout,
    name,
    blockType,
    parentLock,
    defaultLayout
  } = props;
  useNestedSettingsUpdate(
    clientId,
    parentLock,
    allowedBlocks,
    prioritizedInserterBlocks,
    defaultBlock,
    directInsert,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    templateLock,
    captureToolbars,
    orientation,
    layout
  );
  useInnerBlockTemplateSync(
    clientId,
    template,
    templateLock,
    templateInsertUpdatesSelection
  );
  const defaultLayoutBlockSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, "layout") || (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, "__experimentalLayout") || inner_blocks_EMPTY_OBJECT;
  const { allowSizingOnChildren = false } = defaultLayoutBlockSupport;
  const usedLayout = layout || defaultLayoutBlockSupport;
  const memoedLayout = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      // Default layout will know about any content/wide size defined by the theme.
      ...defaultLayout,
      ...usedLayout,
      ...allowSizingOnChildren && {
        allowSizingOnChildren: true
      }
    }),
    [defaultLayout, usedLayout, allowSizingOnChildren]
  );
  const items = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockListItemsMemo,
    {
      rootClientId: clientId,
      renderAppender,
      __experimentalAppenderTagName,
      layout: memoedLayout,
      wrapperRef,
      placeholder
    }
  );
  if (!blockType?.providesContext || Object.keys(blockType.providesContext).length === 0) {
    return items;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockContext, { clientId, children: items });
}
function ControlledInnerBlocks(props) {
  useBlockSync(props);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(UncontrolledInnerBlocks, { ...props });
}
const ForwardedInnerBlocks = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  const innerBlocksProps = useInnerBlocksProps({ ref }, props);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inner-blocks", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ...innerBlocksProps }) });
});
function useInnerBlocksProps(props = {}, options = {}) {
  const {
    __unstableDisableLayoutClassNames,
    __unstableDisableDropZone,
    dropZoneElement
  } = options;
  const {
    clientId,
    layout = null,
    __unstableLayoutClassNames: layoutClassNames = ""
  } = useBlockEditContext();
  const selected = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockName,
        isZoomOut,
        getTemplateLock,
        getBlockRootClientId,
        getBlockEditingMode,
        getBlockSettings,
        getSectionRootClientId
      } = unlock(select(store));
      if (!clientId) {
        const sectionRootClientId = getSectionRootClientId();
        return {
          isDropZoneDisabled: isZoomOut() && sectionRootClientId !== ""
        };
      }
      const { hasBlockSupport, getBlockType } = select(external_wp_blocks_namespaceObject.store);
      const blockName = getBlockName(clientId);
      const blockEditingMode = getBlockEditingMode(clientId);
      const parentClientId2 = getBlockRootClientId(clientId);
      const [defaultLayout2] = getBlockSettings(clientId, "layout");
      let _isDropZoneDisabled = blockEditingMode === "disabled";
      if (isZoomOut()) {
        const sectionRootClientId = getSectionRootClientId();
        _isDropZoneDisabled = clientId !== sectionRootClientId;
      }
      return {
        __experimentalCaptureToolbars: hasBlockSupport(
          blockName,
          "__experimentalExposeControlsToChildren",
          false
        ),
        name: blockName,
        blockType: getBlockType(blockName),
        parentLock: getTemplateLock(parentClientId2),
        parentClientId: parentClientId2,
        isDropZoneDisabled: _isDropZoneDisabled,
        defaultLayout: defaultLayout2
      };
    },
    [clientId]
  );
  const {
    __experimentalCaptureToolbars,
    name,
    blockType,
    parentLock,
    parentClientId,
    isDropZoneDisabled,
    defaultLayout
  } = selected;
  const blockDropZoneRef = useBlockDropZone({
    dropZoneElement,
    rootClientId: clientId,
    parentClientId
  });
  const ref = (0,external_wp_compose_namespaceObject.useMergeRefs)([
    props.ref,
    __unstableDisableDropZone || isDropZoneDisabled || layout?.isManualPlacement && window.__experimentalEnableGridInteractivity ? null : blockDropZoneRef
  ]);
  const innerBlocksProps = {
    __experimentalCaptureToolbars,
    layout,
    name,
    blockType,
    parentLock,
    defaultLayout,
    ...options
  };
  const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
  return {
    ...props,
    ref,
    className: dist_clsx(
      props.className,
      "block-editor-block-list__layout",
      __unstableDisableLayoutClassNames ? "" : layoutClassNames
    ),
    children: clientId ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(InnerBlocks, { ...innerBlocksProps, clientId }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockListItems, { ...options })
  };
}
useInnerBlocksProps.save = external_wp_blocks_namespaceObject.__unstableGetInnerBlocksProps;
ForwardedInnerBlocks.DefaultBlockAppender = default_block_appender_DefaultBlockAppender;
ForwardedInnerBlocks.ButtonBlockAppender = ButtonBlockAppender;
ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;
var inner_blocks_default = ForwardedInnerBlocks;


;// ./node_modules/@wordpress/block-editor/build-module/components/observe-typing/index.js






const KEY_DOWN_ELIGIBLE_KEY_CODES = /* @__PURE__ */ new Set([
  external_wp_keycodes_namespaceObject.UP,
  external_wp_keycodes_namespaceObject.RIGHT,
  external_wp_keycodes_namespaceObject.DOWN,
  external_wp_keycodes_namespaceObject.LEFT,
  external_wp_keycodes_namespaceObject.ENTER,
  external_wp_keycodes_namespaceObject.BACKSPACE
]);
function isKeyDownEligibleForStartTyping(event) {
  const { keyCode, shiftKey } = event;
  return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
}
function useMouseMoveTypingReset() {
  const isTyping = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).isTyping(),
    []
  );
  const { stopTyping } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (!isTyping) {
        return;
      }
      const { ownerDocument } = node;
      let lastClientX;
      let lastClientY;
      function stopTypingOnMouseMove(event) {
        const { clientX, clientY } = event;
        if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
          stopTyping();
        }
        lastClientX = clientX;
        lastClientY = clientY;
      }
      ownerDocument.addEventListener(
        "mousemove",
        stopTypingOnMouseMove
      );
      return () => {
        ownerDocument.removeEventListener(
          "mousemove",
          stopTypingOnMouseMove
        );
      };
    },
    [isTyping, stopTyping]
  );
}
function useTypingObserver() {
  const { isTyping } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { isTyping: _isTyping } = select(store);
    return {
      isTyping: _isTyping()
    };
  }, []);
  const { startTyping, stopTyping } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const ref1 = useMouseMoveTypingReset();
  const ref2 = (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      const selection = defaultView.getSelection();
      if (isTyping) {
        let stopTypingOnNonTextField2 = function(event) {
          const { target } = event;
          timerId = defaultView.setTimeout(() => {
            if (!(0,external_wp_dom_namespaceObject.isTextField)(target)) {
              stopTyping();
            }
          });
        }, stopTypingOnEscapeKey2 = function(event) {
          const { keyCode } = event;
          if (keyCode === external_wp_keycodes_namespaceObject.ESCAPE || keyCode === external_wp_keycodes_namespaceObject.TAB) {
            stopTyping();
          }
        }, stopTypingOnSelectionUncollapse2 = function() {
          if (!selection.isCollapsed) {
            stopTyping();
          }
        };
        var stopTypingOnNonTextField = stopTypingOnNonTextField2, stopTypingOnEscapeKey = stopTypingOnEscapeKey2, stopTypingOnSelectionUncollapse = stopTypingOnSelectionUncollapse2;
        let timerId;
        node.addEventListener("focus", stopTypingOnNonTextField2);
        node.addEventListener("keydown", stopTypingOnEscapeKey2);
        ownerDocument.addEventListener(
          "selectionchange",
          stopTypingOnSelectionUncollapse2
        );
        return () => {
          defaultView.clearTimeout(timerId);
          node.removeEventListener(
            "focus",
            stopTypingOnNonTextField2
          );
          node.removeEventListener(
            "keydown",
            stopTypingOnEscapeKey2
          );
          ownerDocument.removeEventListener(
            "selectionchange",
            stopTypingOnSelectionUncollapse2
          );
        };
      }
      function startTypingInTextField(event) {
        const { type, target } = event;
        if (!(0,external_wp_dom_namespaceObject.isTextField)(target) || !node.contains(target)) {
          return;
        }
        if (type === "keydown" && !isKeyDownEligibleForStartTyping(event)) {
          return;
        }
        startTyping();
      }
      node.addEventListener("keypress", startTypingInTextField);
      node.addEventListener("keydown", startTypingInTextField);
      return () => {
        node.removeEventListener("keypress", startTypingInTextField);
        node.removeEventListener("keydown", startTypingInTextField);
      };
    },
    [isTyping, startTyping, stopTyping]
  );
  return (0,external_wp_compose_namespaceObject.useMergeRefs)([ref1, ref2]);
}
function ObserveTyping({ children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ref: useTypingObserver(), children });
}
var observe_typing_default = ObserveTyping;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/zoom-out-separator.js









function ZoomOutSeparator({
  clientId,
  rootClientId = "",
  position = "top"
}) {
  const [isDraggedOver, setIsDraggedOver] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    sectionRootClientId,
    sectionClientIds,
    insertionPoint,
    blockInsertionPointVisible,
    blockInsertionPoint,
    blocksBeingDragged
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getInsertionPoint,
      getBlockOrder,
      getSectionRootClientId,
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getDraggedBlockClientIds
    } = unlock(select(store));
    const root = getSectionRootClientId();
    const sectionRootClientIds = getBlockOrder(root);
    return {
      sectionRootClientId: root,
      sectionClientIds: sectionRootClientIds,
      insertionPoint: getInsertionPoint(),
      blockInsertionPoint: getBlockInsertionPoint(),
      blockInsertionPointVisible: isBlockInsertionPointVisible(),
      blocksBeingDragged: getDraggedBlockClientIds()
    };
  }, []);
  const isReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  if (!clientId) {
    return;
  }
  let isVisible = false;
  const isSectionBlock = rootClientId === sectionRootClientId && sectionClientIds && sectionClientIds.includes(clientId);
  if (!isSectionBlock) {
    return null;
  }
  const hasTopInsertionPoint = insertionPoint?.index === 0 && clientId === sectionClientIds[insertionPoint.index];
  const hasBottomInsertionPoint = insertionPoint && insertionPoint.hasOwnProperty("index") && clientId === sectionClientIds[insertionPoint.index - 1];
  if (position === "top") {
    isVisible = hasTopInsertionPoint || blockInsertionPointVisible && blockInsertionPoint.index === 0 && clientId === sectionClientIds[blockInsertionPoint.index];
  }
  if (position === "bottom") {
    isVisible = hasBottomInsertionPoint || blockInsertionPointVisible && clientId === sectionClientIds[blockInsertionPoint.index - 1];
  }
  const blockBeingDraggedClientId = blocksBeingDragged[0];
  const isCurrentBlockBeingDragged = blocksBeingDragged.includes(clientId);
  const blockBeingDraggedIndex = sectionClientIds.indexOf(
    blockBeingDraggedClientId
  );
  const blockBeingDraggedPreviousSiblingClientId = blockBeingDraggedIndex > 0 ? sectionClientIds[blockBeingDraggedIndex - 1] : null;
  const isCurrentBlockPreviousSiblingOfBlockBeingDragged = blockBeingDraggedPreviousSiblingClientId === clientId;
  if (isCurrentBlockBeingDragged || isCurrentBlockPreviousSiblingOfBlockBeingDragged) {
    isVisible = false;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__unstableAnimatePresence, { children: isVisible && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__unstableMotion.div,
    {
      initial: { height: 0 },
      animate: {
        // Use a height equal to that of the zoom out frame size.
        height: "calc(1 * var(--wp-block-editor-iframe-zoom-out-frame-size) / var(--wp-block-editor-iframe-zoom-out-scale)"
      },
      exit: { height: 0 },
      transition: {
        type: "tween",
        duration: isReducedMotion ? 0 : 0.2,
        ease: [0.6, 0, 0.4, 1]
      },
      className: dist_clsx(
        "block-editor-block-list__zoom-out-separator",
        {
          "is-dragged-over": isDraggedOver
        }
      ),
      "data-is-insertion-point": "true",
      onDragOver: () => setIsDraggedOver(true),
      onDragLeave: () => setIsDraggedOver(false),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__unstableMotion.div,
        {
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0, transition: { delay: -0.125 } },
          transition: {
            ease: "linear",
            duration: 0.1,
            delay: 0.125
          },
          children: (0,external_wp_i18n_namespaceObject.__)("Drop pattern.")
        }
      )
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-list/index.js

















const block_list_IntersectionObserver = (0,external_wp_element_namespaceObject.createContext)();
block_list_IntersectionObserver.displayName = "IntersectionObserverContext";
const pendingBlockVisibilityUpdatesPerRegistry = /* @__PURE__ */ new WeakMap();
const delayedBlockVisibilityDebounceOptions = {
  trailing: true
};
function Root({ className, ...settings }) {
  const { isOutlineMode, isFocusMode, temporarilyEditingAsBlocks } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getSettings,
      getTemporarilyEditingAsBlocks,
      isTyping,
      hasBlockSpotlight
    } = unlock(select(store));
    const { outlineMode, focusMode } = getSettings();
    return {
      isOutlineMode: outlineMode && !isTyping(),
      isFocusMode: focusMode || hasBlockSpotlight(),
      temporarilyEditingAsBlocks: getTemporarilyEditingAsBlocks()
    };
  }, []);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const { setBlockVisibility } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const delayedBlockVisibilityUpdates = (0,external_wp_compose_namespaceObject.useDebounce)(
    (0,external_wp_element_namespaceObject.useCallback)(() => {
      const updates = {};
      pendingBlockVisibilityUpdatesPerRegistry.get(registry).forEach(([id, isIntersecting]) => {
        updates[id] = isIntersecting;
      });
      setBlockVisibility(updates);
    }, [registry]),
    300,
    delayedBlockVisibilityDebounceOptions
  );
  const intersectionObserver = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const { IntersectionObserver: Observer } = window;
    if (!Observer) {
      return;
    }
    return new Observer((entries) => {
      if (!pendingBlockVisibilityUpdatesPerRegistry.get(registry)) {
        pendingBlockVisibilityUpdatesPerRegistry.set(registry, []);
      }
      for (const entry of entries) {
        const clientId = entry.target.getAttribute("data-block");
        pendingBlockVisibilityUpdatesPerRegistry.get(registry).push([clientId, entry.isIntersecting]);
      }
      delayedBlockVisibilityUpdates();
    });
  }, []);
  const innerBlocksProps = useInnerBlocksProps(
    {
      ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([
        useBlockSelectionClearer(),
        useInBetweenInserter(),
        useTypingObserver()
      ]),
      className: dist_clsx("is-root-container", className, {
        "is-outline-mode": isOutlineMode,
        "is-focus-mode": isFocusMode
      })
    },
    settings
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(block_list_IntersectionObserver.Provider, { value: intersectionObserver, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ...innerBlocksProps }),
    !!temporarilyEditingAsBlocks && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      StopEditingAsBlocksOnOutsideSelect,
      {
        clientId: temporarilyEditingAsBlocks
      }
    )
  ] });
}
function StopEditingAsBlocksOnOutsideSelect({ clientId }) {
  const { stopEditingAsBlocks } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const isBlockOrDescendantSelected = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { isBlockSelected, hasSelectedInnerBlock } = select(store);
      return isBlockSelected(clientId) || hasSelectedInnerBlock(clientId, true);
    },
    [clientId]
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isBlockOrDescendantSelected) {
      stopEditingAsBlocks(clientId);
    }
  }, [isBlockOrDescendantSelected, clientId, stopEditingAsBlocks]);
  return null;
}
function BlockList(settings) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Provider, { value: DEFAULT_BLOCK_EDIT_CONTEXT, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Root, { ...settings }) });
}
const block_list_EMPTY_ARRAY = [];
const block_list_EMPTY_SET = /* @__PURE__ */ new Set();
function Items({
  placeholder,
  rootClientId,
  renderAppender: CustomAppender,
  __experimentalAppenderTagName,
  layout = defaultLayout
}) {
  const hasAppender = CustomAppender !== false;
  const hasCustomAppender = !!CustomAppender;
  const {
    order,
    isZoomOut,
    selectedBlocks,
    visibleBlocks,
    shouldRenderAppender
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getSettings,
        getBlockOrder,
        getSelectedBlockClientIds,
        __unstableGetVisibleBlocks,
        getTemplateLock,
        getBlockEditingMode,
        isSectionBlock,
        isContainerInsertableToInContentOnlyMode,
        getBlockName,
        isZoomOut: _isZoomOut,
        canInsertBlockType
      } = unlock(select(store));
      const _order = getBlockOrder(rootClientId);
      if (getSettings().isPreviewMode) {
        return {
          order: _order,
          selectedBlocks: block_list_EMPTY_ARRAY,
          visibleBlocks: block_list_EMPTY_SET
        };
      }
      const selectedBlockClientIds = getSelectedBlockClientIds();
      const selectedBlockClientId = selectedBlockClientIds[0];
      const showRootAppender = !rootClientId && !selectedBlockClientId && (!_order.length || !canInsertBlockType(
        (0,external_wp_blocks_namespaceObject.getDefaultBlockName)(),
        rootClientId
      ));
      const hasSelectedRoot = !!(rootClientId && selectedBlockClientId && rootClientId === selectedBlockClientId);
      return {
        order: _order,
        selectedBlocks: selectedBlockClientIds,
        visibleBlocks: __unstableGetVisibleBlocks(),
        isZoomOut: _isZoomOut(),
        shouldRenderAppender: (!isSectionBlock(rootClientId) || isContainerInsertableToInContentOnlyMode(
          getBlockName(selectedBlockClientId),
          rootClientId
        )) && getBlockEditingMode(rootClientId) !== "disabled" && !getTemplateLock(rootClientId) && hasAppender && !_isZoomOut() && (hasCustomAppender || hasSelectedRoot || showRootAppender)
      };
    },
    [rootClientId, hasAppender, hasCustomAppender]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(LayoutProvider, { value: layout, children: [
    order.map((clientId) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_data_namespaceObject.AsyncModeProvider,
      {
        value: (
          // Only provide data asynchronously if the block is
          // not visible and not selected.
          !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId)
        ),
        children: [
          isZoomOut && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ZoomOutSeparator,
            {
              clientId,
              rootClientId,
              position: "top"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_default,
            {
              rootClientId,
              clientId
            }
          ),
          isZoomOut && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ZoomOutSeparator,
            {
              clientId,
              rootClientId,
              position: "bottom"
            }
          )
        ]
      },
      clientId
    )),
    order.length < 1 && placeholder,
    shouldRenderAppender && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockListAppender,
      {
        tagName: __experimentalAppenderTagName,
        rootClientId,
        CustomAppender
      }
    )
  ] });
}
function BlockListItems(props) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_data_namespaceObject.AsyncModeProvider, { value: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Items, { ...props }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js



function selector(select) {
  const {
    isMultiSelecting,
    getMultiSelectedBlockClientIds,
    hasMultiSelection,
    getSelectedBlockClientId,
    getSelectedBlocksInitialCaretPosition,
    __unstableIsFullySelected
  } = select(store);
  return {
    isMultiSelecting: isMultiSelecting(),
    multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
    hasMultiSelection: hasMultiSelection(),
    selectedBlockClientId: getSelectedBlockClientId(),
    initialPosition: getSelectedBlocksInitialCaretPosition(),
    isFullSelection: __unstableIsFullySelected()
  };
}
function useMultiSelection() {
  const {
    initialPosition,
    isMultiSelecting,
    multiSelectedBlockClientIds,
    hasMultiSelection,
    selectedBlockClientId,
    isFullSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(selector, []);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      if (initialPosition === void 0 || initialPosition === null) {
        return;
      }
      if (!hasMultiSelection || isMultiSelecting) {
        return;
      }
      const { length } = multiSelectedBlockClientIds;
      if (length < 2) {
        return;
      }
      if (!isFullSelection) {
        return;
      }
      node.contentEditable = true;
      node.focus();
      defaultView.getSelection().removeAllRanges();
    },
    [
      hasMultiSelection,
      isMultiSelecting,
      multiSelectedBlockClientIds,
      selectedBlockClientId,
      initialPosition,
      isFullSelection
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js









function useTabNav() {
  const containerRef = (
    /** @type {typeof useRef<HTMLElement>} */
    (0,external_wp_element_namespaceObject.useRef)()
  );
  const focusCaptureBeforeRef = (0,external_wp_element_namespaceObject.useRef)();
  const focusCaptureAfterRef = (0,external_wp_element_namespaceObject.useRef)();
  const {
    hasMultiSelection,
    getSelectedBlockClientId,
    getBlockCount,
    getBlockOrder,
    getLastFocus,
    getSectionRootClientId,
    isZoomOut
  } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  const { setLastFocus } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const noCaptureRef = (0,external_wp_element_namespaceObject.useRef)();
  function onFocusCapture(event) {
    const canvasElement = containerRef.current.ownerDocument === event.target.ownerDocument ? containerRef.current : containerRef.current.ownerDocument.defaultView.frameElement;
    if (noCaptureRef.current) {
      noCaptureRef.current = null;
    } else if (hasMultiSelection()) {
      containerRef.current.focus();
    } else if (getSelectedBlockClientId()) {
      if (getLastFocus()?.current) {
        getLastFocus().current.focus();
      } else {
        containerRef.current.querySelector(
          `[data-block="${getSelectedBlockClientId()}"]`
        ).focus();
      }
    } else if (isZoomOut()) {
      const sectionRootClientId = getSectionRootClientId();
      const sectionBlocks = getBlockOrder(sectionRootClientId);
      if (sectionBlocks.length) {
        containerRef.current.querySelector(`[data-block="${sectionBlocks[0]}"]`).focus();
      } else if (sectionRootClientId) {
        containerRef.current.querySelector(`[data-block="${sectionRootClientId}"]`).focus();
      } else {
        canvasElement.focus();
      }
    } else {
      const isBefore = (
        // eslint-disable-next-line no-bitwise
        event.target.compareDocumentPosition(canvasElement) & event.target.DOCUMENT_POSITION_FOLLOWING
      );
      const tabbables = external_wp_dom_namespaceObject.focus.tabbable.find(containerRef.current);
      if (tabbables.length) {
        const next = isBefore ? tabbables[0] : tabbables[tabbables.length - 1];
        next.focus();
      }
    }
  }
  const before = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      ref: focusCaptureBeforeRef,
      tabIndex: "0",
      onFocus: onFocusCapture
    }
  );
  const after = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      ref: focusCaptureAfterRef,
      tabIndex: "0",
      onFocus: onFocusCapture
    }
  );
  const ref = (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode !== external_wp_keycodes_namespaceObject.TAB) {
        return;
      }
      if (
        // Bails in case the focus capture elements arent present. They
        // may be omitted to avoid silent tab stops in preview mode.
        // See: https://github.com/WordPress/gutenberg/pull/59317
        !focusCaptureAfterRef.current || !focusCaptureBeforeRef.current
      ) {
        return;
      }
      const { target, shiftKey: isShift } = event;
      const direction = isShift ? "findPrevious" : "findNext";
      const nextTabbable = external_wp_dom_namespaceObject.focus.tabbable[direction](target);
      const currentBlock = target.closest("[data-block]");
      const isElementPartOfSelectedBlock = currentBlock && nextTabbable && (isInSameBlock(currentBlock, nextTabbable) || isInsideRootBlock(currentBlock, nextTabbable));
      if ((0,external_wp_dom_namespaceObject.isFormElement)(nextTabbable) && isElementPartOfSelectedBlock) {
        return;
      }
      const next = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef;
      noCaptureRef.current = true;
      next.current.focus({ preventScroll: true });
    }
    function onFocusOut(event) {
      setLastFocus({ ...getLastFocus(), current: event.target });
      const { ownerDocument: ownerDocument2 } = node;
      if (!event.relatedTarget && event.target.hasAttribute("data-block") && ownerDocument2.activeElement === ownerDocument2.body && getBlockCount() === 0) {
        node.focus();
      }
    }
    function preventScrollOnTab(event) {
      if (event.keyCode !== external_wp_keycodes_namespaceObject.TAB) {
        return;
      }
      if (event.target?.getAttribute("role") === "region") {
        return;
      }
      if (containerRef.current === event.target) {
        return;
      }
      const isShift = event.shiftKey;
      const direction = isShift ? "findPrevious" : "findNext";
      const target = external_wp_dom_namespaceObject.focus.tabbable[direction](event.target);
      if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
        event.preventDefault();
        target.focus({ preventScroll: true });
      }
    }
    const { ownerDocument } = node;
    const { defaultView } = ownerDocument;
    defaultView.addEventListener("keydown", preventScrollOnTab);
    node.addEventListener("keydown", onKeyDown);
    node.addEventListener("focusout", onFocusOut);
    return () => {
      defaultView.removeEventListener("keydown", preventScrollOnTab);
      node.removeEventListener("keydown", onKeyDown);
      node.removeEventListener("focusout", onFocusOut);
    };
  }, []);
  const mergedRefs = (0,external_wp_compose_namespaceObject.useMergeRefs)([containerRef, ref]);
  return [before, mergedRefs, after];
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js






function isNavigationCandidate(element, keyCode, hasModifier) {
  const isVertical = keyCode === external_wp_keycodes_namespaceObject.UP || keyCode === external_wp_keycodes_namespaceObject.DOWN;
  const { tagName } = element;
  const elementType = element.getAttribute("type");
  if (isVertical && !hasModifier) {
    if (tagName === "INPUT") {
      const verticalInputTypes = [
        "date",
        "datetime-local",
        "month",
        "number",
        "range",
        "time",
        "week"
      ];
      return !verticalInputTypes.includes(elementType);
    }
    return true;
  }
  if (tagName === "INPUT") {
    const simpleInputTypes = [
      "button",
      "checkbox",
      "number",
      "color",
      "file",
      "image",
      "radio",
      "reset",
      "submit"
    ];
    return simpleInputTypes.includes(elementType);
  }
  return tagName !== "TEXTAREA";
}
function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
  let focusableNodes = external_wp_dom_namespaceObject.focus.focusable.find(containerElement);
  if (isReverse) {
    focusableNodes.reverse();
  }
  focusableNodes = focusableNodes.slice(
    focusableNodes.indexOf(target) + 1
  );
  let targetRect;
  if (onlyVertical) {
    targetRect = target.getBoundingClientRect();
  }
  function isTabCandidate(node) {
    if (node.closest("[inert]")) {
      return;
    }
    if (node.children.length === 1 && isInSameBlock(node, node.firstElementChild) && node.firstElementChild.getAttribute("contenteditable") === "true") {
      return;
    }
    if (!external_wp_dom_namespaceObject.focus.tabbable.isTabbableIndex(node)) {
      return false;
    }
    if (node.isContentEditable && node.contentEditable !== "true") {
      return false;
    }
    if (onlyVertical) {
      const nodeRect = node.getBoundingClientRect();
      if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
        return false;
      }
    }
    return true;
  }
  return focusableNodes.find(isTabCandidate);
}
function useArrowNav() {
  const {
    getMultiSelectedBlocksStartClientId,
    getMultiSelectedBlocksEndClientId,
    getSettings,
    hasMultiSelection,
    __unstableIsFullySelected
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    let verticalRect;
    function onMouseDown() {
      verticalRect = null;
    }
    function isClosestTabbableABlock(target, isReverse) {
      const closestTabbable = getClosestTabbable(
        target,
        isReverse,
        node
      );
      return closestTabbable && getBlockClientId(closestTabbable);
    }
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      const { keyCode, target, shiftKey, ctrlKey, altKey, metaKey } = event;
      const isUp = keyCode === external_wp_keycodes_namespaceObject.UP;
      const isDown = keyCode === external_wp_keycodes_namespaceObject.DOWN;
      const isLeft = keyCode === external_wp_keycodes_namespaceObject.LEFT;
      const isRight = keyCode === external_wp_keycodes_namespaceObject.RIGHT;
      const isReverse = isUp || isLeft;
      const isHorizontal = isLeft || isRight;
      const isVertical = isUp || isDown;
      const isNav = isHorizontal || isVertical;
      const hasModifier = shiftKey || ctrlKey || altKey || metaKey;
      const isNavEdge = isVertical ? external_wp_dom_namespaceObject.isVerticalEdge : external_wp_dom_namespaceObject.isHorizontalEdge;
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      if (!isNav) {
        return;
      }
      if (hasMultiSelection()) {
        if (shiftKey) {
          return;
        }
        if (!__unstableIsFullySelected()) {
          return;
        }
        event.preventDefault();
        if (isReverse) {
          selectBlock(getMultiSelectedBlocksStartClientId());
        } else {
          selectBlock(getMultiSelectedBlocksEndClientId(), -1);
        }
        return;
      }
      if (!isNavigationCandidate(target, keyCode, hasModifier)) {
        return;
      }
      if (!isVertical) {
        verticalRect = null;
      } else if (!verticalRect) {
        verticalRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);
      }
      const isReverseDir = (0,external_wp_dom_namespaceObject.isRTL)(target) ? !isReverse : isReverse;
      const { keepCaretInsideBlock } = getSettings();
      if (shiftKey) {
        if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
          node.contentEditable = true;
          node.focus();
        }
      } else if (isVertical && (0,external_wp_dom_namespaceObject.isVerticalEdge)(target, isReverse) && // When Alt is pressed, only intercept if the caret is also at
      // the horizontal edge.
      (altKey ? (0,external_wp_dom_namespaceObject.isHorizontalEdge)(target, isReverseDir) : true) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(
          target,
          isReverse,
          node,
          true
        );
        if (closestTabbable) {
          (0,external_wp_dom_namespaceObject.placeCaretAtVerticalEdge)(
            closestTabbable,
            // When Alt is pressed, place the caret at the furthest
            // horizontal edge and the furthest vertical edge.
            altKey ? !isReverse : isReverse,
            altKey ? void 0 : verticalRect
          );
          event.preventDefault();
        }
      } else if (isHorizontal && defaultView.getSelection().isCollapsed && (0,external_wp_dom_namespaceObject.isHorizontalEdge)(target, isReverseDir) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(
          target,
          isReverseDir,
          node
        );
        (0,external_wp_dom_namespaceObject.placeCaretAtHorizontalEdge)(closestTabbable, isReverse);
        event.preventDefault();
      }
    }
    node.addEventListener("mousedown", onMouseDown);
    node.addEventListener("keydown", onKeyDown);
    return () => {
      node.removeEventListener("mousedown", onMouseDown);
      node.removeEventListener("keydown", onKeyDown);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js





function useSelectAll() {
  const { getBlockOrder, getSelectedBlockClientIds, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { multiSelect, selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    function onKeyDown(event) {
      if (!isMatch("core/block-editor/select-all", event)) {
        return;
      }
      const selectedClientIds = getSelectedBlockClientIds();
      if (selectedClientIds.length < 2 && !(0,external_wp_dom_namespaceObject.isEntirelySelected)(event.target)) {
        return;
      }
      event.preventDefault();
      const [firstSelectedClientId] = selectedClientIds;
      const rootClientId = getBlockRootClientId(firstSelectedClientId);
      const blockClientIds = getBlockOrder(rootClientId);
      if (selectedClientIds.length === blockClientIds.length) {
        if (rootClientId) {
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
          selectBlock(rootClientId);
        }
        return;
      }
      multiSelect(
        blockClientIds[0],
        blockClientIds[blockClientIds.length - 1]
      );
    }
    node.addEventListener("keydown", onKeyDown);
    return () => {
      node.removeEventListener("keydown", onKeyDown);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-drag-selection.js



function setContentEditableWrapper(node, value) {
  node.contentEditable = value;
  if (value) {
    node.focus();
  }
}
function useDragSelection() {
  const { startMultiSelect, stopMultiSelect } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    isSelectionEnabled,
    hasSelectedBlock,
    isDraggingBlocks,
    isMultiSelecting
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      let anchorElement;
      let rafId;
      function onMouseUp() {
        stopMultiSelect();
        defaultView.removeEventListener("mouseup", onMouseUp);
        rafId = defaultView.requestAnimationFrame(() => {
          if (!hasSelectedBlock()) {
            return;
          }
          setContentEditableWrapper(node, false);
          const selection = defaultView.getSelection();
          if (selection.rangeCount) {
            const range = selection.getRangeAt(0);
            const { commonAncestorContainer } = range;
            const clonedRange = range.cloneRange();
            if (anchorElement.contains(commonAncestorContainer)) {
              anchorElement.focus();
              selection.removeAllRanges();
              selection.addRange(clonedRange);
            }
          }
        });
      }
      let lastMouseDownTarget;
      function onMouseDown({ target }) {
        lastMouseDownTarget = target;
      }
      function onMouseLeave({ buttons, target, relatedTarget }) {
        if (!target.contains(lastMouseDownTarget)) {
          return;
        }
        if (target.contains(relatedTarget)) {
          return;
        }
        if (isDraggingBlocks()) {
          return;
        }
        if (buttons !== 1) {
          return;
        }
        if (isMultiSelecting()) {
          return;
        }
        if (node === target) {
          return;
        }
        if (target.getAttribute("contenteditable") !== "true") {
          return;
        }
        if (!isSelectionEnabled()) {
          return;
        }
        anchorElement = target;
        startMultiSelect();
        defaultView.addEventListener("mouseup", onMouseUp);
        setContentEditableWrapper(node, true);
      }
      node.addEventListener("mouseout", onMouseLeave);
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.removeEventListener("mouseout", onMouseLeave);
        defaultView.removeEventListener("mouseup", onMouseUp);
        defaultView.cancelAnimationFrame(rafId);
      };
    },
    [
      startMultiSelect,
      stopMultiSelect,
      isSelectionEnabled,
      hasSelectedBlock
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-selection-observer.js






function extractSelectionStartNode(selection) {
  const { anchorNode, anchorOffset } = selection;
  if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
    return anchorNode;
  }
  if (anchorOffset === 0) {
    return anchorNode;
  }
  return anchorNode.childNodes[anchorOffset - 1];
}
function extractSelectionEndNode(selection) {
  const { focusNode, focusOffset } = selection;
  if (focusNode.nodeType === focusNode.TEXT_NODE) {
    return focusNode;
  }
  if (focusOffset === focusNode.childNodes.length) {
    return focusNode;
  }
  if (focusOffset === 0 && (0,external_wp_dom_namespaceObject.isSelectionForward)(selection)) {
    return focusNode.previousSibling ?? focusNode.parentElement;
  }
  return focusNode.childNodes[focusOffset];
}
function findDepth(a, b) {
  let depth = 0;
  while (a[depth] === b[depth]) {
    depth++;
  }
  return depth;
}
function use_selection_observer_setContentEditableWrapper(node, value) {
  if (node.contentEditable !== String(value)) {
    node.contentEditable = value;
    if (value) {
      node.focus();
    }
  }
}
function getRichTextElement(node) {
  const element = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;
  return element?.closest("[data-wp-block-attribute-key]");
}
function useSelectionObserver() {
  const { multiSelect, selectBlock, selectionChange } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { getBlockParents, getBlockSelectionStart, isMultiSelecting } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      function onSelectionChange(event) {
        const selection = defaultView.getSelection();
        if (!selection.rangeCount) {
          return;
        }
        const startNode = extractSelectionStartNode(selection);
        const endNode = extractSelectionEndNode(selection);
        if (!node.contains(startNode) || !node.contains(endNode)) {
          return;
        }
        const isClickShift = event.shiftKey && event.type === "mouseup";
        if (selection.isCollapsed && !isClickShift) {
          if (node.contentEditable === "true" && !isMultiSelecting()) {
            use_selection_observer_setContentEditableWrapper(node, false);
            let element = startNode.nodeType === startNode.ELEMENT_NODE ? startNode : startNode.parentElement;
            element = element?.closest("[contenteditable]");
            element?.focus();
          }
          return;
        }
        let startClientId = getBlockClientId(startNode);
        let endClientId = getBlockClientId(endNode);
        if (isClickShift) {
          const selectedClientId = getBlockSelectionStart();
          const clickedClientId = getBlockClientId(event.target);
          const focusNodeIsNonSelectable = clickedClientId !== endClientId;
          if (startClientId === endClientId && selection.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
            endClientId = clickedClientId;
          }
          if (startClientId !== selectedClientId) {
            startClientId = selectedClientId;
          }
        }
        if (startClientId === void 0 && endClientId === void 0) {
          use_selection_observer_setContentEditableWrapper(node, false);
          return;
        }
        const isSingularSelection = startClientId === endClientId;
        if (isSingularSelection) {
          if (!isMultiSelecting()) {
            selectBlock(startClientId);
          } else {
            multiSelect(startClientId, startClientId);
          }
        } else {
          const startPath = [
            ...getBlockParents(startClientId),
            startClientId
          ];
          const endPath = [
            ...getBlockParents(endClientId),
            endClientId
          ];
          const depth = findDepth(startPath, endPath);
          if (startPath[depth] !== startClientId || endPath[depth] !== endClientId) {
            multiSelect(startPath[depth], endPath[depth]);
            return;
          }
          const richTextElementStart = getRichTextElement(startNode);
          const richTextElementEnd = getRichTextElement(endNode);
          if (richTextElementStart && richTextElementEnd) {
            const range = selection.getRangeAt(0);
            const richTextDataStart = (0,external_wp_richText_namespaceObject.create)({
              element: richTextElementStart,
              range,
              __unstableIsEditableTree: true
            });
            const richTextDataEnd = (0,external_wp_richText_namespaceObject.create)({
              element: richTextElementEnd,
              range,
              __unstableIsEditableTree: true
            });
            const startOffset = richTextDataStart.start ?? richTextDataStart.end;
            const endOffset = richTextDataEnd.start ?? richTextDataEnd.end;
            selectionChange({
              start: {
                clientId: startClientId,
                attributeKey: richTextElementStart.dataset.wpBlockAttributeKey,
                offset: startOffset
              },
              end: {
                clientId: endClientId,
                attributeKey: richTextElementEnd.dataset.wpBlockAttributeKey,
                offset: endOffset
              }
            });
          } else {
            multiSelect(startClientId, endClientId);
          }
        }
      }
      ownerDocument.addEventListener(
        "selectionchange",
        onSelectionChange
      );
      defaultView.addEventListener("mouseup", onSelectionChange);
      return () => {
        ownerDocument.removeEventListener(
          "selectionchange",
          onSelectionChange
        );
        defaultView.removeEventListener("mouseup", onSelectionChange);
      };
    },
    [multiSelect, selectBlock, selectionChange, getBlockParents]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-click-selection.js




function useClickSelection() {
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { isSelectionEnabled, getBlockSelectionStart, hasMultiSelection } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      function onMouseDown(event) {
        if (!isSelectionEnabled() || event.button !== 0) {
          return;
        }
        const startClientId = getBlockSelectionStart();
        const clickedClientId = getBlockClientId(event.target);
        if (event.shiftKey) {
          if (startClientId && startClientId !== clickedClientId) {
            node.contentEditable = true;
            node.focus();
          }
        } else if (hasMultiSelection()) {
          selectBlock(clickedClientId);
        }
      }
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.removeEventListener("mousedown", onMouseDown);
      };
    },
    [
      selectBlock,
      isSelectionEnabled,
      getBlockSelectionStart,
      hasMultiSelection
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-input.js





function useInput() {
  const {
    __unstableIsFullySelected,
    getSelectedBlockClientIds,
    getSelectedBlockClientId,
    __unstableIsSelectionMergeable,
    hasMultiSelection,
    getBlockName,
    canInsertBlockType,
    getBlockRootClientId,
    getSelectionStart,
    getSelectionEnd,
    getBlockAttributes
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    replaceBlocks,
    __unstableSplitSelection,
    removeBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection,
    __unstableMarkAutomaticChange
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    function onBeforeInput(event) {
      if (node.contentEditable === "true") {
        event.preventDefault();
      }
    }
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (!hasMultiSelection()) {
        if (event.keyCode === external_wp_keycodes_namespaceObject.ENTER) {
          if (event.shiftKey || __unstableIsFullySelected()) {
            return;
          }
          const clientId = getSelectedBlockClientId();
          const blockName = getBlockName(clientId);
          const selectionStart = getSelectionStart();
          const selectionEnd = getSelectionEnd();
          if (selectionStart.attributeKey === selectionEnd.attributeKey) {
            const selectedAttributeValue = getBlockAttributes(clientId)[selectionStart.attributeKey];
            const transforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)("from").filter(
              ({ type }) => type === "enter"
            );
            const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(
              transforms,
              (item) => {
                return item.regExp.test(
                  selectedAttributeValue
                );
              }
            );
            if (transformation) {
              replaceBlocks(
                clientId,
                transformation.transform({
                  content: selectedAttributeValue
                })
              );
              __unstableMarkAutomaticChange();
              return;
            }
          }
          if (!(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "splitting", false) && !event.__deprecatedOnSplit) {
            return;
          }
          if (canInsertBlockType(
            blockName,
            getBlockRootClientId(clientId)
          )) {
            __unstableSplitSelection();
            event.preventDefault();
          }
        }
        return;
      }
      if (event.keyCode === external_wp_keycodes_namespaceObject.ENTER) {
        node.contentEditable = false;
        event.preventDefault();
        if (__unstableIsFullySelected()) {
          replaceBlocks(
            getSelectedBlockClientIds(),
            (0,external_wp_blocks_namespaceObject.createBlock)((0,external_wp_blocks_namespaceObject.getDefaultBlockName)())
          );
        } else {
          __unstableSplitSelection();
        }
      } else if (event.keyCode === external_wp_keycodes_namespaceObject.BACKSPACE || event.keyCode === external_wp_keycodes_namespaceObject.DELETE) {
        node.contentEditable = false;
        event.preventDefault();
        if (__unstableIsFullySelected()) {
          removeBlocks(getSelectedBlockClientIds());
        } else if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === external_wp_keycodes_namespaceObject.DELETE);
        } else {
          __unstableExpandSelection();
        }
      } else if (
        // If key.length is longer than 1, it's a control key that doesn't
        // input anything.
        event.key.length === 1 && !(event.metaKey || event.ctrlKey)
      ) {
        node.contentEditable = false;
        if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === external_wp_keycodes_namespaceObject.DELETE);
        } else {
          event.preventDefault();
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
    }
    function onCompositionStart(event) {
      if (!hasMultiSelection()) {
        return;
      }
      node.contentEditable = false;
      if (__unstableIsSelectionMergeable()) {
        __unstableDeleteSelection();
      } else {
        event.preventDefault();
        node.ownerDocument.defaultView.getSelection().removeAllRanges();
      }
    }
    node.addEventListener("beforeinput", onBeforeInput);
    node.addEventListener("keydown", onKeyDown);
    node.addEventListener("compositionstart", onCompositionStart);
    return () => {
      node.removeEventListener("beforeinput", onBeforeInput);
      node.removeEventListener("keydown", onKeyDown);
      node.removeEventListener("compositionstart", onCompositionStart);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/use-notify-copy.js






function useNotifyCopy() {
  const { getBlockName } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getBlockType } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const { createSuccessNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  return (0,external_wp_element_namespaceObject.useCallback)(
    (eventType, selectedBlockClientIds) => {
      let notice = "";
      if (eventType === "copyStyles") {
        notice = (0,external_wp_i18n_namespaceObject.__)("Styles copied to clipboard.");
      } else if (selectedBlockClientIds.length === 1) {
        const clientId = selectedBlockClientIds[0];
        const title = getBlockType(getBlockName(clientId))?.title;
        if (eventType === "copy") {
          notice = (0,external_wp_i18n_namespaceObject.sprintf)(
            // Translators: %s: Name of the block being copied, e.g. "Paragraph".
            (0,external_wp_i18n_namespaceObject.__)('Copied "%s" to clipboard.'),
            title
          );
        } else {
          notice = (0,external_wp_i18n_namespaceObject.sprintf)(
            // Translators: %s: Name of the block being cut, e.g. "Paragraph".
            (0,external_wp_i18n_namespaceObject.__)('Moved "%s" to clipboard.'),
            title
          );
        }
      } else if (eventType === "copy") {
        notice = (0,external_wp_i18n_namespaceObject.sprintf)(
          // Translators: %d: Number of blocks being copied.
          (0,external_wp_i18n_namespaceObject._n)(
            "Copied %d block to clipboard.",
            "Copied %d blocks to clipboard.",
            selectedBlockClientIds.length
          ),
          selectedBlockClientIds.length
        );
      } else {
        notice = (0,external_wp_i18n_namespaceObject.sprintf)(
          // Translators: %d: Number of blocks being moved.
          (0,external_wp_i18n_namespaceObject._n)(
            "Moved %d block to clipboard.",
            "Moved %d blocks to clipboard.",
            selectedBlockClientIds.length
          ),
          selectedBlockClientIds.length
        );
      }
      createSuccessNotice(notice, {
        type: "snackbar"
      });
    },
    [createSuccessNotice, getBlockName, getBlockType]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/pasting.js

function removeWindowsFragments(html) {
  const startStr = "<!--StartFragment-->";
  const startIdx = html.indexOf(startStr);
  if (startIdx > -1) {
    html = html.substring(startIdx + startStr.length);
  } else {
    return html;
  }
  const endStr = "<!--EndFragment-->";
  const endIdx = html.indexOf(endStr);
  if (endIdx > -1) {
    html = html.substring(0, endIdx);
  }
  return html;
}
function removeCharsetMetaTag(html) {
  const metaTag = `<meta charset='utf-8'>`;
  if (html.startsWith(metaTag)) {
    return html.slice(metaTag.length);
  }
  return html;
}
function getPasteEventData({ clipboardData }) {
  let plainText = "";
  let html = "";
  try {
    plainText = clipboardData.getData("text/plain");
    html = clipboardData.getData("text/html");
  } catch (error) {
    return;
  }
  html = removeWindowsFragments(html);
  html = removeCharsetMetaTag(html);
  const files = (0,external_wp_dom_namespaceObject.getFilesFromDataTransfer)(clipboardData);
  if (files.length && !shouldDismissPastedFiles(files, html)) {
    return { files };
  }
  return { html, plainText, files: [] };
}
function shouldDismissPastedFiles(files, html) {
  if (html && files?.length === 1 && files[0].type.indexOf("image/") === 0) {
    const IMAGE_TAG = /<\s*img\b/gi;
    if (html.match(IMAGE_TAG)?.length !== 1) {
      return true;
    }
    const IMG_WITH_LOCAL_SRC = /<\s*img\b[^>]*\bsrc="file:\/\//i;
    if (html.match(IMG_WITH_LOCAL_SRC)) {
      return true;
    }
  }
  return false;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/utils.js




const requiresWrapperOnCopy = Symbol("requiresWrapperOnCopy");
function setClipboardBlocks(event, blocks, registry) {
  let _blocks = blocks;
  const [firstBlock] = blocks;
  if (firstBlock) {
    const firstBlockType = registry.select(external_wp_blocks_namespaceObject.store).getBlockType(firstBlock.name);
    if (firstBlockType[requiresWrapperOnCopy]) {
      const { getBlockRootClientId, getBlockName, getBlockAttributes } = registry.select(store);
      const wrapperBlockClientId = getBlockRootClientId(
        firstBlock.clientId
      );
      const wrapperBlockName = getBlockName(wrapperBlockClientId);
      if (wrapperBlockName) {
        _blocks = (0,external_wp_blocks_namespaceObject.createBlock)(
          wrapperBlockName,
          getBlockAttributes(wrapperBlockClientId),
          _blocks
        );
      }
    }
  }
  const serialized = (0,external_wp_blocks_namespaceObject.serialize)(_blocks);
  event.clipboardData.setData("text/plain", toPlainText(serialized));
  event.clipboardData.setData("text/html", serialized);
}
function getPasteBlocks(event, canUserUseUnfilteredHTML) {
  const { plainText, html, files } = getPasteEventData(event);
  let blocks = [];
  if (files.length) {
    const fromTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)("from");
    blocks = files.reduce((accumulator, file) => {
      const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(
        fromTransforms,
        (transform) => transform.type === "files" && transform.isMatch([file])
      );
      if (transformation) {
        accumulator.push(transformation.transform([file]));
      }
      return accumulator;
    }, []).flat();
  } else {
    blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({
      HTML: html,
      plainText,
      mode: "BLOCKS",
      canUserUseUnfilteredHTML
    });
  }
  return blocks;
}
function toPlainText(html) {
  html = html.replace(/<br>/g, "\n");
  const plainText = (0,external_wp_dom_namespaceObject.__unstableStripHTML)(html).trim();
  return plainText.replace(/\n\n+/g, "\n\n");
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-clipboard-handler.js








function useClipboardHandler() {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    hasMultiSelection,
    getSettings,
    getBlockName,
    __unstableIsFullySelected,
    __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable,
    __unstableGetSelectedBlocksWithPartialSelection,
    canInsertBlockType,
    getBlockRootClientId
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    flashBlock,
    removeBlocks,
    replaceBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection,
    __unstableSplitSelection
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const notifyCopy = useNotifyCopy();
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    function handler(event) {
      if (event.defaultPrevented) {
        return;
      }
      const selectedBlockClientIds = getSelectedBlockClientIds();
      if (selectedBlockClientIds.length === 0) {
        return;
      }
      if (!hasMultiSelection()) {
        const { target } = event;
        const { ownerDocument } = target;
        const hasSelection = event.type === "copy" || event.type === "cut" ? (0,external_wp_dom_namespaceObject.documentHasUncollapsedSelection)(ownerDocument) : (0,external_wp_dom_namespaceObject.documentHasSelection)(ownerDocument) && !ownerDocument.activeElement.isContentEditable;
        if (hasSelection) {
          return;
        }
      }
      const { activeElement } = event.target.ownerDocument;
      if (!node.contains(activeElement)) {
        return;
      }
      const isSelectionMergeable = __unstableIsSelectionMergeable();
      const shouldHandleWholeBlocks = __unstableIsSelectionCollapsed() || __unstableIsFullySelected();
      const expandSelectionIsNeeded = !shouldHandleWholeBlocks && !isSelectionMergeable;
      if (event.type === "copy" || event.type === "cut") {
        event.preventDefault();
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        }
        if (expandSelectionIsNeeded) {
          __unstableExpandSelection();
        } else {
          notifyCopy(event.type, selectedBlockClientIds);
          let blocks;
          if (shouldHandleWholeBlocks) {
            blocks = getBlocksByClientId(selectedBlockClientIds);
          } else {
            const [head, tail] = __unstableGetSelectedBlocksWithPartialSelection();
            const inBetweenBlocks = getBlocksByClientId(
              selectedBlockClientIds.slice(
                1,
                selectedBlockClientIds.length - 1
              )
            );
            blocks = [head, ...inBetweenBlocks, tail];
          }
          setClipboardBlocks(event, blocks, registry);
        }
      }
      if (event.type === "cut") {
        if (shouldHandleWholeBlocks && !expandSelectionIsNeeded) {
          removeBlocks(selectedBlockClientIds);
        } else {
          event.target.ownerDocument.activeElement.contentEditable = false;
          __unstableDeleteSelection();
        }
      } else if (event.type === "paste") {
        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML,
          mediaUpload
        } = getSettings();
        const isInternal = event.clipboardData.getData("rich-text") === "true";
        if (isInternal) {
          return;
        }
        const { plainText, html, files } = getPasteEventData(event);
        const isFullySelected = __unstableIsFullySelected();
        let blocks = [];
        if (files.length) {
          if (!mediaUpload) {
            event.preventDefault();
            return;
          }
          const fromTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)("from");
          blocks = files.reduce((accumulator, file) => {
            const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(
              fromTransforms,
              (transform) => transform.type === "files" && transform.isMatch([file])
            );
            if (transformation) {
              accumulator.push(
                transformation.transform([file])
              );
            }
            return accumulator;
          }, []).flat();
        } else {
          blocks = (0,external_wp_blocks_namespaceObject.pasteHandler)({
            HTML: html,
            plainText,
            mode: isFullySelected ? "BLOCKS" : "AUTO",
            canUserUseUnfilteredHTML
          });
        }
        if (typeof blocks === "string") {
          return;
        }
        if (isFullySelected) {
          replaceBlocks(
            selectedBlockClientIds,
            blocks,
            blocks.length - 1,
            -1
          );
          event.preventDefault();
          return;
        }
        if (!hasMultiSelection() && !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(
          getBlockName(selectedBlockClientIds[0]),
          "splitting",
          false
        ) && !event.__deprecatedOnSplit) {
          return;
        }
        const [firstSelectedClientId] = selectedBlockClientIds;
        const rootClientId = getBlockRootClientId(
          firstSelectedClientId
        );
        const newBlocks = [];
        for (const block of blocks) {
          if (canInsertBlockType(block.name, rootClientId)) {
            newBlocks.push(block);
          } else {
            const rootBlockName = getBlockName(rootClientId);
            const switchedBlocks = block.name !== rootBlockName ? (0,external_wp_blocks_namespaceObject.switchToBlockType)(block, rootBlockName) : [block];
            if (!switchedBlocks) {
              return;
            }
            for (const switchedBlock of switchedBlocks) {
              for (const innerBlock of switchedBlock.innerBlocks) {
                newBlocks.push(innerBlock);
              }
            }
          }
        }
        __unstableSplitSelection(newBlocks);
        event.preventDefault();
      }
    }
    node.ownerDocument.addEventListener("copy", handler);
    node.ownerDocument.addEventListener("cut", handler);
    node.ownerDocument.addEventListener("paste", handler);
    return () => {
      node.ownerDocument.removeEventListener("copy", handler);
      node.ownerDocument.removeEventListener("cut", handler);
      node.ownerDocument.removeEventListener("paste", handler);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js
















function useWritingFlow() {
  const [before, ref, after] = useTabNav();
  const hasMultiSelection = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).hasMultiSelection(),
    []
  );
  return [
    before,
    (0,external_wp_compose_namespaceObject.useMergeRefs)([
      ref,
      useClipboardHandler(),
      useInput(),
      useDragSelection(),
      useSelectionObserver(),
      useClickSelection(),
      useMultiSelection(),
      useSelectAll(),
      useArrowNav(),
      (0,external_wp_compose_namespaceObject.useRefEffect)(
        (node) => {
          node.tabIndex = 0;
          node.dataset.hasMultiSelection = hasMultiSelection;
          if (!hasMultiSelection) {
            return () => {
              delete node.dataset.hasMultiSelection;
            };
          }
          node.setAttribute(
            "aria-label",
            (0,external_wp_i18n_namespaceObject.__)("Multiple selected blocks")
          );
          return () => {
            delete node.dataset.hasMultiSelection;
            node.removeAttribute("aria-label");
          };
        },
        [hasMultiSelection]
      )
    ]),
    after
  ];
}
function WritingFlow({ children, ...props }, forwardedRef) {
  const [before, ref, after] = useWritingFlow();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    before,
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        ...props,
        ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, forwardedRef]),
        className: dist_clsx(
          props.className,
          "block-editor-writing-flow"
        ),
        children
      }
    ),
    after
  ] });
}
var writing_flow_default = (0,external_wp_element_namespaceObject.forwardRef)(WritingFlow);


;// ./node_modules/@wordpress/block-editor/build-module/components/iframe/get-compatibility-styles.js
let compatibilityStyles = null;
function getCompatibilityStyles() {
  if (compatibilityStyles) {
    return compatibilityStyles;
  }
  compatibilityStyles = Array.from(document.styleSheets).reduce(
    (accumulator, styleSheet) => {
      try {
        styleSheet.cssRules;
      } catch (e) {
        return accumulator;
      }
      const { ownerNode, cssRules } = styleSheet;
      if (ownerNode === null) {
        return accumulator;
      }
      if (!cssRules) {
        return accumulator;
      }
      if (ownerNode.id.startsWith("wp-")) {
        return accumulator;
      }
      if (!ownerNode.id) {
        return accumulator;
      }
      function matchFromRules(_cssRules) {
        return Array.from(_cssRules).find(
          ({
            selectorText,
            conditionText,
            cssRules: __cssRules
          }) => {
            if (conditionText) {
              return matchFromRules(__cssRules);
            }
            return selectorText && (selectorText.includes(
              ".editor-styles-wrapper"
            ) || selectorText.includes(".wp-block"));
          }
        );
      }
      if (matchFromRules(cssRules)) {
        const isInline = ownerNode.tagName === "STYLE";
        if (isInline) {
          const mainStylesCssId = ownerNode.id.replace(
            "-inline-css",
            "-css"
          );
          const mainStylesElement = document.getElementById(mainStylesCssId);
          if (mainStylesElement) {
            accumulator.push(mainStylesElement.cloneNode(true));
          }
        }
        accumulator.push(ownerNode.cloneNode(true));
        if (!isInline) {
          const inlineStylesCssId = ownerNode.id.replace(
            "-css",
            "-inline-css"
          );
          const inlineStylesElement = document.getElementById(inlineStylesCssId);
          if (inlineStylesElement) {
            accumulator.push(
              inlineStylesElement.cloneNode(true)
            );
          }
        }
      }
      return accumulator;
    },
    []
  );
  return compatibilityStyles;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/iframe/use-scale-canvas.js


function calculateScale({
  frameSize,
  containerWidth,
  maxContainerWidth,
  scaleContainerWidth
}) {
  return (Math.min(containerWidth, maxContainerWidth) - frameSize * 2) / scaleContainerWidth;
}
function computeScrollHeightNext(transitionFrom, transitionTo) {
  const { scaleValue: prevScale, scrollHeight: prevScrollHeight } = transitionFrom;
  const { frameSize, scaleValue } = transitionTo;
  return prevScrollHeight * (scaleValue / prevScale) + frameSize * 2;
}
function computeScrollTopNext(transitionFrom, transitionTo) {
  const {
    containerHeight: prevContainerHeight,
    frameSize: prevFrameSize,
    scaleValue: prevScale,
    scrollTop: prevScrollTop
  } = transitionFrom;
  const { containerHeight, frameSize, scaleValue, scrollHeight } = transitionTo;
  let scrollTopNext = prevScrollTop;
  scrollTopNext = (scrollTopNext + prevContainerHeight / 2 - prevFrameSize) / prevScale - prevContainerHeight / 2;
  scrollTopNext = (scrollTopNext + containerHeight / 2) * scaleValue + frameSize - containerHeight / 2;
  scrollTopNext = prevScrollTop <= prevFrameSize ? 0 : scrollTopNext;
  const maxScrollTop = scrollHeight - containerHeight;
  return Math.round(
    Math.min(Math.max(0, scrollTopNext), Math.max(0, maxScrollTop))
  );
}
function getAnimationKeyframes(transitionFrom, transitionTo) {
  const {
    scaleValue: prevScale,
    frameSize: prevFrameSize,
    scrollTop
  } = transitionFrom;
  const { scaleValue, frameSize, scrollTop: scrollTopNext } = transitionTo;
  return [
    {
      translate: `0 0`,
      scale: prevScale,
      paddingTop: `${prevFrameSize / prevScale}px`,
      paddingBottom: `${prevFrameSize / prevScale}px`
    },
    {
      translate: `0 ${scrollTop - scrollTopNext}px`,
      scale: scaleValue,
      paddingTop: `${frameSize / scaleValue}px`,
      paddingBottom: `${frameSize / scaleValue}px`
    }
  ];
}
function useScaleCanvas({
  frameSize,
  iframeDocument,
  maxContainerWidth = 750,
  scale
}) {
  const [contentResizeListener, { height: contentHeight }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  const [
    containerResizeListener,
    { width: containerWidth, height: containerHeight }
  ] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  const initialContainerWidthRef = (0,external_wp_element_namespaceObject.useRef)(0);
  const isZoomedOut = scale !== 1;
  const prefersReducedMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  const isAutoScaled = scale === "auto-scaled";
  const startAnimationRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const animationRef = (0,external_wp_element_namespaceObject.useRef)(null);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!isZoomedOut) {
      initialContainerWidthRef.current = containerWidth;
    }
  }, [containerWidth, isZoomedOut]);
  const scaleContainerWidth = Math.max(
    initialContainerWidthRef.current,
    containerWidth
  );
  const scaleValue = isAutoScaled ? calculateScale({
    frameSize,
    containerWidth,
    maxContainerWidth,
    scaleContainerWidth
  }) : scale;
  const transitionFromRef = (0,external_wp_element_namespaceObject.useRef)({
    scaleValue,
    frameSize,
    containerHeight: 0,
    scrollTop: 0,
    scrollHeight: 0
  });
  const transitionToRef = (0,external_wp_element_namespaceObject.useRef)({
    scaleValue,
    frameSize,
    containerHeight: 0,
    scrollTop: 0,
    scrollHeight: 0
  });
  const startZoomOutAnimation = (0,external_wp_element_namespaceObject.useCallback)(() => {
    const { scrollTop } = transitionFromRef.current;
    const { scrollTop: scrollTopNext } = transitionToRef.current;
    iframeDocument.documentElement.style.setProperty(
      "--wp-block-editor-iframe-zoom-out-scroll-top",
      `${scrollTop}px`
    );
    iframeDocument.documentElement.style.setProperty(
      "--wp-block-editor-iframe-zoom-out-scroll-top-next",
      `${scrollTopNext}px`
    );
    iframeDocument.documentElement.style.setProperty(
      "--wp-block-editor-iframe-zoom-out-overflow-behavior",
      transitionFromRef.current.scrollHeight === transitionFromRef.current.containerHeight ? "auto" : "scroll"
    );
    iframeDocument.documentElement.classList.add("zoom-out-animation");
    return iframeDocument.documentElement.animate(
      getAnimationKeyframes(
        transitionFromRef.current,
        transitionToRef.current
      ),
      {
        easing: "cubic-bezier(0.46, 0.03, 0.52, 0.96)",
        duration: 400
      }
    );
  }, [iframeDocument]);
  const finishZoomOutAnimation = (0,external_wp_element_namespaceObject.useCallback)(() => {
    startAnimationRef.current = false;
    animationRef.current = null;
    iframeDocument.documentElement.style.setProperty(
      "--wp-block-editor-iframe-zoom-out-scale",
      transitionToRef.current.scaleValue
    );
    iframeDocument.documentElement.style.setProperty(
      "--wp-block-editor-iframe-zoom-out-frame-size",
      `${transitionToRef.current.frameSize}px`
    );
    iframeDocument.documentElement.classList.remove("zoom-out-animation");
    iframeDocument.documentElement.scrollTop = transitionToRef.current.scrollTop;
    iframeDocument.documentElement.style.removeProperty(
      "--wp-block-editor-iframe-zoom-out-scroll-top"
    );
    iframeDocument.documentElement.style.removeProperty(
      "--wp-block-editor-iframe-zoom-out-scroll-top-next"
    );
    iframeDocument.documentElement.style.removeProperty(
      "--wp-block-editor-iframe-zoom-out-overflow-behavior"
    );
    transitionFromRef.current = transitionToRef.current;
  }, [iframeDocument]);
  const previousIsZoomedOut = (0,external_wp_element_namespaceObject.useRef)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const trigger = iframeDocument && previousIsZoomedOut.current !== isZoomedOut;
    previousIsZoomedOut.current = isZoomedOut;
    if (!trigger) {
      return;
    }
    startAnimationRef.current = true;
    if (!isZoomedOut) {
      return;
    }
    iframeDocument.documentElement.classList.add("is-zoomed-out");
    return () => {
      iframeDocument.documentElement.classList.remove("is-zoomed-out");
    };
  }, [iframeDocument, isZoomedOut]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!iframeDocument) {
      return;
    }
    if (isAutoScaled && transitionFromRef.current.scaleValue !== 1) {
      transitionFromRef.current.scaleValue = calculateScale({
        frameSize: transitionFromRef.current.frameSize,
        containerWidth,
        maxContainerWidth,
        scaleContainerWidth: containerWidth
      });
    }
    if (scaleValue < 1) {
      if (!startAnimationRef.current) {
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-scale",
          scaleValue
        );
        iframeDocument.documentElement.style.setProperty(
          "--wp-block-editor-iframe-zoom-out-frame-size",
          `${frameSize}px`
        );
      }
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-content-height",
        `${contentHeight}px`
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-inner-height",
        `${containerHeight}px`
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-container-width",
        `${containerWidth}px`
      );
      iframeDocument.documentElement.style.setProperty(
        "--wp-block-editor-iframe-zoom-out-scale-container-width",
        `${scaleContainerWidth}px`
      );
    }
    if (startAnimationRef.current) {
      startAnimationRef.current = false;
      if (animationRef.current) {
        animationRef.current.reverse();
        const tempTransitionFrom = transitionFromRef.current;
        const tempTransitionTo = transitionToRef.current;
        transitionFromRef.current = tempTransitionTo;
        transitionToRef.current = tempTransitionFrom;
      } else {
        transitionFromRef.current.scrollTop = iframeDocument.documentElement.scrollTop;
        transitionFromRef.current.scrollHeight = iframeDocument.documentElement.scrollHeight;
        transitionFromRef.current.containerHeight = containerHeight;
        transitionToRef.current = {
          scaleValue,
          frameSize,
          containerHeight: iframeDocument.documentElement.clientHeight
          // use clientHeight to get the actual height of the new container after zoom state changes have rendered, as it will be the most up-to-date.
        };
        transitionToRef.current.scrollHeight = computeScrollHeightNext(
          transitionFromRef.current,
          transitionToRef.current
        );
        transitionToRef.current.scrollTop = computeScrollTopNext(
          transitionFromRef.current,
          transitionToRef.current
        );
        animationRef.current = startZoomOutAnimation();
        if (prefersReducedMotion) {
          finishZoomOutAnimation();
        } else {
          animationRef.current.onfinish = finishZoomOutAnimation;
        }
      }
    }
  }, [
    startZoomOutAnimation,
    finishZoomOutAnimation,
    prefersReducedMotion,
    isAutoScaled,
    scaleValue,
    frameSize,
    iframeDocument,
    contentHeight,
    containerWidth,
    containerHeight,
    maxContainerWidth,
    scaleContainerWidth
  ]);
  return {
    isZoomedOut,
    scaleContainerWidth,
    contentResizeListener,
    containerResizeListener
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/iframe/index.js












function bubbleEvent(event, Constructor, frame) {
  const init = {};
  for (const key in event) {
    init[key] = event[key];
  }
  if (event instanceof frame.contentDocument.defaultView.MouseEvent) {
    const rect = frame.getBoundingClientRect();
    init.clientX += rect.left;
    init.clientY += rect.top;
  }
  const newEvent = new Constructor(event.type, init);
  if (init.defaultPrevented) {
    newEvent.preventDefault();
  }
  const cancelled = !frame.dispatchEvent(newEvent);
  if (cancelled) {
    event.preventDefault();
  }
}
function useBubbleEvents(iframeDocument) {
  return (0,external_wp_compose_namespaceObject.useRefEffect)(() => {
    const { defaultView } = iframeDocument;
    if (!defaultView) {
      return;
    }
    const { frameElement } = defaultView;
    const html = iframeDocument.documentElement;
    const eventTypes = ["dragover", "mousemove"];
    const handlers = {};
    for (const name of eventTypes) {
      handlers[name] = (event) => {
        const prototype = Object.getPrototypeOf(event);
        const constructorName = prototype.constructor.name;
        const Constructor = window[constructorName];
        bubbleEvent(event, Constructor, frameElement);
      };
      html.addEventListener(name, handlers[name]);
    }
    return () => {
      for (const name of eventTypes) {
        html.removeEventListener(name, handlers[name]);
      }
    };
  });
}
function Iframe({
  contentRef,
  children,
  tabIndex = 0,
  scale = 1,
  frameSize = 0,
  readonly,
  forwardedRef: ref,
  title = (0,external_wp_i18n_namespaceObject.__)("Editor canvas"),
  ...props
}) {
  const { resolvedAssets, isPreviewMode } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    const settings = getSettings();
    return {
      resolvedAssets: settings.__unstableResolvedAssets,
      isPreviewMode: settings.isPreviewMode
    };
  }, []);
  const { styles = "", scripts = "" } = resolvedAssets;
  const [iframeDocument, setIframeDocument] = (0,external_wp_element_namespaceObject.useState)();
  const [bodyClasses, setBodyClasses] = (0,external_wp_element_namespaceObject.useState)([]);
  const clearerRef = useBlockSelectionClearer();
  const [before, writingFlowRef, after] = useWritingFlow();
  const setRef = (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    node._load = () => {
      setIframeDocument(node.contentDocument);
    };
    let iFrameDocument;
    function preventFileDropDefault(event) {
      event.preventDefault();
    }
    function interceptLinkClicks(event) {
      if (event.target.tagName === "A" && event.target.getAttribute("href")?.startsWith("#")) {
        event.preventDefault();
        iFrameDocument.defaultView.location.hash = event.target.getAttribute("href").slice(1);
      }
    }
    const { ownerDocument } = node;
    setBodyClasses(
      Array.from(ownerDocument.body.classList).filter(
        (name) => name.startsWith("admin-color-") || name.startsWith("post-type-") || name === "wp-embed-responsive"
      )
    );
    function onLoad() {
      const { contentDocument } = node;
      const { documentElement } = contentDocument;
      iFrameDocument = contentDocument;
      documentElement.classList.add("block-editor-iframe__html");
      clearerRef(documentElement);
      contentDocument.dir = ownerDocument.dir;
      for (const compatStyle of getCompatibilityStyles()) {
        if (contentDocument.getElementById(compatStyle.id)) {
          continue;
        }
        contentDocument.head.appendChild(
          compatStyle.cloneNode(true)
        );
        if (!isPreviewMode) {
          console.warn(
            `${compatStyle.id} was added to the iframe incorrectly. Please use block.json or enqueue_block_assets to add styles to the iframe.`,
            compatStyle
          );
        }
      }
      iFrameDocument.addEventListener(
        "dragover",
        preventFileDropDefault,
        false
      );
      iFrameDocument.addEventListener(
        "drop",
        preventFileDropDefault,
        false
      );
      iFrameDocument.addEventListener("click", interceptLinkClicks);
    }
    node.addEventListener("load", onLoad);
    return () => {
      delete node._load;
      node.removeEventListener("load", onLoad);
      iFrameDocument?.removeEventListener(
        "dragover",
        preventFileDropDefault
      );
      iFrameDocument?.removeEventListener(
        "drop",
        preventFileDropDefault
      );
      iFrameDocument?.removeEventListener("click", interceptLinkClicks);
    };
  }, []);
  const {
    contentResizeListener,
    containerResizeListener,
    isZoomedOut,
    scaleContainerWidth
  } = useScaleCanvas({
    scale,
    frameSize: parseInt(frameSize),
    iframeDocument
  });
  const disabledRef = (0,external_wp_compose_namespaceObject.useDisabled)({ isDisabled: !readonly });
  const bodyRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([
    useBubbleEvents(iframeDocument),
    contentRef,
    clearerRef,
    writingFlowRef,
    disabledRef
  ]);
  const html = `<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<base href="${window.location.origin}">
		<script>window.frameElement._load()</script>
		<style>
			html{
				height: auto !important;
				min-height: 100%;
			}
			/* Lowest specificity to not override global styles */
			:where(body) {
				margin: 0;
				/* Default background color in case zoom out mode background
				colors the html element */
				background-color: white;
			}
		</style>
		${styles}
		${scripts}
	</head>
	<body>
		<script>document.currentScript.parentElement.remove()</script>
	</body>
</html>`;
  const [src, cleanup] = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const _src = URL.createObjectURL(
      new window.Blob([html], { type: "text/html" })
    );
    return [_src, () => URL.revokeObjectURL(_src)];
  }, [html]);
  (0,external_wp_element_namespaceObject.useEffect)(() => cleanup, [cleanup]);
  const shouldRenderFocusCaptureElements = tabIndex >= 0 && !isPreviewMode;
  const iframe = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    shouldRenderFocusCaptureElements && before,
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "iframe",
      {
        ...props,
        style: {
          ...props.style,
          height: props.style?.height,
          border: 0
        },
        ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, setRef]),
        tabIndex,
        src,
        title,
        onKeyDown: (event) => {
          if (props.onKeyDown) {
            props.onKeyDown(event);
          }
          if (event.currentTarget.ownerDocument !== event.target.ownerDocument) {
            const { stopPropagation } = event.nativeEvent;
            event.nativeEvent.stopPropagation = () => {
            };
            event.stopPropagation();
            event.nativeEvent.stopPropagation = stopPropagation;
            bubbleEvent(
              event,
              window.KeyboardEvent,
              event.currentTarget
            );
          }
        },
        children: iframeDocument && (0,external_wp_element_namespaceObject.createPortal)(
          // We want to prevent React events from bubbling through the iframe
          // we bubble these manually.
          /* eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions */
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            "body",
            {
              ref: bodyRef,
              className: dist_clsx(
                "block-editor-iframe__body",
                "editor-styles-wrapper",
                ...bodyClasses
              ),
              children: [
                contentResizeListener,
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalStyleProvider, { document: iframeDocument, children })
              ]
            }
          ),
          iframeDocument.documentElement
        )
      }
    ),
    shouldRenderFocusCaptureElements && after
  ] });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-iframe__container", children: [
    containerResizeListener,
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        className: dist_clsx(
          "block-editor-iframe__scale-container",
          isZoomedOut && "is-zoomed-out"
        ),
        style: {
          "--wp-block-editor-iframe-zoom-out-scale-container-width": isZoomedOut && `${scaleContainerWidth}px`
        },
        children: iframe
      }
    )
  ] });
}
function IframeIfReady(props, ref) {
  const isInitialised = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings().__internalIsInitialized,
    []
  );
  if (!isInitialised) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Iframe, { ...props, forwardedRef: ref });
}
var iframe_default = (0,external_wp_element_namespaceObject.forwardRef)(IframeIfReady);


;// ./node_modules/parsel-js/dist/parsel.js
const TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
    id: /#(?<name>[-\w\P{ASCII}]+)/gu,
    class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    'pseudo-element': /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
    'pseudo-class': /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
    universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
    type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu, // this must be last
};
const TRIM_TOKENS = new Set(['combinator', 'comma']);
const RECURSIVE_PSEUDO_CLASSES = new Set([
    'not',
    'is',
    'where',
    'has',
    'matches',
    '-moz-any',
    '-webkit-any',
    'nth-child',
    'nth-last-child',
]);
const nthChildRegExp = /(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/;
const RECURSIVE_PSEUDO_CLASSES_ARGS = {
    'nth-child': nthChildRegExp,
    'nth-last-child': nthChildRegExp,
};
const getArgumentPatternByType = (type) => {
    switch (type) {
        case 'pseudo-element':
        case 'pseudo-class':
            return new RegExp(TOKENS[type].source.replace('(?<argument>*)', '(?<argument>.*)'), 'gu');
        default:
            return TOKENS[type];
    }
};
function gobbleParens(text, offset) {
    let nesting = 0;
    let result = '';
    for (; offset < text.length; offset++) {
        const char = text[offset];
        switch (char) {
            case '(':
                ++nesting;
                break;
            case ')':
                --nesting;
                break;
        }
        result += char;
        if (nesting === 0) {
            return result;
        }
    }
    return result;
}
function tokenizeBy(text, grammar = TOKENS) {
    if (!text) {
        return [];
    }
    const tokens = [text];
    for (const [type, pattern] of Object.entries(grammar)) {
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (typeof token !== 'string') {
                continue;
            }
            pattern.lastIndex = 0;
            const match = pattern.exec(token);
            if (!match) {
                continue;
            }
            const from = match.index - 1;
            const args = [];
            const content = match[0];
            const before = token.slice(0, from + 1);
            if (before) {
                args.push(before);
            }
            args.push({
                ...match.groups,
                type,
                content,
            });
            const after = token.slice(from + content.length + 1);
            if (after) {
                args.push(after);
            }
            tokens.splice(i, 1, ...args);
        }
    }
    let offset = 0;
    for (const token of tokens) {
        switch (typeof token) {
            case 'string':
                throw new Error(`Unexpected sequence ${token} found at index ${offset}`);
            case 'object':
                offset += token.content.length;
                token.pos = [offset - token.content.length, offset];
                if (TRIM_TOKENS.has(token.type)) {
                    token.content = token.content.trim() || ' ';
                }
                break;
        }
    }
    return tokens;
}
const STRING_PATTERN = /(['"])([^\\\n]+?)\1/g;
const ESCAPE_PATTERN = /\\./g;
function parsel_tokenize(selector, grammar = TOKENS) {
    // Prevent leading/trailing whitespaces from being interpreted as combinators
    selector = selector.trim();
    if (selector === '') {
        return [];
    }
    const replacements = [];
    // Replace escapes with placeholders.
    selector = selector.replace(ESCAPE_PATTERN, (value, offset) => {
        replacements.push({ value, offset });
        return '\uE000'.repeat(value.length);
    });
    // Replace strings with placeholders.
    selector = selector.replace(STRING_PATTERN, (value, quote, content, offset) => {
        replacements.push({ value, offset });
        return `${quote}${'\uE001'.repeat(content.length)}${quote}`;
    });
    // Replace parentheses with placeholders.
    {
        let pos = 0;
        let offset;
        while ((offset = selector.indexOf('(', pos)) > -1) {
            const value = gobbleParens(selector, offset);
            replacements.push({ value, offset });
            selector = `${selector.substring(0, offset)}(${''.repeat(value.length - 2)})${selector.substring(offset + value.length)}`;
            pos = offset + value.length;
        }
    }
    // Now we have no nested structures and we can parse with regexes
    const tokens = tokenizeBy(selector, grammar);
    // Replace placeholders in reverse order.
    const changedTokens = new Set();
    for (const replacement of replacements.reverse()) {
        for (const token of tokens) {
            const { offset, value } = replacement;
            if (!(token.pos[0] <= offset &&
                offset + value.length <= token.pos[1])) {
                continue;
            }
            const { content } = token;
            const tokenOffset = offset - token.pos[0];
            token.content =
                content.slice(0, tokenOffset) +
                    value +
                    content.slice(tokenOffset + value.length);
            if (token.content !== content) {
                changedTokens.add(token);
            }
        }
    }
    // Update changed tokens.
    for (const token of changedTokens) {
        const pattern = getArgumentPatternByType(token.type);
        if (!pattern) {
            throw new Error(`Unknown token type: ${token.type}`);
        }
        pattern.lastIndex = 0;
        const match = pattern.exec(token.content);
        if (!match) {
            throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
        }
        Object.assign(token, match.groups);
    }
    return tokens;
}
/**
 *  Convert a flat list of tokens into a tree of complex & compound selectors
 */
function nestTokens(tokens, { list = true } = {}) {
    if (list && tokens.find((t) => t.type === 'comma')) {
        const selectors = [];
        const temp = [];
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].type === 'comma') {
                if (temp.length === 0) {
                    throw new Error('Incorrect comma at ' + i);
                }
                selectors.push(nestTokens(temp, { list: false }));
                temp.length = 0;
            }
            else {
                temp.push(tokens[i]);
            }
        }
        if (temp.length === 0) {
            throw new Error('Trailing comma');
        }
        else {
            selectors.push(nestTokens(temp, { list: false }));
        }
        return { type: 'list', list: selectors };
    }
    for (let i = tokens.length - 1; i >= 0; i--) {
        let token = tokens[i];
        if (token.type === 'combinator') {
            let left = tokens.slice(0, i);
            let right = tokens.slice(i + 1);
            return {
                type: 'complex',
                combinator: token.content,
                left: nestTokens(left),
                right: nestTokens(right),
            };
        }
    }
    switch (tokens.length) {
        case 0:
            throw new Error('Could not build AST.');
        case 1:
            // If we're here, there are no combinators, so it's just a list.
            return tokens[0];
        default:
            return {
                type: 'compound',
                list: [...tokens], // clone to avoid pointers messing up the AST
            };
    }
}
/**
 * Traverse an AST in depth-first order
 */
function* flatten(node, 
/**
 * @internal
 */
parent) {
    switch (node.type) {
        case 'list':
            for (let child of node.list) {
                yield* flatten(child, node);
            }
            break;
        case 'complex':
            yield* flatten(node.left, node);
            yield* flatten(node.right, node);
            break;
        case 'compound':
            yield* node.list.map((token) => [token, node]);
            break;
        default:
            yield [node, parent];
    }
}
/**
 * Traverse an AST (or part thereof), in depth-first order
 */
function walk(node, visit, 
/**
 * @internal
 */
parent) {
    if (!node) {
        return;
    }
    for (const [token, ast] of flatten(node, parent)) {
        visit(token, ast);
    }
}
/**
 * Parse a CSS selector
 *
 * @param selector - The selector to parse
 * @param options.recursive - Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.
 * @param options.list - Whether this can be a selector list (A, B, C etc). Defaults to true.
 */
function parse(selector, { recursive = true, list = true } = {}) {
    const tokens = parsel_tokenize(selector);
    if (!tokens) {
        return;
    }
    const ast = nestTokens(tokens, { list });
    if (!recursive) {
        return ast;
    }
    for (const [token] of flatten(ast)) {
        if (token.type !== 'pseudo-class' || !token.argument) {
            continue;
        }
        if (!RECURSIVE_PSEUDO_CLASSES.has(token.name)) {
            continue;
        }
        let argument = token.argument;
        const childArg = RECURSIVE_PSEUDO_CLASSES_ARGS[token.name];
        if (childArg) {
            const match = childArg.exec(argument);
            if (!match) {
                continue;
            }
            Object.assign(token, match.groups);
            argument = match.groups['subtree'];
        }
        if (!argument) {
            continue;
        }
        Object.assign(token, {
            subtree: parse(argument, {
                recursive: true,
                list: true,
            }),
        });
    }
    return ast;
}
/**
 * Converts the given list or (sub)tree to a string.
 */
function parsel_stringify(listOrNode) {
    let tokens;
    if (Array.isArray(listOrNode)) {
        tokens = listOrNode;
    }
    else {
        tokens = [...flatten(listOrNode)].map(([token]) => token);
    }
    return tokens.map(token => token.content).join('');
}
/**
 * To convert the specificity array to a number
 */
function specificityToNumber(specificity, base) {
    base = base || Math.max(...specificity) + 1;
    return (specificity[0] * (base << 1) + specificity[1] * base + specificity[2]);
}
/**
 * Calculate specificity of a selector.
 *
 * If the selector is a list, the max specificity is returned.
 */
function specificity(selector) {
    let ast = selector;
    if (typeof ast === 'string') {
        ast = parse(ast, { recursive: true });
    }
    if (!ast) {
        return [];
    }
    if (ast.type === 'list' && 'list' in ast) {
        let base = 10;
        const specificities = ast.list.map((ast) => {
            const sp = specificity(ast);
            base = Math.max(base, ...specificity(ast));
            return sp;
        });
        const numbers = specificities.map((ast) => specificityToNumber(ast, base));
        return specificities[numbers.indexOf(Math.max(...numbers))];
    }
    const ret = [0, 0, 0];
    for (const [token] of flatten(ast)) {
        switch (token.type) {
            case 'id':
                ret[0]++;
                break;
            case 'class':
            case 'attribute':
                ret[1]++;
                break;
            case 'pseudo-element':
            case 'type':
                ret[2]++;
                break;
            case 'pseudo-class':
                if (token.name === 'where') {
                    break;
                }
                if (!RECURSIVE_PSEUDO_CLASSES.has(token.name) ||
                    !token.subtree) {
                    ret[1]++;
                    break;
                }
                const sub = specificity(token.subtree);
                sub.forEach((s, i) => (ret[i] += s));
                // :nth-child() & :nth-last-child() add (0, 1, 0) to the specificity of their most complex selector
                if (token.name === 'nth-child' ||
                    token.name === 'nth-last-child') {
                    ret[1]++;
                }
        }
    }
    return ret;
}



// EXTERNAL MODULE: ./node_modules/postcss/lib/processor.js
var processor = __webpack_require__(9656);
var processor_default = /*#__PURE__*/__webpack_require__.n(processor);
// EXTERNAL MODULE: ./node_modules/postcss/lib/css-syntax-error.js
var css_syntax_error = __webpack_require__(356);
var css_syntax_error_default = /*#__PURE__*/__webpack_require__.n(css_syntax_error);
// EXTERNAL MODULE: ./node_modules/postcss-prefix-selector/index.js
var postcss_prefix_selector = __webpack_require__(1443);
var postcss_prefix_selector_default = /*#__PURE__*/__webpack_require__.n(postcss_prefix_selector);
// EXTERNAL MODULE: ./node_modules/postcss-urlrebase/index.js
var postcss_urlrebase = __webpack_require__(5404);
var postcss_urlrebase_default = /*#__PURE__*/__webpack_require__.n(postcss_urlrebase);
;// ./node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js





const cacheByWrapperSelector = /* @__PURE__ */ new Map();
const ROOT_SELECTOR_TOKENS = [
  { type: "type", content: "body" },
  { type: "type", content: "html" },
  { type: "pseudo-class", content: ":root" },
  { type: "pseudo-class", content: ":where(body)" },
  { type: "pseudo-class", content: ":where(:root)" },
  { type: "pseudo-class", content: ":where(html)" }
];
function prefixRootSelector(prefix, selector) {
  const tokenized = parsel_tokenize(selector);
  const lastRootIndex = tokenized.findLastIndex(({ content, type }) => {
    return ROOT_SELECTOR_TOKENS.some(
      (rootSelector) => content === rootSelector.content && type === rootSelector.type
    );
  });
  let insertionPoint = -1;
  for (let i = lastRootIndex + 1; i < tokenized.length; i++) {
    if (tokenized[i].type === "combinator") {
      insertionPoint = i;
      break;
    }
  }
  const tokenizedPrefix = parsel_tokenize(prefix);
  tokenized.splice(
    // Insert at the insertion point, or the end.
    insertionPoint === -1 ? tokenized.length : insertionPoint,
    0,
    {
      type: "combinator",
      content: " "
    },
    ...tokenizedPrefix
  );
  return parsel_stringify(tokenized);
}
function transformStyle({ css, ignoredSelectors = [], baseURL }, wrapperSelector = "", transformOptions) {
  if (!wrapperSelector && !baseURL) {
    return css;
  }
  try {
    const excludedSelectors = [
      ...ignoredSelectors,
      ...transformOptions?.ignoredSelectors ?? [],
      wrapperSelector
    ];
    return new (processor_default())(
      [
        wrapperSelector && postcss_prefix_selector_default()({
          prefix: wrapperSelector,
          transform(prefix, selector, prefixedSelector) {
            if (excludedSelectors.some(
              (excludedSelector) => excludedSelector instanceof RegExp ? selector.match(excludedSelector) : selector.includes(excludedSelector)
            )) {
              return selector;
            }
            const hasRootSelector = ROOT_SELECTOR_TOKENS.some(
              (rootSelector) => selector.startsWith(rootSelector.content)
            );
            if (hasRootSelector) {
              return prefixRootSelector(prefix, selector);
            }
            return prefixedSelector;
          }
        }),
        baseURL && postcss_urlrebase_default()({ rootUrl: baseURL })
      ].filter(Boolean)
    ).process(css, {}).css;
  } catch (error) {
    if (error instanceof (css_syntax_error_default())) {
      console.warn(
        "wp.blockEditor.transformStyles Failed to transform CSS.",
        error.message + "\n" + error.showSourceCode(false)
      );
    } else {
      console.warn(
        "wp.blockEditor.transformStyles Failed to transform CSS.",
        error
      );
    }
    return null;
  }
}
const transform_styles_transformStyles = (styles, wrapperSelector = "", transformOptions) => {
  let cache = cacheByWrapperSelector.get(wrapperSelector);
  if (!cache) {
    cache = /* @__PURE__ */ new WeakMap();
    cacheByWrapperSelector.set(wrapperSelector, cache);
  }
  return styles.map((style) => {
    let css = cache.get(style);
    if (!css) {
      css = transformStyle(style, wrapperSelector, transformOptions);
      cache.set(style, css);
    }
    return css;
  });
};
var transform_styles_default = transform_styles_transformStyles;


;// ./node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js










k([names, a11y]);
function useDarkThemeBodyClassName(styles, scope) {
  return (0,external_wp_element_namespaceObject.useCallback)(
    (node) => {
      if (!node) {
        return;
      }
      const { ownerDocument } = node;
      const { defaultView, body } = ownerDocument;
      const canvas = scope ? ownerDocument.querySelector(scope) : body;
      let backgroundColor;
      if (!canvas) {
        const tempCanvas = ownerDocument.createElement("div");
        tempCanvas.classList.add("editor-styles-wrapper");
        body.appendChild(tempCanvas);
        backgroundColor = defaultView?.getComputedStyle(tempCanvas, null).getPropertyValue("background-color");
        body.removeChild(tempCanvas);
      } else {
        backgroundColor = defaultView?.getComputedStyle(canvas, null).getPropertyValue("background-color");
      }
      const colordBackgroundColor = w(backgroundColor);
      if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
        body.classList.remove("is-dark-theme");
      } else {
        body.classList.add("is-dark-theme");
      }
    },
    [styles, scope]
  );
}
function EditorStyles({ styles, scope, transformOptions }) {
  const overrides = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(store)).getStyleOverrides(),
    []
  );
  const [transformedStyles, transformedSvgs] = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const _styles = Object.values(styles ?? []);
    for (const [id, override] of overrides) {
      const index = _styles.findIndex(({ id: _id }) => id === _id);
      const overrideWithId = { ...override, id };
      if (index === -1) {
        _styles.push(overrideWithId);
      } else {
        _styles[index] = overrideWithId;
      }
    }
    return [
      transform_styles_default(
        _styles.filter((style) => style?.css),
        scope,
        transformOptions
      ),
      _styles.filter((style) => style.__unstableType === "svgs").map((style) => style.assets).join("")
    ];
  }, [styles, overrides, scope, transformOptions]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "style",
      {
        ref: useDarkThemeBodyClassName(transformedStyles, scope)
      }
    ),
    transformedStyles.map((css, index) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("style", { children: css }, index)),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.SVG,
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 0 0",
        width: "0",
        height: "0",
        role: "none",
        style: {
          visibility: "hidden",
          position: "absolute",
          left: "-9999px",
          overflow: "hidden"
        },
        dangerouslySetInnerHTML: { __html: transformedSvgs }
      }
    )
  ] });
}
var editor_styles_default = (0,external_wp_element_namespaceObject.memo)(EditorStyles);


;// ./node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js









const MemoizedBlockList = (0,external_wp_element_namespaceObject.memo)(BlockList);
const MAX_HEIGHT = 2e3;
const EMPTY_ADDITIONAL_STYLES = [];
function ScaledBlockPreview({
  viewportWidth,
  containerWidth,
  minHeight,
  additionalStyles = EMPTY_ADDITIONAL_STYLES
}) {
  if (!viewportWidth) {
    viewportWidth = containerWidth;
  }
  const [contentResizeListener, { height: contentHeight }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  const { styles } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const settings = select(store).getSettings();
    return {
      styles: settings.styles
    };
  }, []);
  const editorStyles = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (styles) {
      return [
        ...styles,
        {
          css: "body{height:auto;overflow:hidden;border:none;padding:0;}",
          __unstableType: "presets"
        },
        ...additionalStyles
      ];
    }
    return styles;
  }, [styles, additionalStyles]);
  const scale = containerWidth / viewportWidth;
  const aspectRatio = contentHeight ? containerWidth / (contentHeight * scale) : 0;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Disabled,
    {
      className: "block-editor-block-preview__content",
      style: {
        transform: `scale(${scale})`,
        // Using width + aspect-ratio instead of height here triggers browsers' native
        // handling of scrollbar's visibility. It prevents the flickering issue seen
        // in https://github.com/WordPress/gutenberg/issues/52027.
        // See https://github.com/WordPress/gutenberg/pull/52921 for more info.
        aspectRatio,
        maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale : void 0,
        minHeight
      },
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        iframe_default,
        {
          contentRef: (0,external_wp_compose_namespaceObject.useRefEffect)((bodyElement) => {
            const {
              ownerDocument: { documentElement }
            } = bodyElement;
            documentElement.classList.add(
              "block-editor-block-preview__content-iframe"
            );
            documentElement.style.position = "absolute";
            documentElement.style.width = "100%";
            bodyElement.style.boxSizing = "border-box";
            bodyElement.style.position = "absolute";
            bodyElement.style.width = "100%";
          }, []),
          "aria-hidden": true,
          tabIndex: -1,
          style: {
            position: "absolute",
            width: viewportWidth,
            height: contentHeight,
            pointerEvents: "none",
            // This is a catch-all max-height for patterns.
            // See: https://github.com/WordPress/gutenberg/pull/38175.
            maxHeight: MAX_HEIGHT,
            minHeight: scale !== 0 && scale < 1 && minHeight ? minHeight / scale : minHeight
          },
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(editor_styles_default, { styles: editorStyles }),
            contentResizeListener,
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MemoizedBlockList, { renderAppender: false })
          ]
        }
      )
    }
  );
}
function AutoBlockPreview(props) {
  const [containerResizeListener, { width: containerWidth }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { style: { position: "relative", width: "100%", height: 0 }, children: containerResizeListener }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-preview__container", children: !!containerWidth && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ScaledBlockPreview,
      {
        ...props,
        containerWidth
      }
    ) })
  ] });
}


;// external ["wp","priorityQueue"]
const external_wp_priorityQueue_namespaceObject = window["wp"]["priorityQueue"];
;// ./node_modules/@wordpress/block-editor/build-module/components/block-preview/async.js


const blockPreviewQueue = (0,external_wp_priorityQueue_namespaceObject.createQueue)();
function Async({ children, placeholder }) {
  const [shouldRender, setShouldRender] = (0,external_wp_element_namespaceObject.useState)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const context = {};
    blockPreviewQueue.add(context, () => {
      (0,external_wp_element_namespaceObject.flushSync)(() => {
        setShouldRender(true);
      });
    });
    return () => {
      blockPreviewQueue.cancel(context);
    };
  }, []);
  if (!shouldRender) {
    return placeholder;
  }
  return children;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js












const block_preview_EMPTY_ADDITIONAL_STYLES = [];
function BlockPreview({
  blocks,
  viewportWidth = 1200,
  minHeight,
  additionalStyles = block_preview_EMPTY_ADDITIONAL_STYLES,
  // Deprecated props:
  __experimentalMinHeight,
  __experimentalPadding
}) {
  if (__experimentalMinHeight) {
    minHeight = __experimentalMinHeight;
    external_wp_deprecated_default()("The __experimentalMinHeight prop", {
      since: "6.2",
      version: "6.4",
      alternative: "minHeight"
    });
  }
  if (__experimentalPadding) {
    additionalStyles = [
      ...additionalStyles,
      { css: `body { padding: ${__experimentalPadding}px; }` }
    ];
    external_wp_deprecated_default()("The __experimentalPadding prop of BlockPreview", {
      since: "6.2",
      version: "6.4",
      alternative: "additionalStyles"
    });
  }
  const originalSettings = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings(),
    []
  );
  const settings = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      ...originalSettings,
      focusMode: false,
      // Disable "Spotlight mode".
      isPreviewMode: true
    }),
    [originalSettings]
  );
  const renderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(
    () => Array.isArray(blocks) ? blocks : [blocks],
    [blocks]
  );
  if (!blocks || blocks.length === 0) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    ExperimentalBlockEditorProvider,
    {
      value: renderedBlocks,
      settings,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        AutoBlockPreview,
        {
          viewportWidth,
          minHeight,
          additionalStyles
        }
      )
    }
  );
}
const MemoizedBlockPreview = (0,external_wp_element_namespaceObject.memo)(BlockPreview);
MemoizedBlockPreview.Async = Async;
var block_preview_default = MemoizedBlockPreview;
function useBlockPreview({ blocks, props = {}, layout }) {
  const originalSettings = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings(),
    []
  );
  const settings = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      ...originalSettings,
      styles: void 0,
      // Clear styles included by the parent settings, as they are already output by the parent's EditorStyles.
      focusMode: false,
      // Disable "Spotlight mode".
      isPreviewMode: true
    }),
    [originalSettings]
  );
  const disabledRef = (0,external_wp_compose_namespaceObject.useDisabled)();
  const ref = (0,external_wp_compose_namespaceObject.useMergeRefs)([props.ref, disabledRef]);
  const renderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(
    () => Array.isArray(blocks) ? blocks : [blocks],
    [blocks]
  );
  const children = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    ExperimentalBlockEditorProvider,
    {
      value: renderedBlocks,
      settings,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(editor_styles_default, {}),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockListItems, { renderAppender: false, layout })
      ]
    }
  );
  return {
    ...props,
    ref,
    className: dist_clsx(
      props.className,
      "block-editor-block-preview__live-content",
      "components-disabled"
    ),
    children: blocks?.length ? children : null
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js






function InserterPreviewPanel({ item }) {
  const { name, title, icon, description, initialAttributes, example } = item;
  const isReusable = (0,external_wp_blocks_namespaceObject.isReusableBlock)(item);
  const blocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!example) {
      return (0,external_wp_blocks_namespaceObject.createBlock)(name, initialAttributes);
    }
    return (0,external_wp_blocks_namespaceObject.getBlockFromExample)(name, {
      attributes: {
        ...example.attributes,
        ...initialAttributes
      },
      innerBlocks: example.innerBlocks
    });
  }, [name, example, initialAttributes]);
  const previewHeight = 144;
  const sidebarWidth = 280;
  const viewportWidth = example?.viewportWidth ?? 500;
  const scale = sidebarWidth / viewportWidth;
  const minHeight = scale !== 0 && scale < 1 && previewHeight ? previewHeight / scale : previewHeight;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-inserter__preview-container", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__preview", children: isReusable || example ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__preview-content", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_preview_default,
      {
        blocks,
        viewportWidth,
        minHeight: previewHeight,
        additionalStyles: (
          //We want this CSS to be in sync with the one in BlockPreviewPanel.
          [
            {
              css: `
										body { 
											padding: 24px;
											min-height:${Math.round(minHeight)}px;
											display:flex;
											align-items:center;
										}
										.is-root-container { width: 100%; }
									`
            }
          ]
        )
      }
    ) }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__preview-content-missing", children: (0,external_wp_i18n_namespaceObject.__)("No preview available.") }) }),
    !isReusable && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_card_default,
      {
        title,
        icon,
        description
      }
    )
  ] });
}
var preview_panel_default = InserterPreviewPanel;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js



function InserterListboxItem({ isFirst, as: Component, children, ...props }, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite.Item,
    {
      ref,
      role: "option",
      accessibleWhenDisabled: true,
      ...props,
      render: (htmlProps) => {
        const propsWithTabIndex = {
          ...htmlProps,
          tabIndex: isFirst ? 0 : htmlProps.tabIndex
        };
        if (Component) {
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Component, { ...propsWithTabIndex, children });
        }
        if (typeof children === "function") {
          return children(propsWithTabIndex);
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { __next40pxDefaultSize: true, ...propsWithTabIndex, children });
      }
    }
  );
}
var item_default = (0,external_wp_element_namespaceObject.forwardRef)(InserterListboxItem);


;// ./node_modules/@wordpress/icons/build-module/library/drag-handle.js


var drag_handle_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js





function BlockDraggableChip({
  count,
  icon,
  isPattern,
  fadeWhenDisabled
}) {
  const patternLabel = isPattern && (0,external_wp_i18n_namespaceObject.__)("Pattern");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-draggable-chip-wrapper", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      className: "block-editor-block-draggable-chip",
      "data-testid": "block-draggable-chip",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        external_wp_components_namespaceObject.Flex,
        {
          justify: "center",
          className: "block-editor-block-draggable-chip__content",
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: icon ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon }) : patternLabel || (0,external_wp_i18n_namespaceObject.sprintf)(
              /* translators: %d: Number of blocks. */
              (0,external_wp_i18n_namespaceObject._n)("%d block", "%d blocks", count),
              count
            ) }),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: drag_handle_default }) }),
            fadeWhenDisabled && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { className: "block-editor-block-draggable-chip__disabled", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-block-draggable-chip__disabled-icon" }) })
          ]
        }
      )
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js









const InserterDraggableBlocks = ({
  isEnabled,
  blocks,
  icon,
  children,
  pattern
}) => {
  const blockTypeIcon = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockType } = select(external_wp_blocks_namespaceObject.store);
      return blocks.length === 1 && getBlockType(blocks[0].name)?.icon;
    },
    [blocks]
  );
  const { startDragging, stopDragging } = unlock(
    (0,external_wp_data_namespaceObject.useDispatch)(store)
  );
  const patternBlock = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return pattern?.type === INSERTER_PATTERN_TYPES.user && pattern?.syncStatus !== "unsynced" ? [(0,external_wp_blocks_namespaceObject.createBlock)("core/block", { ref: pattern.id })] : void 0;
  }, [pattern?.type, pattern?.syncStatus, pattern?.id]);
  if (!isEnabled) {
    return children({
      draggable: false,
      onDragStart: void 0,
      onDragEnd: void 0
    });
  }
  const draggableBlocks = patternBlock ?? blocks;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Draggable,
    {
      __experimentalTransferDataType: "wp-blocks",
      transferData: { type: "inserter", blocks: draggableBlocks },
      onDragStart: (event) => {
        startDragging();
        for (const block of draggableBlocks) {
          const type = `wp-block:${block.name}`;
          event.dataTransfer.items.add("", type);
        }
      },
      onDragEnd: () => {
        stopDragging();
      },
      __experimentalDragComponent: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockDraggableChip,
        {
          count: blocks.length,
          icon: icon || !pattern && blockTypeIcon,
          isPattern: !!pattern
        }
      ),
      children: ({ onDraggableStart, onDraggableEnd }) => {
        return children({
          draggable: true,
          onDragStart: onDraggableStart,
          onDragEnd: onDraggableEnd
        });
      }
    }
  );
};
var inserter_draggable_blocks_default = InserterDraggableBlocks;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js









function InserterListItem({
  className,
  isFirst,
  item,
  onSelect,
  onHover,
  isDraggable,
  ...props
}) {
  const isDraggingRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const itemIconStyle = item.icon ? {
    backgroundColor: item.icon.background,
    color: item.icon.foreground
  } : {};
  const blocks = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      (0,external_wp_blocks_namespaceObject.createBlock)(
        item.name,
        item.initialAttributes,
        (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(item.innerBlocks)
      )
    ],
    [item.name, item.initialAttributes, item.innerBlocks]
  );
  const isSynced = (0,external_wp_blocks_namespaceObject.isReusableBlock)(item) && item.syncStatus !== "unsynced" || (0,external_wp_blocks_namespaceObject.isTemplatePart)(item);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inserter_draggable_blocks_default,
    {
      isEnabled: isDraggable && !item.isDisabled,
      blocks,
      icon: item.icon,
      children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "div",
        {
          className: dist_clsx(
            "block-editor-block-types-list__list-item",
            {
              "is-synced": isSynced
            }
          ),
          draggable,
          onDragStart: (event) => {
            isDraggingRef.current = true;
            if (onDragStart) {
              onHover(null);
              onDragStart(event);
            }
          },
          onDragEnd: (event) => {
            isDraggingRef.current = false;
            if (onDragEnd) {
              onDragEnd(event);
            }
          },
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            item_default,
            {
              isFirst,
              className: dist_clsx(
                "block-editor-block-types-list__item",
                className
              ),
              disabled: item.isDisabled,
              onClick: (event) => {
                event.preventDefault();
                onSelect(
                  item,
                  (0,external_wp_keycodes_namespaceObject.isAppleOS)() ? event.metaKey : event.ctrlKey
                );
                onHover(null);
              },
              onKeyDown: (event) => {
                const { keyCode } = event;
                if (keyCode === external_wp_keycodes_namespaceObject.ENTER) {
                  event.preventDefault();
                  onSelect(
                    item,
                    (0,external_wp_keycodes_namespaceObject.isAppleOS)() ? event.metaKey : event.ctrlKey
                  );
                  onHover(null);
                }
              },
              onMouseEnter: () => {
                if (isDraggingRef.current) {
                  return;
                }
                onHover(item);
              },
              onMouseLeave: () => onHover(null),
              ...props,
              children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  "span",
                  {
                    className: "block-editor-block-types-list__item-icon",
                    style: itemIconStyle,
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: item.icon, showColors: true })
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-block-types-list__item-title", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { numberOfLines: 3, children: item.title }) })
              ]
            }
          )
        }
      )
    }
  );
}
var inserter_list_item_default = (0,external_wp_element_namespaceObject.memo)(InserterListItem);


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js




function InserterListboxGroup(props, ref) {
  const [shouldSpeak, setShouldSpeak] = (0,external_wp_element_namespaceObject.useState)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (shouldSpeak) {
      (0,external_wp_a11y_namespaceObject.speak)(
        (0,external_wp_i18n_namespaceObject.__)("Use left and right arrow keys to move through blocks")
      );
    }
  }, [shouldSpeak]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      ref,
      role: "listbox",
      "aria-orientation": "horizontal",
      onFocus: () => {
        setShouldSpeak(true);
      },
      onBlur: (event) => {
        const focusingOutsideGroup = !event.currentTarget.contains(
          event.relatedTarget
        );
        if (focusingOutsideGroup) {
          setShouldSpeak(false);
        }
      },
      ...props
    }
  );
}
var group_default = (0,external_wp_element_namespaceObject.forwardRef)(InserterListboxGroup);


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js



function InserterListboxRow(props, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Composite.Group, { role: "presentation", ref, ...props });
}
var row_default = (0,external_wp_element_namespaceObject.forwardRef)(InserterListboxRow);


;// ./node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js





function chunk(array, size) {
  const chunks = [];
  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
function BlockTypesList({
  items = [],
  onSelect,
  onHover = () => {
  },
  children,
  label,
  isDraggable = true
}) {
  const className = "block-editor-block-types-list";
  const listId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockTypesList, className);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(group_default, { className, "aria-label": label, children: [
    chunk(items, 3).map((row, i) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(row_default, { children: row.map((item, j) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inserter_list_item_default,
      {
        item,
        className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(
          item.id
        ),
        onSelect,
        onHover,
        isDraggable: isDraggable && !item.isDisabled,
        isFirst: i === 0 && j === 0,
        rowId: `${listId}-${i}`
      },
      item.id
    )) }, i)),
    children
  ] });
}
var block_types_list_default = BlockTypesList;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js


function InserterPanel({ title, icon, children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-inserter__panel-header", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("h2", { className: "block-editor-inserter__panel-title", children: title }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Icon, { icon })
    ] }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__panel-content", children })
  ] });
}
var panel_default = InserterPanel;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js








const useBlockTypesState = (rootClientId, onInsert, isQuick) => {
  const options = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({ [isFiltered]: !!isQuick }),
    [isQuick]
  );
  const [items] = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => [
      select(store).getInserterItems(
        rootClientId,
        options
      )
    ],
    [rootClientId, options]
  );
  const { getClosestAllowedInsertionPoint } = unlock(
    (0,external_wp_data_namespaceObject.useSelect)(store)
  );
  const { createErrorNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const [categories, collections] = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getCategories, getCollections } = select(external_wp_blocks_namespaceObject.store);
    return [getCategories(), getCollections()];
  }, []);
  const onSelectItem = (0,external_wp_element_namespaceObject.useCallback)(
    ({ name, initialAttributes, innerBlocks, syncStatus, content }, shouldFocusBlock) => {
      const destinationClientId = getClosestAllowedInsertionPoint(
        name,
        rootClientId
      );
      if (destinationClientId === null) {
        const title = (0,external_wp_blocks_namespaceObject.getBlockType)(name)?.title ?? name;
        createErrorNotice(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %s: block pattern title. */
            (0,external_wp_i18n_namespaceObject.__)(`Block "%s" can't be inserted.`),
            title
          ),
          {
            type: "snackbar",
            id: "inserter-notice"
          }
        );
        return;
      }
      const insertedBlock = syncStatus === "unsynced" ? (0,external_wp_blocks_namespaceObject.parse)(content, {
        __unstableSkipMigrationLogs: true
      }) : (0,external_wp_blocks_namespaceObject.createBlock)(
        name,
        initialAttributes,
        (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(innerBlocks)
      );
      onInsert(
        insertedBlock,
        void 0,
        shouldFocusBlock,
        destinationClientId
      );
    },
    [
      getClosestAllowedInsertionPoint,
      rootClientId,
      onInsert,
      createErrorNotice
    ]
  );
  return [items, categories, collections, onSelectItem];
};
var use_block_types_state_default = useBlockTypesState;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js






function InserterListBoxWrapper({ key, children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_element_namespaceObject.Fragment, { children }, key);
}
function InserterListbox({ children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite,
    {
      focusShift: true,
      focusWrap: "horizontal",
      render: InserterListBoxWrapper,
      children
    }
  );
}
var inserter_listbox_default = InserterListbox;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js


function InserterNoResults() {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__no-results", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)("No results found.") }) });
}
var no_results_default = InserterNoResults;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js










const getBlockNamespace = (item) => item.name.split("/")[0];
const MAX_SUGGESTED_ITEMS = 6;
const block_types_tab_EMPTY_ARRAY = [];
function BlockTypesTabPanel({
  items,
  collections,
  categories,
  onSelectItem,
  onHover,
  showMostUsedBlocks,
  className
}) {
  const suggestedItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return orderBy(items, "frecency", "desc").slice(
      0,
      MAX_SUGGESTED_ITEMS
    );
  }, [items]);
  const uncategorizedItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return items.filter((item) => !item.category);
  }, [items]);
  const itemsPerCollection = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const result = { ...collections };
    Object.keys(collections).forEach((namespace) => {
      result[namespace] = items.filter(
        (item) => getBlockNamespace(item) === namespace
      );
      if (result[namespace].length === 0) {
        delete result[namespace];
      }
    });
    return result;
  }, [items, collections]);
  (0,external_wp_element_namespaceObject.useEffect)(() => () => onHover(null), []);
  const currentlyRenderedCategories = (0,external_wp_compose_namespaceObject.useAsyncList)(categories);
  const didRenderAllCategories = categories.length === currentlyRenderedCategories.length;
  const collectionEntries = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return Object.entries(collections);
  }, [collections]);
  const currentlyRenderedCollections = (0,external_wp_compose_namespaceObject.useAsyncList)(
    didRenderAllCategories ? collectionEntries : block_types_tab_EMPTY_ARRAY
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className, children: [
    showMostUsedBlocks && // Only show the most used blocks if the total amount of block
    // is larger than 1 row, otherwise it is not so useful.
    items.length > 3 && !!suggestedItems.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(panel_default, { title: (0,external_wp_i18n_namespaceObject._x)("Most used", "blocks"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_types_list_default,
      {
        items: suggestedItems,
        onSelect: onSelectItem,
        onHover,
        label: (0,external_wp_i18n_namespaceObject._x)("Most used", "blocks")
      }
    ) }),
    currentlyRenderedCategories.map((category) => {
      const categoryItems = items.filter(
        (item) => item.category === category.slug
      );
      if (!categoryItems || !categoryItems.length) {
        return null;
      }
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        panel_default,
        {
          title: category.title,
          icon: category.icon,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_types_list_default,
            {
              items: categoryItems,
              onSelect: onSelectItem,
              onHover,
              label: category.title
            }
          )
        },
        category.slug
      );
    }),
    didRenderAllCategories && uncategorizedItems.length > 0 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      panel_default,
      {
        className: "block-editor-inserter__uncategorized-blocks-panel",
        title: (0,external_wp_i18n_namespaceObject.__)("Uncategorized"),
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          block_types_list_default,
          {
            items: uncategorizedItems,
            onSelect: onSelectItem,
            onHover,
            label: (0,external_wp_i18n_namespaceObject.__)("Uncategorized")
          }
        )
      }
    ),
    currentlyRenderedCollections.map(
      ([namespace, collection]) => {
        const collectionItems = itemsPerCollection[namespace];
        if (!collectionItems || !collectionItems.length) {
          return null;
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          panel_default,
          {
            title: collection.title,
            icon: collection.icon,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              block_types_list_default,
              {
                items: collectionItems,
                onSelect: onSelectItem,
                onHover,
                label: collection.title
              }
            )
          },
          namespace
        );
      }
    )
  ] });
}
function BlockTypesTab({ rootClientId, onInsert, onHover, showMostUsedBlocks }, ref) {
  const [items, categories, collections, onSelectItem] = use_block_types_state_default(
    rootClientId,
    onInsert
  );
  if (!items.length) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {});
  }
  const itemsForCurrentRoot = [];
  const itemsRemaining = [];
  for (const item of items) {
    if (item.category === "reusable") {
      continue;
    }
    if (item.isAllowedInCurrentRoot) {
      itemsForCurrentRoot.push(item);
    } else {
      itemsRemaining.push(item);
    }
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inserter_listbox_default, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { ref, children: [
    !!itemsForCurrentRoot.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockTypesTabPanel,
      {
        items: itemsForCurrentRoot,
        categories,
        collections,
        onSelectItem,
        onHover,
        showMostUsedBlocks,
        className: "block-editor-inserter__insertable-blocks-at-selection"
      }
    ) }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockTypesTabPanel,
      {
        items: itemsRemaining,
        categories,
        collections,
        onSelectItem,
        onHover,
        showMostUsedBlocks,
        className: "block-editor-inserter__all-blocks"
      }
    )
  ] }) });
}
var block_types_tab_default = (0,external_wp_element_namespaceObject.forwardRef)(BlockTypesTab);


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-explorer-sidebar.js



function PatternCategoriesList({
  selectedCategory,
  patternCategories,
  onClickCategory
}) {
  const baseClassName = "block-editor-block-patterns-explorer__sidebar";
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: `${baseClassName}__categories-list`, children: patternCategories.map(({ name, label }) => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        label,
        className: `${baseClassName}__categories-list__item`,
        isPressed: selectedCategory === name,
        onClick: () => {
          onClickCategory(name);
        },
        children: label
      },
      name
    );
  }) });
}
function PatternsExplorerSearch({ searchValue, setSearchValue }) {
  const baseClassName = "block-editor-block-patterns-explorer__search";
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: baseClassName, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.SearchControl,
    {
      __nextHasNoMarginBottom: true,
      onChange: setSearchValue,
      value: searchValue,
      label: (0,external_wp_i18n_namespaceObject.__)("Search"),
      placeholder: (0,external_wp_i18n_namespaceObject.__)("Search")
    }
  ) });
}
function PatternExplorerSidebar({
  selectedCategory,
  patternCategories,
  onClickCategory,
  searchValue,
  setSearchValue
}) {
  const baseClassName = "block-editor-block-patterns-explorer__sidebar";
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: baseClassName, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PatternsExplorerSearch,
      {
        searchValue,
        setSearchValue
      }
    ),
    !searchValue && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PatternCategoriesList,
      {
        selectedCategory,
        patternCategories,
        onClickCategory
      }
    )
  ] });
}
var pattern_explorer_sidebar_default = PatternExplorerSidebar;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-patterns-paging/index.js



function Pagination({
  currentPage,
  numPages,
  changePage,
  totalItems
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { className: "block-editor-patterns__grid-pagination-wrapper", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { variant: "muted", children: (0,external_wp_i18n_namespaceObject.sprintf)(
      // translators: %s: Total number of patterns.
      (0,external_wp_i18n_namespaceObject._n)("%s item", "%s items", totalItems),
      totalItems
    ) }),
    numPages > 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.__experimentalHStack,
      {
        expanded: false,
        spacing: 3,
        justify: "flex-start",
        className: "block-editor-patterns__grid-pagination",
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            external_wp_components_namespaceObject.__experimentalHStack,
            {
              expanded: false,
              spacing: 1,
              className: "block-editor-patterns__grid-pagination-previous",
              children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.Button,
                  {
                    variant: "tertiary",
                    onClick: () => changePage(1),
                    disabled: currentPage === 1,
                    "aria-label": (0,external_wp_i18n_namespaceObject.__)("First page"),
                    size: "compact",
                    accessibleWhenDisabled: true,
                    className: "block-editor-patterns__grid-pagination-button",
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { children: "\xAB" })
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.Button,
                  {
                    variant: "tertiary",
                    onClick: () => changePage(currentPage - 1),
                    disabled: currentPage === 1,
                    "aria-label": (0,external_wp_i18n_namespaceObject.__)("Previous page"),
                    size: "compact",
                    accessibleWhenDisabled: true,
                    className: "block-editor-patterns__grid-pagination-button",
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { children: "\u2039" })
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { variant: "muted", children: (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: 1: Current page number. 2: Total number of pages.
            (0,external_wp_i18n_namespaceObject._x)("%1$s of %2$s", "paging"),
            currentPage,
            numPages
          ) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            external_wp_components_namespaceObject.__experimentalHStack,
            {
              expanded: false,
              spacing: 1,
              className: "block-editor-patterns__grid-pagination-next",
              children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.Button,
                  {
                    variant: "tertiary",
                    onClick: () => changePage(currentPage + 1),
                    disabled: currentPage === numPages,
                    "aria-label": (0,external_wp_i18n_namespaceObject.__)("Next page"),
                    size: "compact",
                    accessibleWhenDisabled: true,
                    className: "block-editor-patterns__grid-pagination-button",
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { children: "\u203A" })
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.Button,
                  {
                    variant: "tertiary",
                    onClick: () => changePage(numPages),
                    disabled: currentPage === numPages,
                    "aria-label": (0,external_wp_i18n_namespaceObject.__)("Last page"),
                    size: "compact",
                    accessibleWhenDisabled: true,
                    className: "block-editor-patterns__grid-pagination-button",
                    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { children: "\xBB" })
                  }
                )
              ]
            }
          )
        ]
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js












const WithToolTip = ({ showTooltip, title, children }) => {
  if (showTooltip) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tooltip, { text: title, children });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children });
};
function BlockPattern({
  id,
  isDraggable,
  pattern,
  onClick,
  onHover,
  showTitlesAsTooltip,
  category,
  isSelected
}) {
  const [isDragging, setIsDragging] = (0,external_wp_element_namespaceObject.useState)(false);
  const { blocks, viewportWidth } = pattern;
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockPattern);
  const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
  const isUserPattern = pattern.type === INSERTER_PATTERN_TYPES.user;
  const patternBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!category || !isDraggable) {
      return blocks;
    }
    return (blocks ?? []).map((block) => {
      const clonedBlock = (0,external_wp_blocks_namespaceObject.cloneBlock)(block);
      if (clonedBlock.attributes.metadata?.categories?.includes(
        category
      )) {
        clonedBlock.attributes.metadata.categories = [category];
      }
      return clonedBlock;
    });
  }, [blocks, isDraggable, category]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inserter_draggable_blocks_default,
    {
      isEnabled: isDraggable,
      blocks: patternBlocks,
      pattern,
      children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "div",
        {
          className: "block-editor-block-patterns-list__list-item",
          draggable,
          onDragStart: (event) => {
            setIsDragging(true);
            if (onDragStart) {
              onHover?.(null);
              onDragStart(event);
            }
          },
          onDragEnd: (event) => {
            setIsDragging(false);
            if (onDragEnd) {
              onDragEnd(event);
            }
          },
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            WithToolTip,
            {
              showTooltip: showTitlesAsTooltip && !isUserPattern,
              title: pattern.title,
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
                external_wp_components_namespaceObject.Composite.Item,
                {
                  render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    "div",
                    {
                      role: "option",
                      "aria-label": pattern.title,
                      "aria-describedby": pattern.description ? descriptionId : void 0,
                      className: dist_clsx(
                        "block-editor-block-patterns-list__item",
                        {
                          "block-editor-block-patterns-list__list-item-synced": pattern.type === INSERTER_PATTERN_TYPES.user && !pattern.syncStatus,
                          "is-selected": isSelected
                        }
                      )
                    }
                  ),
                  id,
                  onClick: () => {
                    onClick(pattern, blocks);
                    onHover?.(null);
                  },
                  onMouseEnter: () => {
                    if (isDragging) {
                      return;
                    }
                    onHover?.(pattern);
                  },
                  onMouseLeave: () => onHover?.(null),
                  children: [
                    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                      block_preview_default.Async,
                      {
                        placeholder: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockPatternPlaceholder, {}),
                        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                          block_preview_default,
                          {
                            blocks,
                            viewportWidth
                          }
                        )
                      }
                    ),
                    (!showTitlesAsTooltip || isUserPattern) && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
                      external_wp_components_namespaceObject.__experimentalHStack,
                      {
                        className: "block-editor-patterns__pattern-details",
                        spacing: 2,
                        children: [
                          isUserPattern && !pattern.syncStatus && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-patterns__pattern-icon-wrapper", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                            icon_default,
                            {
                              className: "block-editor-patterns__pattern-icon",
                              icon: symbol_default
                            }
                          ) }),
                          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-patterns-list__item-title", children: pattern.title })
                        ]
                      }
                    ),
                    !!pattern.description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: pattern.description })
                  ]
                }
              )
            }
          )
        }
      )
    }
  );
}
function BlockPatternPlaceholder() {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-patterns-list__item is-placeholder" });
}
function BlockPatternsList({
  isDraggable,
  blockPatterns,
  onHover,
  onClickPattern,
  orientation,
  label = (0,external_wp_i18n_namespaceObject.__)("Block patterns"),
  category,
  showTitlesAsTooltip,
  pagingProps
}, ref) {
  const [activeCompositeId, setActiveCompositeId] = (0,external_wp_element_namespaceObject.useState)(void 0);
  const [activePattern, setActivePattern] = (0,external_wp_element_namespaceObject.useState)(null);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const firstCompositeItemId = blockPatterns[0]?.name;
    setActiveCompositeId(firstCompositeItemId);
  }, [blockPatterns]);
  const handleClickPattern = (pattern, blocks) => {
    setActivePattern(pattern.name);
    onClickPattern(pattern, blocks);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Composite,
    {
      orientation,
      activeId: activeCompositeId,
      setActiveId: setActiveCompositeId,
      role: "listbox",
      className: "block-editor-block-patterns-list",
      "aria-label": label,
      ref,
      children: [
        blockPatterns.map((pattern) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          BlockPattern,
          {
            id: pattern.name,
            pattern,
            onClick: handleClickPattern,
            onHover,
            isDraggable,
            showTitlesAsTooltip,
            category,
            isSelected: !!activePattern && activePattern === pattern.name
          },
          pattern.name
        )),
        pagingProps && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Pagination, { ...pagingProps })
      ]
    }
  );
}
var block_patterns_list_default = (0,external_wp_element_namespaceObject.forwardRef)(BlockPatternsList);


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js







function getIndex({
  destinationRootClientId,
  destinationIndex,
  rootClientId,
  registry
}) {
  if (rootClientId === destinationRootClientId) {
    return destinationIndex;
  }
  const parents = [
    "",
    ...registry.select(store).getBlockParents(destinationRootClientId),
    destinationRootClientId
  ];
  const parentIndex = parents.indexOf(rootClientId);
  if (parentIndex !== -1) {
    return registry.select(store).getBlockIndex(parents[parentIndex + 1]) + 1;
  }
  return registry.select(store).getBlockOrder(rootClientId).length;
}
function useInsertionPoint({
  rootClientId = "",
  insertionIndex,
  clientId,
  isAppender,
  onSelect,
  shouldFocusBlock = true,
  selectBlockOnInsert = true
}) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    getSelectedBlock,
    getClosestAllowedInsertionPoint,
    isBlockInsertionPointVisible
  } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  const { destinationRootClientId, destinationIndex } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getSelectedBlockClientId,
        getBlockRootClientId,
        getBlockIndex,
        getBlockOrder,
        getInsertionPoint
      } = unlock(select(store));
      const selectedBlockClientId = getSelectedBlockClientId();
      let _destinationRootClientId = rootClientId;
      let _destinationIndex;
      const insertionPoint = getInsertionPoint();
      if (insertionIndex !== void 0) {
        _destinationIndex = insertionIndex;
      } else if (insertionPoint && insertionPoint.hasOwnProperty("index")) {
        _destinationRootClientId = insertionPoint?.rootClientId ? insertionPoint.rootClientId : rootClientId;
        _destinationIndex = insertionPoint.index;
      } else if (clientId) {
        _destinationIndex = getBlockIndex(clientId);
      } else if (!isAppender && selectedBlockClientId) {
        _destinationRootClientId = getBlockRootClientId(
          selectedBlockClientId
        );
        _destinationIndex = getBlockIndex(selectedBlockClientId) + 1;
      } else {
        _destinationIndex = getBlockOrder(
          _destinationRootClientId
        ).length;
      }
      return {
        destinationRootClientId: _destinationRootClientId,
        destinationIndex: _destinationIndex
      };
    },
    [rootClientId, insertionIndex, clientId, isAppender]
  );
  const {
    replaceBlocks,
    insertBlocks,
    showInsertionPoint,
    hideInsertionPoint,
    setLastFocus
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const onInsertBlocks = (0,external_wp_element_namespaceObject.useCallback)(
    (blocks, meta, shouldForceFocusBlock = false, _rootClientId) => {
      if (shouldForceFocusBlock || shouldFocusBlock || selectBlockOnInsert) {
        setLastFocus(null);
      }
      const selectedBlock = getSelectedBlock();
      if (!isAppender && selectedBlock && (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(selectedBlock, "content")) {
        replaceBlocks(
          selectedBlock.clientId,
          blocks,
          null,
          shouldFocusBlock || shouldForceFocusBlock ? 0 : null,
          meta
        );
      } else {
        insertBlocks(
          blocks,
          isAppender || _rootClientId === void 0 ? destinationIndex : getIndex({
            destinationRootClientId,
            destinationIndex,
            rootClientId: _rootClientId,
            registry
          }),
          isAppender || _rootClientId === void 0 ? destinationRootClientId : _rootClientId,
          selectBlockOnInsert,
          shouldFocusBlock || shouldForceFocusBlock ? 0 : null,
          meta
        );
      }
      const blockLength = Array.isArray(blocks) ? blocks.length : 1;
      const message = (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: %d: the name of the block that has been added
        (0,external_wp_i18n_namespaceObject._n)("%d block added.", "%d blocks added.", blockLength),
        blockLength
      );
      (0,external_wp_a11y_namespaceObject.speak)(message);
      if (onSelect) {
        onSelect(blocks);
      }
    },
    [
      isAppender,
      getSelectedBlock,
      replaceBlocks,
      insertBlocks,
      destinationRootClientId,
      destinationIndex,
      onSelect,
      shouldFocusBlock,
      selectBlockOnInsert
    ]
  );
  const onToggleInsertionPoint = (0,external_wp_element_namespaceObject.useCallback)(
    (item) => {
      if (item && !isBlockInsertionPointVisible()) {
        const allowedDestinationRootClientId = getClosestAllowedInsertionPoint(
          item.name,
          destinationRootClientId
        );
        if (allowedDestinationRootClientId !== null) {
          showInsertionPoint(
            allowedDestinationRootClientId,
            getIndex({
              destinationRootClientId,
              destinationIndex,
              rootClientId: allowedDestinationRootClientId,
              registry
            })
          );
        }
      } else {
        hideInsertionPoint();
      }
    },
    [
      getClosestAllowedInsertionPoint,
      isBlockInsertionPointVisible,
      showInsertionPoint,
      hideInsertionPoint,
      destinationRootClientId,
      destinationIndex
    ]
  );
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}
var use_insertion_point_default = useInsertionPoint;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js









const usePatternsState = (onInsert, rootClientId, selectedCategory, isQuick) => {
  const options = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({ [isFiltered]: !!isQuick }),
    [isQuick]
  );
  const { patternCategories, patterns, userPatternCategories } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getSettings, __experimentalGetAllowedPatterns } = unlock(
        select(store)
      );
      const {
        __experimentalUserPatternCategories,
        __experimentalBlockPatternCategories
      } = getSettings();
      return {
        patterns: __experimentalGetAllowedPatterns(
          rootClientId,
          options
        ),
        userPatternCategories: __experimentalUserPatternCategories,
        patternCategories: __experimentalBlockPatternCategories
      };
    },
    [rootClientId, options]
  );
  const { getClosestAllowedInsertionPointForPattern } = unlock(
    (0,external_wp_data_namespaceObject.useSelect)(store)
  );
  const allCategories = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const categories = [...patternCategories];
    userPatternCategories?.forEach((userCategory) => {
      if (!categories.find(
        (existingCategory) => existingCategory.name === userCategory.name
      )) {
        categories.push(userCategory);
      }
    });
    return categories;
  }, [patternCategories, userPatternCategories]);
  const { createSuccessNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const onClickPattern = (0,external_wp_element_namespaceObject.useCallback)(
    (pattern, blocks) => {
      const destinationRootClientId = isQuick ? rootClientId : getClosestAllowedInsertionPointForPattern(
        pattern,
        rootClientId
      );
      if (destinationRootClientId === null) {
        return;
      }
      const patternBlocks = pattern.type === INSERTER_PATTERN_TYPES.user && pattern.syncStatus !== "unsynced" ? [(0,external_wp_blocks_namespaceObject.createBlock)("core/block", { ref: pattern.id })] : blocks;
      onInsert(
        (patternBlocks ?? []).map((block) => {
          const clonedBlock = (0,external_wp_blocks_namespaceObject.cloneBlock)(block);
          if (clonedBlock.attributes.metadata?.categories?.includes(
            selectedCategory
          )) {
            clonedBlock.attributes.metadata.categories = [
              selectedCategory
            ];
          }
          return clonedBlock;
        }),
        pattern.name,
        false,
        destinationRootClientId
      );
      createSuccessNotice(
        (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %s: block pattern title. */
          (0,external_wp_i18n_namespaceObject.__)('Block pattern "%s" inserted.'),
          pattern.title
        ),
        {
          type: "snackbar",
          id: "inserter-notice"
        }
      );
    },
    [
      createSuccessNotice,
      onInsert,
      selectedCategory,
      rootClientId,
      getClosestAllowedInsertionPointForPattern,
      isQuick
    ]
  );
  return [patterns, allCategories, onClickPattern];
};
var use_patterns_state_default = usePatternsState;


// EXTERNAL MODULE: ./node_modules/remove-accents/index.js
var remove_accents = __webpack_require__(9681);
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
;// ./node_modules/lower-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var SUPPORTED_LOCALE = {
    tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
            : "\u0069",
            I: "\u0131",
            I: "\u0069",
        },
    },
    az: {
        regexp: /\u0130/g,
        map: {
            : "\u0069",
            I: "\u0131",
            I: "\u0069",
        },
    },
    lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
            I: "\u0069\u0307",
            J: "\u006A\u0307",
            : "\u012F\u0307",
            : "\u0069\u0307\u0300",
            : "\u0069\u0307\u0301",
            : "\u0069\u0307\u0303",
        },
    },
};
/**
 * Localized lower case.
 */
function localeLowerCase(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return lowerCase(str);
}
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}

;// ./node_modules/no-case/dist.es2015/index.js

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = dist_es2015_replace(dist_es2015_replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function dist_es2015_replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}

;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js


const defaultGetName = (item) => item.name || "";
const defaultGetTitle = (item) => item.title;
const defaultGetDescription = (item) => item.description || "";
const defaultGetKeywords = (item) => item.keywords || [];
const defaultGetCategory = (item) => item.category;
const defaultGetCollection = () => null;
const splitRegexp = [
  /([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu,
  // One lowercase or digit, followed by one uppercase.
  /([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu
  // One uppercase followed by one uppercase and one lowercase.
];
const stripRegexp = new RegExp("(\\p{C}|\\p{P}|\\p{S})+", "giu");
const extractedWords = /* @__PURE__ */ new Map();
const normalizedStrings = /* @__PURE__ */ new Map();
function extractWords(input = "") {
  if (extractedWords.has(input)) {
    return extractedWords.get(input);
  }
  const result = noCase(input, {
    splitRegexp,
    stripRegexp
  }).split(" ").filter(Boolean);
  extractedWords.set(input, result);
  return result;
}
function normalizeString(input = "") {
  if (normalizedStrings.has(input)) {
    return normalizedStrings.get(input);
  }
  let result = remove_accents_default()(input);
  result = result.replace(/^\//, "");
  result = result.toLowerCase();
  normalizedStrings.set(input, result);
  return result;
}
const getNormalizedSearchTerms = (input = "") => {
  return extractWords(normalizeString(input));
};
const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return unmatchedTerms.filter(
    (term) => !getNormalizedSearchTerms(unprocessedTerms).some(
      (unprocessedTerm) => unprocessedTerm.includes(term)
    )
  );
};
const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
  if (normalizedSearchTerms.length === 0) {
    return items;
  }
  const config = {
    getCategory: (item) => categories.find(({ slug }) => slug === item.category)?.title,
    getCollection: (item) => collections[item.name.split("/")[0]]?.title
  };
  return searchItems(items, searchInput, config);
};
const searchItems = (items = [], searchInput = "", config = {}) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
  if (normalizedSearchTerms.length === 0) {
    return items;
  }
  const rankedItems = items.map((item) => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(([, rank]) => rank > 0);
  rankedItems.sort(([, rank1], [, rank2]) => rank2 - rank1);
  return rankedItems.map(([item]) => item);
};
function getItemSearchRank(item, searchTerm, config = {}) {
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeString(searchTerm);
  const normalizedTitle = normalizeString(title);
  let rank = 0;
  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [
      name,
      title,
      description,
      ...keywords,
      category,
      collection
    ].join(" ");
    const normalizedSearchTerms = extractWords(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(
      normalizedSearchTerms,
      terms
    );
    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  }
  if (rank !== 0 && name.startsWith("core/")) {
    const isCoreBlockVariation = name !== item.id;
    rank += isCoreBlockVariation ? 1 : 2;
  }
  return rank;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-paging.js



const PAGE_SIZE = 20;
function usePatternsPaging(currentCategoryPatterns, currentCategory, scrollContainerRef, currentFilter = "") {
  const [currentPage, setCurrentPage] = (0,external_wp_element_namespaceObject.useState)(1);
  const previousCategory = (0,external_wp_compose_namespaceObject.usePrevious)(currentCategory);
  const previousFilter = (0,external_wp_compose_namespaceObject.usePrevious)(currentFilter);
  if ((previousCategory !== currentCategory || previousFilter !== currentFilter) && currentPage !== 1) {
    setCurrentPage(1);
  }
  const totalItems = currentCategoryPatterns.length;
  const pageIndex = currentPage - 1;
  const categoryPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return currentCategoryPatterns.slice(
      pageIndex * PAGE_SIZE,
      pageIndex * PAGE_SIZE + PAGE_SIZE
    );
  }, [pageIndex, currentCategoryPatterns]);
  const numPages = Math.ceil(currentCategoryPatterns.length / PAGE_SIZE);
  const changePage = (page) => {
    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(
      scrollContainerRef?.current
    );
    scrollContainer?.scrollTo(0, 0);
    setCurrentPage(page);
  };
  (0,external_wp_element_namespaceObject.useEffect)(
    function scrollToTopOnCategoryChange() {
      const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(
        scrollContainerRef?.current
      );
      scrollContainer?.scrollTo(0, 0);
    },
    [currentCategory, scrollContainerRef]
  );
  return {
    totalItems,
    categoryPatterns,
    numPages,
    changePage,
    currentPage
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/pattern-list.js














function PatternsListHeader({ filterValue, filteredBlockPatternsLength }) {
  if (!filterValue) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalHeading,
    {
      level: 2,
      lineHeight: "48px",
      className: "block-editor-block-patterns-explorer__search-results-count",
      children: (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %d: number of patterns. */
        (0,external_wp_i18n_namespaceObject._n)(
          "%d pattern found",
          "%d patterns found",
          filteredBlockPatternsLength
        ),
        filteredBlockPatternsLength
      )
    }
  );
}
function PatternList({
  searchValue,
  selectedCategory,
  patternCategories,
  rootClientId,
  onModalClose
}) {
  const container = (0,external_wp_element_namespaceObject.useRef)();
  const debouncedSpeak = (0,external_wp_compose_namespaceObject.useDebounce)(external_wp_a11y_namespaceObject.speak, 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
    rootClientId,
    shouldFocusBlock: true
  });
  const [patterns, , onClickPattern] = use_patterns_state_default(
    onInsertBlocks,
    destinationRootClientId,
    selectedCategory
  );
  const registeredPatternCategories = (0,external_wp_element_namespaceObject.useMemo)(
    () => patternCategories.map(
      (patternCategory) => patternCategory.name
    ),
    [patternCategories]
  );
  const filteredBlockPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const filteredPatterns = patterns.filter((pattern) => {
      if (selectedCategory === allPatternsCategory.name) {
        return true;
      }
      if (selectedCategory === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
        return true;
      }
      if (selectedCategory === starterPatternsCategory.name && pattern.blockTypes?.includes("core/post-content")) {
        return true;
      }
      if (selectedCategory === "uncategorized") {
        const hasKnownCategory = pattern.categories?.some(
          (category) => registeredPatternCategories.includes(category)
        ) ?? false;
        return !pattern.categories?.length || !hasKnownCategory;
      }
      return pattern.categories?.includes(selectedCategory);
    });
    if (!searchValue) {
      return filteredPatterns;
    }
    return searchItems(filteredPatterns, searchValue);
  }, [
    searchValue,
    patterns,
    selectedCategory,
    registeredPatternCategories
  ]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!searchValue) {
      return;
    }
    const count = filteredBlockPatterns.length;
    const resultsFoundMessage = (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %d: number of results. */
      (0,external_wp_i18n_namespaceObject._n)("%d result found.", "%d results found.", count),
      count
    );
    debouncedSpeak(resultsFoundMessage);
  }, [searchValue, debouncedSpeak, filteredBlockPatterns.length]);
  const pagingProps = usePatternsPaging(
    filteredBlockPatterns,
    selectedCategory,
    container
  );
  const [previousSearchValue, setPreviousSearchValue] = (0,external_wp_element_namespaceObject.useState)(searchValue);
  if (searchValue !== previousSearchValue) {
    setPreviousSearchValue(searchValue);
    pagingProps.changePage(1);
  }
  const hasItems = !!filteredBlockPatterns?.length;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: "block-editor-block-patterns-explorer__list",
      ref: container,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          PatternsListHeader,
          {
            filterValue: searchValue,
            filteredBlockPatternsLength: filteredBlockPatterns.length
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inserter_listbox_default, { children: hasItems && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_patterns_list_default,
            {
              blockPatterns: pagingProps.categoryPatterns,
              onClickPattern: (pattern, blocks) => {
                onClickPattern(pattern, blocks);
                onModalClose();
              },
              isDraggable: false
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Pagination, { ...pagingProps })
        ] }) })
      ]
    }
  );
}
var pattern_list_default = PatternList;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/use-pattern-categories.js





function hasRegisteredCategory(pattern, allCategories) {
  if (!pattern.categories || !pattern.categories.length) {
    return false;
  }
  return pattern.categories.some(
    (cat) => allCategories.some((category) => category.name === cat)
  );
}
function usePatternCategories(rootClientId, sourceFilter = "all") {
  const [patterns, allCategories] = use_patterns_state_default(
    void 0,
    rootClientId
  );
  const filteredPatterns = (0,external_wp_element_namespaceObject.useMemo)(
    () => sourceFilter === "all" ? patterns : patterns.filter(
      (pattern) => !isPatternFiltered(pattern, sourceFilter)
    ),
    [sourceFilter, patterns]
  );
  const populatedCategories = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const categories = allCategories.filter(
      (category) => filteredPatterns.some(
        (pattern) => pattern.categories?.includes(category.name)
      )
    ).sort((a, b) => a.label.localeCompare(b.label));
    if (filteredPatterns.some(
      (pattern) => !hasRegisteredCategory(pattern, allCategories)
    ) && !categories.find(
      (category) => category.name === "uncategorized"
    )) {
      categories.push({
        name: "uncategorized",
        label: (0,external_wp_i18n_namespaceObject._x)("Uncategorized")
      });
    }
    if (filteredPatterns.some(
      (pattern) => pattern.blockTypes?.includes("core/post-content")
    )) {
      categories.unshift(starterPatternsCategory);
    }
    if (filteredPatterns.some(
      (pattern) => pattern.type === INSERTER_PATTERN_TYPES.user
    )) {
      categories.unshift(myPatternsCategory);
    }
    if (filteredPatterns.length > 0) {
      categories.unshift({
        name: allPatternsCategory.name,
        label: allPatternsCategory.label
      });
    }
    (0,external_wp_a11y_namespaceObject.speak)(
      (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %d: number of categories . */
        (0,external_wp_i18n_namespaceObject._n)(
          "%d category button displayed.",
          "%d category buttons displayed.",
          categories.length
        ),
        categories.length
      )
    );
    return categories;
  }, [allCategories, filteredPatterns]);
  return populatedCategories;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/index.js







function PatternsExplorer({ initialCategory, rootClientId, onModalClose }) {
  const [searchValue, setSearchValue] = (0,external_wp_element_namespaceObject.useState)("");
  const [selectedCategory, setSelectedCategory] = (0,external_wp_element_namespaceObject.useState)(
    initialCategory?.name
  );
  const patternCategories = usePatternCategories(rootClientId);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-patterns-explorer", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      pattern_explorer_sidebar_default,
      {
        selectedCategory,
        patternCategories,
        onClickCategory: setSelectedCategory,
        searchValue,
        setSearchValue
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      pattern_list_default,
      {
        searchValue,
        selectedCategory,
        patternCategories,
        rootClientId,
        onModalClose
      }
    )
  ] });
}
function PatternsExplorerModal({ onModalClose, ...restProps }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.__)("Patterns"),
      onRequestClose: onModalClose,
      isFullScreen: true,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PatternsExplorer, { onModalClose, ...restProps })
    }
  );
}
var block_patterns_explorer_default = PatternsExplorerModal;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/mobile-tab-navigation.js




function ScreenHeader({ title }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 0, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalView, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalSpacer, { marginBottom: 0, paddingX: 4, paddingY: 3, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { spacing: 2, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Navigator.BackButton,
      {
        style: (
          // TODO: This style override is also used in ToolsPanelHeader.
          // It should be supported out-of-the-box by Button.
          { minWidth: 24, padding: 0 }
        ),
        icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right_default : chevron_left_default,
        size: "small",
        label: (0,external_wp_i18n_namespaceObject.__)("Back")
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalSpacer, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalHeading, { level: 5, children: title }) })
  ] }) }) }) });
}
function MobileTabNavigation({ categories, children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Navigator,
    {
      initialPath: "/",
      className: "block-editor-inserter__mobile-tab-navigation",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Navigator.Screen, { path: "/", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalItemGroup, { children: categories.map((category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Navigator.Button,
          {
            path: `/category/${category.name}`,
            as: external_wp_components_namespaceObject.__experimentalItem,
            isAction: true,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexBlock, { children: category.label }),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                icon_default,
                {
                  icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_default : chevron_right_default
                }
              )
            ] })
          },
          category.name
        )) }) }),
        categories.map((category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.Navigator.Screen,
          {
            path: `/category/${category.name}`,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ScreenHeader, { title: (0,external_wp_i18n_namespaceObject.__)("Back") }),
              children(category)
            ]
          },
          category.name
        ))
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/patterns-filter.js






const getShouldDisableSyncFilter = (sourceFilter) => sourceFilter !== "all" && sourceFilter !== "user";
const getShouldHideSourcesFilter = (category) => {
  return category.name === myPatternsCategory.name;
};
const PATTERN_SOURCE_MENU_OPTIONS = [
  {
    value: "all",
    label: (0,external_wp_i18n_namespaceObject._x)("All", "patterns")
  },
  {
    value: INSERTER_PATTERN_TYPES.directory,
    label: (0,external_wp_i18n_namespaceObject.__)("Pattern Directory")
  },
  {
    value: INSERTER_PATTERN_TYPES.theme,
    label: (0,external_wp_i18n_namespaceObject.__)("Theme & Plugins")
  },
  {
    value: INSERTER_PATTERN_TYPES.user,
    label: (0,external_wp_i18n_namespaceObject.__)("User")
  }
];
function PatternsFilter({
  setPatternSyncFilter,
  setPatternSourceFilter,
  patternSyncFilter,
  patternSourceFilter,
  scrollContainerRef,
  category
}) {
  const currentPatternSourceFilter = category.name === myPatternsCategory.name ? INSERTER_PATTERN_TYPES.user : patternSourceFilter;
  const shouldDisableSyncFilter = getShouldDisableSyncFilter(
    currentPatternSourceFilter
  );
  const shouldHideSourcesFilter = getShouldHideSourcesFilter(category);
  const patternSyncMenuOptions = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      {
        value: "all",
        label: (0,external_wp_i18n_namespaceObject._x)("All", "patterns")
      },
      {
        value: INSERTER_SYNC_TYPES.full,
        label: (0,external_wp_i18n_namespaceObject._x)("Synced", "patterns"),
        disabled: shouldDisableSyncFilter
      },
      {
        value: INSERTER_SYNC_TYPES.unsynced,
        label: (0,external_wp_i18n_namespaceObject._x)("Not synced", "patterns"),
        disabled: shouldDisableSyncFilter
      }
    ],
    [shouldDisableSyncFilter]
  );
  function handleSetSourceFilterChange(newSourceFilter) {
    setPatternSourceFilter(newSourceFilter);
    if (getShouldDisableSyncFilter(newSourceFilter)) {
      setPatternSyncFilter("all");
    }
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.DropdownMenu,
    {
      popoverProps: {
        placement: "right-end"
      },
      label: (0,external_wp_i18n_namespaceObject.__)("Filter patterns"),
      toggleProps: { size: "compact" },
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        icon_default,
        {
          icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.SVG,
            {
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Path,
                {
                  d: "M10 17.5H14V16H10V17.5ZM6 6V7.5H18V6H6ZM8 12.5H16V11H8V12.5Z",
                  fill: "currentColor"
                }
              )
            }
          )
        }
      ),
      children: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        !shouldHideSourcesFilter && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { label: (0,external_wp_i18n_namespaceObject.__)("Source"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.MenuItemsChoice,
          {
            choices: PATTERN_SOURCE_MENU_OPTIONS,
            onSelect: (value) => {
              handleSetSourceFilterChange(value);
              scrollContainerRef.current?.scrollTo(
                0,
                0
              );
            },
            value: currentPatternSourceFilter
          }
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { label: (0,external_wp_i18n_namespaceObject.__)("Type"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.MenuItemsChoice,
          {
            choices: patternSyncMenuOptions,
            onSelect: (value) => {
              setPatternSyncFilter(value);
              scrollContainerRef.current?.scrollTo(
                0,
                0
              );
            },
            value: patternSyncFilter
          }
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__patterns-filter-help", children: (0,external_wp_element_namespaceObject.createInterpolateElement)(
          (0,external_wp_i18n_namespaceObject.__)(
            "Patterns are available from the <Link>WordPress.org Pattern Directory</Link>, bundled in the active theme, or created by users on this site. Only patterns created on this site can be synced."
          ),
          {
            Link: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.ExternalLink,
              {
                href: (0,external_wp_i18n_namespaceObject.__)(
                  "https://wordpress.org/patterns/"
                )
              }
            )
          }
        ) })
      ] })
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/pattern-category-previews.js










const pattern_category_previews_noop = () => {
};
function PatternCategoryPreviews({
  rootClientId,
  onInsert,
  onHover = pattern_category_previews_noop,
  category,
  showTitlesAsTooltip
}) {
  const [allPatterns, , onClickPattern] = use_patterns_state_default(
    onInsert,
    rootClientId,
    category?.name
  );
  const [patternSyncFilter, setPatternSyncFilter] = (0,external_wp_element_namespaceObject.useState)("all");
  const [patternSourceFilter, setPatternSourceFilter] = (0,external_wp_element_namespaceObject.useState)("all");
  const availableCategories = usePatternCategories(
    rootClientId,
    patternSourceFilter
  );
  const scrollContainerRef = (0,external_wp_element_namespaceObject.useRef)();
  const currentCategoryPatterns = (0,external_wp_element_namespaceObject.useMemo)(
    () => allPatterns.filter((pattern) => {
      if (isPatternFiltered(
        pattern,
        patternSourceFilter,
        patternSyncFilter
      )) {
        return false;
      }
      if (category.name === allPatternsCategory.name) {
        return true;
      }
      if (category.name === myPatternsCategory.name && pattern.type === INSERTER_PATTERN_TYPES.user) {
        return true;
      }
      if (category.name === starterPatternsCategory.name && pattern.blockTypes?.includes("core/post-content")) {
        return true;
      }
      if (category.name === "uncategorized") {
        if (!pattern.categories) {
          return true;
        }
        return !pattern.categories.some(
          (catName) => availableCategories.some((c) => c.name === catName)
        );
      }
      return pattern.categories?.includes(category.name);
    }),
    [
      allPatterns,
      availableCategories,
      category.name,
      patternSourceFilter,
      patternSyncFilter
    ]
  );
  const pagingProps = usePatternsPaging(
    currentCategoryPatterns,
    category,
    scrollContainerRef
  );
  const { changePage } = pagingProps;
  (0,external_wp_element_namespaceObject.useEffect)(() => () => onHover(null), []);
  const onSetPatternSyncFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (value) => {
      setPatternSyncFilter(value);
      changePage(1);
    },
    [setPatternSyncFilter, changePage]
  );
  const onSetPatternSourceFilter = (0,external_wp_element_namespaceObject.useCallback)(
    (value) => {
      setPatternSourceFilter(value);
      changePage(1);
    },
    [setPatternSourceFilter, changePage]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.__experimentalVStack,
      {
        spacing: 2,
        className: "block-editor-inserter__patterns-category-panel-header",
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexBlock, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalHeading,
              {
                className: "block-editor-inserter__patterns-category-panel-title",
                size: 13,
                level: 4,
                as: "div",
                children: category.label
              }
            ) }),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              PatternsFilter,
              {
                patternSyncFilter,
                patternSourceFilter,
                setPatternSyncFilter: onSetPatternSyncFilter,
                setPatternSourceFilter: onSetPatternSourceFilter,
                scrollContainerRef,
                category
              }
            )
          ] }),
          !currentCategoryPatterns.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalText,
            {
              variant: "muted",
              className: "block-editor-inserter__patterns-category-no-results",
              children: (0,external_wp_i18n_namespaceObject.__)("No results found")
            }
          )
        ]
      }
    ),
    currentCategoryPatterns.length > 0 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalText,
        {
          size: "12",
          as: "p",
          className: "block-editor-inserter__help-text",
          children: (0,external_wp_i18n_namespaceObject.__)("Drag and drop patterns into the canvas.")
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_patterns_list_default,
        {
          ref: scrollContainerRef,
          blockPatterns: pagingProps.categoryPatterns,
          onClickPattern,
          onHover,
          label: category.label,
          orientation: "vertical",
          category: category.name,
          isDraggable: true,
          showTitlesAsTooltip,
          patternFilter: patternSourceFilter,
          pagingProps
        }
      )
    ] })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/category-tabs/index.js





const { Tabs: category_tabs_Tabs } = unlock(external_wp_components_namespaceObject.privateApis);
function CategoryTabs({
  categories,
  selectedCategory,
  onSelectCategory,
  children
}) {
  const ANIMATION_DURATION = 0.25;
  const disableMotion = (0,external_wp_compose_namespaceObject.useReducedMotion)();
  const defaultTransition = {
    type: "tween",
    duration: disableMotion ? 0 : ANIMATION_DURATION,
    ease: [0.6, 0, 0.4, 1]
  };
  const previousSelectedCategory = (0,external_wp_compose_namespaceObject.usePrevious)(selectedCategory);
  const selectedTabId = selectedCategory ? selectedCategory.name : null;
  const [activeTabId, setActiveId] = (0,external_wp_element_namespaceObject.useState)();
  const firstTabId = categories?.[0]?.name;
  if (selectedTabId === null && !activeTabId && firstTabId) {
    setActiveId(firstTabId);
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    category_tabs_Tabs,
    {
      selectOnMove: false,
      selectedTabId,
      orientation: "vertical",
      onSelect: (categoryId) => {
        onSelectCategory(
          categories.find(
            (category) => category.name === categoryId
          )
        );
      },
      activeTabId,
      onActiveTabIdChange: setActiveId,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(category_tabs_Tabs.TabList, { className: "block-editor-inserter__category-tablist", children: categories.map((category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          category_tabs_Tabs.Tab,
          {
            tabId: category.name,
            "aria-current": category === selectedCategory ? "true" : void 0,
            children: category.label
          },
          category.name
        )) }),
        categories.map((category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          category_tabs_Tabs.TabPanel,
          {
            tabId: category.name,
            focusable: false,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__unstableMotion.div,
              {
                className: "block-editor-inserter__category-panel",
                initial: !previousSelectedCategory ? "closed" : "open",
                animate: "open",
                variants: {
                  open: {
                    transform: "translateX( 0 )",
                    transitionEnd: {
                      zIndex: "1"
                    }
                  },
                  closed: {
                    transform: "translateX( -100% )",
                    zIndex: "-1"
                  }
                },
                transition: defaultTransition,
                children
              }
            )
          },
          category.name
        ))
      ]
    }
  );
}
var category_tabs_default = CategoryTabs;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab/index.js











function BlockPatternsTab({
  onSelectCategory,
  selectedCategory,
  onInsert,
  rootClientId,
  children
}) {
  const [showPatternsExplorer, setShowPatternsExplorer] = (0,external_wp_element_namespaceObject.useState)(false);
  const categories = usePatternCategories(rootClientId);
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  if (!categories.length) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {});
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    !isMobile && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-inserter__block-patterns-tabs-container", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        category_tabs_default,
        {
          categories,
          selectedCategory,
          onSelectCategory,
          children
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          __next40pxDefaultSize: true,
          className: "block-editor-inserter__patterns-explore-button",
          onClick: () => setShowPatternsExplorer(true),
          variant: "secondary",
          children: (0,external_wp_i18n_namespaceObject.__)("Explore all patterns")
        }
      )
    ] }),
    isMobile && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MobileTabNavigation, { categories, children: (category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__category-panel", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PatternCategoryPreviews,
      {
        onInsert,
        rootClientId,
        category
      },
      category.name
    ) }) }),
    showPatternsExplorer && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_patterns_explorer_default,
      {
        initialCategory: selectedCategory || categories[0],
        patternCategories: categories,
        onModalClose: () => setShowPatternsExplorer(false),
        rootClientId
      }
    )
  ] });
}
var block_patterns_tab_default = BlockPatternsTab;


;// ./node_modules/@wordpress/icons/build-module/library/external.js


var external_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19.5 4.5h-7V6h4.44l-5.97 5.97 1.06 1.06L18 7.06v4.44h1.5v-7Zm-13 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3H17v3a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h3V5.5h-3Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/utils.js


const mediaTypeTag = { image: "img", video: "video", audio: "audio" };
function getBlockAndPreviewFromMedia(media, mediaType) {
  const attributes = {
    id: media.id || void 0,
    caption: media.caption || void 0
  };
  const mediaSrc = media.url;
  const alt = media.alt || void 0;
  if (mediaType === "image") {
    attributes.url = mediaSrc;
    attributes.alt = alt;
  } else if (["video", "audio"].includes(mediaType)) {
    attributes.src = mediaSrc;
  }
  const PreviewTag = mediaTypeTag[mediaType];
  const preview = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PreviewTag,
    {
      src: media.previewUrl || mediaSrc,
      alt,
      controls: mediaType === "audio" ? true : void 0,
      inert: "true",
      onError: ({ currentTarget }) => {
        if (currentTarget.src === media.previewUrl) {
          currentTarget.src = mediaSrc;
        }
      }
    }
  );
  return [(0,external_wp_blocks_namespaceObject.createBlock)(`core/${mediaType}`, attributes), preview];
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-preview.js














const ALLOWED_MEDIA_TYPES = ["image"];
const MEDIA_OPTIONS_POPOVER_PROPS = {
  placement: "bottom-end",
  className: "block-editor-inserter__media-list__item-preview-options__popover"
};
function MediaPreviewOptions({ category, media }) {
  if (!category.getReportUrl) {
    return null;
  }
  const reportUrl = category.getReportUrl(media);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.DropdownMenu,
    {
      className: "block-editor-inserter__media-list__item-preview-options",
      label: (0,external_wp_i18n_namespaceObject.__)("Options"),
      popoverProps: MEDIA_OPTIONS_POPOVER_PROPS,
      icon: more_vertical_default,
      children: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.MenuItem,
        {
          onClick: () => window.open(reportUrl, "_blank").focus(),
          icon: external_default,
          children: (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %s: The media type to report e.g: "image", "video", "audio" */
            (0,external_wp_i18n_namespaceObject.__)("Report %s"),
            category.mediaType
          )
        }
      ) })
    }
  );
}
function InsertExternalImageModal({ onClose, onSubmit }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.__)("Insert external image"),
      onRequestClose: onClose,
      className: "block-editor-inserter-media-tab-media-preview-inserter-external-image-modal",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 3, children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)(
            "This image cannot be uploaded to your Media Library, but it can still be inserted as an external image."
          ) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)(
            "External images can be removed by the external provider without warning and could even have legal compliance issues related to privacy legislation."
          ) })
        ] }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.Flex,
          {
            className: "block-editor-block-lock-modal__actions",
            justify: "flex-end",
            expanded: false,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "tertiary",
                  onClick: onClose,
                  children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
                }
              ) }),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "primary",
                  onClick: onSubmit,
                  children: (0,external_wp_i18n_namespaceObject.__)("Insert")
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
function MediaPreview({ media, onClick, category }) {
  const [showExternalUploadModal, setShowExternalUploadModal] = (0,external_wp_element_namespaceObject.useState)(false);
  const [isHovered, setIsHovered] = (0,external_wp_element_namespaceObject.useState)(false);
  const [isInserting, setIsInserting] = (0,external_wp_element_namespaceObject.useState)(false);
  const [block, preview] = (0,external_wp_element_namespaceObject.useMemo)(
    () => getBlockAndPreviewFromMedia(media, category.mediaType),
    [media, category.mediaType]
  );
  const { createErrorNotice, createSuccessNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const { getSettings, getBlock } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onMediaInsert = (0,external_wp_element_namespaceObject.useCallback)(
    (previewBlock) => {
      if (isInserting) {
        return;
      }
      const settings = getSettings();
      const clonedBlock = (0,external_wp_blocks_namespaceObject.cloneBlock)(previewBlock);
      const { id, url, caption } = clonedBlock.attributes;
      if (!id && !settings.mediaUpload) {
        setShowExternalUploadModal(true);
        return;
      }
      if (!!id) {
        onClick(clonedBlock);
        return;
      }
      setIsInserting(true);
      window.fetch(url).then((response) => response.blob()).then((blob) => {
        const fileName = (0,external_wp_url_namespaceObject.getFilename)(url) || "image.jpg";
        const file = new File([blob], fileName, {
          type: blob.type
        });
        settings.mediaUpload({
          filesList: [file],
          additionalData: { caption },
          onFileChange([img]) {
            if ((0,external_wp_blob_namespaceObject.isBlobURL)(img.url)) {
              return;
            }
            if (!getBlock(clonedBlock.clientId)) {
              onClick({
                ...clonedBlock,
                attributes: {
                  ...clonedBlock.attributes,
                  id: img.id,
                  url: img.url
                }
              });
              createSuccessNotice(
                (0,external_wp_i18n_namespaceObject.__)("Image uploaded and inserted."),
                { type: "snackbar", id: "inserter-notice" }
              );
            } else {
              updateBlockAttributes(clonedBlock.clientId, {
                ...clonedBlock.attributes,
                id: img.id,
                url: img.url
              });
            }
            setIsInserting(false);
          },
          allowedTypes: ALLOWED_MEDIA_TYPES,
          onError(message) {
            createErrorNotice(message, {
              type: "snackbar",
              id: "inserter-notice"
            });
            setIsInserting(false);
          }
        });
      }).catch(() => {
        setShowExternalUploadModal(true);
        setIsInserting(false);
      });
    },
    [
      isInserting,
      getSettings,
      onClick,
      createSuccessNotice,
      updateBlockAttributes,
      createErrorNotice,
      getBlock
    ]
  );
  const title = typeof media.title === "string" ? media.title : media.title?.rendered || (0,external_wp_i18n_namespaceObject.__)("no title");
  const onMouseEnter = (0,external_wp_element_namespaceObject.useCallback)(() => setIsHovered(true), []);
  const onMouseLeave = (0,external_wp_element_namespaceObject.useCallback)(() => setIsHovered(false), []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inserter_draggable_blocks_default, { isEnabled: true, blocks: [block], children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        className: dist_clsx(
          "block-editor-inserter__media-list__list-item",
          {
            "is-hovered": isHovered
          }
        ),
        draggable,
        onDragStart,
        onDragEnd,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          "div",
          {
            onMouseEnter,
            onMouseLeave,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tooltip, { text: title, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Composite.Item,
                {
                  render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    "div",
                    {
                      "aria-label": title,
                      role: "option",
                      className: "block-editor-inserter__media-list__item"
                    }
                  ),
                  onClick: () => onMediaInsert(block),
                  children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-inserter__media-list__item-preview", children: [
                    preview,
                    isInserting && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__media-list__item-preview-spinner", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {}) })
                  ] })
                }
              ) }),
              !isInserting && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                MediaPreviewOptions,
                {
                  category,
                  media
                }
              )
            ]
          }
        )
      }
    ) }),
    showExternalUploadModal && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      InsertExternalImageModal,
      {
        onClose: () => setShowExternalUploadModal(false),
        onSubmit: () => {
          onClick((0,external_wp_blocks_namespaceObject.cloneBlock)(block));
          createSuccessNotice((0,external_wp_i18n_namespaceObject.__)("Image inserted."), {
            type: "snackbar",
            id: "inserter-notice"
          });
          setShowExternalUploadModal(false);
        }
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-list.js




function MediaList({
  mediaList,
  category,
  onClick,
  label = (0,external_wp_i18n_namespaceObject.__)("Media List")
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite,
    {
      role: "listbox",
      className: "block-editor-inserter__media-list",
      "aria-label": label,
      children: mediaList.map((media, index) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        MediaPreview,
        {
          media,
          category,
          onClick
        },
        media.id || media.sourceId || index
      ))
    }
  );
}
var media_list_default = MediaList;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/hooks.js




function useMediaResults(category, query = {}) {
  const [mediaList, setMediaList] = (0,external_wp_element_namespaceObject.useState)();
  const [isLoading, setIsLoading] = (0,external_wp_element_namespaceObject.useState)(false);
  const lastRequestRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    (async () => {
      const key = JSON.stringify({
        category: category.name,
        ...query
      });
      lastRequestRef.current = key;
      setIsLoading(true);
      setMediaList([]);
      const _media = await category.fetch?.(query);
      if (key === lastRequestRef.current) {
        setMediaList(_media);
        setIsLoading(false);
      }
    })();
  }, [category.name, ...Object.values(query)]);
  return { mediaList, isLoading };
}
function useMediaCategories(rootClientId) {
  const [categories, setCategories] = (0,external_wp_element_namespaceObject.useState)([]);
  const inserterMediaCategories = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(store)).getInserterMediaCategories(),
    []
  );
  const { canInsertImage, canInsertVideo, canInsertAudio } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { canInsertBlockType } = select(store);
      return {
        canInsertImage: canInsertBlockType(
          "core/image",
          rootClientId
        ),
        canInsertVideo: canInsertBlockType(
          "core/video",
          rootClientId
        ),
        canInsertAudio: canInsertBlockType(
          "core/audio",
          rootClientId
        )
      };
    },
    [rootClientId]
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    (async () => {
      const _categories = [];
      if (!inserterMediaCategories) {
        return;
      }
      const categoriesHaveMedia = new Map(
        await Promise.all(
          inserterMediaCategories.map(async (category) => {
            if (category.isExternalResource) {
              return [category.name, true];
            }
            let results = [];
            try {
              results = await category.fetch({
                per_page: 1
              });
            } catch (e) {
            }
            return [category.name, !!results.length];
          })
        )
      );
      const canInsertMediaType = {
        image: canInsertImage,
        video: canInsertVideo,
        audio: canInsertAudio
      };
      inserterMediaCategories.forEach((category) => {
        if (canInsertMediaType[category.mediaType] && categoriesHaveMedia.get(category.name)) {
          _categories.push(category);
        }
      });
      if (!!_categories.length) {
        setCategories(_categories);
      }
    })();
  }, [
    canInsertImage,
    canInsertVideo,
    canInsertAudio,
    inserterMediaCategories
  ]);
  return categories;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-panel.js







const INITIAL_MEDIA_ITEMS_PER_PAGE = 10;
function MediaCategoryPanel({ rootClientId, onInsert, category }) {
  const [search, setSearch, debouncedSearch] = (0,external_wp_compose_namespaceObject.useDebouncedInput)();
  const { mediaList, isLoading } = useMediaResults(category, {
    per_page: !!debouncedSearch ? 20 : INITIAL_MEDIA_ITEMS_PER_PAGE,
    search: debouncedSearch
  });
  const baseCssClass = "block-editor-inserter__media-panel";
  const searchLabel = category.labels.search_items || (0,external_wp_i18n_namespaceObject.__)("Search");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: baseCssClass, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.SearchControl,
      {
        __nextHasNoMarginBottom: true,
        className: `${baseCssClass}-search`,
        onChange: setSearch,
        value: search,
        label: searchLabel,
        placeholder: searchLabel
      }
    ),
    isLoading && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: `${baseCssClass}-spinner`, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {}) }),
    !isLoading && !mediaList?.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {}),
    !isLoading && !!mediaList?.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      media_list_default,
      {
        rootClientId,
        onClick: onInsert,
        mediaList,
        category
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/media-tab/media-tab.js













const media_tab_ALLOWED_MEDIA_TYPES = ["image", "video", "audio"];
function MediaTab({
  rootClientId,
  selectedCategory,
  onSelectCategory,
  onInsert,
  children
}) {
  const mediaCategories = useMediaCategories(rootClientId);
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  const baseCssClass = "block-editor-inserter__media-tabs";
  const onSelectMedia = (0,external_wp_element_namespaceObject.useCallback)(
    (media) => {
      if (!media?.url) {
        return;
      }
      const [block] = getBlockAndPreviewFromMedia(media, media.type);
      onInsert(block);
    },
    [onInsert]
  );
  const categories = (0,external_wp_element_namespaceObject.useMemo)(
    () => mediaCategories.map((mediaCategory) => ({
      ...mediaCategory,
      label: mediaCategory.labels.name
    })),
    [mediaCategories]
  );
  if (!categories.length) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {});
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    !isMobile && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: `${baseCssClass}-container`, children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        category_tabs_default,
        {
          categories,
          selectedCategory,
          onSelectCategory,
          children
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(check_default, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        media_upload_default,
        {
          multiple: false,
          onSelect: onSelectMedia,
          allowedTypes: media_tab_ALLOWED_MEDIA_TYPES,
          render: ({ open }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              __next40pxDefaultSize: true,
              onClick: (event) => {
                event.target.focus();
                open();
              },
              className: "block-editor-inserter__media-library-button",
              variant: "secondary",
              "data-unstable-ignore-focus-outside-for-relatedtarget": ".media-modal",
              children: (0,external_wp_i18n_namespaceObject.__)("Open Media Library")
            }
          )
        }
      ) })
    ] }),
    isMobile && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MobileTabNavigation, { categories, children: (category) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      MediaCategoryPanel,
      {
        onInsert,
        rootClientId,
        category
      }
    ) })
  ] });
}
var media_tab_default = MediaTab;


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js

const { Fill: __unstableInserterMenuExtension, Slot } = (0,external_wp_components_namespaceObject.createSlotFill)(
  "__unstableInserterMenuExtension"
);
__unstableInserterMenuExtension.Slot = Slot;
var inserter_menu_extension_default = __unstableInserterMenuExtension;


;// ./node_modules/@wordpress/block-editor/build-module/utils/order-inserter-block-items.js
const orderInserterBlockItems = (items, priority) => {
  if (!priority) {
    return items;
  }
  items.sort(({ id: aName }, { id: bName }) => {
    let aIndex = priority.indexOf(aName);
    let bIndex = priority.indexOf(bName);
    if (aIndex < 0) {
      aIndex = priority.length;
    }
    if (bIndex < 0) {
      bIndex = priority.length;
    }
    return aIndex - bIndex;
  });
  return items;
};


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js




















const INITIAL_INSERTER_RESULTS = 9;
const search_results_EMPTY_ARRAY = [];
function InserterSearchResults({
  filterValue,
  onSelect,
  onHover,
  onHoverPattern,
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  maxBlockPatterns,
  maxBlockTypes,
  showBlockDirectory = false,
  isDraggable = true,
  shouldFocusBlock = true,
  prioritizePatterns,
  selectBlockOnInsert,
  isQuick
}) {
  const debouncedSpeak = (0,external_wp_compose_namespaceObject.useDebounce)(external_wp_a11y_namespaceObject.speak, 500);
  const { prioritizedBlocks } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const blockListSettings = select(store).getBlockListSettings(rootClientId);
      return {
        prioritizedBlocks: blockListSettings?.prioritizedInserterBlocks || search_results_EMPTY_ARRAY
      };
    },
    [rootClientId]
  );
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock,
    selectBlockOnInsert
  });
  const [
    blockTypes,
    blockTypeCategories,
    blockTypeCollections,
    onSelectBlockType
  ] = use_block_types_state_default(destinationRootClientId, onInsertBlocks, isQuick);
  const [patterns, , onClickPattern] = use_patterns_state_default(
    onInsertBlocks,
    destinationRootClientId,
    void 0,
    isQuick
  );
  const filteredBlockPatterns = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (maxBlockPatterns === 0) {
      return [];
    }
    const results = searchItems(patterns, filterValue);
    return maxBlockPatterns !== void 0 ? results.slice(0, maxBlockPatterns) : results;
  }, [filterValue, patterns, maxBlockPatterns]);
  let maxBlockTypesToShow = maxBlockTypes;
  if (prioritizePatterns && filteredBlockPatterns.length > 2) {
    maxBlockTypesToShow = 0;
  }
  const filteredBlockTypes = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (maxBlockTypesToShow === 0) {
      return [];
    }
    const nonPatternBlockTypes = blockTypes.filter(
      (blockType) => blockType.name !== "core/block"
    );
    let orderedItems = orderBy(nonPatternBlockTypes, "frecency", "desc");
    if (!filterValue && prioritizedBlocks.length) {
      orderedItems = orderInserterBlockItems(
        orderedItems,
        prioritizedBlocks
      );
    }
    const results = searchBlockItems(
      orderedItems,
      blockTypeCategories,
      blockTypeCollections,
      filterValue
    );
    return maxBlockTypesToShow !== void 0 ? results.slice(0, maxBlockTypesToShow) : results;
  }, [
    filterValue,
    blockTypes,
    blockTypeCategories,
    blockTypeCollections,
    maxBlockTypesToShow,
    prioritizedBlocks
  ]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!filterValue) {
      return;
    }
    const count = filteredBlockTypes.length + filteredBlockPatterns.length;
    const resultsFoundMessage = (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %d: number of results. */
      (0,external_wp_i18n_namespaceObject._n)("%d result found.", "%d results found.", count),
      count
    );
    debouncedSpeak(resultsFoundMessage);
  }, [
    filterValue,
    debouncedSpeak,
    filteredBlockTypes,
    filteredBlockPatterns
  ]);
  const currentShownBlockTypes = (0,external_wp_compose_namespaceObject.useAsyncList)(filteredBlockTypes, {
    step: INITIAL_INSERTER_RESULTS
  });
  const hasItems = filteredBlockTypes.length > 0 || filteredBlockPatterns.length > 0;
  const blocksUI = !!filteredBlockTypes.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    panel_default,
    {
      title: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { children: (0,external_wp_i18n_namespaceObject.__)("Blocks") }),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_types_list_default,
        {
          items: currentShownBlockTypes,
          onSelect: onSelectBlockType,
          onHover,
          label: (0,external_wp_i18n_namespaceObject.__)("Blocks"),
          isDraggable
        }
      )
    }
  );
  const patternsUI = !!filteredBlockPatterns.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    panel_default,
    {
      title: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { children: (0,external_wp_i18n_namespaceObject.__)("Block patterns") }),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__quick-inserter-patterns", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_patterns_list_default,
        {
          blockPatterns: filteredBlockPatterns,
          onClickPattern,
          onHover: onHoverPattern,
          isDraggable
        }
      ) })
    }
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(inserter_listbox_default, { children: [
    !showBlockDirectory && !hasItems && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {}),
    prioritizePatterns ? patternsUI : blocksUI,
    !!filteredBlockTypes.length && !!filteredBlockPatterns.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__quick-inserter-separator" }),
    prioritizePatterns ? blocksUI : patternsUI,
    showBlockDirectory && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inserter_menu_extension_default.Slot,
      {
        fillProps: {
          onSelect: onSelectBlockType,
          onHover,
          filterValue,
          hasItems,
          rootClientId: destinationRootClientId
        },
        children: (fills) => {
          if (fills.length) {
            return fills;
          }
          if (!hasItems) {
            return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(no_results_default, {});
          }
          return null;
        }
      }
    )
  ] });
}
var search_results_search_results_default = InserterSearchResults;


;// ./node_modules/@wordpress/icons/build-module/library/close-small.js


var close_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/tabbed-sidebar/index.js





const { Tabs: tabbed_sidebar_Tabs } = unlock(external_wp_components_namespaceObject.privateApis);
function TabbedSidebar({ defaultTabId, onClose, onSelect, selectedTab, tabs, closeButtonLabel }, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-tabbed-sidebar", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    tabbed_sidebar_Tabs,
    {
      selectOnMove: false,
      defaultTabId,
      onSelect,
      selectedTabId: selectedTab,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-tabbed-sidebar__tablist-and-close-button", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              className: "block-editor-tabbed-sidebar__close-button",
              icon: close_small_default,
              label: closeButtonLabel,
              onClick: () => onClose(),
              size: "compact"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            tabbed_sidebar_Tabs.TabList,
            {
              className: "block-editor-tabbed-sidebar__tablist",
              ref,
              children: tabs.map((tab) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                tabbed_sidebar_Tabs.Tab,
                {
                  tabId: tab.name,
                  className: "block-editor-tabbed-sidebar__tab",
                  children: tab.title
                },
                tab.name
              ))
            }
          )
        ] }),
        tabs.map((tab) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          tabbed_sidebar_Tabs.TabPanel,
          {
            tabId: tab.name,
            focusable: false,
            className: "block-editor-tabbed-sidebar__tabpanel",
            ref: tab.panelRef,
            children: tab.panel
          },
          tab.name
        ))
      ]
    }
  ) });
}
var tabbed_sidebar_default = (0,external_wp_element_namespaceObject.forwardRef)(TabbedSidebar);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-zoom-out.js




function useZoomOut(enabled = true) {
  const { setZoomLevel, resetZoomLevel } = unlock(
    (0,external_wp_data_namespaceObject.useDispatch)(store)
  );
  const { isZoomedOut, isZoomOut } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { isZoomOut: _isZoomOut } = unlock(select(store));
    return {
      isZoomedOut: _isZoomOut(),
      isZoomOut: _isZoomOut
    };
  }, []);
  const controlZoomLevelRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const isEnabledRef = (0,external_wp_element_namespaceObject.useRef)(enabled);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (isZoomedOut !== isEnabledRef.current) {
      controlZoomLevelRef.current = false;
    }
  }, [isZoomedOut]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    isEnabledRef.current = enabled;
    if (enabled !== isZoomOut()) {
      controlZoomLevelRef.current = true;
      if (enabled) {
        setZoomLevel("auto-scaled");
      } else {
        resetZoomLevel();
      }
    }
    return () => {
      if (controlZoomLevelRef.current && isZoomOut()) {
        resetZoomLevel();
      }
    };
  }, [enabled, isZoomOut, resetZoomLevel, setZoomLevel]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js



















const NOOP = () => {
};
function InserterMenu({
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  onSelect,
  showInserterHelpPanel,
  showMostUsedBlocks,
  __experimentalFilterValue = "",
  shouldFocusBlock = true,
  onPatternCategorySelection,
  onClose,
  __experimentalInitialTab,
  __experimentalInitialCategory
}, ref) {
  const { isZoomOutMode, hasSectionRootClientId } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { isZoomOut, getSectionRootClientId } = unlock(
      select(store)
    );
    return {
      isZoomOutMode: isZoomOut(),
      hasSectionRootClientId: !!getSectionRootClientId()
    };
  }, []);
  const [filterValue, setFilterValue, delayedFilterValue] = (0,external_wp_compose_namespaceObject.useDebouncedInput)(__experimentalFilterValue);
  const [hoveredItem, setHoveredItem] = (0,external_wp_element_namespaceObject.useState)(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = (0,external_wp_element_namespaceObject.useState)(
    __experimentalInitialCategory
  );
  const [patternFilter, setPatternFilter] = (0,external_wp_element_namespaceObject.useState)("all");
  const [selectedMediaCategory, setSelectedMediaCategory] = (0,external_wp_element_namespaceObject.useState)(null);
  const isLargeViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)("large");
  function getInitialTab() {
    if (__experimentalInitialTab) {
      return __experimentalInitialTab;
    }
    if (isZoomOutMode) {
      return "patterns";
    }
    return "blocks";
  }
  const [selectedTab, setSelectedTab] = (0,external_wp_element_namespaceObject.useState)(getInitialTab());
  const shouldUseZoomOut = hasSectionRootClientId && (selectedTab === "patterns" || selectedTab === "media");
  useZoomOut(shouldUseZoomOut && isLargeViewport);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point_default({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const blockTypesTabRef = (0,external_wp_element_namespaceObject.useRef)();
  const onInsert = (0,external_wp_element_namespaceObject.useCallback)(
    (blocks, meta, shouldForceFocusBlock, _rootClientId) => {
      onInsertBlocks(
        blocks,
        meta,
        shouldForceFocusBlock,
        _rootClientId
      );
      onSelect(blocks);
      window.requestAnimationFrame(() => {
        if (!shouldFocusBlock && !blockTypesTabRef.current?.contains(
          ref.current.ownerDocument.activeElement
        )) {
          blockTypesTabRef.current?.querySelector("button").focus();
        }
      });
    },
    [onInsertBlocks, onSelect, shouldFocusBlock]
  );
  const onInsertPattern = (0,external_wp_element_namespaceObject.useCallback)(
    (blocks, patternName, ...args) => {
      onToggleInsertionPoint(false);
      onInsertBlocks(blocks, { patternName }, ...args);
      onSelect();
    },
    [onInsertBlocks, onSelect]
  );
  const onHover = (0,external_wp_element_namespaceObject.useCallback)(
    (item) => {
      onToggleInsertionPoint(item);
      setHoveredItem(item);
    },
    [onToggleInsertionPoint, setHoveredItem]
  );
  const onClickPatternCategory = (0,external_wp_element_namespaceObject.useCallback)(
    (patternCategory, filter) => {
      setSelectedPatternCategory(patternCategory);
      setPatternFilter(filter);
      onPatternCategorySelection?.();
    },
    [setSelectedPatternCategory, onPatternCategorySelection]
  );
  const showPatternPanel = selectedTab === "patterns" && !delayedFilterValue && !!selectedPatternCategory;
  const showMediaPanel = selectedTab === "media" && !!selectedMediaCategory;
  const inserterSearch = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (selectedTab === "media") {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.SearchControl,
        {
          __nextHasNoMarginBottom: true,
          className: "block-editor-inserter__search",
          onChange: (value) => {
            if (hoveredItem) {
              setHoveredItem(null);
            }
            setFilterValue(value);
          },
          value: filterValue,
          label: (0,external_wp_i18n_namespaceObject.__)("Search"),
          placeholder: (0,external_wp_i18n_namespaceObject.__)("Search")
        }
      ),
      !!delayedFilterValue && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        search_results_search_results_default,
        {
          filterValue: delayedFilterValue,
          onSelect,
          onHover,
          rootClientId,
          clientId,
          isAppender,
          __experimentalInsertionIndex,
          showBlockDirectory: true,
          shouldFocusBlock,
          prioritizePatterns: selectedTab === "patterns"
        }
      )
    ] });
  }, [
    selectedTab,
    hoveredItem,
    setHoveredItem,
    setFilterValue,
    filterValue,
    delayedFilterValue,
    onSelect,
    onHover,
    shouldFocusBlock,
    clientId,
    rootClientId,
    __experimentalInsertionIndex,
    isAppender
  ]);
  const blocksTab = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__block-list", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_types_tab_default,
        {
          ref: blockTypesTabRef,
          rootClientId: destinationRootClientId,
          onInsert,
          onHover,
          showMostUsedBlocks
        }
      ) }),
      showInserterHelpPanel && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-inserter__tips", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "h2", children: (0,external_wp_i18n_namespaceObject.__)("A tip for using the block editor") }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(tips_default, {})
      ] })
    ] });
  }, [
    destinationRootClientId,
    onInsert,
    onHover,
    showMostUsedBlocks,
    showInserterHelpPanel
  ]);
  const patternsTab = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_patterns_tab_default,
      {
        rootClientId: destinationRootClientId,
        onInsert: onInsertPattern,
        onSelectCategory: onClickPatternCategory,
        selectedCategory: selectedPatternCategory,
        children: showPatternPanel && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          PatternCategoryPreviews,
          {
            rootClientId: destinationRootClientId,
            onInsert: onInsertPattern,
            category: selectedPatternCategory,
            patternFilter,
            showTitlesAsTooltip: true
          }
        )
      }
    );
  }, [
    destinationRootClientId,
    onInsertPattern,
    onClickPatternCategory,
    patternFilter,
    selectedPatternCategory,
    showPatternPanel
  ]);
  const mediaTab = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      media_tab_default,
      {
        rootClientId: destinationRootClientId,
        selectedCategory: selectedMediaCategory,
        onSelectCategory: setSelectedMediaCategory,
        onInsert,
        children: showMediaPanel && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          MediaCategoryPanel,
          {
            rootClientId: destinationRootClientId,
            onInsert,
            category: selectedMediaCategory
          }
        )
      }
    );
  }, [
    destinationRootClientId,
    onInsert,
    selectedMediaCategory,
    setSelectedMediaCategory,
    showMediaPanel
  ]);
  const handleSetSelectedTab = (value) => {
    if (value !== "patterns") {
      setSelectedPatternCategory(null);
    }
    setSelectedTab(value);
  };
  const tabsRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (tabsRef.current) {
      window.requestAnimationFrame(() => {
        tabsRef.current.querySelector('[role="tab"][aria-selected="true"]')?.focus();
      });
    }
  }, []);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: dist_clsx("block-editor-inserter__menu", {
        "show-panel": showPatternPanel || showMediaPanel,
        "is-zoom-out": isZoomOutMode
      }),
      ref,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__main-area", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          tabbed_sidebar_default,
          {
            ref: tabsRef,
            onSelect: handleSetSelectedTab,
            onClose,
            selectedTab,
            closeButtonLabel: (0,external_wp_i18n_namespaceObject.__)("Close Block Inserter"),
            tabs: [
              {
                name: "blocks",
                title: (0,external_wp_i18n_namespaceObject.__)("Blocks"),
                panel: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                  inserterSearch,
                  selectedTab === "blocks" && !delayedFilterValue && blocksTab
                ] })
              },
              {
                name: "patterns",
                title: (0,external_wp_i18n_namespaceObject.__)("Patterns"),
                panel: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                  inserterSearch,
                  selectedTab === "patterns" && !delayedFilterValue && patternsTab
                ] })
              },
              {
                name: "media",
                title: (0,external_wp_i18n_namespaceObject.__)("Media"),
                panel: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                  inserterSearch,
                  mediaTab
                ] })
              }
            ]
          }
        ) }),
        showInserterHelpPanel && hoveredItem && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Popover,
          {
            className: "block-editor-inserter__preview-container__popover",
            placement: "right-start",
            offset: 16,
            focusOnMount: false,
            animate: false,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(preview_panel_default, { item: hoveredItem })
          }
        )
      ]
    }
  );
}
const PrivateInserterMenu = (0,external_wp_element_namespaceObject.forwardRef)(InserterMenu);
function PublicInserterMenu(props, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateInserterMenu,
    {
      ...props,
      onPatternCategorySelection: NOOP,
      ref
    }
  );
}
var menu_default = (0,external_wp_element_namespaceObject.forwardRef)(PublicInserterMenu);


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js










const SEARCH_THRESHOLD = 6;
const SHOWN_BLOCK_TYPES = 6;
const SHOWN_BLOCK_PATTERNS = 2;
function QuickInserter({
  onSelect,
  rootClientId,
  clientId,
  isAppender,
  selectBlockOnInsert,
  hasSearch = true
}) {
  const [filterValue, setFilterValue] = (0,external_wp_element_namespaceObject.useState)("");
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    selectBlockOnInsert
  });
  const [blockTypes] = use_block_types_state_default(
    destinationRootClientId,
    onInsertBlocks,
    true
  );
  const { setInserterIsOpened, insertionIndex } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getSettings, getBlockIndex, getBlockCount } = select(store);
      const settings = getSettings();
      const index = getBlockIndex(clientId);
      const blockCount = getBlockCount();
      return {
        setInserterIsOpened: settings.__experimentalSetIsInserterOpened,
        insertionIndex: index === -1 ? blockCount : index
      };
    },
    [clientId]
  );
  const showSearch = hasSearch && blockTypes.length > SEARCH_THRESHOLD;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (setInserterIsOpened) {
      setInserterIsOpened(false);
    }
  }, [setInserterIsOpened]);
  const onBrowseAll = () => {
    setInserterIsOpened({
      filterValue,
      onSelect,
      rootClientId,
      insertionIndex
    });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: dist_clsx("block-editor-inserter__quick-inserter", {
        "has-search": showSearch,
        "has-expand": setInserterIsOpened
      }),
      children: [
        showSearch && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.SearchControl,
          {
            __nextHasNoMarginBottom: true,
            className: "block-editor-inserter__search",
            value: filterValue,
            onChange: (value) => {
              setFilterValue(value);
            },
            label: (0,external_wp_i18n_namespaceObject.__)("Search"),
            placeholder: (0,external_wp_i18n_namespaceObject.__)("Search")
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-inserter__quick-inserter-results", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          search_results_search_results_default,
          {
            filterValue,
            onSelect,
            rootClientId,
            clientId,
            isAppender,
            maxBlockPatterns: !!filterValue ? SHOWN_BLOCK_PATTERNS : 0,
            maxBlockTypes: SHOWN_BLOCK_TYPES,
            isDraggable: false,
            selectBlockOnInsert,
            isQuick: true
          }
        ) }),
        setInserterIsOpened && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            className: "block-editor-inserter__quick-inserter-expand",
            onClick: onBrowseAll,
            "aria-label": (0,external_wp_i18n_namespaceObject.__)(
              "Browse all. This will open the main inserter panel in the editor toolbar."
            ),
            children: (0,external_wp_i18n_namespaceObject.__)("Browse all")
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/index.js













const defaultRenderToggle = ({
  onToggle,
  disabled,
  isOpen,
  blockTitle,
  hasSingleBlockType,
  toggleProps = {}
}) => {
  const {
    as: Wrapper = external_wp_components_namespaceObject.Button,
    label: labelProp,
    onClick,
    ...rest
  } = toggleProps;
  let label = labelProp;
  if (!label && hasSingleBlockType) {
    label = (0,external_wp_i18n_namespaceObject.sprintf)(
      // translators: %s: the name of the block when there is only one
      (0,external_wp_i18n_namespaceObject._x)("Add %s", "directly add the only allowed block"),
      blockTitle
    );
  } else if (!label) {
    label = (0,external_wp_i18n_namespaceObject._x)("Add block", "Generic label for block inserter button");
  }
  function handleClick(event) {
    if (onToggle) {
      onToggle(event);
    }
    if (onClick) {
      onClick(event);
    }
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    Wrapper,
    {
      __next40pxDefaultSize: toggleProps.as ? void 0 : true,
      icon: plus_default,
      label,
      tooltipPosition: "bottom",
      onClick: handleClick,
      className: "block-editor-inserter__toggle",
      "aria-haspopup": !hasSingleBlockType ? "true" : false,
      "aria-expanded": !hasSingleBlockType ? isOpen : false,
      disabled,
      ...rest
    }
  );
};
class Inserter extends external_wp_element_namespaceObject.Component {
  constructor() {
    super(...arguments);
    this.onToggle = this.onToggle.bind(this);
    this.renderToggle = this.renderToggle.bind(this);
    this.renderContent = this.renderContent.bind(this);
  }
  onToggle(isOpen) {
    const { onToggle } = this.props;
    if (onToggle) {
      onToggle(isOpen);
    }
  }
  /**
   * Render callback to display Dropdown toggle element.
   *
   * @param {Object}   options
   * @param {Function} options.onToggle Callback to invoke when toggle is
   *                                    pressed.
   * @param {boolean}  options.isOpen   Whether dropdown is currently open.
   *
   * @return {Element} Dropdown toggle element.
   */
  renderToggle({ onToggle, isOpen }) {
    const {
      disabled,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      hasItems,
      renderToggle = defaultRenderToggle
    } = this.props;
    return renderToggle({
      onToggle,
      isOpen,
      disabled: disabled || !hasItems,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps
    });
  }
  /**
   * Render callback to display Dropdown content element.
   *
   * @param {Object}   options
   * @param {Function} options.onClose Callback to invoke when dropdown is
   *                                   closed.
   *
   * @return {Element} Dropdown content element.
   */
  renderContent({ onClose }) {
    const {
      rootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      // This prop is experimental to give some time for the quick inserter to mature
      // Feel free to make them stable after a few releases.
      __experimentalIsQuick: isQuick,
      onSelectOrClose,
      selectBlockOnInsert
    } = this.props;
    if (isQuick) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        QuickInserter,
        {
          onSelect: (blocks) => {
            const firstBlock = Array.isArray(blocks) && blocks?.length ? blocks[0] : blocks;
            if (onSelectOrClose && typeof onSelectOrClose === "function") {
              onSelectOrClose(firstBlock);
            }
            onClose();
          },
          rootClientId,
          clientId,
          isAppender,
          selectBlockOnInsert
        }
      );
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      menu_default,
      {
        onSelect: () => {
          onClose();
        },
        rootClientId,
        clientId,
        isAppender,
        showInserterHelpPanel
      }
    );
  }
  render() {
    const {
      position,
      hasSingleBlockType,
      directInsertBlock,
      insertOnlyAllowedBlock,
      __experimentalIsQuick: isQuick,
      onSelectOrClose
    } = this.props;
    if (hasSingleBlockType || directInsertBlock) {
      return this.renderToggle({ onToggle: insertOnlyAllowedBlock });
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Dropdown,
      {
        className: "block-editor-inserter",
        contentClassName: dist_clsx("block-editor-inserter__popover", {
          "is-quick": isQuick
        }),
        popoverProps: { position, shift: true },
        onToggle: this.onToggle,
        expandOnMobile: true,
        headerTitle: (0,external_wp_i18n_namespaceObject.__)("Add a block"),
        renderToggle: this.renderToggle,
        renderContent: this.renderContent,
        onClose: onSelectOrClose
      }
    );
  }
}
var inserter_default = (0,external_wp_compose_namespaceObject.compose)([
  (0,external_wp_data_namespaceObject.withSelect)(
    (select, { clientId, rootClientId, shouldDirectInsert = true }) => {
      const {
        getBlockRootClientId,
        hasInserterItems,
        getAllowedBlocks,
        getDirectInsertBlock
      } = select(store);
      const { getBlockVariations } = select(external_wp_blocks_namespaceObject.store);
      rootClientId = rootClientId || getBlockRootClientId(clientId) || void 0;
      const allowedBlocks = getAllowedBlocks(rootClientId);
      const directInsertBlock = shouldDirectInsert && getDirectInsertBlock(rootClientId);
      const hasSingleBlockType = allowedBlocks?.length === 1 && getBlockVariations(allowedBlocks[0].name, "inserter")?.length === 0;
      let allowedBlockType = false;
      if (hasSingleBlockType) {
        allowedBlockType = allowedBlocks[0];
      }
      return {
        hasItems: hasInserterItems(rootClientId),
        hasSingleBlockType,
        blockTitle: allowedBlockType ? allowedBlockType.title : "",
        allowedBlockType,
        directInsertBlock,
        rootClientId
      };
    }
  ),
  (0,external_wp_data_namespaceObject.withDispatch)((dispatch, ownProps, { select }) => {
    return {
      insertOnlyAllowedBlock() {
        const {
          rootClientId,
          clientId,
          isAppender,
          hasSingleBlockType,
          allowedBlockType,
          directInsertBlock,
          onSelectOrClose,
          selectBlockOnInsert
        } = ownProps;
        if (!hasSingleBlockType && !directInsertBlock) {
          return;
        }
        function getAdjacentBlockAttributes(attributesToCopy) {
          const { getBlock, getPreviousBlockClientId } = select(store);
          if (!attributesToCopy || !clientId && !rootClientId) {
            return {};
          }
          const result = {};
          let adjacentAttributes = {};
          if (!clientId) {
            const parentBlock = getBlock(rootClientId);
            if (parentBlock?.innerBlocks?.length) {
              const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];
              if (directInsertBlock && directInsertBlock?.name === lastInnerBlock.name) {
                adjacentAttributes = lastInnerBlock.attributes;
              }
            }
          } else {
            const currentBlock = getBlock(clientId);
            const previousBlock = getBlock(
              getPreviousBlockClientId(clientId)
            );
            if (currentBlock?.name === previousBlock?.name) {
              adjacentAttributes = previousBlock?.attributes || {};
            }
          }
          attributesToCopy.forEach((attribute) => {
            if (adjacentAttributes.hasOwnProperty(attribute)) {
              result[attribute] = adjacentAttributes[attribute];
            }
          });
          return result;
        }
        function getInsertionIndex() {
          const {
            getBlockIndex,
            getBlockSelectionEnd,
            getBlockOrder,
            getBlockRootClientId
          } = select(store);
          if (clientId) {
            return getBlockIndex(clientId);
          }
          const end = getBlockSelectionEnd();
          if (!isAppender && end && getBlockRootClientId(end) === rootClientId) {
            return getBlockIndex(end) + 1;
          }
          return getBlockOrder(rootClientId).length;
        }
        const { insertBlock } = dispatch(store);
        let blockToInsert;
        if (directInsertBlock) {
          const newAttributes = getAdjacentBlockAttributes(
            directInsertBlock.attributesToCopy
          );
          blockToInsert = (0,external_wp_blocks_namespaceObject.createBlock)(directInsertBlock.name, {
            ...directInsertBlock.attributes || {},
            ...newAttributes
          });
        } else {
          blockToInsert = (0,external_wp_blocks_namespaceObject.createBlock)(allowedBlockType.name);
        }
        insertBlock(
          blockToInsert,
          getInsertionIndex(),
          rootClientId,
          selectBlockOnInsert
        );
        if (onSelectOrClose) {
          onSelectOrClose(blockToInsert);
        }
        const message = (0,external_wp_i18n_namespaceObject.sprintf)(
          // translators: %s: the name of the block that has been added
          (0,external_wp_i18n_namespaceObject.__)("%s block added"),
          allowedBlockType.title
        );
        (0,external_wp_a11y_namespaceObject.speak)(message);
      }
    };
  }),
  // The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
  // a way to detect the global Inserter.
  (0,external_wp_compose_namespaceObject.ifCondition)(
    ({ hasItems, isAppender, rootClientId, clientId }) => hasItems || !isAppender && !rootClientId && !clientId
  )
])(Inserter);


;// ./node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js








function button_block_appender_ButtonBlockAppender({ rootClientId, className, onFocus, tabIndex, onSelect }, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inserter_default,
    {
      position: "bottom center",
      rootClientId,
      __experimentalIsQuick: true,
      onSelectOrClose: (...args) => {
        if (onSelect && typeof onSelect === "function") {
          onSelect(...args);
        }
      },
      renderToggle: ({
        onToggle,
        disabled,
        isOpen,
        blockTitle,
        hasSingleBlockType
      }) => {
        const isToggleButton = !hasSingleBlockType;
        const label = hasSingleBlockType ? (0,external_wp_i18n_namespaceObject.sprintf)(
          // translators: %s: the name of the block when there is only one
          (0,external_wp_i18n_namespaceObject._x)(
            "Add %s",
            "directly add the only allowed block"
          ),
          blockTitle
        ) : (0,external_wp_i18n_namespaceObject._x)(
          "Add block",
          "Generic label for block inserter button"
        );
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            ref,
            onFocus,
            tabIndex,
            className: dist_clsx(
              className,
              "block-editor-button-block-appender"
            ),
            onClick: onToggle,
            "aria-haspopup": isToggleButton ? "true" : void 0,
            "aria-expanded": isToggleButton ? isOpen : void 0,
            disabled,
            label,
            showTooltip: true,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: plus_default })
          }
        );
      },
      isAppender: true
    }
  );
}
const ButtonBlockerAppender = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  external_wp_deprecated_default()(`wp.blockEditor.ButtonBlockerAppender`, {
    alternative: "wp.blockEditor.ButtonBlockAppender",
    since: "5.9"
  });
  return button_block_appender_ButtonBlockAppender(props, ref);
});
var button_block_appender_default = (0,external_wp_element_namespaceObject.forwardRef)(button_block_appender_ButtonBlockAppender);


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/grid-visualizer.js












function GridVisualizer({ clientId, contentRef, parentLayout }) {
  const isDistractionFree = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings().isDistractionFree,
    []
  );
  const gridElement = useBlockElement(clientId);
  if (isDistractionFree || !gridElement) {
    return null;
  }
  const isManualGrid = parentLayout?.isManualPlacement && window.__experimentalEnableGridInteractivity;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    GridVisualizerGrid,
    {
      gridClientId: clientId,
      gridElement,
      isManualGrid,
      ref: contentRef
    }
  );
}
const GridVisualizerGrid = (0,external_wp_element_namespaceObject.forwardRef)(
  ({ gridClientId, gridElement, isManualGrid }, ref) => {
    const [gridInfo, setGridInfo] = (0,external_wp_element_namespaceObject.useState)(
      () => getGridInfo(gridElement)
    );
    const [isDroppingAllowed, setIsDroppingAllowed] = (0,external_wp_element_namespaceObject.useState)(false);
    (0,external_wp_element_namespaceObject.useEffect)(() => {
      const resizeCallback = () => setGridInfo(getGridInfo(gridElement));
      const borderBoxSpy = new window.ResizeObserver(resizeCallback);
      borderBoxSpy.observe(gridElement, { box: "border-box" });
      const contentBoxSpy = new window.ResizeObserver(resizeCallback);
      contentBoxSpy.observe(gridElement);
      return () => {
        borderBoxSpy.disconnect();
        contentBoxSpy.disconnect();
      };
    }, [gridElement]);
    (0,external_wp_element_namespaceObject.useEffect)(() => {
      function onGlobalDrag() {
        setIsDroppingAllowed(true);
      }
      function onGlobalDragEnd() {
        setIsDroppingAllowed(false);
      }
      document.addEventListener("drag", onGlobalDrag);
      document.addEventListener("dragend", onGlobalDragEnd);
      return () => {
        document.removeEventListener("drag", onGlobalDrag);
        document.removeEventListener("dragend", onGlobalDragEnd);
      };
    }, []);
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      cover_default,
      {
        className: dist_clsx("block-editor-grid-visualizer", {
          "is-dropping-allowed": isDroppingAllowed
        }),
        clientId: gridClientId,
        __unstablePopoverSlot: "__unstable-block-tools-after",
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "div",
          {
            ref,
            className: "block-editor-grid-visualizer__grid",
            style: gridInfo.style,
            children: isManualGrid ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              ManualGridVisualizer,
              {
                gridClientId,
                gridInfo
              }
            ) : Array.from({ length: gridInfo.numItems }, (_, i) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              GridVisualizerCell,
              {
                color: gridInfo.currentColor
              },
              i
            ))
          }
        )
      }
    );
  }
);
function ManualGridVisualizer({ gridClientId, gridInfo }) {
  const [highlightedRect, setHighlightedRect] = (0,external_wp_element_namespaceObject.useState)(null);
  const gridItemStyles = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockOrder, getBlockStyles } = unlock(
        select(store)
      );
      const blockOrder = getBlockOrder(gridClientId);
      return getBlockStyles(blockOrder);
    },
    [gridClientId]
  );
  const occupiedRects = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const rects = [];
    for (const style of Object.values(gridItemStyles)) {
      const {
        columnStart,
        rowStart,
        columnSpan = 1,
        rowSpan = 1
      } = style?.layout ?? {};
      if (!columnStart || !rowStart) {
        continue;
      }
      rects.push(
        new GridRect({
          columnStart,
          rowStart,
          columnSpan,
          rowSpan
        })
      );
    }
    return rects;
  }, [gridItemStyles]);
  return range(1, gridInfo.numRows).map(
    (row) => range(1, gridInfo.numColumns).map((column) => {
      const isCellOccupied = occupiedRects.some(
        (rect) => rect.contains(column, row)
      );
      const isHighlighted = highlightedRect?.contains(column, row) ?? false;
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        GridVisualizerCell,
        {
          color: gridInfo.currentColor,
          className: isHighlighted && "is-highlighted",
          children: isCellOccupied ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            GridVisualizerDropZone,
            {
              column,
              row,
              gridClientId,
              gridInfo,
              setHighlightedRect
            }
          ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            GridVisualizerAppender,
            {
              column,
              row,
              gridClientId,
              gridInfo,
              setHighlightedRect
            }
          )
        },
        `${row}-${column}`
      );
    })
  );
}
function GridVisualizerCell({ color, children, className }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      className: dist_clsx(
        "block-editor-grid-visualizer__cell",
        className
      ),
      style: {
        boxShadow: `inset 0 0 0 1px color-mix(in srgb, ${color} 20%, #0000)`,
        color
      },
      children
    }
  );
}
function useGridVisualizerDropZone(column, row, gridClientId, gridInfo, setHighlightedRect) {
  const {
    getBlockAttributes,
    getBlockRootClientId,
    canInsertBlockType,
    getBlockName
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const {
    updateBlockAttributes,
    moveBlocksToPosition,
    __unstableMarkNextChangeAsNotPersistent
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
    gridClientId,
    gridInfo.numColumns
  );
  return useDropZoneWithValidation({
    validateDrag(srcClientId) {
      const blockName = getBlockName(srcClientId);
      if (!canInsertBlockType(blockName, gridClientId)) {
        return false;
      }
      const attributes = getBlockAttributes(srcClientId);
      const rect = new GridRect({
        columnStart: column,
        rowStart: row,
        columnSpan: attributes.style?.layout?.columnSpan,
        rowSpan: attributes.style?.layout?.rowSpan
      });
      const isInBounds = new GridRect({
        columnSpan: gridInfo.numColumns,
        rowSpan: gridInfo.numRows
      }).containsRect(rect);
      return isInBounds;
    },
    onDragEnter(srcClientId) {
      const attributes = getBlockAttributes(srcClientId);
      setHighlightedRect(
        new GridRect({
          columnStart: column,
          rowStart: row,
          columnSpan: attributes.style?.layout?.columnSpan,
          rowSpan: attributes.style?.layout?.rowSpan
        })
      );
    },
    onDragLeave() {
      setHighlightedRect(
        (prevHighlightedRect) => prevHighlightedRect?.columnStart === column && prevHighlightedRect?.rowStart === row ? null : prevHighlightedRect
      );
    },
    onDrop(srcClientId) {
      setHighlightedRect(null);
      const attributes = getBlockAttributes(srcClientId);
      updateBlockAttributes(srcClientId, {
        style: {
          ...attributes.style,
          layout: {
            ...attributes.style?.layout,
            columnStart: column,
            rowStart: row
          }
        }
      });
      __unstableMarkNextChangeAsNotPersistent();
      moveBlocksToPosition(
        [srcClientId],
        getBlockRootClientId(srcClientId),
        gridClientId,
        getNumberOfBlocksBeforeCell(column, row)
      );
    }
  });
}
function GridVisualizerDropZone({
  column,
  row,
  gridClientId,
  gridInfo,
  setHighlightedRect
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      className: "block-editor-grid-visualizer__drop-zone",
      ref: useGridVisualizerDropZone(
        column,
        row,
        gridClientId,
        gridInfo,
        setHighlightedRect
      )
    }
  );
}
function GridVisualizerAppender({
  column,
  row,
  gridClientId,
  gridInfo,
  setHighlightedRect
}) {
  const {
    updateBlockAttributes,
    moveBlocksToPosition,
    __unstableMarkNextChangeAsNotPersistent
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
    gridClientId,
    gridInfo.numColumns
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    button_block_appender_default,
    {
      rootClientId: gridClientId,
      className: "block-editor-grid-visualizer__appender",
      ref: useGridVisualizerDropZone(
        column,
        row,
        gridClientId,
        gridInfo,
        setHighlightedRect
      ),
      style: {
        color: gridInfo.currentColor
      },
      onSelect: (block) => {
        if (!block) {
          return;
        }
        updateBlockAttributes(block.clientId, {
          style: {
            layout: {
              columnStart: column,
              rowStart: row
            }
          }
        });
        __unstableMarkNextChangeAsNotPersistent();
        moveBlocksToPosition(
          [block.clientId],
          gridClientId,
          gridClientId,
          getNumberOfBlocksBeforeCell(column, row)
        );
      }
    }
  );
}
function useDropZoneWithValidation({
  validateDrag,
  onDragEnter,
  onDragLeave,
  onDrop
}) {
  const { getDraggedBlockClientIds } = (0,external_wp_data_namespaceObject.useSelect)(store);
  return (0,external_wp_compose_namespaceObject.__experimentalUseDropZone)({
    onDragEnter() {
      const [srcClientId] = getDraggedBlockClientIds();
      if (srcClientId && validateDrag(srcClientId)) {
        onDragEnter(srcClientId);
      }
    },
    onDragLeave() {
      onDragLeave();
    },
    onDrop() {
      const [srcClientId] = getDraggedBlockClientIds();
      if (srcClientId && validateDrag(srcClientId)) {
        onDrop(srcClientId);
      }
    }
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/grid-item-resizer.js






function GridItemResizer({
  clientId,
  bounds,
  onChange,
  parentLayout
}) {
  const blockElement = useBlockElement(clientId);
  const rootBlockElement = blockElement?.parentElement;
  const { isManualPlacement } = parentLayout;
  if (!blockElement || !rootBlockElement) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    GridItemResizerInner,
    {
      clientId,
      bounds,
      blockElement,
      rootBlockElement,
      onChange,
      isManualGrid: isManualPlacement && window.__experimentalEnableGridInteractivity
    }
  );
}
function GridItemResizerInner({
  clientId,
  bounds,
  blockElement,
  rootBlockElement,
  onChange,
  isManualGrid
}) {
  const [resizeDirection, setResizeDirection] = (0,external_wp_element_namespaceObject.useState)(null);
  const [enableSide, setEnableSide] = (0,external_wp_element_namespaceObject.useState)({
    top: false,
    bottom: false,
    left: false,
    right: false
  });
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const observer = new window.ResizeObserver(() => {
      const blockClientRect = blockElement.getBoundingClientRect();
      const rootBlockClientRect = rootBlockElement.getBoundingClientRect();
      setEnableSide({
        top: blockClientRect.top > rootBlockClientRect.top,
        bottom: blockClientRect.bottom < rootBlockClientRect.bottom,
        left: blockClientRect.left > rootBlockClientRect.left,
        right: blockClientRect.right < rootBlockClientRect.right
      });
    });
    observer.observe(blockElement);
    return () => observer.disconnect();
  }, [blockElement, rootBlockElement]);
  const justification = {
    right: "left",
    left: "right"
  };
  const alignment = {
    top: "flex-end",
    bottom: "flex-start"
  };
  const styles = {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    ...justification[resizeDirection] && {
      justifyContent: justification[resizeDirection]
    },
    ...alignment[resizeDirection] && {
      alignItems: alignment[resizeDirection]
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    cover_default,
    {
      className: "block-editor-grid-item-resizer",
      clientId,
      __unstablePopoverSlot: "__unstable-block-tools-after",
      additionalStyles: styles,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ResizableBox,
        {
          className: "block-editor-grid-item-resizer__box",
          size: {
            width: "100%",
            height: "100%"
          },
          enable: {
            bottom: enableSide.bottom,
            bottomLeft: false,
            bottomRight: false,
            left: enableSide.left,
            right: enableSide.right,
            top: enableSide.top,
            topLeft: false,
            topRight: false
          },
          bounds,
          boundsByDirection: true,
          onPointerDown: ({ target, pointerId }) => {
            target.setPointerCapture(pointerId);
          },
          onResizeStart: (event, direction) => {
            setResizeDirection(direction);
          },
          onResizeStop: (event, direction, boxElement) => {
            const columnGap = parseFloat(
              utils_getComputedCSS(rootBlockElement, "column-gap")
            );
            const rowGap = parseFloat(
              utils_getComputedCSS(rootBlockElement, "row-gap")
            );
            const gridColumnTracks = getGridTracks(
              utils_getComputedCSS(
                rootBlockElement,
                "grid-template-columns"
              ),
              columnGap
            );
            const gridRowTracks = getGridTracks(
              utils_getComputedCSS(
                rootBlockElement,
                "grid-template-rows"
              ),
              rowGap
            );
            const rect = new window.DOMRect(
              blockElement.offsetLeft + boxElement.offsetLeft,
              blockElement.offsetTop + boxElement.offsetTop,
              boxElement.offsetWidth,
              boxElement.offsetHeight
            );
            const columnStart = getClosestTrack(gridColumnTracks, rect.left) + 1;
            const rowStart = getClosestTrack(gridRowTracks, rect.top) + 1;
            const columnEnd = getClosestTrack(gridColumnTracks, rect.right, "end") + 1;
            const rowEnd = getClosestTrack(gridRowTracks, rect.bottom, "end") + 1;
            onChange({
              columnSpan: columnEnd - columnStart + 1,
              rowSpan: rowEnd - rowStart + 1,
              columnStart: isManualGrid ? columnStart : void 0,
              rowStart: isManualGrid ? rowStart : void 0
            });
          }
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/chevron-up.js


var chevron_up_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/chevron-down.js


var chevron_down_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/grid-item-movers.js










function GridItemMovers({
  layout,
  parentLayout,
  onChange,
  gridClientId,
  blockClientId
}) {
  const { moveBlocksToPosition, __unstableMarkNextChangeAsNotPersistent } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const columnStart = layout?.columnStart ?? 1;
  const rowStart = layout?.rowStart ?? 1;
  const columnSpan = layout?.columnSpan ?? 1;
  const rowSpan = layout?.rowSpan ?? 1;
  const columnEnd = columnStart + columnSpan - 1;
  const rowEnd = rowStart + rowSpan - 1;
  const columnCount = parentLayout?.columnCount;
  const rowCount = parentLayout?.rowCount;
  const getNumberOfBlocksBeforeCell = useGetNumberOfBlocksBeforeCell(
    gridClientId,
    columnCount
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "parent", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.ToolbarGroup, { className: "block-editor-grid-item-mover__move-button-container", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-grid-item-mover__move-horizontal-button-container is-left", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridItemMover,
      {
        icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right_default : chevron_left_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Move left"),
        description: (0,external_wp_i18n_namespaceObject.__)("Move left"),
        isDisabled: columnStart <= 1,
        onClick: () => {
          onChange({
            columnStart: columnStart - 1
          });
          __unstableMarkNextChangeAsNotPersistent();
          moveBlocksToPosition(
            [blockClientId],
            gridClientId,
            gridClientId,
            getNumberOfBlocksBeforeCell(
              columnStart - 1,
              rowStart
            )
          );
        }
      }
    ) }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-grid-item-mover__move-vertical-button-container", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        GridItemMover,
        {
          className: "is-up-button",
          icon: chevron_up_default,
          label: (0,external_wp_i18n_namespaceObject.__)("Move up"),
          description: (0,external_wp_i18n_namespaceObject.__)("Move up"),
          isDisabled: rowStart <= 1,
          onClick: () => {
            onChange({
              rowStart: rowStart - 1
            });
            __unstableMarkNextChangeAsNotPersistent();
            moveBlocksToPosition(
              [blockClientId],
              gridClientId,
              gridClientId,
              getNumberOfBlocksBeforeCell(
                columnStart,
                rowStart - 1
              )
            );
          }
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        GridItemMover,
        {
          className: "is-down-button",
          icon: chevron_down_default,
          label: (0,external_wp_i18n_namespaceObject.__)("Move down"),
          description: (0,external_wp_i18n_namespaceObject.__)("Move down"),
          isDisabled: rowCount && rowEnd >= rowCount,
          onClick: () => {
            onChange({
              rowStart: rowStart + 1
            });
            __unstableMarkNextChangeAsNotPersistent();
            moveBlocksToPosition(
              [blockClientId],
              gridClientId,
              gridClientId,
              getNumberOfBlocksBeforeCell(
                columnStart,
                rowStart + 1
              )
            );
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-grid-item-mover__move-horizontal-button-container is-right", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridItemMover,
      {
        icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_default : chevron_right_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Move right"),
        description: (0,external_wp_i18n_namespaceObject.__)("Move right"),
        isDisabled: columnCount && columnEnd >= columnCount,
        onClick: () => {
          onChange({
            columnStart: columnStart + 1
          });
          __unstableMarkNextChangeAsNotPersistent();
          moveBlocksToPosition(
            [blockClientId],
            gridClientId,
            gridClientId,
            getNumberOfBlocksBeforeCell(
              columnStart + 1,
              rowStart
            )
          );
        }
      }
    ) })
  ] }) });
}
function GridItemMover({
  className,
  icon,
  label,
  isDisabled,
  onClick,
  description
}) {
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(GridItemMover);
  const descriptionId = `block-editor-grid-item-mover-button__description-${instanceId}`;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        className: dist_clsx(
          "block-editor-grid-item-mover-button",
          className
        ),
        icon,
        label,
        "aria-describedby": descriptionId,
        onClick: isDisabled ? null : onClick,
        disabled: isDisabled,
        accessibleWhenDisabled: true
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: description })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/layout-child.js








const LAYOUT_CHILD_BLOCK_PROPS_REFERENCE = {};
function useBlockPropsChildLayoutStyles({ style }) {
  const shouldRenderChildLayoutStyles = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    return !select(store).getSettings().disableLayoutStyles;
  });
  const layout = style?.layout ?? {};
  const {
    selfStretch,
    flexSize,
    columnStart,
    rowStart,
    columnSpan,
    rowSpan
  } = layout;
  const parentLayout = useLayout() || {};
  const { columnCount, minimumColumnWidth } = parentLayout;
  const id = (0,external_wp_compose_namespaceObject.useInstanceId)(LAYOUT_CHILD_BLOCK_PROPS_REFERENCE);
  const selector = `.wp-container-content-${id}`;
  if (false) {}
  let css = "";
  if (shouldRenderChildLayoutStyles) {
    if (selfStretch === "fixed" && flexSize) {
      css = `${selector} {
				flex-basis: ${flexSize};
				box-sizing: border-box;
			}`;
    } else if (selfStretch === "fill") {
      css = `${selector} {
				flex-grow: 1;
			}`;
    } else if (columnStart && columnSpan) {
      css = `${selector} {
				grid-column: ${columnStart} / span ${columnSpan};
			}`;
    } else if (columnStart) {
      css = `${selector} {
				grid-column: ${columnStart};
			}`;
    } else if (columnSpan) {
      css = `${selector} {
				grid-column: span ${columnSpan};
			}`;
    }
    if (rowStart && rowSpan) {
      css += `${selector} {
				grid-row: ${rowStart} / span ${rowSpan};
			}`;
    } else if (rowStart) {
      css += `${selector} {
				grid-row: ${rowStart};
			}`;
    } else if (rowSpan) {
      css += `${selector} {
				grid-row: span ${rowSpan};
			}`;
    }
    if ((columnSpan || columnStart) && (minimumColumnWidth || !columnCount)) {
      let parentColumnValue = parseFloat(minimumColumnWidth);
      if (isNaN(parentColumnValue)) {
        parentColumnValue = 12;
      }
      let parentColumnUnit = minimumColumnWidth?.replace(
        parentColumnValue,
        ""
      );
      if (!["px", "rem", "em"].includes(parentColumnUnit)) {
        parentColumnUnit = "rem";
      }
      let numColsToBreakAt = 2;
      if (columnSpan && columnStart) {
        numColsToBreakAt = columnSpan + columnStart - 1;
      } else if (columnSpan) {
        numColsToBreakAt = columnSpan;
      } else {
        numColsToBreakAt = columnStart;
      }
      const defaultGapValue = parentColumnUnit === "px" ? 24 : 1.5;
      const containerQueryValue = numColsToBreakAt * parentColumnValue + (numColsToBreakAt - 1) * defaultGapValue;
      const minimumContainerQueryValue = parentColumnValue * 2 + defaultGapValue - 1;
      const gridColumnValue = columnSpan && columnSpan > 1 ? "1/-1" : "auto";
      css += `@container (max-width: ${Math.max(
        containerQueryValue,
        minimumContainerQueryValue
      )}${parentColumnUnit}) {
				${selector} {
					grid-column: ${gridColumnValue};
					grid-row: auto;
				}
			}`;
    }
  }
  useStyleOverride({ css });
  if (!css) {
    return;
  }
  return { className: `wp-container-content-${id}` };
}
function ChildLayoutControlsPure({ clientId, style, setAttributes }) {
  const parentLayout = useLayout() || {};
  const {
    type: parentLayoutType = "default",
    allowSizingOnChildren = false,
    isManualPlacement
  } = parentLayout;
  if (parentLayoutType !== "grid") {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    GridTools,
    {
      clientId,
      style,
      setAttributes,
      allowSizingOnChildren,
      isManualPlacement,
      parentLayout
    }
  );
}
function GridTools({
  clientId,
  style,
  setAttributes,
  allowSizingOnChildren,
  isManualPlacement,
  parentLayout
}) {
  const { rootClientId, isVisible } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockRootClientId,
        getBlockEditingMode,
        getTemplateLock
      } = select(store);
      const _rootClientId = getBlockRootClientId(clientId);
      if (getTemplateLock(_rootClientId) || getBlockEditingMode(_rootClientId) !== "default") {
        return {
          rootClientId: _rootClientId,
          isVisible: false
        };
      }
      return {
        rootClientId: _rootClientId,
        isVisible: true
      };
    },
    [clientId]
  );
  const [resizerBounds, setResizerBounds] = (0,external_wp_element_namespaceObject.useState)();
  if (!isVisible) {
    return null;
  }
  function updateLayout(layout) {
    setAttributes({
      style: {
        ...style,
        layout: {
          ...style?.layout,
          ...layout
        }
      }
    });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridVisualizer,
      {
        clientId: rootClientId,
        contentRef: setResizerBounds,
        parentLayout
      }
    ),
    allowSizingOnChildren && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridItemResizer,
      {
        clientId,
        bounds: resizerBounds,
        onChange: updateLayout,
        parentLayout
      }
    ),
    isManualPlacement && window.__experimentalEnableGridInteractivity && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      GridItemMovers,
      {
        layout: style?.layout,
        parentLayout,
        onChange: updateLayout,
        gridClientId: rootClientId,
        blockClientId: clientId
      }
    )
  ] });
}
var layout_child_default = {
  useBlockProps: useBlockPropsChildLayoutStyles,
  edit: ChildLayoutControlsPure,
  attributeKeys: ["style"],
  hasSupport() {
    return true;
  }
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/content-lock-ui.js








function ContentLockControlsPure({ clientId }) {
  const { templateLock, isLockedByParent, isEditingAsBlocks } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getContentLockingParent,
        getTemplateLock,
        getTemporarilyEditingAsBlocks
      } = unlock(select(store));
      return {
        templateLock: getTemplateLock(clientId),
        isLockedByParent: !!getContentLockingParent(clientId),
        isEditingAsBlocks: getTemporarilyEditingAsBlocks() === clientId
      };
    },
    [clientId]
  );
  const { stopEditingAsBlocks } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const isContentLocked = !isLockedByParent && templateLock === "contentOnly";
  const stopEditingAsBlockCallback = (0,external_wp_element_namespaceObject.useCallback)(() => {
    stopEditingAsBlocks(clientId);
  }, [clientId, stopEditingAsBlocks]);
  if (!isContentLocked && !isEditingAsBlocks) {
    return null;
  }
  const showStopEditingAsBlocks = isEditingAsBlocks && !isContentLocked;
  return showStopEditingAsBlocks && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "other", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarButton, { onClick: stopEditingAsBlockCallback, children: (0,external_wp_i18n_namespaceObject.__)("Done") }) });
}
var content_lock_ui_default = {
  edit: ContentLockControlsPure,
  hasSupport() {
    return true;
  }
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/metadata.js


const META_ATTRIBUTE_NAME = "metadata";
function addMetaAttribute(blockTypeSettings) {
  if (blockTypeSettings?.attributes?.[META_ATTRIBUTE_NAME]?.type) {
    return blockTypeSettings;
  }
  blockTypeSettings.attributes = {
    ...blockTypeSettings.attributes,
    [META_ATTRIBUTE_NAME]: {
      type: "object"
    }
  };
  return blockTypeSettings;
}
function metadata_addTransforms(result, source, index, results) {
  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  }
  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  }
  if (results.length > 1 && source.length > 1 && results.length !== source.length) {
    return result;
  }
  const sourceMetadata = source[index]?.attributes?.metadata;
  if (!sourceMetadata) {
    return result;
  }
  const preservedMetadata = {};
  if (sourceMetadata.noteId && !result.attributes?.metadata?.noteId) {
    preservedMetadata.noteId = sourceMetadata.noteId;
  }
  if (sourceMetadata.name && !result.attributes?.metadata?.name && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(result.name, "renaming", true)) {
    preservedMetadata.name = sourceMetadata.name;
  }
  if (sourceMetadata.blockVisibility !== void 0 && !result.attributes?.metadata?.blockVisibility && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(result.name, "visibility", true)) {
    preservedMetadata.blockVisibility = sourceMetadata.blockVisibility;
  }
  if (Object.keys(preservedMetadata).length > 0) {
    return {
      ...result,
      attributes: {
        ...result.attributes,
        metadata: {
          ...result.attributes.metadata,
          ...preservedMetadata
        }
      }
    };
  }
  return result;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/metadata/addMetaAttribute",
  addMetaAttribute
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.switchToBlockType.transformedBlock",
  "core/metadata/addTransforms",
  metadata_addTransforms
);


;// ./node_modules/@wordpress/block-editor/build-module/hooks/block-hooks.js








const block_hooks_EMPTY_OBJECT = {};
function BlockHooksControlPure({
  name,
  clientId,
  metadata: { ignoredHookedBlocks = [] } = {}
}) {
  const blockTypes = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(external_wp_blocks_namespaceObject.store).getBlockTypes(),
    []
  );
  const hookedBlocksForCurrentBlock = (0,external_wp_element_namespaceObject.useMemo)(
    () => blockTypes?.filter(
      ({ name: blockName, blockHooks }) => blockHooks && name in blockHooks || ignoredHookedBlocks.includes(blockName)
    ),
    [blockTypes, name, ignoredHookedBlocks]
  );
  const hookedBlockClientIds = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlocks, getBlockRootClientId: getBlockRootClientId2, getGlobalBlockCount } = select(store);
      const rootClientId = getBlockRootClientId2(clientId);
      const _hookedBlockClientIds = hookedBlocksForCurrentBlock.reduce(
        (clientIds, block) => {
          if (getGlobalBlockCount(block.name) === 0) {
            return clientIds;
          }
          const relativePosition = block?.blockHooks?.[name];
          let candidates;
          switch (relativePosition) {
            case "before":
            case "after":
              candidates = getBlocks(rootClientId);
              break;
            case "first_child":
            case "last_child":
              candidates = getBlocks(clientId);
              break;
            case void 0:
              candidates = [
                ...getBlocks(rootClientId),
                ...getBlocks(clientId)
              ];
              break;
          }
          const hookedBlock = candidates?.find(
            (candidate) => candidate.name === block.name
          );
          if (hookedBlock) {
            return {
              ...clientIds,
              [block.name]: hookedBlock.clientId
            };
          }
          return clientIds;
        },
        {}
      );
      if (Object.values(_hookedBlockClientIds).length > 0) {
        return _hookedBlockClientIds;
      }
      return block_hooks_EMPTY_OBJECT;
    },
    [hookedBlocksForCurrentBlock, name, clientId]
  );
  const { getBlockIndex, getBlockCount, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { insertBlock, removeBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  if (!hookedBlocksForCurrentBlock.length) {
    return null;
  }
  const groupedHookedBlocks = hookedBlocksForCurrentBlock.reduce(
    (groups, block) => {
      const [namespace] = block.name.split("/");
      if (!groups[namespace]) {
        groups[namespace] = [];
      }
      groups[namespace].push(block);
      return groups;
    },
    {}
  );
  const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
    const blockIndex = getBlockIndex(clientId);
    const innerBlocksLength = getBlockCount(clientId);
    const rootClientId = getBlockRootClientId(clientId);
    switch (relativePosition) {
      case "before":
      case "after":
        insertBlock(
          block,
          relativePosition === "after" ? blockIndex + 1 : blockIndex,
          rootClientId,
          // Insert as a child of the current block's parent
          false
        );
        break;
      case "first_child":
      case "last_child":
        insertBlock(
          block,
          // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
          relativePosition === "first_child" ? 0 : innerBlocksLength,
          clientId,
          // Insert as a child of the current block.
          false
        );
        break;
      case void 0:
        insertBlock(
          block,
          blockIndex + 1,
          rootClientId,
          // Insert as a child of the current block's parent
          false
        );
        break;
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.PanelBody,
    {
      className: "block-editor-hooks__block-hooks",
      title: (0,external_wp_i18n_namespaceObject.__)("Plugins"),
      initialOpen: true,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-hooks__block-hooks-helptext", children: (0,external_wp_i18n_namespaceObject.__)(
          "Manage the inclusion of blocks added automatically by plugins."
        ) }),
        Object.keys(groupedHookedBlocks).map((vendor) => {
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_element_namespaceObject.Fragment, { children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("h3", { children: vendor }),
            groupedHookedBlocks[vendor].map((block) => {
              const checked = block.name in hookedBlockClientIds;
              return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.ToggleControl,
                {
                  __nextHasNoMarginBottom: true,
                  checked,
                  label: block.title,
                  onChange: () => {
                    if (!checked) {
                      const relativePosition = block.blockHooks[name];
                      insertBlockIntoDesignatedLocation(
                        (0,external_wp_blocks_namespaceObject.createBlock)(block.name),
                        relativePosition
                      );
                      return;
                    }
                    removeBlock(
                      hookedBlockClientIds[block.name],
                      false
                    );
                  }
                },
                block.title
              );
            })
          ] }, vendor);
        })
      ]
    }
  ) });
}
var block_hooks_default = {
  edit: BlockHooksControlPure,
  attributeKeys: ["metadata"],
  hasSupport() {
    return true;
  }
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/block-bindings.js














const { Menu } = unlock(external_wp_components_namespaceObject.privateApis);
const block_bindings_EMPTY_OBJECT = {};
const getAttributeType = (blockName, attribute) => {
  const _attributeType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName).attributes?.[attribute]?.type;
  return _attributeType === "rich-text" ? "string" : _attributeType;
};
const block_bindings_useToolsPanelDropdownMenuProps = () => {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  return !isMobile ? {
    popoverProps: {
      placement: "left-start",
      // For non-mobile, inner sidebar width (248px) - button width (24px) - border (1px) + padding (16px) + spacing (20px)
      offset: 259
    }
  } : {};
};
function BlockBindingsPanelMenuContent({ attribute, binding, sources }) {
  const { clientId } = useBlockEditContext();
  const { updateBlockBindings } = useBlockBindingsUtils();
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context_default);
  const { attributeType, select } = (0,external_wp_data_namespaceObject.useSelect)(
    (_select) => {
      const { name: blockName } = _select(store).getBlock(clientId);
      return {
        attributeType: getAttributeType(blockName, attribute),
        select: _select
      };
    },
    [clientId, attribute]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: Object.entries(sources).map(([sourceKey, source]) => {
    const sourceDataItems = source.data?.filter(
      (item) => item?.type === attributeType
    );
    const noItemsAvailable = !sourceDataItems || sourceDataItems.length === 0;
    if (noItemsAvailable) {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      Menu,
      {
        placement: isMobile ? "bottom-start" : "left-start",
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.SubmenuTriggerItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.ItemLabel, { children: source.label }) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.Popover, { gutter: 8, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.Group, { children: sourceDataItems.map((item) => {
            const itemBindings = {
              source: sourceKey,
              args: item?.args || {
                key: item.key
              }
            };
            let values = {};
            try {
              values = source.getValues({
                select,
                context: blockContext,
                bindings: {
                  [attribute]: itemBindings
                }
              });
            } catch (e) {
            }
            return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
              Menu.CheckboxItem,
              {
                onChange: () => {
                  const isCurrentlySelected = es6_default()(
                    binding?.args,
                    item.args
                  ) ?? // Deprecate key dependency in 7.0.
                  item.key === binding?.args?.key;
                  if (isCurrentlySelected) {
                    updateBlockBindings({
                      [attribute]: void 0
                    });
                  } else {
                    updateBlockBindings({
                      [attribute]: itemBindings
                    });
                  }
                },
                name: attribute + "-binding",
                value: values[attribute],
                checked: es6_default()(
                  binding?.args,
                  item.args
                ) ?? // Deprecate key dependency in 7.0.
                item.key === binding?.args?.key,
                children: [
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.ItemLabel, { children: item?.label }),
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.ItemHelpText, { children: values[attribute] })
                ]
              },
              sourceKey + JSON.stringify(
                item.args
              ) || item.key
            );
          }) }) })
        ]
      },
      sourceKey
    );
  }) });
}
function BlockBindingsAttribute({ attribute, binding, sources, blockName }) {
  const { source: sourceName, args } = binding || {};
  const source = sources?.[sourceName];
  let displayText;
  let isValid = true;
  const isNotBound = binding === void 0;
  if (isNotBound) {
    const attributeType = getAttributeType(blockName, attribute);
    const hasCompatibleSources = Object.values(sources).some(
      (src) => src.data?.some((item) => item?.type === attributeType)
    );
    if (!hasCompatibleSources) {
      displayText = (0,external_wp_i18n_namespaceObject.__)("No sources available");
    } else {
      displayText = (0,external_wp_i18n_namespaceObject.__)("Not connected");
    }
    isValid = true;
  } else if (!source) {
    isValid = false;
    displayText = (0,external_wp_i18n_namespaceObject.__)("Source not registered");
    if (Object.keys(sources).length === 0) {
      displayText = (0,external_wp_i18n_namespaceObject.__)("No sources available");
    }
  } else {
    displayText = source.data?.find((item) => es6_default()(item.args, args))?.label || source.label || sourceName;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { className: "block-editor-bindings__item", spacing: 0, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { truncate: true, children: attribute }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.__experimentalText,
      {
        truncate: true,
        variant: isValid ? "muted" : void 0,
        isDestructive: !isValid,
        children: displayText
      }
    )
  ] });
}
function ReadOnlyBlockBindingsPanelItem({
  attribute,
  binding,
  sources,
  blockName
}) {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalToolsPanelItem, { hasValue: () => !!binding, label: attribute, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.TriggerButton, { render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalItem, {}), disabled: true, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockBindingsAttribute,
    {
      attribute,
      binding,
      sources,
      blockName
    }
  ) }) }) });
}
function EditableBlockBindingsPanelItem({
  attribute,
  binding,
  sources,
  blockName
}) {
  const { updateBlockBindings } = useBlockBindingsUtils();
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      hasValue: () => !!binding,
      label: attribute,
      onDeselect: () => {
        updateBlockBindings({
          [attribute]: void 0
        });
      },
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(Menu, { placement: isMobile ? "bottom-start" : "left-start", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.TriggerButton, { render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalItem, {}), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          BlockBindingsAttribute,
          {
            attribute,
            binding,
            sources,
            blockName
          }
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Menu.Popover, { gutter: isMobile ? 8 : 36, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          BlockBindingsPanelMenuContent,
          {
            attribute,
            binding,
            sources
          }
        ) })
      ] })
    }
  );
}
const BlockBindingsPanel = ({ name: blockName, metadata }) => {
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context_default);
  const { removeAllBlockBindings } = useBlockBindingsUtils();
  const dropdownMenuProps = block_bindings_useToolsPanelDropdownMenuProps();
  const _sources = {};
  const { sources, canUpdateBlockBindings, bindableAttributes } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { __experimentalBlockBindingsSupportedAttributes } = select(store).getSettings();
      const _bindableAttributes = __experimentalBlockBindingsSupportedAttributes?.[blockName];
      if (!_bindableAttributes || _bindableAttributes.length === 0) {
        return block_bindings_EMPTY_OBJECT;
      }
      const registeredSources = (0,external_wp_blocks_namespaceObject.getBlockBindingsSources)();
      Object.entries(registeredSources).forEach(
        ([
          sourceName,
          { getFieldsList, usesContext, label, getValues }
        ]) => {
          const context = {};
          if (usesContext?.length) {
            for (const key of usesContext) {
              context[key] = blockContext[key];
            }
          }
          if (getFieldsList) {
            const fieldsListResult = getFieldsList({
              select,
              context
            });
            _sources[sourceName] = {
              data: fieldsListResult || [],
              label,
              getValues
            };
          } else {
            _sources[sourceName] = {
              data: [],
              label,
              getValues
            };
          }
        }
      );
      return {
        sources: Object.values(_sources).length > 0 ? _sources : block_bindings_EMPTY_OBJECT,
        canUpdateBlockBindings: select(store).getSettings().canUpdateBlockBindings,
        bindableAttributes: _bindableAttributes
      };
    },
    [blockContext, blockName]
  );
  if (!bindableAttributes || bindableAttributes.length === 0) {
    return null;
  }
  const { bindings } = metadata || {};
  const hasCompatibleData = Object.values(sources).some(
    (source) => source.data && source.data.length > 0
  );
  const readOnly = !canUpdateBlockBindings || !hasCompatibleData;
  if (bindings === void 0 && !hasCompatibleData) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default, { group: "bindings", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Attributes"),
      resetAll: () => {
        removeAllBlockBindings();
      },
      dropdownMenuProps,
      className: "block-editor-bindings__panel",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalItemGroup, { isBordered: true, isSeparated: true, children: bindableAttributes.map((attribute) => {
          const binding = bindings?.[attribute];
          const attributeType = getAttributeType(
            blockName,
            attribute
          );
          const hasCompatibleDataForAttribute = Object.values(
            sources
          ).some(
            (source) => source.data?.some(
              (item) => item?.type === attributeType
            )
          );
          const isAttributeReadOnly = readOnly || !hasCompatibleDataForAttribute;
          return isAttributeReadOnly ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ReadOnlyBlockBindingsPanelItem,
            {
              attribute,
              binding,
              sources,
              blockName
            },
            attribute
          ) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            EditableBlockBindingsPanelItem,
            {
              attribute,
              binding,
              sources,
              blockName
            },
            attribute
          );
        }) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { as: "div", variant: "muted", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)(
          "Attributes connected to custom fields or other dynamic data."
        ) }) })
      ]
    }
  ) });
};
var block_bindings_default = {
  edit: BlockBindingsPanel,
  attributeKeys: ["metadata"],
  hasSupport(name) {
    return ![
      "core/post-date",
      "core/navigation-link",
      "core/navigation-submenu"
    ].includes(name);
  }
};


;// ./node_modules/@wordpress/block-editor/build-module/hooks/block-renaming.js


function addLabelCallback(settings) {
  if (settings.__experimentalLabel) {
    return settings;
  }
  const supportsBlockNaming = (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
    settings,
    "renaming",
    true
    // default value
  );
  if (supportsBlockNaming) {
    settings.__experimentalLabel = (attributes, { context }) => {
      const { metadata } = attributes;
      if (context === "list-view" && metadata?.name) {
        return metadata.name;
      }
    };
  }
  return settings;
}
(0,external_wp_hooks_namespaceObject.addFilter)(
  "blocks.registerBlockType",
  "core/metadata/addLabelCallback",
  addLabelCallback
);


;// ./node_modules/@wordpress/block-editor/build-module/components/grid/use-grid-layout-sync.js






function useGridLayoutSync({ clientId: gridClientId }) {
  const { gridLayout, blockOrder, selectedBlockLayout } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes: getBlockAttributes2, getBlockOrder } = select(store);
      const selectedBlock = select(store).getSelectedBlock();
      return {
        gridLayout: getBlockAttributes2(gridClientId).layout ?? {},
        blockOrder: getBlockOrder(gridClientId),
        selectedBlockLayout: selectedBlock?.attributes.style?.layout
      };
    },
    [gridClientId]
  );
  const { getBlockAttributes, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { updateBlockAttributes, __unstableMarkNextChangeAsNotPersistent } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const selectedBlockRect = (0,external_wp_element_namespaceObject.useMemo)(
    () => selectedBlockLayout ? new GridRect(selectedBlockLayout) : null,
    [selectedBlockLayout]
  );
  const previouslySelectedBlockRect = (0,external_wp_compose_namespaceObject.usePrevious)(selectedBlockRect);
  const previousIsManualPlacement = (0,external_wp_compose_namespaceObject.usePrevious)(
    gridLayout.isManualPlacement
  );
  const previousBlockOrder = (0,external_wp_compose_namespaceObject.usePrevious)(blockOrder);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const updates = {};
    if (gridLayout.isManualPlacement) {
      const occupiedRects = [];
      for (const clientId of blockOrder) {
        const {
          columnStart,
          rowStart,
          columnSpan = 1,
          rowSpan = 1
        } = getBlockAttributes(clientId).style?.layout ?? {};
        if (!columnStart || !rowStart) {
          continue;
        }
        occupiedRects.push(
          new GridRect({
            columnStart,
            rowStart,
            columnSpan,
            rowSpan
          })
        );
      }
      for (const clientId of blockOrder) {
        const attributes = getBlockAttributes(clientId);
        const {
          columnStart,
          rowStart,
          columnSpan = 1,
          rowSpan = 1
        } = attributes.style?.layout ?? {};
        if (columnStart && rowStart) {
          continue;
        }
        const [newColumnStart, newRowStart] = placeBlock(
          occupiedRects,
          gridLayout.columnCount,
          columnSpan,
          rowSpan,
          previouslySelectedBlockRect?.columnEnd,
          previouslySelectedBlockRect?.rowEnd
        );
        occupiedRects.push(
          new GridRect({
            columnStart: newColumnStart,
            rowStart: newRowStart,
            columnSpan,
            rowSpan
          })
        );
        updates[clientId] = {
          style: {
            ...attributes.style,
            layout: {
              ...attributes.style?.layout,
              columnStart: newColumnStart,
              rowStart: newRowStart
            }
          }
        };
      }
      const bottomMostRow = Math.max(
        ...occupiedRects.map((r) => r.rowEnd)
      );
      if (!gridLayout.rowCount || gridLayout.rowCount < bottomMostRow) {
        updates[gridClientId] = {
          layout: {
            ...gridLayout,
            rowCount: bottomMostRow
          }
        };
      }
      for (const clientId of previousBlockOrder ?? []) {
        if (!blockOrder.includes(clientId)) {
          const rootClientId = getBlockRootClientId(clientId);
          if (rootClientId === null) {
            continue;
          }
          const rootAttributes = getBlockAttributes(rootClientId);
          if (rootAttributes?.layout?.type === "grid") {
            continue;
          }
          const attributes = getBlockAttributes(clientId);
          const {
            columnStart,
            rowStart,
            columnSpan,
            rowSpan,
            ...layout
          } = attributes.style?.layout ?? {};
          if (columnStart || rowStart || columnSpan || rowSpan) {
            const hasEmptyLayoutAttribute = Object.keys(layout).length === 0;
            updates[clientId] = setImmutably(
              attributes,
              ["style", "layout"],
              hasEmptyLayoutAttribute ? void 0 : layout
            );
          }
        }
      }
    } else {
      if (previousIsManualPlacement === true) {
        for (const clientId of blockOrder) {
          const attributes = getBlockAttributes(clientId);
          const { columnStart, rowStart, ...layout } = attributes.style?.layout ?? {};
          if (columnStart || rowStart) {
            const hasEmptyLayoutAttribute = Object.keys(layout).length === 0;
            updates[clientId] = setImmutably(
              attributes,
              ["style", "layout"],
              hasEmptyLayoutAttribute ? void 0 : layout
            );
          }
        }
      }
      if (gridLayout.rowCount) {
        updates[gridClientId] = {
          layout: {
            ...gridLayout,
            rowCount: void 0
          }
        };
      }
    }
    if (Object.keys(updates).length) {
      __unstableMarkNextChangeAsNotPersistent();
      updateBlockAttributes(
        Object.keys(updates),
        updates,
        /* uniqueByBlock: */
        true
      );
    }
  }, [
    // Actual deps to sync:
    gridClientId,
    gridLayout,
    previousBlockOrder,
    blockOrder,
    previouslySelectedBlockRect,
    previousIsManualPlacement,
    // These won't change, but the linter thinks they might:
    __unstableMarkNextChangeAsNotPersistent,
    getBlockAttributes,
    getBlockRootClientId,
    updateBlockAttributes
  ]);
}
function placeBlock(occupiedRects, gridColumnCount, blockColumnSpan, blockRowSpan, startColumn = 1, startRow = 1) {
  for (let row = startRow; ; row++) {
    for (let column = row === startRow ? startColumn : 1; column <= gridColumnCount; column++) {
      const candidateRect = new GridRect({
        columnStart: column,
        rowStart: row,
        columnSpan: blockColumnSpan,
        rowSpan: blockRowSpan
      });
      if (!occupiedRects.some(
        (r) => r.intersectsRect(candidateRect)
      )) {
        return [column, row];
      }
    }
  }
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/grid-visualizer.js






function GridLayoutSync(props) {
  useGridLayoutSync(props);
}
function grid_visualizer_GridTools({ clientId, layout }) {
  const isVisible = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        isBlockSelected,
        isDraggingBlocks,
        getTemplateLock,
        getBlockEditingMode
      } = select(store);
      if (!isDraggingBlocks() && !isBlockSelected(clientId) || getTemplateLock(clientId) || getBlockEditingMode(clientId) !== "default") {
        return false;
      }
      return true;
    },
    [clientId]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(GridLayoutSync, { clientId }),
    isVisible && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(GridVisualizer, { clientId, parentLayout: layout })
  ] });
}
const addGridVisualizerToBlockEdit = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (BlockEdit) => (props) => {
    if (props.attributes.layout?.type !== "grid") {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockEdit, { ...props }, "edit");
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        grid_visualizer_GridTools,
        {
          clientId: props.clientId,
          layout: props.attributes.layout
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockEdit, { ...props }, "edit")
    ] });
  },
  "addGridVisualizerToBlockEdit"
);
(0,external_wp_hooks_namespaceObject.addFilter)(
  "editor.BlockEdit",
  "core/editor/grid-visualizer",
  addGridVisualizerToBlockEdit
);

;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-border-props.js



function getBorderClassesAndStyles(attributes) {
  const border = attributes.style?.border || {};
  const className = getBorderClasses(attributes);
  return {
    className: className || void 0,
    style: getInlineStyles({ border })
  };
}
function useBorderProps(attributes) {
  const { colors } = useMultipleOriginColorsAndGradients();
  const borderProps = getBorderClassesAndStyles(attributes);
  const { borderColor } = attributes;
  if (borderColor) {
    const borderColorObject = getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    borderProps.style.borderColor = borderColorObject.color;
  }
  return borderProps;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-shadow-props.js

function getShadowClassesAndStyles(attributes) {
  const shadow = attributes.style?.shadow || "";
  return {
    style: getInlineStyles({ shadow })
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-color-props.js






function getColorClassesAndStyles(attributes) {
  const { backgroundColor, textColor, gradient, style } = attributes;
  const backgroundClass = getColorClassName(
    "background-color",
    backgroundColor
  );
  const textClass = getColorClassName("color", textColor);
  const gradientClass = __experimentalGetGradientClass(gradient);
  const hasGradient = gradientClass || style?.color?.gradient;
  const className = dist_clsx(textClass, gradientClass, {
    // Don't apply the background class if there's a gradient.
    [backgroundClass]: !hasGradient && !!backgroundClass,
    "has-text-color": textColor || style?.color?.text,
    "has-background": backgroundColor || style?.color?.background || gradient || style?.color?.gradient,
    "has-link-color": style?.elements?.link?.color
  });
  const colorStyles = style?.color || {};
  const styleProp = getInlineStyles({ color: colorStyles });
  return {
    className: className || void 0,
    style: styleProp
  };
}
function useColorProps(attributes) {
  const { backgroundColor, textColor, gradient } = attributes;
  const [
    userPalette,
    themePalette,
    defaultPalette,
    userGradients,
    themeGradients,
    defaultGradients
  ] = use_settings_useSettings(
    "color.palette.custom",
    "color.palette.theme",
    "color.palette.default",
    "color.gradients.custom",
    "color.gradients.theme",
    "color.gradients.default"
  );
  const colors = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userPalette || [],
      ...themePalette || [],
      ...defaultPalette || []
    ],
    [userPalette, themePalette, defaultPalette]
  );
  const gradients = (0,external_wp_element_namespaceObject.useMemo)(
    () => [
      ...userGradients || [],
      ...themeGradients || [],
      ...defaultGradients || []
    ],
    [userGradients, themeGradients, defaultGradients]
  );
  const colorProps = getColorClassesAndStyles(attributes);
  if (backgroundColor) {
    const backgroundColorObject = getColorObjectByAttributeValues(
      colors,
      backgroundColor
    );
    colorProps.style.backgroundColor = backgroundColorObject.color;
  }
  if (gradient) {
    colorProps.style.background = getGradientValueBySlug(
      gradients,
      gradient
    );
  }
  if (textColor) {
    const textColorObject = getColorObjectByAttributeValues(
      colors,
      textColor
    );
    colorProps.style.color = textColorObject.color;
  }
  return colorProps;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-spacing-props.js

function getSpacingClassesAndStyles(attributes) {
  const { style } = attributes;
  const spacingStyles = style?.spacing || {};
  const styleProp = getInlineStyles({ spacing: spacingStyles });
  return {
    style: styleProp
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-typography-props.js






const { kebabCase: use_typography_props_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
function getTypographyClassesAndStyles(attributes, settings) {
  let typographyStyles = attributes?.style?.typography || {};
  typographyStyles = {
    ...typographyStyles,
    fontSize: getTypographyFontSizeValue(
      { size: attributes?.style?.typography?.fontSize },
      settings
    )
  };
  const style = getInlineStyles({ typography: typographyStyles });
  const fontFamilyClassName = !!attributes?.fontFamily ? `has-${use_typography_props_kebabCase(attributes.fontFamily)}-font-family` : "";
  const textAlignClassName = !!attributes?.style?.typography?.textAlign ? `has-text-align-${attributes?.style?.typography?.textAlign}` : "";
  const className = dist_clsx(
    fontFamilyClassName,
    textAlignClassName,
    getFontSizeClass(attributes?.fontSize)
  );
  return {
    className,
    style
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/use-cached-truthy.js

function useCachedTruthy(value) {
  const [cachedValue, setCachedValue] = (0,external_wp_element_namespaceObject.useState)(value);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (value) {
      setCachedValue(value);
    }
  }, [value]);
  return cachedValue;
}


;// ./node_modules/@wordpress/block-editor/build-module/hooks/index.js






























createBlockEditFilter(
  [
    align_default,
    text_align_default,
    anchor_default,
    custom_class_name_default,
    style_default,
    duotone_default,
    fit_text_default,
    position_default,
    layout_default,
    content_lock_ui_default,
    block_hooks_default,
    block_bindings_default,
    layout_child_default,
    allowed_blocks_default
  ].filter(Boolean)
);
createBlockListBlockFilter([
  align_default,
  text_align_default,
  background_default,
  style_default,
  color_default,
  dimensions_default,
  duotone_default,
  font_family_default,
  font_size_default,
  fit_text_default,
  border_default,
  position_default,
  block_style_variation_default,
  layout_child_default
]);
createBlockSaveFilter([
  align_default,
  text_align_default,
  anchor_default,
  aria_label_default,
  custom_class_name_default,
  border_default,
  fit_text_default,
  color_default,
  style_default,
  font_family_default,
  font_size_default
]);















;// ./node_modules/@wordpress/block-editor/build-module/components/colors/with-colors.js







const { kebabCase: with_colors_kebabCase } = unlock(external_wp_components_namespaceObject.privateApis);
const upperFirst = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join("");
const withCustomColorPalette = (colorsArray) => (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (WrappedComponent) => (props) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { ...props, colors: colorsArray }),
  "withCustomColorPalette"
);
const withEditorColorPalette = () => (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
  (WrappedComponent) => (props) => {
    const [userPalette, themePalette, defaultPalette] = use_settings_useSettings(
      "color.palette.custom",
      "color.palette.theme",
      "color.palette.default"
    );
    const allColors = (0,external_wp_element_namespaceObject.useMemo)(
      () => [
        ...userPalette || [],
        ...themePalette || [],
        ...defaultPalette || []
      ],
      [userPalette, themePalette, defaultPalette]
    );
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(WrappedComponent, { ...props, colors: allColors });
  },
  "withEditorColorPalette"
);
function createColorHOC(colorTypes, withColorPalette) {
  const colorMap = colorTypes.reduce((colorObject, colorType) => {
    return {
      ...colorObject,
      ...typeof colorType === "string" ? { [colorType]: with_colors_kebabCase(colorType) } : colorType
    };
  }, {});
  return (0,external_wp_compose_namespaceObject.compose)([
    withColorPalette,
    (WrappedComponent) => {
      return class extends external_wp_element_namespaceObject.Component {
        constructor(props) {
          super(props);
          this.setters = this.createSetters();
          this.colorUtils = {
            getMostReadableColor: this.getMostReadableColor.bind(this)
          };
          this.state = {};
        }
        getMostReadableColor(colorValue) {
          const { colors } = this.props;
          return getMostReadableColor(colors, colorValue);
        }
        createSetters() {
          return Object.keys(colorMap).reduce(
            (settersAccumulator, colorAttributeName) => {
              const upperFirstColorAttributeName = upperFirst(colorAttributeName);
              const customColorAttributeName = `custom${upperFirstColorAttributeName}`;
              settersAccumulator[`set${upperFirstColorAttributeName}`] = this.createSetColor(
                colorAttributeName,
                customColorAttributeName
              );
              return settersAccumulator;
            },
            {}
          );
        }
        createSetColor(colorAttributeName, customColorAttributeName) {
          return (colorValue) => {
            const colorObject = getColorObjectByColorValue(
              this.props.colors,
              colorValue
            );
            this.props.setAttributes({
              [colorAttributeName]: colorObject && colorObject.slug ? colorObject.slug : void 0,
              [customColorAttributeName]: colorObject && colorObject.slug ? void 0 : colorValue
            });
          };
        }
        static getDerivedStateFromProps({ attributes, colors }, previousState) {
          return Object.entries(colorMap).reduce(
            (newState, [colorAttributeName, colorContext]) => {
              const colorObject = getColorObjectByAttributeValues(
                colors,
                attributes[colorAttributeName],
                attributes[`custom${upperFirst(
                  colorAttributeName
                )}`]
              );
              const previousColorObject = previousState[colorAttributeName];
              const previousColor = previousColorObject?.color;
              if (previousColor === colorObject.color && previousColorObject) {
                newState[colorAttributeName] = previousColorObject;
              } else {
                newState[colorAttributeName] = {
                  ...colorObject,
                  class: getColorClassName(
                    colorContext,
                    colorObject.slug
                  )
                };
              }
              return newState;
            },
            {}
          );
        }
        render() {
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            WrappedComponent,
            {
              ...{
                ...this.props,
                colors: void 0,
                ...this.state,
                ...this.setters,
                colorUtils: this.colorUtils
              }
            }
          );
        }
      };
    }
  ]);
}
function createCustomColorsHOC(colorsArray) {
  return (...colorTypes) => {
    const withColorPalette = withCustomColorPalette(colorsArray);
    return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
      createColorHOC(colorTypes, withColorPalette),
      "withCustomColors"
    );
  };
}
function withColors(...colorTypes) {
  const withColorPalette = withEditorColorPalette();
  return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
    createColorHOC(colorTypes, withColorPalette),
    "withColors"
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/colors/index.js




;// ./node_modules/@wordpress/block-editor/build-module/components/gradients/index.js


;// ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/font-size-picker.js



function font_size_picker_FontSizePicker(props) {
  const [fontSizes, customFontSize] = use_settings_useSettings(
    "typography.fontSizes",
    "typography.customFontSize"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.FontSizePicker,
    {
      ...props,
      fontSizes,
      disableCustomFontSizes: !customFontSize
    }
  );
}
var font_size_picker_default = font_size_picker_FontSizePicker;


;// ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/with-font-sizes.js





const DEFAULT_FONT_SIZES = [];
const with_font_sizes_upperFirst = ([firstLetter, ...rest]) => firstLetter.toUpperCase() + rest.join("");
var with_font_sizes_default = (...fontSizeNames) => {
  const fontSizeAttributeNames = fontSizeNames.reduce(
    (fontSizeAttributeNamesAccumulator, fontSizeAttributeName) => {
      fontSizeAttributeNamesAccumulator[fontSizeAttributeName] = `custom${with_font_sizes_upperFirst(fontSizeAttributeName)}`;
      return fontSizeAttributeNamesAccumulator;
    },
    {}
  );
  return (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
    (0,external_wp_compose_namespaceObject.compose)([
      (0,external_wp_compose_namespaceObject.createHigherOrderComponent)(
        (WrappedComponent) => (props) => {
          const [fontSizes] = use_settings_useSettings("typography.fontSizes");
          return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            WrappedComponent,
            {
              ...props,
              fontSizes: fontSizes || DEFAULT_FONT_SIZES
            }
          );
        },
        "withFontSizes"
      ),
      (WrappedComponent) => {
        return class extends external_wp_element_namespaceObject.Component {
          constructor(props) {
            super(props);
            this.setters = this.createSetters();
            this.state = {};
          }
          createSetters() {
            return Object.entries(fontSizeAttributeNames).reduce(
              (settersAccumulator, [
                fontSizeAttributeName,
                customFontSizeAttributeName
              ]) => {
                const upperFirstFontSizeAttributeName = with_font_sizes_upperFirst(fontSizeAttributeName);
                settersAccumulator[`set${upperFirstFontSizeAttributeName}`] = this.createSetFontSize(
                  fontSizeAttributeName,
                  customFontSizeAttributeName
                );
                return settersAccumulator;
              },
              {}
            );
          }
          createSetFontSize(fontSizeAttributeName, customFontSizeAttributeName) {
            return (fontSizeValue) => {
              const fontSizeObject = this.props.fontSizes?.find(
                ({ size }) => size === Number(fontSizeValue)
              );
              this.props.setAttributes({
                [fontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? fontSizeObject.slug : void 0,
                [customFontSizeAttributeName]: fontSizeObject && fontSizeObject.slug ? void 0 : fontSizeValue
              });
            };
          }
          static getDerivedStateFromProps({ attributes, fontSizes }, previousState) {
            const didAttributesChange = (customFontSizeAttributeName, fontSizeAttributeName) => {
              if (previousState[fontSizeAttributeName]) {
                if (attributes[fontSizeAttributeName]) {
                  return attributes[fontSizeAttributeName] !== previousState[fontSizeAttributeName].slug;
                }
                return previousState[fontSizeAttributeName].size !== attributes[customFontSizeAttributeName];
              }
              return true;
            };
            if (!Object.values(fontSizeAttributeNames).some(
              didAttributesChange
            )) {
              return null;
            }
            const newState = Object.entries(
              fontSizeAttributeNames
            ).filter(
              ([key, value]) => didAttributesChange(value, key)
            ).reduce(
              (newStateAccumulator, [
                fontSizeAttributeName,
                customFontSizeAttributeName
              ]) => {
                const fontSizeAttributeValue = attributes[fontSizeAttributeName];
                const fontSizeObject = utils_getFontSize(
                  fontSizes,
                  fontSizeAttributeValue,
                  attributes[customFontSizeAttributeName]
                );
                newStateAccumulator[fontSizeAttributeName] = {
                  ...fontSizeObject,
                  class: getFontSizeClass(
                    fontSizeAttributeValue
                  )
                };
                return newStateAccumulator;
              },
              {}
            );
            return {
              ...previousState,
              ...newState
            };
          }
          render() {
            return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              WrappedComponent,
              {
                ...{
                  ...this.props,
                  fontSizes: void 0,
                  ...this.state,
                  ...this.setters
                }
              }
            );
          }
        };
      }
    ]),
    "withFontSizes"
  );
};


;// ./node_modules/@wordpress/block-editor/build-module/components/font-sizes/index.js






;// ./node_modules/@wordpress/block-editor/build-module/autocompleters/block.js










const block_noop = () => {
};
const block_SHOWN_BLOCK_TYPES = 9;
function createBlockCompleter() {
  return {
    name: "blocks",
    className: "block-editor-autocompleters__block",
    triggerPrefix: "/",
    useItems(filterValue) {
      const { rootClientId, selectedBlockId, prioritizedBlocks } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
        const {
          getSelectedBlockClientId,
          getBlock,
          getBlockListSettings,
          getBlockRootClientId
        } = select(store);
        const { getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
        const selectedBlockClientId = getSelectedBlockClientId();
        const { name: blockName, attributes } = getBlock(
          selectedBlockClientId
        );
        const activeBlockVariation = getActiveBlockVariation(
          blockName,
          attributes
        );
        const _rootClientId = getBlockRootClientId(
          selectedBlockClientId
        );
        return {
          selectedBlockId: activeBlockVariation ? `${blockName}/${activeBlockVariation.name}` : blockName,
          rootClientId: _rootClientId,
          prioritizedBlocks: getBlockListSettings(_rootClientId)?.prioritizedInserterBlocks
        };
      }, []);
      const [items, categories, collections] = use_block_types_state_default(
        rootClientId,
        block_noop,
        true
      );
      const filteredItems = (0,external_wp_element_namespaceObject.useMemo)(() => {
        const initialFilteredItems = !!filterValue.trim() ? searchBlockItems(
          items,
          categories,
          collections,
          filterValue
        ) : orderInserterBlockItems(
          orderBy(items, "frecency", "desc"),
          prioritizedBlocks
        );
        return initialFilteredItems.filter((item) => item.id !== selectedBlockId).slice(0, block_SHOWN_BLOCK_TYPES);
      }, [
        filterValue,
        selectedBlockId,
        items,
        categories,
        collections,
        prioritizedBlocks
      ]);
      const options = (0,external_wp_element_namespaceObject.useMemo)(
        () => filteredItems.map((blockItem) => {
          const { title, icon, isDisabled } = blockItem;
          return {
            key: `block-${blockItem.id}`,
            value: blockItem,
            label: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                block_icon_default,
                {
                  icon,
                  showColors: true
                },
                "icon"
              ),
              title
            ] }),
            isDisabled
          };
        }),
        [filteredItems]
      );
      return [options];
    },
    allowContext(before, after) {
      return !(/\S/.test(before) || /\S/.test(after));
    },
    getOptionCompletion(inserterItem) {
      const { name, initialAttributes, innerBlocks, syncStatus, blocks } = inserterItem;
      return {
        action: "replace",
        value: syncStatus === "unsynced" ? (blocks ?? []).map(
          (block) => (0,external_wp_blocks_namespaceObject.cloneBlock)(block)
        ) : (0,external_wp_blocks_namespaceObject.createBlock)(
          name,
          initialAttributes,
          (0,external_wp_blocks_namespaceObject.createBlocksFromInnerBlocksTemplate)(
            innerBlocks
          )
        )
      };
    }
  };
}
var block_block_default = createBlockCompleter();


;// external ["wp","apiFetch"]
const external_wp_apiFetch_namespaceObject = window["wp"]["apiFetch"];
var external_wp_apiFetch_default = /*#__PURE__*/__webpack_require__.n(external_wp_apiFetch_namespaceObject);
;// ./node_modules/@wordpress/icons/build-module/library/post.js


var post_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m7.3 9.7 1.4 1.4c.2-.2.3-.3.4-.5 0 0 0-.1.1-.1.3-.5.4-1.1.3-1.6L12 7 9 4 7.2 6.5c-.6-.1-1.1 0-1.6.3 0 0-.1 0-.1.1-.3.1-.4.2-.6.4l1.4 1.4L4 11v1h1l2.3-2.3zM4 20h9v-1.5H4V20zm0-5.5V16h16v-1.5H4z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/autocompleters/link.js





const SHOWN_SUGGESTIONS = 10;
function createLinkCompleter() {
  return {
    name: "links",
    className: "block-editor-autocompleters__link",
    triggerPrefix: "[[",
    options: async (letters) => {
      let options = await external_wp_apiFetch_default()({
        path: (0,external_wp_url_namespaceObject.addQueryArgs)("/wp/v2/search", {
          per_page: SHOWN_SUGGESTIONS,
          search: letters,
          type: "post",
          order_by: "menu_order"
        })
      });
      options = options.filter((option) => option.title !== "");
      return options;
    },
    getOptionKeywords(item) {
      const expansionWords = item.title.split(/\s+/);
      return [...expansionWords];
    },
    getOptionLabel(item) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          icon_default,
          {
            icon: item.subtype === "page" ? page_default : post_default
          },
          "icon"
        ),
        (0,external_wp_htmlEntities_namespaceObject.decodeEntities)(item.title)
      ] });
    },
    getOptionCompletion(item) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("a", { href: item.url, children: item.title });
    }
  };
}
var link_link_default = createLinkCompleter();


;// ./node_modules/@wordpress/block-editor/build-module/components/autocomplete/index.js








const autocomplete_EMPTY_ARRAY = [];
function useCompleters({ completers = autocomplete_EMPTY_ARRAY }) {
  const { name } = useBlockEditContext();
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    let filteredCompleters = [...completers, link_link_default];
    if (name === (0,external_wp_blocks_namespaceObject.getDefaultBlockName)() || (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, "__experimentalSlashInserter", false)) {
      filteredCompleters = [...filteredCompleters, block_block_default];
    }
    if ((0,external_wp_hooks_namespaceObject.hasFilter)("editor.Autocomplete.completers")) {
      if (filteredCompleters === completers) {
        filteredCompleters = filteredCompleters.map(
          (completer) => ({ ...completer })
        );
      }
      filteredCompleters = (0,external_wp_hooks_namespaceObject.applyFilters)(
        "editor.Autocomplete.completers",
        filteredCompleters,
        name
      );
    }
    return filteredCompleters;
  }, [completers, name]);
}
function useBlockEditorAutocompleteProps(props) {
  return (0,external_wp_components_namespaceObject.__unstableUseAutocompleteProps)({
    ...props,
    completers: useCompleters(props)
  });
}
function BlockEditorAutocomplete(props) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Autocomplete, { ...props, completers: useCompleters(props) });
}
var autocomplete_default = BlockEditorAutocomplete;


;// ./node_modules/@wordpress/icons/build-module/library/fullscreen.js


var fullscreen_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M6 4a2 2 0 0 0-2 2v3h1.5V6a.5.5 0 0 1 .5-.5h3V4H6Zm3 14.5H6a.5.5 0 0 1-.5-.5v-3H4v3a2 2 0 0 0 2 2h3v-1.5Zm6 1.5v-1.5h3a.5.5 0 0 0 .5-.5v-3H20v3a2 2 0 0 1-2 2h-3Zm3-16a2 2 0 0 1 2 2v3h-1.5V6a.5.5 0 0 0-.5-.5h-3V4h3Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-full-height-alignment-control/index.js




function BlockFullHeightAlignmentControl({
  isActive,
  label = (0,external_wp_i18n_namespaceObject.__)("Full height"),
  onToggle,
  isDisabled
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      isActive,
      icon: fullscreen_default,
      label,
      onClick: () => onToggle(!isActive),
      disabled: isDisabled
    }
  );
}
var block_full_height_alignment_control_default = BlockFullHeightAlignmentControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-alignment-matrix-control/index.js




const block_alignment_matrix_control_noop = () => {
};
function BlockAlignmentMatrixControl(props) {
  const {
    label = (0,external_wp_i18n_namespaceObject.__)("Change matrix alignment"),
    onChange = block_alignment_matrix_control_noop,
    value = "center",
    isDisabled
  } = props;
  const icon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.AlignmentMatrixControl.Icon, { value });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps: { placement: "bottom-start" },
      renderToggle: ({ onToggle, isOpen }) => {
        const openOnArrowDown = (event) => {
          if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
            event.preventDefault();
            onToggle();
          }
        };
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.ToolbarButton,
          {
            onClick: onToggle,
            "aria-haspopup": "true",
            "aria-expanded": isOpen,
            onKeyDown: openOnArrowDown,
            label,
            icon,
            showTooltip: true,
            disabled: isDisabled
          }
        );
      },
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.AlignmentMatrixControl,
        {
          hasFocusBorder: false,
          onChange,
          value
        }
      )
    }
  );
}
var block_alignment_matrix_control_default = BlockAlignmentMatrixControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-title/use-block-display-title.js



function useBlockDisplayTitle({
  clientId,
  maximumLength,
  context
}) {
  const blockTitle = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!clientId) {
        return null;
      }
      const { getBlockName, getBlockAttributes } = select(store);
      const { getBlockType, getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
      const blockName = getBlockName(clientId);
      const blockType = getBlockType(blockName);
      if (!blockType) {
        return null;
      }
      const attributes = getBlockAttributes(clientId);
      const label = (0,external_wp_blocks_namespaceObject.__experimentalGetBlockLabel)(blockType, attributes, context);
      if (label !== blockType.title) {
        return label;
      }
      const match = getActiveBlockVariation(blockName, attributes);
      return match?.title || blockType.title;
    },
    [clientId, context]
  );
  if (!blockTitle) {
    return null;
  }
  if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
    const omission = "...";
    return blockTitle.slice(0, maximumLength - omission.length) + omission;
  }
  return blockTitle;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-title/index.js

function BlockTitle({ clientId, maximumLength, context }) {
  return useBlockDisplayTitle({ clientId, maximumLength, context });
}


;// ./node_modules/@wordpress/block-editor/build-module/utils/get-editor-region.js
function getEditorRegion(editor) {
  if (!editor) {
    return null;
  }
  const editorCanvas = Array.from(
    document.querySelectorAll('iframe[name="editor-canvas"]').values()
  ).find((iframe) => {
    const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
    return iframeDocument === editor.ownerDocument;
  }) ?? editor;
  return editorCanvas?.closest('[role="region"]') ?? editorCanvas;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-breadcrumb/index.js











function BlockBreadcrumb({ rootLabelText }) {
  const { selectBlock, clearSelectedBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { clientId, parents, hasSelection } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getSelectionStart,
      getSelectedBlockClientId,
      getEnabledBlockParents
    } = unlock(select(store));
    const selectedBlockClientId = getSelectedBlockClientId();
    return {
      parents: getEnabledBlockParents(selectedBlockClientId),
      clientId: selectedBlockClientId,
      hasSelection: !!getSelectionStart().clientId
    };
  }, []);
  const rootLabel = rootLabelText || (0,external_wp_i18n_namespaceObject.__)("Document");
  const blockRef = (0,external_wp_element_namespaceObject.useRef)();
  useBlockElementRef(clientId, blockRef);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "ul",
    {
      className: "block-editor-block-breadcrumb",
      role: "list",
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Block breadcrumb"),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          "li",
          {
            className: !hasSelection ? "block-editor-block-breadcrumb__current" : void 0,
            "aria-current": !hasSelection ? "true" : void 0,
            children: [
              hasSelection && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  size: "small",
                  className: "block-editor-block-breadcrumb__button",
                  onClick: () => {
                    const blockEditor = blockRef.current?.closest(
                      ".editor-styles-wrapper"
                    );
                    clearSelectedBlock();
                    getEditorRegion(blockEditor)?.focus();
                  },
                  children: rootLabel
                }
              ),
              !hasSelection && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { children: rootLabel }),
              !!clientId && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                icon_default,
                {
                  icon: chevron_right_small_default,
                  className: "block-editor-block-breadcrumb__separator"
                }
              )
            ]
          }
        ),
        parents.map((parentClientId) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              size: "small",
              className: "block-editor-block-breadcrumb__button",
              onClick: () => selectBlock(parentClientId),
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                BlockTitle,
                {
                  clientId: parentClientId,
                  maximumLength: 35
                }
              )
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            icon_default,
            {
              icon: chevron_right_small_default,
              className: "block-editor-block-breadcrumb__separator"
            }
          )
        ] }, parentClientId)),
        !!clientId && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "li",
          {
            className: "block-editor-block-breadcrumb__current",
            "aria-current": "true",
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockTitle, { clientId, maximumLength: 35 })
          }
        )
      ]
    }
  );
}
var block_breadcrumb_default = BlockBreadcrumb;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-content-overlay/index.js


function useBlockOverlayActive(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { __unstableHasActiveBlockOverlayActive } = select(store);
      return __unstableHasActiveBlockOverlayActive(clientId);
    },
    [clientId]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js








const COMMON_PROPS = {
  placement: "top-start"
};
const DEFAULT_PROPS = {
  ...COMMON_PROPS,
  flip: false,
  shift: true
};
const RESTRICTED_HEIGHT_PROPS = {
  ...COMMON_PROPS,
  flip: true,
  shift: false
};
function getProps(contentElement, selectedBlockElement, scrollContainer, toolbarHeight, isSticky) {
  if (!contentElement || !selectedBlockElement) {
    return DEFAULT_PROPS;
  }
  const scrollTop = scrollContainer?.scrollTop || 0;
  const blockRect = getElementBounds(selectedBlockElement);
  const contentRect = contentElement.getBoundingClientRect();
  const topOfContentElementInViewport = scrollTop + contentRect.top;
  const viewportHeight = contentElement.ownerDocument.documentElement.clientHeight;
  const restrictedTopArea = topOfContentElementInViewport + toolbarHeight;
  const hasSpaceForToolbarAbove = blockRect.top > restrictedTopArea;
  const isBlockTallerThanViewport = blockRect.height > viewportHeight - toolbarHeight;
  if (!isSticky && (hasSpaceForToolbarAbove || isBlockTallerThanViewport)) {
    return DEFAULT_PROPS;
  }
  return RESTRICTED_HEIGHT_PROPS;
}
function useBlockToolbarPopoverProps({
  contentElement,
  clientId
}) {
  const selectedBlockElement = useBlockElement(clientId);
  const [toolbarHeight, setToolbarHeight] = (0,external_wp_element_namespaceObject.useState)(0);
  const { blockIndex, isSticky } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockIndex, getBlockAttributes } = select(store);
      return {
        blockIndex: getBlockIndex(clientId),
        isSticky: hasStickyOrFixedPositionValue(
          getBlockAttributes(clientId)
        )
      };
    },
    [clientId]
  );
  const scrollContainer = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!contentElement) {
      return;
    }
    return (0,external_wp_dom_namespaceObject.getScrollContainer)(contentElement);
  }, [contentElement]);
  const [props, setProps] = (0,external_wp_element_namespaceObject.useState)(
    () => getProps(
      contentElement,
      selectedBlockElement,
      scrollContainer,
      toolbarHeight,
      isSticky
    )
  );
  const popoverRef = (0,external_wp_compose_namespaceObject.useRefEffect)((popoverNode) => {
    setToolbarHeight(popoverNode.offsetHeight);
  }, []);
  const updateProps = (0,external_wp_element_namespaceObject.useCallback)(
    () => setProps(
      getProps(
        contentElement,
        selectedBlockElement,
        scrollContainer,
        toolbarHeight,
        isSticky
      )
    ),
    [contentElement, selectedBlockElement, scrollContainer, toolbarHeight]
  );
  (0,external_wp_element_namespaceObject.useLayoutEffect)(updateProps, [blockIndex, updateProps]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!contentElement || !selectedBlockElement) {
      return;
    }
    const contentView = contentElement?.ownerDocument?.defaultView;
    contentView?.addEventHandler?.("resize", updateProps);
    let resizeObserver;
    const blockView = selectedBlockElement?.ownerDocument?.defaultView;
    if (blockView.ResizeObserver) {
      resizeObserver = new blockView.ResizeObserver(updateProps);
      resizeObserver.observe(selectedBlockElement);
    }
    return () => {
      contentView?.removeEventHandler?.("resize", updateProps);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateProps, contentElement, selectedBlockElement]);
  return {
    ...props,
    ref: popoverRef
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/use-selected-block-tool-props.js


function useSelectedBlockToolProps(clientId) {
  const selectedBlockProps = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockRootClientId,
        getBlockParents,
        __experimentalGetBlockListSettingsForBlocks,
        isBlockInsertionPointVisible,
        getBlockInsertionPoint,
        getBlockOrder,
        hasMultiSelection,
        getLastMultiSelectedBlockClientId
      } = select(store);
      const blockParentsClientIds = getBlockParents(clientId);
      const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(
        blockParentsClientIds
      );
      const capturingClientId = blockParentsClientIds.find(
        (parentClientId) => parentBlockListSettings[parentClientId]?.__experimentalCaptureToolbars
      );
      let isInsertionPointVisible = false;
      if (isBlockInsertionPointVisible()) {
        const insertionPoint = getBlockInsertionPoint();
        const order = getBlockOrder(insertionPoint.rootClientId);
        isInsertionPointVisible = order[insertionPoint.index] === clientId;
      }
      return {
        capturingClientId,
        isInsertionPointVisible,
        lastClientId: hasMultiSelection() ? getLastMultiSelectedBlockClientId() : null,
        rootClientId: getBlockRootClientId(clientId)
      };
    },
    [clientId]
  );
  return selectedBlockProps;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/empty-block-inserter.js






function EmptyBlockInserter({
  clientId,
  __unstableContentRef
}) {
  const {
    capturingClientId,
    isInsertionPointVisible,
    lastClientId,
    rootClientId
  } = useSelectedBlockToolProps(clientId);
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    cover_default,
    {
      clientId: capturingClientId || clientId,
      bottomClientId: lastClientId,
      className: dist_clsx(
        "block-editor-block-list__block-side-inserter-popover",
        {
          "is-insertion-point-visible": isInsertionPointVisible
        }
      ),
      __unstableContentRef,
      ...popoverProps,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-list__empty-block-inserter", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inserter_default,
        {
          position: "bottom right",
          rootClientId,
          clientId,
          __experimentalIsQuick: true
        }
      ) })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js


const SCROLL_INACTIVE_DISTANCE_PX = 50;
const SCROLL_INTERVAL_MS = 25;
const PIXELS_PER_SECOND_PER_PERCENTAGE = 1e3;
const VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1e3);
function useScrollWhenDragging() {
  const dragStartYRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const velocityYRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const scrollParentYRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const scrollEditorIntervalRef = (0,external_wp_element_namespaceObject.useRef)(null);
  (0,external_wp_element_namespaceObject.useEffect)(
    () => () => {
      if (scrollEditorIntervalRef.current) {
        clearInterval(scrollEditorIntervalRef.current);
        scrollEditorIntervalRef.current = null;
      }
    },
    []
  );
  const startScrolling = (0,external_wp_element_namespaceObject.useCallback)((event) => {
    dragStartYRef.current = event.clientY;
    scrollParentYRef.current = (0,external_wp_dom_namespaceObject.getScrollContainer)(event.target);
    scrollEditorIntervalRef.current = setInterval(() => {
      if (scrollParentYRef.current && velocityYRef.current) {
        const newTop = scrollParentYRef.current.scrollTop + velocityYRef.current;
        scrollParentYRef.current.scroll({
          top: newTop
        });
      }
    }, SCROLL_INTERVAL_MS);
  }, []);
  const scrollOnDragOver = (0,external_wp_element_namespaceObject.useCallback)((event) => {
    if (!scrollParentYRef.current) {
      return;
    }
    const scrollParentHeight = scrollParentYRef.current.offsetHeight;
    const offsetDragStartPosition = dragStartYRef.current - scrollParentYRef.current.offsetTop;
    const offsetDragPosition = event.clientY - scrollParentYRef.current.offsetTop;
    if (event.clientY > offsetDragStartPosition) {
      const moveableDistance = Math.max(
        scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
        0
      );
      const dragDistance = Math.max(
        offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
        0
      );
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityYRef.current = VELOCITY_MULTIPLIER * distancePercentage;
    } else if (event.clientY < offsetDragStartPosition) {
      const moveableDistance = Math.max(
        offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX,
        0
      );
      const dragDistance = Math.max(
        offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX,
        0
      );
      const distancePercentage = moveableDistance === 0 || dragDistance === 0 ? 0 : dragDistance / moveableDistance;
      velocityYRef.current = -VELOCITY_MULTIPLIER * distancePercentage;
    } else {
      velocityYRef.current = 0;
    }
  }, []);
  const stopScrolling = () => {
    dragStartYRef.current = null;
    scrollParentYRef.current = null;
    if (scrollEditorIntervalRef.current) {
      clearInterval(scrollEditorIntervalRef.current);
      scrollEditorIntervalRef.current = null;
    }
  };
  return [startScrolling, scrollOnDragOver, stopScrolling];
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js











const BlockDraggable = ({
  appendToOwnerDocument,
  children,
  clientIds,
  cloneClassname,
  elementId,
  onDragStart,
  onDragEnd,
  fadeWhenDisabled = false,
  dragComponent
}) => {
  const {
    srcRootClientId,
    isDraggable,
    icon,
    visibleInserter,
    getBlockType
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        canMoveBlocks,
        getBlockRootClientId: getBlockRootClientId2,
        getBlockName,
        getBlockAttributes,
        isBlockInsertionPointVisible
      } = select(store);
      const { getBlockType: _getBlockType, getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
      const rootClientId = getBlockRootClientId2(clientIds[0]);
      const blockName = getBlockName(clientIds[0]);
      const variation = getActiveBlockVariation(
        blockName,
        getBlockAttributes(clientIds[0])
      );
      return {
        srcRootClientId: rootClientId,
        isDraggable: canMoveBlocks(clientIds),
        icon: variation?.icon || _getBlockType(blockName)?.icon,
        visibleInserter: isBlockInsertionPointVisible(),
        getBlockType: _getBlockType
      };
    },
    [clientIds]
  );
  const isDraggingRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const { getAllowedBlocks, getBlockNamesByClientId, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { startDraggingBlocks, stopDraggingBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    return () => {
      if (isDraggingRef.current) {
        stopDraggingBlocks();
      }
    };
  }, []);
  const blockEl = useBlockElement(clientIds[0]);
  const editorRoot = blockEl?.closest("body");
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!editorRoot || !fadeWhenDisabled) {
      return;
    }
    const onDragOver = (event) => {
      if (!event.target.closest("[data-block]")) {
        return;
      }
      const draggedBlockNames = getBlockNamesByClientId(clientIds);
      const targetClientId = event.target.closest("[data-block]").getAttribute("data-block");
      const allowedBlocks = getAllowedBlocks(targetClientId);
      const targetBlockName = getBlockNamesByClientId([
        targetClientId
      ])[0];
      let dropTargetValid;
      if (allowedBlocks?.length === 0) {
        const targetRootClientId = getBlockRootClientId(targetClientId);
        const targetRootBlockName = getBlockNamesByClientId([
          targetRootClientId
        ])[0];
        const rootAllowedBlocks = getAllowedBlocks(targetRootClientId);
        dropTargetValid = isDropTargetValid(
          getBlockType,
          rootAllowedBlocks,
          draggedBlockNames,
          targetRootBlockName
        );
      } else {
        dropTargetValid = isDropTargetValid(
          getBlockType,
          allowedBlocks,
          draggedBlockNames,
          targetBlockName
        );
      }
      if (!dropTargetValid && !visibleInserter) {
        window?.document?.body?.classList?.add(
          "block-draggable-invalid-drag-token"
        );
      } else {
        window?.document?.body?.classList?.remove(
          "block-draggable-invalid-drag-token"
        );
      }
    };
    const throttledOnDragOver = (0,external_wp_compose_namespaceObject.throttle)(onDragOver, 200);
    editorRoot.addEventListener("dragover", throttledOnDragOver);
    return () => {
      editorRoot.removeEventListener("dragover", throttledOnDragOver);
    };
  }, [
    clientIds,
    editorRoot,
    fadeWhenDisabled,
    getAllowedBlocks,
    getBlockNamesByClientId,
    getBlockRootClientId,
    getBlockType,
    visibleInserter
  ]);
  if (!isDraggable) {
    return children({ draggable: false });
  }
  const transferData = {
    type: "block",
    srcClientIds: clientIds,
    srcRootClientId
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Draggable,
    {
      appendToOwnerDocument,
      cloneClassname,
      __experimentalTransferDataType: "wp-blocks",
      transferData,
      onDragStart: (event) => {
        window.requestAnimationFrame(() => {
          startDraggingBlocks(clientIds);
          isDraggingRef.current = true;
          startScrolling(event);
          if (onDragStart) {
            onDragStart();
          }
        });
      },
      onDragOver: scrollOnDragOver,
      onDragEnd: () => {
        stopDraggingBlocks();
        isDraggingRef.current = false;
        stopScrolling();
        if (onDragEnd) {
          onDragEnd();
        }
      },
      __experimentalDragComponent: (
        // Check against `undefined` so that `null` can be used to disable
        // the default drag component.
        dragComponent !== void 0 ? dragComponent : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          BlockDraggableChip,
          {
            count: clientIds.length,
            icon,
            fadeWhenDisabled: true
          }
        )
      ),
      elementId,
      children: ({ onDraggableStart, onDraggableEnd }) => {
        return children({
          draggable: true,
          onDragStart: onDraggableStart,
          onDragEnd: onDraggableEnd
        });
      }
    }
  );
};
var block_draggable_default = BlockDraggable;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js

const getMovementDirection = (moveDirection, orientation) => {
  if (moveDirection === "up") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? "right" : "left";
    }
    return "up";
  } else if (moveDirection === "down") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? "left" : "right";
    }
    return "down";
  }
  return null;
};
function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;
  if (selectedCount > 1) {
    return getMultiBlockMoverDescription(
      selectedCount,
      firstIndex,
      isFirst,
      isLast,
      dir,
      orientation
    );
  }
  if (isFirst && isLast) {
    return (0,external_wp_i18n_namespaceObject.sprintf)(
      // translators: %s: Type of block (i.e. Text, Image etc)
      (0,external_wp_i18n_namespaceObject.__)("Block %s is the only block, and cannot be moved"),
      type
    );
  }
  if (dir > 0 && !isLast) {
    const movementDirection = getMovementDirection("down", orientation);
    if (movementDirection === "down") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)(
          "Move %1$s block from position %2$d down to position %3$d"
        ),
        type,
        position,
        position + 1
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)(
          "Move %1$s block from position %2$d left to position %3$d"
        ),
        type,
        position,
        position + 1
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)(
          "Move %1$s block from position %2$d right to position %3$d"
        ),
        type,
        position,
        position + 1
      );
    }
  }
  if (dir > 0 && isLast) {
    const movementDirection = getMovementDirection("down", orientation);
    if (movementDirection === "down") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the end of the content and can\u2019t be moved down"
        ),
        type
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the end of the content and can\u2019t be moved left"
        ),
        type
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the end of the content and can\u2019t be moved right"
        ),
        type
      );
    }
  }
  if (dir < 0 && !isFirst) {
    const movementDirection = getMovementDirection("up", orientation);
    if (movementDirection === "up") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)("Move %1$s block from position %2$d up to position %3$d"),
        type,
        position,
        position - 1
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)(
          "Move %1$s block from position %2$d left to position %3$d"
        ),
        type,
        position,
        position - 1
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
        (0,external_wp_i18n_namespaceObject.__)(
          "Move %1$s block from position %2$d right to position %3$d"
        ),
        type,
        position,
        position - 1
      );
    }
  }
  if (dir < 0 && isFirst) {
    const movementDirection = getMovementDirection("up", orientation);
    if (movementDirection === "up") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the beginning of the content and can\u2019t be moved up"
        ),
        type
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the beginning of the content and can\u2019t be moved left"
        ),
        type
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Type of block (i.e. Text, Image etc)
        (0,external_wp_i18n_namespaceObject.__)(
          "Block %1$s is at the beginning of the content and can\u2019t be moved right"
        ),
        type
      );
    }
  }
}
function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;
  if (isFirst && isLast) {
    return (0,external_wp_i18n_namespaceObject.__)("All blocks are selected, and cannot be moved");
  }
  if (dir > 0 && !isLast) {
    const movementDirection = getMovementDirection("down", orientation);
    if (movementDirection === "down") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d down by one place"),
        selectedCount,
        position
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d left by one place"),
        selectedCount,
        position
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d right by one place"),
        selectedCount,
        position
      );
    }
  }
  if (dir > 0 && isLast) {
    const movementDirection = getMovementDirection("down", orientation);
    if (movementDirection === "down") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved down as they are already at the bottom"
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved left as they are already are at the leftmost position"
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved right as they are already are at the rightmost position"
      );
    }
  }
  if (dir < 0 && !isFirst) {
    const movementDirection = getMovementDirection("up", orientation);
    if (movementDirection === "up") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d up by one place"),
        selectedCount,
        position
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d left by one place"),
        selectedCount,
        position
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.sprintf)(
        // translators: 1: Number of selected blocks, 2: Position of selected blocks
        (0,external_wp_i18n_namespaceObject.__)("Move %1$d blocks from position %2$d right by one place"),
        selectedCount,
        position
      );
    }
  }
  if (dir < 0 && isFirst) {
    const movementDirection = getMovementDirection("up", orientation);
    if (movementDirection === "up") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved up as they are already at the top"
      );
    }
    if (movementDirection === "left") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved left as they are already are at the leftmost position"
      );
    }
    if (movementDirection === "right") {
      return (0,external_wp_i18n_namespaceObject.__)(
        "Blocks cannot be moved right as they are already are at the rightmost position"
      );
    }
  }
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js











const getArrowIcon = (direction, orientation) => {
  if (direction === "up") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right_default : chevron_left_default;
    }
    return chevron_up_default;
  } else if (direction === "down") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_default : chevron_right_default;
    }
    return chevron_down_default;
  }
  return null;
};
const getMovementDirectionLabel = (moveDirection, orientation) => {
  if (moveDirection === "up") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? (0,external_wp_i18n_namespaceObject.__)("Move right") : (0,external_wp_i18n_namespaceObject.__)("Move left");
    }
    return (0,external_wp_i18n_namespaceObject.__)("Move up");
  } else if (moveDirection === "down") {
    if (orientation === "horizontal") {
      return (0,external_wp_i18n_namespaceObject.isRTL)() ? (0,external_wp_i18n_namespaceObject.__)("Move left") : (0,external_wp_i18n_namespaceObject.__)("Move right");
    }
    return (0,external_wp_i18n_namespaceObject.__)("Move down");
  }
  return null;
};
const BlockMoverButton = (0,external_wp_element_namespaceObject.forwardRef)(
  ({ clientIds, direction, orientation: moverOrientation, ...props }, ref) => {
    const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(BlockMoverButton);
    const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
    const blocksCount = normalizedClientIds.length;
    const { disabled } = props;
    const {
      blockType,
      isDisabled,
      rootClientId,
      isFirst,
      isLast,
      firstIndex,
      orientation = "vertical"
    } = (0,external_wp_data_namespaceObject.useSelect)(
      (select) => {
        const {
          getBlockIndex,
          getBlockRootClientId,
          getBlockOrder,
          getBlock,
          getBlockListSettings
        } = select(store);
        const firstClientId = normalizedClientIds[0];
        const blockRootClientId = getBlockRootClientId(firstClientId);
        const firstBlockIndex = getBlockIndex(firstClientId);
        const lastBlockIndex = getBlockIndex(
          normalizedClientIds[normalizedClientIds.length - 1]
        );
        const blockOrder = getBlockOrder(blockRootClientId);
        const block = getBlock(firstClientId);
        const isFirstBlock = firstBlockIndex === 0;
        const isLastBlock = lastBlockIndex === blockOrder.length - 1;
        const { orientation: blockListOrientation } = getBlockListSettings(blockRootClientId) || {};
        return {
          blockType: block ? (0,external_wp_blocks_namespaceObject.getBlockType)(block.name) : null,
          isDisabled: disabled || (direction === "up" ? isFirstBlock : isLastBlock),
          rootClientId: blockRootClientId,
          firstIndex: firstBlockIndex,
          isFirst: isFirstBlock,
          isLast: isLastBlock,
          orientation: moverOrientation || blockListOrientation
        };
      },
      [clientIds, direction]
    );
    const { moveBlocksDown, moveBlocksUp } = (0,external_wp_data_namespaceObject.useDispatch)(store);
    const moverFunction = direction === "up" ? moveBlocksUp : moveBlocksDown;
    const onClick = (event) => {
      moverFunction(clientIds, rootClientId);
      if (props.onClick) {
        props.onClick(event);
      }
    };
    const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          __next40pxDefaultSize: true,
          ref,
          className: dist_clsx(
            "block-editor-block-mover-button",
            `is-${direction}-button`
          ),
          icon: getArrowIcon(direction, orientation),
          label: getMovementDirectionLabel(
            direction,
            orientation
          ),
          "aria-describedby": descriptionId,
          ...props,
          onClick: isDisabled ? null : onClick,
          disabled: isDisabled,
          accessibleWhenDisabled: true
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: getBlockMoverDescription(
        blocksCount,
        blockType && blockType.title,
        firstIndex,
        isFirst,
        isLast,
        direction === "up" ? -1 : 1,
        orientation
      ) })
    ] });
  }
);
const BlockMoverUpButton = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockMoverButton, { direction: "up", ref, ...props });
});
const BlockMoverDownButton = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockMoverButton, { direction: "down", ref, ...props });
});


;// ./node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js









function BlockMover({
  clientIds,
  hideDragHandle,
  isBlockMoverUpButtonDisabled,
  isBlockMoverDownButtonDisabled
}) {
  const {
    canMove,
    rootClientId,
    isFirst,
    isLast,
    orientation,
    isManualGrid
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockIndex,
        getBlockListSettings,
        canMoveBlocks,
        getBlockOrder,
        getBlockRootClientId,
        getBlockAttributes
      } = select(store);
      const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
      const firstClientId = normalizedClientIds[0];
      const _rootClientId = getBlockRootClientId(firstClientId);
      const firstIndex = getBlockIndex(firstClientId);
      const lastIndex = getBlockIndex(
        normalizedClientIds[normalizedClientIds.length - 1]
      );
      const blockOrder = getBlockOrder(_rootClientId);
      const { layout = {} } = getBlockAttributes(_rootClientId) ?? {};
      return {
        canMove: canMoveBlocks(clientIds),
        rootClientId: _rootClientId,
        isFirst: firstIndex === 0,
        isLast: lastIndex === blockOrder.length - 1,
        orientation: getBlockListSettings(_rootClientId)?.orientation,
        isManualGrid: layout.type === "grid" && layout.isManualPlacement && window.__experimentalEnableGridInteractivity
      };
    },
    [clientIds]
  );
  if (!canMove || isFirst && isLast && !rootClientId || hideDragHandle && isManualGrid) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.ToolbarGroup,
    {
      className: dist_clsx("block-editor-block-mover", {
        "is-horizontal": orientation === "horizontal"
      }),
      children: [
        !hideDragHandle && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_draggable_default, { clientIds, fadeWhenDisabled: true, children: (draggableProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            icon: drag_handle_default,
            className: "block-editor-block-mover__drag-handle",
            label: (0,external_wp_i18n_namespaceObject.__)("Drag"),
            tabIndex: "-1",
            ...draggableProps
          }
        ) }),
        !isManualGrid && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-mover__move-button-container", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (itemProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockMoverUpButton,
            {
              disabled: isBlockMoverUpButtonDisabled,
              clientIds,
              ...itemProps
            }
          ) }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (itemProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockMoverDownButton,
            {
              disabled: isBlockMoverDownButtonDisabled,
              clientIds,
              ...itemProps
            }
          ) })
        ] })
      ]
    }
  );
}
var block_mover_default = BlockMover;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js



const { clearTimeout: utils_clearTimeout, setTimeout: utils_setTimeout } = window;
const DEBOUNCE_TIMEOUT = 200;
function useDebouncedShowGestures({
  ref,
  isFocused,
  highlightParent,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const { getSelectedBlockClientId, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { toggleBlockHighlight } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const timeoutRef = (0,external_wp_element_namespaceObject.useRef)();
  const isDistractionFree = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSettings().isDistractionFree,
    []
  );
  const handleOnChange = (nextIsFocused) => {
    if (nextIsFocused && isDistractionFree) {
      return;
    }
    const selectedBlockClientId = getSelectedBlockClientId();
    const clientId = highlightParent ? getBlockRootClientId(selectedBlockClientId) : selectedBlockClientId;
    toggleBlockHighlight(clientId, nextIsFocused);
  };
  const getIsHovered = () => {
    return ref?.current && ref.current.matches(":hover");
  };
  const shouldHideGestures = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };
  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;
    if (timeout && utils_clearTimeout) {
      utils_clearTimeout(timeout);
    }
  };
  const debouncedShowGestures = (event) => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    handleOnChange(true);
  };
  const debouncedHideGestures = (event) => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    timeoutRef.current = utils_setTimeout(() => {
      if (shouldHideGestures()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };
  (0,external_wp_element_namespaceObject.useEffect)(
    () => () => {
      handleOnChange(false);
      clearTimeoutRef();
    },
    []
  );
  return {
    debouncedShowGestures,
    debouncedHideGestures
  };
}
function useShowHoveredOrFocusedGestures({
  ref,
  highlightParent = false,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const [isFocused, setIsFocused] = (0,external_wp_element_namespaceObject.useState)(false);
  const { debouncedShowGestures, debouncedHideGestures } = useDebouncedShowGestures({
    ref,
    debounceTimeout,
    isFocused,
    highlightParent
  });
  const registerRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const isFocusedWithin = () => {
    return ref?.current && ref.current.contains(ref.current.ownerDocument.activeElement);
  };
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const node = ref.current;
    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowGestures();
      }
    };
    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideGestures();
      }
    };
    if (node && !registerRef.current) {
      node.addEventListener("focus", handleOnFocus, true);
      node.addEventListener("blur", handleOnBlur, true);
      registerRef.current = true;
    }
    return () => {
      if (node) {
        node.removeEventListener("focus", handleOnFocus);
        node.removeEventListener("blur", handleOnBlur);
      }
    };
  }, [
    ref,
    registerRef,
    setIsFocused,
    debouncedShowGestures,
    debouncedHideGestures
  ]);
  return {
    onMouseMove: debouncedShowGestures,
    onMouseLeave: debouncedHideGestures
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js










function BlockParentSelector() {
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { parentClientId } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getBlockParents,
      getSelectedBlockClientId,
      getParentSectionBlock
    } = unlock(select(store));
    const selectedBlockClientId = getSelectedBlockClientId();
    const parentSection = getParentSectionBlock(selectedBlockClientId);
    const parents = getBlockParents(selectedBlockClientId);
    const _parentClientId = parentSection ?? parents[parents.length - 1];
    return {
      parentClientId: _parentClientId
    };
  }, []);
  const blockInformation = useBlockDisplayInformation(parentClientId);
  const nodeRef = (0,external_wp_element_namespaceObject.useRef)();
  const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
    ref: nodeRef,
    highlightParent: true
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      className: "block-editor-block-parent-selector",
      ref: nodeRef,
      ...showHoveredOrFocusedGestures,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ToolbarButton,
        {
          className: "block-editor-block-parent-selector__button",
          onClick: () => selectBlock(parentClientId),
          label: (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %s: Name of the block's parent. */
            (0,external_wp_i18n_namespaceObject.__)("Select parent block: %s"),
            blockInformation?.title
          ),
          showTooltip: true,
          icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: blockInformation?.icon })
        }
      )
    },
    parentClientId
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/copy.js


var copy_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M5 4.5h11a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5H5a.5.5 0 0 1-.5-.5V5a.5.5 0 0 1 .5-.5ZM3 5a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5Zm17 3v10.75c0 .69-.56 1.25-1.25 1.25H6v1.5h12.75a2.75 2.75 0 0 0 2.75-2.75V8H20Z"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js





function PreviewBlockPopover({ blocks }) {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  if (isMobile) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-switcher__popover-preview-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      className: "block-editor-block-switcher__popover-preview",
      placement: "right-start",
      focusOnMount: false,
      offset: 16,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-switcher__preview", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-switcher__preview-title", children: (0,external_wp_i18n_namespaceObject.__)("Preview") }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_preview_default, { viewportWidth: 601, blocks })
      ] })
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-variation-transformations.js








const block_variation_transformations_EMPTY_OBJECT = {};
function useBlockVariationTransforms({ clientIds, blocks }) {
  const { activeBlockVariation, blockVariationTransformations } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes, canRemoveBlocks } = select(store);
      const { getActiveBlockVariation, getBlockVariations } = select(external_wp_blocks_namespaceObject.store);
      const canRemove = canRemoveBlocks(clientIds);
      if (blocks.length !== 1 || !canRemove) {
        return block_variation_transformations_EMPTY_OBJECT;
      }
      const [firstBlock] = blocks;
      return {
        blockVariationTransformations: getBlockVariations(
          firstBlock.name,
          "transform"
        ),
        activeBlockVariation: getActiveBlockVariation(
          firstBlock.name,
          getBlockAttributes(firstBlock.clientId)
        )
      };
    },
    [clientIds, blocks]
  );
  const transformations = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return blockVariationTransformations?.filter(
      ({ name }) => name !== activeBlockVariation?.name
    );
  }, [blockVariationTransformations, activeBlockVariation]);
  return transformations;
}
const BlockVariationTransformations = ({
  transformations,
  onSelect,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,external_wp_element_namespaceObject.useState)();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    hoveredTransformItemName && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PreviewBlockPopover,
      {
        blocks: (0,external_wp_blocks_namespaceObject.cloneBlock)(
          blocks[0],
          transformations.find(
            ({ name }) => name === hoveredTransformItemName
          ).attributes
        )
      }
    ),
    transformations?.map((item) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockVariationTransformationItem,
      {
        item,
        onSelect,
        setHoveredTransformItemName
      },
      item.name
    ))
  ] });
};
function BlockVariationTransformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const { name, icon, title } = item;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.MenuItem,
    {
      className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(name),
      onClick: (event) => {
        event.preventDefault();
        onSelect(name);
      },
      onMouseLeave: () => setHoveredTransformItemName(null),
      onMouseEnter: () => setHoveredTransformItemName(name),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon, showColors: true }),
        title
      ]
    }
  );
}
var block_variation_transformations_default = BlockVariationTransformations;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js








function useGroupedTransforms(possibleBlockTransformations) {
  const priorityContentTransformationBlocks = {
    "core/paragraph": 1,
    "core/heading": 2,
    "core/list": 3,
    "core/quote": 4
  };
  const transformations = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const priorityTextTransformsNames = Object.keys(
      priorityContentTransformationBlocks
    );
    const groupedPossibleTransforms = possibleBlockTransformations.reduce(
      (accumulator, item) => {
        const { name } = item;
        if (priorityTextTransformsNames.includes(name)) {
          accumulator.priorityTextTransformations.push(item);
        } else {
          accumulator.restTransformations.push(item);
        }
        return accumulator;
      },
      { priorityTextTransformations: [], restTransformations: [] }
    );
    if (groupedPossibleTransforms.priorityTextTransformations.length === 1 && groupedPossibleTransforms.priorityTextTransformations[0].name === "core/quote") {
      const singleQuote = groupedPossibleTransforms.priorityTextTransformations.pop();
      groupedPossibleTransforms.restTransformations.push(singleQuote);
    }
    return groupedPossibleTransforms;
  }, [possibleBlockTransformations]);
  transformations.priorityTextTransformations.sort(
    ({ name: currentName }, { name: nextName }) => {
      return priorityContentTransformationBlocks[currentName] < priorityContentTransformationBlocks[nextName] ? -1 : 1;
    }
  );
  return transformations;
}
const BlockTransformationsMenu = ({
  className,
  possibleBlockTransformations,
  possibleBlockVariationTransformations,
  onSelect,
  onSelectVariation,
  blocks
}) => {
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,external_wp_element_namespaceObject.useState)();
  const { priorityTextTransformations, restTransformations } = useGroupedTransforms(possibleBlockTransformations);
  const hasBothContentTransformations = priorityTextTransformations.length && restTransformations.length;
  const restTransformItems = !!restTransformations.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    RestTransformationItems,
    {
      restTransformations,
      onSelect,
      setHoveredTransformItemName
    }
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { label: (0,external_wp_i18n_namespaceObject.__)("Transform to"), className, children: [
      hoveredTransformItemName && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        PreviewBlockPopover,
        {
          blocks: (0,external_wp_blocks_namespaceObject.switchToBlockType)(
            blocks,
            hoveredTransformItemName
          )
        }
      ),
      !!possibleBlockVariationTransformations?.length && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_variation_transformations_default,
        {
          transformations: possibleBlockVariationTransformations,
          blocks,
          onSelect: onSelectVariation
        }
      ),
      priorityTextTransformations.map((item) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockTransformationItem,
        {
          item,
          onSelect,
          setHoveredTransformItemName
        },
        item.name
      )),
      !hasBothContentTransformations && restTransformItems
    ] }),
    !!hasBothContentTransformations && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { className, children: restTransformItems })
  ] });
};
function RestTransformationItems({
  restTransformations,
  onSelect,
  setHoveredTransformItemName
}) {
  return restTransformations.map((item) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockTransformationItem,
    {
      item,
      onSelect,
      setHoveredTransformItemName
    },
    item.name
  ));
}
function BlockTransformationItem({
  item,
  onSelect,
  setHoveredTransformItemName
}) {
  const { name, icon, title, isDisabled } = item;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.MenuItem,
    {
      className: (0,external_wp_blocks_namespaceObject.getBlockMenuDefaultClassName)(name),
      onClick: (event) => {
        event.preventDefault();
        onSelect(name);
      },
      disabled: isDisabled,
      onMouseLeave: () => setHoveredTransformItemName(null),
      onMouseEnter: () => setHoveredTransformItemName(name),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon, showColors: true }),
        title
      ]
    }
  );
}
var block_transformations_menu_default = BlockTransformationsMenu;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js


function getActiveStyle(styles, className) {
  for (const style of new (external_wp_tokenList_default())(className).values()) {
    if (style.indexOf("is-style-") === -1) {
      continue;
    }
    const potentialStyleName = style.substring(9);
    const activeStyle = styles?.find(
      ({ name }) => name === potentialStyleName
    );
    if (activeStyle) {
      return activeStyle;
    }
  }
  return getDefaultStyle(styles);
}
function replaceActiveStyle(className, activeStyle, newStyle) {
  const list = new (external_wp_tokenList_default())(className);
  if (activeStyle) {
    list.remove("is-style-" + activeStyle.name);
  }
  list.add("is-style-" + newStyle.name);
  return list.value;
}
function getRenderedStyles(styles) {
  if (!styles || styles.length === 0) {
    return [];
  }
  return getDefaultStyle(styles) ? styles : [
    {
      name: "default",
      label: (0,external_wp_i18n_namespaceObject._x)("Default", "block style"),
      isDefault: true
    },
    ...styles
  ];
}
function getDefaultStyle(styles) {
  return styles?.find((style) => style.isDefault);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-styles/use-styles-for-block.js





function useGenericPreviewBlock(block, type) {
  return (0,external_wp_element_namespaceObject.useMemo)(() => {
    const example = type?.example;
    const blockName = type?.name;
    if (example && blockName) {
      return (0,external_wp_blocks_namespaceObject.getBlockFromExample)(blockName, {
        attributes: example.attributes,
        innerBlocks: example.innerBlocks
      });
    }
    if (block) {
      return (0,external_wp_blocks_namespaceObject.cloneBlock)(block);
    }
  }, [type?.example ? block?.name : block, type]);
}
function useStylesForBlocks({ clientId, onSwitch }) {
  const selector = (select) => {
    const { getBlock } = select(store);
    const block2 = getBlock(clientId);
    if (!block2) {
      return {};
    }
    const blockType2 = (0,external_wp_blocks_namespaceObject.getBlockType)(block2.name);
    const { getBlockStyles } = select(external_wp_blocks_namespaceObject.store);
    return {
      block: block2,
      blockType: blockType2,
      styles: getBlockStyles(block2.name),
      className: block2.attributes.className || ""
    };
  };
  const { styles, block, blockType, className } = (0,external_wp_data_namespaceObject.useSelect)(selector, [
    clientId
  ]);
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const stylesToRender = getRenderedStyles(styles);
  const activeStyle = getActiveStyle(stylesToRender, className);
  const genericPreviewBlock = useGenericPreviewBlock(block, blockType);
  const onSelect = (style) => {
    const styleClassName = replaceActiveStyle(
      className,
      activeStyle,
      style
    );
    updateBlockAttributes(clientId, {
      className: styleClassName
    });
    onSwitch();
  };
  return {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-styles/menu-items.js




const menu_items_noop = () => {
};
function BlockStylesMenuItems({ clientId, onSwitch = menu_items_noop }) {
  const { onSelect, stylesToRender, activeStyle } = useStylesForBlocks({
    clientId,
    onSwitch
  });
  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: stylesToRender.map((style) => {
    const menuItemText = style.label || style.name;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        icon: activeStyle.name === style.name ? check_check_default : null,
        onClick: () => onSelect(style),
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalText,
          {
            as: "span",
            limit: 18,
            ellipsizeMode: "tail",
            truncate: true,
            children: menuItemText
          }
        )
      },
      style.name
    );
  }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js




function BlockStylesMenu({ hoveredBlock, onSwitch }) {
  const { clientId } = hoveredBlock;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuGroup,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Styles"),
      className: "block-editor-block-switcher__styles__menugroup",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockStylesMenuItems, { clientId, onSwitch })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js

const getMatchingBlockByName = (block, selectedBlockName, consumedBlocks = /* @__PURE__ */ new Set()) => {
  const { clientId, name, innerBlocks = [] } = block;
  if (consumedBlocks.has(clientId)) {
    return;
  }
  if (name === selectedBlockName) {
    return block;
  }
  for (const innerBlock of innerBlocks) {
    const match = getMatchingBlockByName(
      innerBlock,
      selectedBlockName,
      consumedBlocks
    );
    if (match) {
      return match;
    }
  }
};
const getRetainedBlockAttributes = (name, attributes) => {
  const contentAttributes = (0,external_wp_blocks_namespaceObject.getBlockAttributesNamesByRole)(name, "content");
  if (!contentAttributes?.length) {
    return attributes;
  }
  return contentAttributes.reduce((_accumulator, attribute) => {
    if (attributes[attribute]) {
      _accumulator[attribute] = attributes[attribute];
    }
    return _accumulator;
  }, {});
};


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js



const transformMatchingBlock = (match, selectedBlock) => {
  const retainedBlockAttributes = getRetainedBlockAttributes(
    selectedBlock.name,
    selectedBlock.attributes
  );
  match.attributes = {
    ...match.attributes,
    ...retainedBlockAttributes
  };
};
const getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
  const _patternBlocks = patternBlocks.map(
    (block) => (0,external_wp_blocks_namespaceObject.cloneBlock)(block)
  );
  const consumedBlocks = /* @__PURE__ */ new Set();
  for (const selectedBlock of selectedBlocks) {
    let isMatch = false;
    for (const patternBlock of _patternBlocks) {
      const match = getMatchingBlockByName(
        patternBlock,
        selectedBlock.name,
        consumedBlocks
      );
      if (!match) {
        continue;
      }
      isMatch = true;
      consumedBlocks.add(match.clientId);
      transformMatchingBlock(match, selectedBlock);
      break;
    }
    if (!isMatch) {
      return;
    }
  }
  return _patternBlocks;
};
const useTransformedPatterns = (patterns, selectedBlocks) => {
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => patterns.reduce((accumulator, _pattern) => {
      const transformedBlocks = getPatternTransformedBlocks(
        selectedBlocks,
        _pattern.blocks
      );
      if (transformedBlocks) {
        accumulator.push({
          ..._pattern,
          transformedBlocks
        });
      }
      return accumulator;
    }, []),
    [patterns, selectedBlocks]
  );
};
var use_transformed_patterns_default = useTransformedPatterns;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js








function PatternTransformationsMenu({
  blocks,
  patterns: statePatterns,
  onSelect
}) {
  const [showTransforms, setShowTransforms] = (0,external_wp_element_namespaceObject.useState)(false);
  const patterns = use_transformed_patterns_default(statePatterns, blocks);
  if (!patterns.length) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { className: "block-editor-block-switcher__pattern__transforms__menugroup", children: [
    showTransforms && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      PreviewPatternsPopover,
      {
        patterns,
        onSelect
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        onClick: (event) => {
          event.preventDefault();
          setShowTransforms(!showTransforms);
        },
        icon: chevron_right_default,
        children: (0,external_wp_i18n_namespaceObject.__)("Patterns")
      }
    )
  ] });
}
function PreviewPatternsPopover({ patterns, onSelect }) {
  const isMobile = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-switcher__popover-preview-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      className: "block-editor-block-switcher__popover-preview",
      placement: isMobile ? "bottom" : "right-start",
      offset: 16,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-switcher__preview is-pattern-list-preview", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        pattern_transformations_menu_BlockPatternsList,
        {
          patterns,
          onSelect
        }
      ) })
    }
  ) });
}
function pattern_transformations_menu_BlockPatternsList({ patterns, onSelect }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite,
    {
      role: "listbox",
      className: "block-editor-block-switcher__preview-patterns-container",
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Patterns list"),
      children: patterns.map((pattern) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        pattern_transformations_menu_BlockPattern,
        {
          pattern,
          onSelect
        },
        pattern.name
      ))
    }
  );
}
function pattern_transformations_menu_BlockPattern({ pattern, onSelect }) {
  const baseClassName = "block-editor-block-switcher__preview-patterns-container";
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(
    pattern_transformations_menu_BlockPattern,
    `${baseClassName}-list__item-description`
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: `${baseClassName}-list__list-item`, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.Composite.Item,
      {
        render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "div",
          {
            role: "option",
            "aria-label": pattern.title,
            "aria-describedby": pattern.description ? descriptionId : void 0,
            className: `${baseClassName}-list__item`
          }
        ),
        onClick: () => onSelect(pattern.transformedBlocks),
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_preview_default,
            {
              blocks: pattern.transformedBlocks,
              viewportWidth: pattern.viewportWidth || 500
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: `${baseClassName}-list__item-title`, children: pattern.title })
        ]
      }
    ),
    !!pattern.description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: pattern.description })
  ] });
}
var pattern_transformations_menu_default = PatternTransformationsMenu;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js















function BlockSwitcherDropdownMenuContents({
  onClose,
  clientIds,
  hasBlockStyles,
  canRemove
}) {
  const { replaceBlocks, multiSelect, updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { possibleBlockTransformations, patterns, blocks, isUsingBindings } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockAttributes,
        getBlocksByClientId,
        getBlockRootClientId,
        getBlockTransformItems,
        __experimentalGetPatternTransformItems
      } = select(store);
      const rootClientId = getBlockRootClientId(clientIds[0]);
      const _blocks = getBlocksByClientId(clientIds);
      return {
        blocks: _blocks,
        possibleBlockTransformations: getBlockTransformItems(
          _blocks,
          rootClientId
        ),
        patterns: __experimentalGetPatternTransformItems(
          _blocks,
          rootClientId
        ),
        isUsingBindings: clientIds.every(
          (clientId) => !!getBlockAttributes(clientId)?.metadata?.bindings
        )
      };
    },
    [clientIds]
  );
  const blockVariationTransformations = useBlockVariationTransforms({
    clientIds,
    blocks
  });
  function selectForMultipleBlocks(insertedBlocks) {
    if (insertedBlocks.length > 1) {
      multiSelect(
        insertedBlocks[0].clientId,
        insertedBlocks[insertedBlocks.length - 1].clientId
      );
    }
  }
  function onBlockTransform(name) {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, name);
    replaceBlocks(clientIds, newBlocks);
    selectForMultipleBlocks(newBlocks);
  }
  function onBlockVariationTransform(name) {
    updateBlockAttributes(blocks[0].clientId, {
      ...blockVariationTransformations.find(
        ({ name: variationName }) => variationName === name
      ).attributes
    });
  }
  function onPatternTransform(transformedBlocks) {
    replaceBlocks(clientIds, transformedBlocks);
    selectForMultipleBlocks(transformedBlocks);
  }
  const isSingleBlock = blocks.length === 1;
  const isSynced = isSingleBlock && ((0,external_wp_blocks_namespaceObject.isTemplatePart)(blocks[0]) || (0,external_wp_blocks_namespaceObject.isReusableBlock)(blocks[0]));
  const hasPossibleBlockTransformations = !!possibleBlockTransformations?.length && canRemove && !isSynced;
  const hasPossibleBlockVariationTransformations = !!blockVariationTransformations?.length;
  const hasPatternTransformation = !!patterns?.length && canRemove;
  const hasBlockOrBlockVariationTransforms = hasPossibleBlockTransformations || hasPossibleBlockVariationTransformations;
  const hasContents = hasBlockStyles || hasBlockOrBlockVariationTransforms || hasPatternTransformation;
  if (!hasContents) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-block-switcher__no-transforms", children: (0,external_wp_i18n_namespaceObject.__)("No transforms.") });
  }
  const connectedBlockDescription = isSingleBlock ? (0,external_wp_i18n_namespaceObject._x)(
    "This block is connected.",
    "block toolbar button label and description"
  ) : (0,external_wp_i18n_namespaceObject._x)(
    "These blocks are connected.",
    "block toolbar button label and description"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-switcher__container", children: [
    hasPatternTransformation && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      pattern_transformations_menu_default,
      {
        blocks,
        patterns,
        onSelect: (transformedBlocks) => {
          onPatternTransform(transformedBlocks);
          onClose();
        }
      }
    ),
    hasBlockOrBlockVariationTransforms && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_transformations_menu_default,
      {
        className: "block-editor-block-switcher__transforms__menugroup",
        possibleBlockTransformations,
        possibleBlockVariationTransformations: blockVariationTransformations,
        blocks,
        onSelect: (name) => {
          onBlockTransform(name);
          onClose();
        },
        onSelectVariation: (name) => {
          onBlockVariationTransform(name);
          onClose();
        }
      }
    ),
    hasBlockStyles && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockStylesMenu,
      {
        hoveredBlock: blocks[0],
        onSwitch: onClose
      }
    ),
    isUsingBindings && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { className: "block-editor-block-switcher__binding-indicator", children: connectedBlockDescription }) })
  ] });
}
const BlockSwitcher = ({ clientIds }) => {
  const {
    hasContentOnlyLocking,
    canRemove,
    hasBlockStyles,
    icon,
    invalidBlocks,
    isReusable,
    isTemplate,
    isDisabled,
    isSectionInSelection
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getTemplateLock,
        getBlocksByClientId,
        getBlockAttributes,
        canRemoveBlocks,
        getBlockEditingMode,
        isSectionBlock
      } = unlock(select(store));
      const { getBlockStyles, getBlockType, getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
      const _blocks = getBlocksByClientId(clientIds);
      if (!_blocks.length || _blocks.some((block) => !block)) {
        return { invalidBlocks: true };
      }
      const [{ name: firstBlockName }] = _blocks;
      const _isSingleBlockSelected = _blocks.length === 1;
      const blockType = getBlockType(firstBlockName);
      const editingMode = getBlockEditingMode(clientIds[0]);
      let _icon;
      let _hasTemplateLock;
      if (_isSingleBlockSelected) {
        const match = getActiveBlockVariation(
          firstBlockName,
          getBlockAttributes(clientIds[0])
        );
        _icon = match?.icon || blockType.icon;
        _hasTemplateLock = getTemplateLock(clientIds[0]) === "contentOnly";
      } else {
        const isSelectionOfSameType = new Set(_blocks.map(({ name }) => name)).size === 1;
        _hasTemplateLock = clientIds.some(
          (id) => getTemplateLock(id) === "contentOnly"
        );
        _icon = isSelectionOfSameType ? blockType.icon : copy_default;
      }
      const _isSectionInSelection = clientIds.some(
        (id) => isSectionBlock(id)
      );
      return {
        canRemove: canRemoveBlocks(clientIds),
        hasBlockStyles: _isSingleBlockSelected && !!getBlockStyles(firstBlockName)?.length,
        icon: _icon,
        isReusable: _isSingleBlockSelected && (0,external_wp_blocks_namespaceObject.isReusableBlock)(_blocks[0]),
        isTemplate: _isSingleBlockSelected && (0,external_wp_blocks_namespaceObject.isTemplatePart)(_blocks[0]),
        hasContentOnlyLocking: _hasTemplateLock,
        isDisabled: editingMode !== "default",
        isSectionInSelection: _isSectionInSelection
      };
    },
    [clientIds]
  );
  const blockTitle = useBlockDisplayTitle({
    clientId: clientIds?.[0],
    maximumLength: 35
  });
  const showIconLabels = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(external_wp_preferences_namespaceObject.store).get("core", "showIconLabels"),
    []
  );
  if (invalidBlocks) {
    return null;
  }
  const isSingleBlock = clientIds.length === 1;
  const blockSwitcherLabel = isSingleBlock ? blockTitle : (0,external_wp_i18n_namespaceObject.__)("Multiple blocks selected");
  const blockIndicatorText = (isReusable || isTemplate) && !showIconLabels && blockTitle ? blockTitle : void 0;
  const hideTransformsForSections = window?.__experimentalContentOnlyPatternInsertion && isSectionInSelection;
  const hideDropdown = hideTransformsForSections || isDisabled || !hasBlockStyles && !canRemove || hasContentOnlyLocking;
  if (hideDropdown) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        disabled: true,
        className: "block-editor-block-switcher__no-switcher-icon",
        title: blockSwitcherLabel,
        icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          block_icon_default,
          {
            className: "block-editor-block-switcher__toggle",
            icon,
            showColors: true
          }
        ),
        text: blockIndicatorText
      }
    ) });
  }
  const blockSwitcherDescription = isSingleBlock ? (0,external_wp_i18n_namespaceObject.__)("Change block type or style") : (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %d: number of blocks. */
    (0,external_wp_i18n_namespaceObject._n)(
      "Change type of %d block",
      "Change type of %d blocks",
      clientIds.length
    ),
    clientIds.length
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.DropdownMenu,
    {
      className: "block-editor-block-switcher",
      label: blockSwitcherLabel,
      popoverProps: {
        placement: "bottom-start",
        className: "block-editor-block-switcher__popover"
      },
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_icon_default,
        {
          className: "block-editor-block-switcher__toggle",
          icon,
          showColors: true
        }
      ),
      text: blockIndicatorText,
      toggleProps: {
        description: blockSwitcherDescription,
        ...toggleProps
      },
      menuProps: { orientation: "both" },
      children: ({ onClose }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockSwitcherDropdownMenuContents,
        {
          onClose,
          clientIds,
          hasBlockStyles,
          canRemove
        }
      )
    }
  ) }) });
};
var block_switcher_default = BlockSwitcher;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js

const { Fill: __unstableBlockToolbarLastItem, Slot: block_toolbar_last_item_Slot } = (0,external_wp_components_namespaceObject.createSlotFill)(
  "__unstableBlockToolbarLastItem"
);
__unstableBlockToolbarLastItem.Slot = block_toolbar_last_item_Slot;
var block_toolbar_last_item_default = __unstableBlockToolbarLastItem;


;// ./node_modules/@wordpress/block-editor/build-module/hooks/supports.js


const ALIGN_SUPPORT_KEY = "align";
const ALIGN_WIDE_SUPPORT_KEY = "alignWide";
const supports_BORDER_SUPPORT_KEY = "__experimentalBorder";
const supports_COLOR_SUPPORT_KEY = "color";
const CUSTOM_CLASS_NAME_SUPPORT_KEY = "customClassName";
const supports_FONT_FAMILY_SUPPORT_KEY = "typography.__experimentalFontFamily";
const supports_FONT_SIZE_SUPPORT_KEY = "typography.fontSize";
const supports_LINE_HEIGHT_SUPPORT_KEY = "typography.lineHeight";
const supports_FONT_STYLE_SUPPORT_KEY = "typography.__experimentalFontStyle";
const supports_FONT_WEIGHT_SUPPORT_KEY = "typography.__experimentalFontWeight";
const supports_TEXT_ALIGN_SUPPORT_KEY = "typography.textAlign";
const supports_TEXT_COLUMNS_SUPPORT_KEY = "typography.textColumns";
const supports_TEXT_DECORATION_SUPPORT_KEY = "typography.__experimentalTextDecoration";
const supports_WRITING_MODE_SUPPORT_KEY = "typography.__experimentalWritingMode";
const supports_TEXT_TRANSFORM_SUPPORT_KEY = "typography.__experimentalTextTransform";
const supports_LETTER_SPACING_SUPPORT_KEY = "typography.__experimentalLetterSpacing";
const LAYOUT_SUPPORT_KEY = "layout";
const supports_TYPOGRAPHY_SUPPORT_KEYS = [
  supports_LINE_HEIGHT_SUPPORT_KEY,
  supports_FONT_SIZE_SUPPORT_KEY,
  supports_FONT_STYLE_SUPPORT_KEY,
  supports_FONT_WEIGHT_SUPPORT_KEY,
  supports_FONT_FAMILY_SUPPORT_KEY,
  supports_TEXT_ALIGN_SUPPORT_KEY,
  supports_TEXT_COLUMNS_SUPPORT_KEY,
  supports_TEXT_DECORATION_SUPPORT_KEY,
  supports_TEXT_TRANSFORM_SUPPORT_KEY,
  supports_WRITING_MODE_SUPPORT_KEY,
  supports_LETTER_SPACING_SUPPORT_KEY
];
const EFFECTS_SUPPORT_KEYS = ["shadow"];
const supports_SPACING_SUPPORT_KEY = "spacing";
const supports_styleSupportKeys = [
  ...EFFECTS_SUPPORT_KEYS,
  ...supports_TYPOGRAPHY_SUPPORT_KEYS,
  supports_BORDER_SUPPORT_KEY,
  supports_COLOR_SUPPORT_KEY,
  supports_SPACING_SUPPORT_KEY
];
const hasAlignSupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, ALIGN_SUPPORT_KEY);
const getAlignSupport = (nameOrType) => getBlockSupport(nameOrType, ALIGN_SUPPORT_KEY);
const hasAlignWideSupport = (nameOrType) => hasBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);
const getAlignWideSupport = (nameOrType) => getBlockSupport(nameOrType, ALIGN_WIDE_SUPPORT_KEY);
function supports_hasBorderSupport(nameOrType, feature = "any") {
  if (external_wp_element_namespaceObject.Platform.OS !== "web") {
    return false;
  }
  const support = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_BORDER_SUPPORT_KEY);
  if (support === true) {
    return true;
  }
  if (feature === "any") {
    return !!(support?.color || support?.radius || support?.width || support?.style);
  }
  return !!support?.[feature];
}
const getBorderSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_BORDER_SUPPORT_KEY, feature]);
const supports_hasColorSupport = (nameOrType) => {
  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};
const supports_hasLinkColorSupport = (nameOrType) => {
  if (Platform.OS !== "web") {
    return false;
  }
  const colorSupport = getBlockSupport(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.link;
};
const supports_hasGradientSupport = (nameOrType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === "object" && !!colorSupport.gradients;
};
const supports_hasBackgroundColorSupport = (nameOrType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};
const hasTextAlignSupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, supports_TEXT_ALIGN_SUPPORT_KEY);
const getTextAlignSupport = (nameOrType) => getBlockSupport(nameOrType, supports_TEXT_ALIGN_SUPPORT_KEY);
const supports_hasTextColorSupport = (nameOrType) => {
  const colorSupport = (0,external_wp_blocks_namespaceObject.getBlockSupport)(nameOrType, supports_COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
const getColorSupport = (nameOrType, feature) => getBlockSupport(nameOrType, [supports_COLOR_SUPPORT_KEY, feature]);
const hasCustomClassNameSupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);
const getCustomClassNameSupport = (nameOrType) => getBlockSupport(nameOrType, CUSTOM_CLASS_NAME_SUPPORT_KEY, true);
const hasFontFamilySupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);
const getFontFamilySupport = (nameOrType) => getBlockSupport(nameOrType, supports_FONT_FAMILY_SUPPORT_KEY);
const hasFontSizeSupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);
const getFontSizeSupport = (nameOrType) => getBlockSupport(nameOrType, supports_FONT_SIZE_SUPPORT_KEY);
const hasLayoutSupport = (nameOrType) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, LAYOUT_SUPPORT_KEY);
const getLayoutSupport = (nameOrType) => getBlockSupport(nameOrType, LAYOUT_SUPPORT_KEY);
const supports_hasStyleSupport = (nameOrType) => supports_styleSupportKeys.some((key) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(nameOrType, key));


;// ./node_modules/@wordpress/block-editor/build-module/components/use-paste-styles/index.js







function hasSerializedBlocks(text) {
  try {
    const blocks = (0,external_wp_blocks_namespaceObject.parse)(text, {
      __unstableSkipMigrationLogs: true,
      __unstableSkipAutop: true
    });
    if (blocks.length === 1 && blocks[0].name === "core/freeform") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
const STYLE_ATTRIBUTES = {
  align: hasAlignSupport,
  borderColor: (nameOrType) => supports_hasBorderSupport(nameOrType, "color"),
  backgroundColor: supports_hasBackgroundColorSupport,
  textAlign: hasTextAlignSupport,
  textColor: supports_hasTextColorSupport,
  gradient: supports_hasGradientSupport,
  className: hasCustomClassNameSupport,
  fontFamily: hasFontFamilySupport,
  fontSize: hasFontSizeSupport,
  layout: hasLayoutSupport,
  style: supports_hasStyleSupport
};
function getStyleAttributes(sourceBlock, targetBlock) {
  return Object.entries(STYLE_ATTRIBUTES).reduce(
    (attributes, [attributeKey, hasSupport]) => {
      if (hasSupport(sourceBlock.name) && hasSupport(targetBlock.name)) {
        attributes[attributeKey] = sourceBlock.attributes[attributeKey];
      }
      return attributes;
    },
    {}
  );
}
function recursivelyUpdateBlockAttributes(targetBlocks, sourceBlocks, updateBlockAttributes) {
  for (let index = 0; index < Math.min(sourceBlocks.length, targetBlocks.length); index += 1) {
    updateBlockAttributes(
      targetBlocks[index].clientId,
      getStyleAttributes(sourceBlocks[index], targetBlocks[index])
    );
    recursivelyUpdateBlockAttributes(
      targetBlocks[index].innerBlocks,
      sourceBlocks[index].innerBlocks,
      updateBlockAttributes
    );
  }
}
function usePasteStyles() {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { createSuccessNotice, createWarningNotice, createErrorNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  return (0,external_wp_element_namespaceObject.useCallback)(
    async (targetBlocks) => {
      let html = "";
      try {
        if (!window.navigator.clipboard) {
          createErrorNotice(
            (0,external_wp_i18n_namespaceObject.__)(
              "Unable to paste styles. This feature is only available on secure (https) sites in supporting browsers."
            ),
            { type: "snackbar" }
          );
          return;
        }
        html = await window.navigator.clipboard.readText();
      } catch (error) {
        createErrorNotice(
          (0,external_wp_i18n_namespaceObject.__)(
            "Unable to paste styles. Please allow browser clipboard permissions before continuing."
          ),
          {
            type: "snackbar"
          }
        );
        return;
      }
      if (!html || !hasSerializedBlocks(html)) {
        createWarningNotice(
          (0,external_wp_i18n_namespaceObject.__)(
            "Unable to paste styles. Block styles couldn't be found within the copied content."
          ),
          {
            type: "snackbar"
          }
        );
        return;
      }
      const copiedBlocks = (0,external_wp_blocks_namespaceObject.parse)(html);
      if (copiedBlocks.length === 1) {
        registry.batch(() => {
          recursivelyUpdateBlockAttributes(
            targetBlocks,
            targetBlocks.map(() => copiedBlocks[0]),
            updateBlockAttributes
          );
        });
      } else {
        registry.batch(() => {
          recursivelyUpdateBlockAttributes(
            targetBlocks,
            copiedBlocks,
            updateBlockAttributes
          );
        });
      }
      if (targetBlocks.length === 1) {
        const title = (0,external_wp_blocks_namespaceObject.getBlockType)(targetBlocks[0].name)?.title;
        createSuccessNotice(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            // Translators: %s: Name of the block being pasted, e.g. "Paragraph".
            (0,external_wp_i18n_namespaceObject.__)("Pasted styles to %s."),
            title
          ),
          { type: "snackbar" }
        );
      } else {
        createSuccessNotice(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            // Translators: %d: The number of the blocks.
            (0,external_wp_i18n_namespaceObject.__)("Pasted styles to %d blocks."),
            targetBlocks.length
          ),
          { type: "snackbar" }
        );
      }
    },
    [
      registry.batch,
      updateBlockAttributes,
      createSuccessNotice,
      createWarningNotice,
      createErrorNotice
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js




function BlockActions({
  clientIds,
  children,
  __experimentalUpdateSelection: updateSelection
}) {
  const { getDefaultBlockName, getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const selected = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        canInsertBlockType,
        getBlockRootClientId,
        getBlocksByClientId: getBlocksByClientId2,
        getDirectInsertBlock,
        canRemoveBlocks
      } = select(store);
      const blocks = getBlocksByClientId2(clientIds);
      const rootClientId = getBlockRootClientId(clientIds[0]);
      const canInsertDefaultBlock = canInsertBlockType(
        getDefaultBlockName(),
        rootClientId
      );
      const directInsertBlock = rootClientId ? getDirectInsertBlock(rootClientId) : null;
      return {
        canRemove: canRemoveBlocks(clientIds),
        canInsertBlock: blocks.every((block) => {
          return (canInsertDefaultBlock || !!directInsertBlock) && canInsertBlockType(block.name, rootClientId);
        }),
        canCopyStyles: blocks.every((block) => {
          return !!block && ((0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "color") || (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "typography"));
        }),
        canDuplicate: blocks.every((block) => {
          return !!block && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "multiple", true) && canInsertBlockType(block.name, rootClientId);
        })
      };
    },
    [clientIds, getDefaultBlockName]
  );
  const { getBlocksByClientId, getBlocks } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { canRemove, canInsertBlock, canCopyStyles, canDuplicate } = selected;
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    flashBlock
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const pasteStyles = usePasteStyles();
  return children({
    canCopyStyles,
    canDuplicate,
    canInsertBlock,
    canRemove,
    onDuplicate() {
      return duplicateBlocks(clientIds, updateSelection);
    },
    onRemove() {
      return removeBlocks(clientIds, updateSelection);
    },
    onInsertBefore() {
      insertBeforeBlock(clientIds[0]);
    },
    onInsertAfter() {
      insertAfterBlock(clientIds[clientIds.length - 1]);
    },
    onGroup() {
      if (!clientIds.length) {
        return;
      }
      const groupingBlockName = getGroupingBlockName();
      const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
        getBlocksByClientId(clientIds),
        groupingBlockName
      );
      if (!newBlocks) {
        return;
      }
      replaceBlocks(clientIds, newBlocks);
    },
    onUngroup() {
      if (!clientIds.length) {
        return;
      }
      const innerBlocks = getBlocks(clientIds[0]);
      if (!innerBlocks.length) {
        return;
      }
      replaceBlocks(clientIds, innerBlocks);
    },
    onCopy() {
      if (clientIds.length === 1) {
        flashBlock(clientIds[0]);
      }
    },
    async onPasteStyles() {
      await pasteStyles(getBlocksByClientId(clientIds));
    }
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/collab/block-comment-icon-slot.js

const CommentIconSlotFill = (0,external_wp_components_namespaceObject.createSlotFill)(Symbol("CommentIconSlotFill"));
var block_comment_icon_slot_default = CommentIconSlotFill;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js






function BlockHTMLConvertButton({ clientId }) {
  const block = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getBlock(clientId),
    [clientId]
  );
  const { replaceBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  if (!block || block.name !== "core/html") {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      onClick: () => replaceBlocks(
        clientId,
        (0,external_wp_blocks_namespaceObject.rawHandler)({ HTML: (0,external_wp_blocks_namespaceObject.getBlockContent)(block) })
      ),
      children: (0,external_wp_i18n_namespaceObject.__)("Convert to Blocks")
    }
  );
}
var block_html_convert_button_default = BlockHTMLConvertButton;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js

const { Fill: __unstableBlockSettingsMenuFirstItem, Slot: block_settings_menu_first_item_Slot } = (0,external_wp_components_namespaceObject.createSlotFill)(
  "__unstableBlockSettingsMenuFirstItem"
);
__unstableBlockSettingsMenuFirstItem.Slot = block_settings_menu_first_item_Slot;
var block_settings_menu_first_item_default = __unstableBlockSettingsMenuFirstItem;


;// ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js



function useConvertToGroupButtonProps(selectedClientIds) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlocksByClientId,
        getSelectedBlockClientIds,
        isUngroupable,
        isGroupable
      } = select(store);
      const { getGroupingBlockName, getBlockType } = select(external_wp_blocks_namespaceObject.store);
      const clientIds = selectedClientIds?.length ? selectedClientIds : getSelectedBlockClientIds();
      const blocksSelection = getBlocksByClientId(clientIds);
      const [firstSelectedBlock] = blocksSelection;
      const _isUngroupable = clientIds.length === 1 && isUngroupable(clientIds[0]);
      return {
        clientIds,
        isGroupable: isGroupable(clientIds),
        isUngroupable: _isUngroupable,
        blocksSelection,
        groupingBlockName: getGroupingBlockName(),
        onUngroup: _isUngroupable && getBlockType(firstSelectedBlock.name)?.transforms?.ungroup
      };
    },
    [selectedClientIds]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js









function ConvertToGroupButton({
  clientIds,
  isGroupable,
  isUngroupable,
  onUngroup,
  blocksSelection,
  groupingBlockName,
  onClose = () => {
  }
}) {
  const { getSelectedBlockClientIds } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { replaceBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onConvertToGroup = () => {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
      blocksSelection,
      groupingBlockName
    );
    if (newBlocks) {
      replaceBlocks(clientIds, newBlocks);
    }
  };
  const onConvertFromGroup = () => {
    let innerBlocks = blocksSelection[0].innerBlocks;
    if (!innerBlocks.length) {
      return;
    }
    if (onUngroup) {
      innerBlocks = onUngroup(
        blocksSelection[0].attributes,
        blocksSelection[0].innerBlocks
      );
    }
    replaceBlocks(clientIds, innerBlocks);
  };
  if (!isGroupable && !isUngroupable) {
    return null;
  }
  const selectedBlockClientIds = getSelectedBlockClientIds();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    isGroupable && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        shortcut: selectedBlockClientIds.length > 1 ? external_wp_keycodes_namespaceObject.displayShortcut.primary("g") : void 0,
        onClick: () => {
          onConvertToGroup();
          onClose();
        },
        children: (0,external_wp_i18n_namespaceObject._x)("Group", "verb")
      }
    ),
    isUngroupable && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        onClick: () => {
          onConvertFromGroup();
          onClose();
        },
        children: (0,external_wp_i18n_namespaceObject._x)(
          "Ungroup",
          "Ungrouping blocks from within a grouping block back into individual blocks within the Editor"
        )
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-lock/use-block-lock.js


function useBlockLock(clientId) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        canEditBlock,
        canMoveBlock,
        canRemoveBlock,
        canLockBlockType,
        getBlockName,
        getTemplateLock
      } = select(store);
      const canEdit = canEditBlock(clientId);
      const canMove = canMoveBlock(clientId);
      const canRemove = canRemoveBlock(clientId);
      return {
        canEdit,
        canMove,
        canRemove,
        canLock: canLockBlockType(getBlockName(clientId)),
        isContentLocked: getTemplateLock(clientId) === "contentOnly",
        isLocked: !canEdit || !canMove || !canRemove
      };
    },
    [clientId]
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/unlock.js


var unlock_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/lock-outline.js


var lock_outline_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zM9.8 7c0-1.2 1-2.2 2.2-2.2 1.2 0 2.2 1 2.2 2.2v3H9.8V7zm6.7 11.5h-9v-7h9v7z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/lock.js


var lock_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-lock/modal.js










const ALLOWS_EDIT_LOCKING = ["core/navigation"];
function getTemplateLockValue(lock) {
  if (lock.remove && lock.move) {
    return "all";
  }
  if (lock.remove && !lock.move) {
    return "insert";
  }
  return false;
}
function BlockLockModal({ clientId, onClose }) {
  const [lock, setLock] = (0,external_wp_element_namespaceObject.useState)({ move: false, remove: false });
  const { canEdit, canMove, canRemove } = useBlockLock(clientId);
  const { allowsEditLocking, templateLock, hasTemplateLock } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockName, getBlockAttributes } = select(store);
      const blockName = getBlockName(clientId);
      const blockType = (0,external_wp_blocks_namespaceObject.getBlockType)(blockName);
      return {
        allowsEditLocking: ALLOWS_EDIT_LOCKING.includes(blockName),
        templateLock: getBlockAttributes(clientId)?.templateLock,
        hasTemplateLock: !!blockType?.attributes?.templateLock
      };
    },
    [clientId]
  );
  const [applyTemplateLock, setApplyTemplateLock] = (0,external_wp_element_namespaceObject.useState)(
    !!templateLock
  );
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockInformation = useBlockDisplayInformation(clientId);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setLock({
      move: !canMove,
      remove: !canRemove,
      ...allowsEditLocking ? { edit: !canEdit } : {}
    });
  }, [canEdit, canMove, canRemove, allowsEditLocking]);
  const isAllChecked = Object.values(lock).every(Boolean);
  const isMixed = Object.values(lock).some(Boolean) && !isAllChecked;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: Name of the block. */
        (0,external_wp_i18n_namespaceObject.__)("Lock %s"),
        blockInformation.title
      ),
      overlayClassName: "block-editor-block-lock-modal",
      onRequestClose: onClose,
      size: "small",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        "form",
        {
          onSubmit: (event) => {
            event.preventDefault();
            updateBlockAttributes([clientId], {
              lock,
              templateLock: applyTemplateLock ? getTemplateLockValue(lock) : void 0
            });
            onClose();
          },
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-block-lock-modal__options", children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("legend", { children: (0,external_wp_i18n_namespaceObject.__)("Select the features you want to lock") }),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                "ul",
                {
                  role: "list",
                  className: "block-editor-block-lock-modal__checklist",
                  children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { children: [
                    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                      external_wp_components_namespaceObject.CheckboxControl,
                      {
                        __nextHasNoMarginBottom: true,
                        className: "block-editor-block-lock-modal__options-all",
                        label: (0,external_wp_i18n_namespaceObject.__)("Lock all"),
                        checked: isAllChecked,
                        indeterminate: isMixed,
                        onChange: (newValue) => setLock({
                          move: newValue,
                          remove: newValue,
                          ...allowsEditLocking ? { edit: newValue } : {}
                        })
                      }
                    ),
                    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
                      "ul",
                      {
                        role: "list",
                        className: "block-editor-block-lock-modal__checklist",
                        children: [
                          allowsEditLocking && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.CheckboxControl,
                              {
                                __nextHasNoMarginBottom: true,
                                label: (0,external_wp_i18n_namespaceObject.__)("Lock editing"),
                                checked: !!lock.edit,
                                onChange: (edit) => setLock((prevLock) => ({
                                  ...prevLock,
                                  edit
                                }))
                              }
                            ),
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.Icon,
                              {
                                className: "block-editor-block-lock-modal__lock-icon",
                                icon: lock.edit ? lock_default : unlock_default
                              }
                            )
                          ] }),
                          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.CheckboxControl,
                              {
                                __nextHasNoMarginBottom: true,
                                label: (0,external_wp_i18n_namespaceObject.__)("Lock movement"),
                                checked: lock.move,
                                onChange: (move) => setLock((prevLock) => ({
                                  ...prevLock,
                                  move
                                }))
                              }
                            ),
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.Icon,
                              {
                                className: "block-editor-block-lock-modal__lock-icon",
                                icon: lock.move ? lock_default : unlock_default
                              }
                            )
                          ] }),
                          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { className: "block-editor-block-lock-modal__checklist-item", children: [
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.CheckboxControl,
                              {
                                __nextHasNoMarginBottom: true,
                                label: (0,external_wp_i18n_namespaceObject.__)("Lock removal"),
                                checked: lock.remove,
                                onChange: (remove) => setLock((prevLock) => ({
                                  ...prevLock,
                                  remove
                                }))
                              }
                            ),
                            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                              external_wp_components_namespaceObject.Icon,
                              {
                                className: "block-editor-block-lock-modal__lock-icon",
                                icon: lock.remove ? lock_default : unlock_default
                              }
                            )
                          ] })
                        ]
                      }
                    )
                  ] })
                }
              ),
              hasTemplateLock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.ToggleControl,
                {
                  __nextHasNoMarginBottom: true,
                  className: "block-editor-block-lock-modal__template-lock",
                  label: (0,external_wp_i18n_namespaceObject.__)("Apply to all blocks inside"),
                  checked: applyTemplateLock,
                  disabled: lock.move && !lock.remove,
                  onChange: () => setApplyTemplateLock(!applyTemplateLock)
                }
              )
            ] }),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
              external_wp_components_namespaceObject.Flex,
              {
                className: "block-editor-block-lock-modal__actions",
                justify: "flex-end",
                expanded: false,
                children: [
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.Button,
                    {
                      variant: "tertiary",
                      onClick: onClose,
                      __next40pxDefaultSize: true,
                      children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
                    }
                  ) }),
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.Button,
                    {
                      variant: "primary",
                      type: "submit",
                      __next40pxDefaultSize: true,
                      children: (0,external_wp_i18n_namespaceObject.__)("Apply")
                    }
                  ) })
                ]
              }
            )
          ]
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-lock/menu-item.js







function BlockLockMenuItem({ clientId }) {
  const { canLock, isLocked } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,external_wp_element_namespaceObject.useReducer)(
    (isActive) => !isActive,
    false
  );
  if (!canLock) {
    return null;
  }
  const label = isLocked ? (0,external_wp_i18n_namespaceObject.__)("Unlock") : (0,external_wp_i18n_namespaceObject.__)("Lock");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        icon: isLocked ? unlock_default : lock_outline_default,
        onClick: toggleModal,
        "aria-expanded": isModalOpen,
        "aria-haspopup": "dialog",
        children: label
      }
    ),
    isModalOpen && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockLockModal, { clientId, onClose: toggleModal })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js






const block_mode_toggle_noop = () => {
};
function BlockModeToggle({ clientId, onToggle = block_mode_toggle_noop }) {
  const { blockType, mode, enabled } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlock, getBlockMode, getSettings } = select(store);
      const block = getBlock(clientId);
      return {
        mode: getBlockMode(clientId),
        blockType: block ? (0,external_wp_blocks_namespaceObject.getBlockType)(block.name) : null,
        enabled: getSettings().codeEditingEnabled && !!block?.isValid
      };
    },
    [clientId]
  );
  const { toggleBlockMode } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  if (!blockType || !(0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "html", true) || !enabled) {
    return null;
  }
  const label = mode === "visual" ? (0,external_wp_i18n_namespaceObject.__)("Edit as HTML") : (0,external_wp_i18n_namespaceObject.__)("Edit visually");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      onClick: () => {
        toggleBlockMode(clientId);
        onToggle();
      },
      children: label
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/content-lock/modify-content-lock-menu-item.js






function ModifyContentLockMenuItem({ clientId, onClose }) {
  const { templateLock, isLockedByParent, isEditingAsBlocks } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getContentLockingParent,
        getTemplateLock,
        getTemporarilyEditingAsBlocks
      } = unlock(select(store));
      return {
        templateLock: getTemplateLock(clientId),
        isLockedByParent: !!getContentLockingParent(clientId),
        isEditingAsBlocks: getTemporarilyEditingAsBlocks() === clientId
      };
    },
    [clientId]
  );
  const blockEditorActions = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isContentLocked = !isLockedByParent && templateLock === "contentOnly";
  if (!isContentLocked && !isEditingAsBlocks) {
    return null;
  }
  const { modifyContentLockBlock } = unlock(blockEditorActions);
  const showStartEditingAsBlocks = !isEditingAsBlocks && isContentLocked;
  return showStartEditingAsBlocks && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      onClick: () => {
        modifyContentLockBlock(clientId);
        onClose();
      },
      children: (0,external_wp_i18n_namespaceObject._x)("Modify", "Unlock content locked blocks")
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-rename/use-block-rename.js

function useBlockRename(name) {
  return {
    canRename: (0,external_wp_blocks_namespaceObject.getBlockSupport)(name, "renaming", true)
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-rename/is-empty-string.js
function isEmptyString(testString) {
  return testString?.trim()?.length === 0;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-rename/modal.js










function BlockRenameModal({ clientId, onClose }) {
  const [editedBlockName, setEditedBlockName] = (0,external_wp_element_namespaceObject.useState)();
  const blockInformation = useBlockDisplayInformation(clientId);
  const { metadata } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockAttributes } = select(store);
      return {
        metadata: getBlockAttributes(clientId)?.metadata
      };
    },
    [clientId]
  );
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const blockName = metadata?.name || "";
  const originalBlockName = blockInformation?.title;
  const hasOverridesWarning = !!blockName && !!metadata?.bindings && Object.values(metadata.bindings).some(
    (binding) => binding.source === "core/pattern-overrides"
  );
  const nameHasChanged = editedBlockName !== void 0 && editedBlockName !== blockName;
  const nameIsOriginal = editedBlockName === originalBlockName;
  const nameIsEmpty = isEmptyString(editedBlockName);
  const isNameValid = nameHasChanged || nameIsOriginal;
  const autoSelectInputText = (event) => event.target.select();
  const handleSubmit = () => {
    const newName = nameIsOriginal || nameIsEmpty ? void 0 : editedBlockName;
    const message = nameIsOriginal || nameIsEmpty ? (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %s: new name/label for the block */
      (0,external_wp_i18n_namespaceObject.__)('Block name reset to: "%s".'),
      editedBlockName
    ) : (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: %s: new name/label for the block */
      (0,external_wp_i18n_namespaceObject.__)('Block name changed to: "%s".'),
      editedBlockName
    );
    (0,external_wp_a11y_namespaceObject.speak)(message, "assertive");
    updateBlockAttributes([clientId], {
      metadata: utils_cleanEmptyObject({
        ...metadata,
        name: newName
      })
    });
    onClose();
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.__)("Rename"),
      onRequestClose: onClose,
      overlayClassName: "block-editor-block-rename-modal",
      focusOnMount: "firstContentElement",
      size: "small",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "form",
        {
          onSubmit: (e) => {
            e.preventDefault();
            if (!isNameValid) {
              return;
            }
            handleSubmit();
          },
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: "3", children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.TextControl,
              {
                __nextHasNoMarginBottom: true,
                __next40pxDefaultSize: true,
                value: editedBlockName ?? blockName,
                label: (0,external_wp_i18n_namespaceObject.__)("Name"),
                help: hasOverridesWarning ? (0,external_wp_i18n_namespaceObject.__)(
                  "This block allows overrides. Changing the name can cause problems with content entered into instances of this pattern."
                ) : void 0,
                placeholder: originalBlockName,
                onChange: setEditedBlockName,
                onFocus: autoSelectInputText
              }
            ),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "right", children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "tertiary",
                  onClick: onClose,
                  children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  accessibleWhenDisabled: true,
                  disabled: !isNameValid,
                  variant: "primary",
                  type: "submit",
                  children: (0,external_wp_i18n_namespaceObject.__)("Save")
                }
              )
            ] })
          ] })
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-rename/rename-control.js





function BlockRenameControl({ clientId }) {
  const [renamingBlock, setRenamingBlock] = (0,external_wp_element_namespaceObject.useState)(false);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.MenuItem,
      {
        onClick: () => {
          setRenamingBlock(true);
        },
        "aria-expanded": renamingBlock,
        "aria-haspopup": "dialog",
        children: (0,external_wp_i18n_namespaceObject.__)("Rename")
      }
    ),
    renamingBlock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockRenameModal,
      {
        clientId,
        onClose: () => setRenamingBlock(false)
      }
    )
  ] });
}


;// ./node_modules/@wordpress/icons/build-module/library/seen.js


var seen_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M3.99961 13C4.67043 13.3354 4.6703 13.3357 4.67017 13.3359L4.67298 13.3305C4.67621 13.3242 4.68184 13.3135 4.68988 13.2985C4.70595 13.2686 4.7316 13.2218 4.76695 13.1608C4.8377 13.0385 4.94692 12.8592 5.09541 12.6419C5.39312 12.2062 5.84436 11.624 6.45435 11.0431C7.67308 9.88241 9.49719 8.75 11.9996 8.75C14.502 8.75 16.3261 9.88241 17.5449 11.0431C18.1549 11.624 18.6061 12.2062 18.9038 12.6419C19.0523 12.8592 19.1615 13.0385 19.2323 13.1608C19.2676 13.2218 19.2933 13.2686 19.3093 13.2985C19.3174 13.3135 19.323 13.3242 19.3262 13.3305L19.3291 13.3359C19.3289 13.3357 19.3288 13.3354 19.9996 13C20.6704 12.6646 20.6703 12.6643 20.6701 12.664L20.6697 12.6632L20.6688 12.6614L20.6662 12.6563L20.6583 12.6408C20.6517 12.6282 20.6427 12.6108 20.631 12.5892C20.6078 12.5459 20.5744 12.4852 20.5306 12.4096C20.4432 12.2584 20.3141 12.0471 20.1423 11.7956C19.7994 11.2938 19.2819 10.626 18.5794 9.9569C17.1731 8.61759 14.9972 7.25 11.9996 7.25C9.00203 7.25 6.82614 8.61759 5.41987 9.9569C4.71736 10.626 4.19984 11.2938 3.85694 11.7956C3.68511 12.0471 3.55605 12.2584 3.4686 12.4096C3.42484 12.4852 3.39142 12.5459 3.36818 12.5892C3.35656 12.6108 3.34748 12.6282 3.34092 12.6408L3.33297 12.6563L3.33041 12.6614L3.32948 12.6632L3.32911 12.664C3.32894 12.6643 3.32879 12.6646 3.99961 13ZM11.9996 16C13.9326 16 15.4996 14.433 15.4996 12.5C15.4996 10.567 13.9326 9 11.9996 9C10.0666 9 8.49961 10.567 8.49961 12.5C8.49961 14.433 10.0666 16 11.9996 16Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/unseen.js


var unseen_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M20.7 12.7s0-.1-.1-.2c0-.2-.2-.4-.4-.6-.3-.5-.9-1.2-1.6-1.8-.7-.6-1.5-1.3-2.6-1.8l-.6 1.4c.9.4 1.6 1 2.1 1.5.6.6 1.1 1.2 1.4 1.6.1.2.3.4.3.5v.1l.7-.3.7-.3Zm-5.2-9.3-1.8 4c-.5-.1-1.1-.2-1.7-.2-3 0-5.2 1.4-6.6 2.7-.7.7-1.2 1.3-1.6 1.8-.2.3-.3.5-.4.6 0 0 0 .1-.1.2s0 0 .7.3l.7.3V13c0-.1.2-.3.3-.5.3-.4.7-1 1.4-1.6 1.2-1.2 3-2.3 5.5-2.3H13v.3c-.4 0-.8-.1-1.1-.1-1.9 0-3.5 1.6-3.5 3.5s.6 2.3 1.6 2.9l-2 4.4.9.4 7.6-16.2-.9-.4Zm-3 12.6c1.7-.2 3-1.7 3-3.5s-.2-1.4-.6-1.9L12.4 16Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-visibility/menu-item.js









function BlockVisibilityMenuItem({ clientIds }) {
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { createSuccessNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const blocks = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return select(store).getBlocksByClientId(clientIds);
    },
    [clientIds]
  );
  const listViewShortcut = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    return select(external_wp_keyboardShortcuts_namespaceObject.store).getShortcutRepresentation(
      "core/editor/toggle-list-view"
    );
  }, []);
  const hasHiddenBlock = blocks.some(
    (block) => block.attributes.metadata?.blockVisibility === false
  );
  const toggleBlockVisibility = () => {
    const isHiding = !hasHiddenBlock;
    const attributesByClientId = Object.fromEntries(
      blocks?.map(({ clientId, attributes }) => [
        clientId,
        {
          metadata: utils_cleanEmptyObject({
            ...attributes?.metadata,
            blockVisibility: isHiding ? false : void 0
          })
        }
      ])
    );
    updateBlockAttributes(clientIds, attributesByClientId, {
      uniqueByBlock: true
    });
    if (isHiding) {
      if (blocks.length > 1) {
        createSuccessNotice(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: The shortcut key to access the List View.
            (0,external_wp_i18n_namespaceObject.__)(
              "Blocks hidden. You can access them via the List View (%s)."
            ),
            listViewShortcut
          ),
          {
            id: "block-visibility-hidden",
            type: "snackbar"
          }
        );
      } else {
        createSuccessNotice(
          (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: The shortcut key to access the List View.
            (0,external_wp_i18n_namespaceObject.__)(
              "Block hidden. You can access it via the List View (%s)."
            ),
            listViewShortcut
          ),
          {
            id: "block-visibility-hidden",
            type: "snackbar"
          }
        );
      }
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      icon: hasHiddenBlock ? seen_default : unseen_default,
      onClick: toggleBlockVisibility,
      children: hasHiddenBlock ? (0,external_wp_i18n_namespaceObject.__)("Show") : (0,external_wp_i18n_namespaceObject.__)("Hide")
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js











const { Fill, Slot: block_settings_menu_controls_Slot } = (0,external_wp_components_namespaceObject.createSlotFill)("BlockSettingsMenuControls");
const BlockSettingsMenuControlsSlot = ({ fillProps, clientIds = null }) => {
  const {
    selectedBlocks,
    selectedClientIds,
    isContentOnly,
    canToggleSelectedBlocksVisibility
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlocksByClientId,
        getBlockNamesByClientId,
        getSelectedBlockClientIds,
        getBlockEditingMode
      } = select(store);
      const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds();
      return {
        selectedBlocks: getBlockNamesByClientId(ids),
        selectedClientIds: ids,
        isContentOnly: getBlockEditingMode(ids[0]) === "contentOnly",
        canToggleSelectedBlocksVisibility: getBlocksByClientId(
          ids
        ).every(
          (block) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "visibility", true)
        )
      };
    },
    [clientIds]
  );
  const { canLock } = useBlockLock(selectedClientIds[0]);
  const { canRename } = useBlockRename(selectedBlocks[0]);
  const showLockButton = selectedClientIds.length === 1 && canLock && !isContentOnly;
  const showRenameButton = selectedClientIds.length === 1 && canRename && !isContentOnly;
  const showVisibilityButton = canToggleSelectedBlocksVisibility && !isContentOnly;
  const convertToGroupButtonProps = useConvertToGroupButtonProps(selectedClientIds);
  const { isGroupable, isUngroupable } = convertToGroupButtonProps;
  const showConvertToGroupButton = (isGroupable || isUngroupable) && !isContentOnly;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    block_settings_menu_controls_Slot,
    {
      fillProps: {
        ...fillProps,
        selectedBlocks,
        selectedClientIds
      },
      children: (fills) => {
        if (!fills?.length > 0 && !showConvertToGroupButton && !showLockButton) {
          return null;
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { children: [
          showConvertToGroupButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ConvertToGroupButton,
            {
              ...convertToGroupButtonProps,
              onClose: fillProps?.onClose
            }
          ),
          showLockButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockLockMenuItem,
            {
              clientId: selectedClientIds[0]
            }
          ),
          showRenameButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockRenameControl,
            {
              clientId: selectedClientIds[0]
            }
          ),
          showVisibilityButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockVisibilityMenuItem,
            {
              clientIds: selectedClientIds
            }
          ),
          fills,
          selectedClientIds.length === 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            ModifyContentLockMenuItem,
            {
              clientId: selectedClientIds[0],
              onClose: fillProps?.onClose
            }
          ),
          fillProps?.count === 1 && !isContentOnly && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockModeToggle,
            {
              clientId: fillProps?.firstBlockClientId,
              onToggle: fillProps?.onClose
            }
          )
        ] });
      }
    }
  );
};
function BlockSettingsMenuControls({ ...props }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalStyleProvider, { document, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Fill, { ...props }) });
}
BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
var block_settings_menu_controls_default = BlockSettingsMenuControls;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-parent-selector-menu-item.js









function BlockParentSelectorMenuItem({
  parentClientId,
  parentBlockType
}) {
  const isSmallViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const menuItemRef = (0,external_wp_element_namespaceObject.useRef)();
  const gesturesProps = useShowHoveredOrFocusedGestures({
    ref: menuItemRef,
    highlightParent: true
  });
  if (!isSmallViewport) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      ...gesturesProps,
      ref: menuItemRef,
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: parentBlockType.icon }),
      onClick: () => selectBlock(parentClientId),
      children: (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: Name of the block's parent. */
        (0,external_wp_i18n_namespaceObject.__)("Select parent block (%s)"),
        parentBlockType.title
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js


















const block_settings_dropdown_POPOVER_PROPS = {
  className: "block-editor-block-settings-menu__popover",
  placement: "bottom-start"
};
function CopyMenuItem({
  clientIds,
  onCopy,
  label,
  shortcut,
  eventType = "copy",
  __experimentalUpdateSelection: updateSelection = false
}) {
  const { getBlocksByClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { removeBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const notifyCopy = useNotifyCopy();
  const ref = (0,external_wp_compose_namespaceObject.useCopyToClipboard)(
    () => (0,external_wp_blocks_namespaceObject.serialize)(getBlocksByClientId(clientIds)),
    () => {
      switch (eventType) {
        case "copy":
        case "copyStyles":
          onCopy();
          notifyCopy(eventType, clientIds);
          break;
        case "cut":
          notifyCopy(eventType, clientIds);
          removeBlocks(clientIds, updateSelection);
          break;
        default:
          break;
      }
    }
  );
  const copyMenuItemLabel = label ? label : (0,external_wp_i18n_namespaceObject.__)("Copy");
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuItem, { ref, shortcut, children: copyMenuItemLabel });
}
function BlockSettingsDropdown({
  block,
  clientIds,
  children,
  __experimentalSelectBlock,
  ...props
}) {
  const currentClientId = block?.clientId;
  const count = clientIds.length;
  const firstBlockClientId = clientIds[0];
  const {
    firstParentClientId,
    parentBlockType,
    previousBlockClientId,
    selectedBlockClientIds,
    openedBlockSettingsMenu,
    isContentOnly,
    isZoomOut
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockName,
        getBlockRootClientId,
        getPreviousBlockClientId,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        getBlockAttributes,
        getOpenedBlockSettingsMenu,
        getBlockEditingMode,
        isZoomOut: _isZoomOut
      } = unlock(select(store));
      const { getActiveBlockVariation } = select(external_wp_blocks_namespaceObject.store);
      const _firstParentClientId = getBlockRootClientId(firstBlockClientId);
      const parentBlockName = _firstParentClientId && getBlockName(_firstParentClientId);
      return {
        firstParentClientId: _firstParentClientId,
        parentBlockType: _firstParentClientId && (getActiveBlockVariation(
          parentBlockName,
          getBlockAttributes(_firstParentClientId)
        ) || (0,external_wp_blocks_namespaceObject.getBlockType)(parentBlockName)),
        previousBlockClientId: getPreviousBlockClientId(firstBlockClientId),
        selectedBlockClientIds: getSelectedBlockClientIds2(),
        openedBlockSettingsMenu: getOpenedBlockSettingsMenu(),
        isContentOnly: getBlockEditingMode(firstBlockClientId) === "contentOnly",
        isZoomOut: _isZoomOut()
      };
    },
    [firstBlockClientId]
  );
  const { getBlockOrder, getSelectedBlockClientIds } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { setOpenedBlockSettingsMenu } = unlock(
    (0,external_wp_data_namespaceObject.useDispatch)(store)
  );
  const shortcuts = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getShortcutRepresentation } = select(external_wp_keyboardShortcuts_namespaceObject.store);
    return {
      copy: getShortcutRepresentation("core/block-editor/copy"),
      cut: getShortcutRepresentation("core/block-editor/cut"),
      duplicate: getShortcutRepresentation(
        "core/block-editor/duplicate"
      ),
      remove: getShortcutRepresentation("core/block-editor/remove"),
      insertAfter: getShortcutRepresentation(
        "core/block-editor/insert-after"
      ),
      insertBefore: getShortcutRepresentation(
        "core/block-editor/insert-before"
      )
    };
  }, []);
  const hasSelectedBlocks = selectedBlockClientIds.length > 0;
  async function updateSelectionAfterDuplicate(clientIdsPromise) {
    if (!__experimentalSelectBlock) {
      return;
    }
    const ids = await clientIdsPromise;
    if (ids && ids[0]) {
      __experimentalSelectBlock(ids[0], false);
    }
  }
  function updateSelectionAfterRemove() {
    if (!__experimentalSelectBlock) {
      return;
    }
    let blockToFocus = previousBlockClientId || firstParentClientId;
    if (!blockToFocus) {
      blockToFocus = getBlockOrder()[0];
    }
    const shouldUpdateSelection = hasSelectedBlocks && getSelectedBlockClientIds().length === 0;
    __experimentalSelectBlock(blockToFocus, shouldUpdateSelection);
  }
  const parentBlockIsSelected = selectedBlockClientIds?.includes(firstParentClientId);
  const open = !currentClientId ? void 0 : openedBlockSettingsMenu === currentClientId || false;
  function onToggle(localOpen) {
    if (localOpen && openedBlockSettingsMenu !== currentClientId) {
      setOpenedBlockSettingsMenu(currentClientId);
    } else if (!localOpen && openedBlockSettingsMenu && openedBlockSettingsMenu === currentClientId) {
      setOpenedBlockSettingsMenu(void 0);
    }
  }
  const shouldShowBlockParentMenuItem = !parentBlockIsSelected && !!firstParentClientId;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockActions,
    {
      clientIds,
      __experimentalUpdateSelection: !__experimentalSelectBlock,
      children: ({
        canCopyStyles,
        canDuplicate,
        canInsertBlock,
        canRemove,
        onDuplicate,
        onInsertAfter,
        onInsertBefore,
        onRemove,
        onCopy,
        onPasteStyles
      }) => {
        const isEmpty = !canRemove && !canDuplicate && !canInsertBlock && isContentOnly;
        if (isEmpty) {
          return null;
        }
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.DropdownMenu,
          {
            icon: more_vertical_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Options"),
            className: "block-editor-block-settings-menu",
            popoverProps: block_settings_dropdown_POPOVER_PROPS,
            open,
            onToggle,
            noIcons: true,
            ...props,
            children: ({ onClose }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  block_settings_menu_first_item_default.Slot,
                  {
                    fillProps: { onClose }
                  }
                ),
                shouldShowBlockParentMenuItem && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  BlockParentSelectorMenuItem,
                  {
                    parentClientId: firstParentClientId,
                    parentBlockType
                  }
                ),
                count === 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  block_html_convert_button_default,
                  {
                    clientId: firstBlockClientId
                  }
                ),
                !isContentOnly && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  CopyMenuItem,
                  {
                    clientIds,
                    onCopy,
                    shortcut: shortcuts.copy
                  }
                ),
                !isContentOnly && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  CopyMenuItem,
                  {
                    clientIds,
                    label: (0,external_wp_i18n_namespaceObject.__)("Cut"),
                    eventType: "cut",
                    shortcut: shortcuts.cut,
                    __experimentalUpdateSelection: !__experimentalSelectBlock
                  }
                ),
                canDuplicate && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.MenuItem,
                  {
                    onClick: (0,external_wp_compose_namespaceObject.pipe)(
                      onClose,
                      onDuplicate,
                      updateSelectionAfterDuplicate
                    ),
                    shortcut: shortcuts.duplicate,
                    children: (0,external_wp_i18n_namespaceObject.__)("Duplicate")
                  }
                ),
                canInsertBlock && !isZoomOut && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.MenuItem,
                    {
                      onClick: (0,external_wp_compose_namespaceObject.pipe)(
                        onClose,
                        onInsertBefore
                      ),
                      shortcut: shortcuts.insertBefore,
                      children: (0,external_wp_i18n_namespaceObject.__)("Add before")
                    }
                  ),
                  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    external_wp_components_namespaceObject.MenuItem,
                    {
                      onClick: (0,external_wp_compose_namespaceObject.pipe)(
                        onClose,
                        onInsertAfter
                      ),
                      shortcut: shortcuts.insertAfter,
                      children: (0,external_wp_i18n_namespaceObject.__)("Add after")
                    }
                  )
                ] }),
                count === 1 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  block_comment_icon_slot_default.Slot,
                  {
                    fillProps: {
                      clientId: firstBlockClientId,
                      onClose
                    }
                  }
                )
              ] }),
              canCopyStyles && !isContentOnly && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.MenuGroup, { children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  CopyMenuItem,
                  {
                    clientIds,
                    onCopy,
                    label: (0,external_wp_i18n_namespaceObject.__)("Copy styles"),
                    eventType: "copyStyles"
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuItem, { onClick: onPasteStyles, children: (0,external_wp_i18n_namespaceObject.__)("Paste styles") })
              ] }),
              !isContentOnly && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                block_settings_menu_controls_default.Slot,
                {
                  fillProps: {
                    onClose,
                    count,
                    firstBlockClientId
                  },
                  clientIds
                }
              ),
              typeof children === "function" ? children({ onClose }) : external_wp_element_namespaceObject.Children.map(
                (child) => (0,external_wp_element_namespaceObject.cloneElement)(child, { onClose })
              ),
              canRemove && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.MenuItem,
                {
                  onClick: (0,external_wp_compose_namespaceObject.pipe)(
                    onClose,
                    onRemove,
                    updateSelectionAfterRemove
                  ),
                  shortcut: shortcuts.remove,
                  children: (0,external_wp_i18n_namespaceObject.__)("Delete")
                }
              ) })
            ] })
          }
        );
      }
    }
  );
}
var block_settings_dropdown_default = BlockSettingsDropdown;


;// ./node_modules/@wordpress/block-editor/build-module/components/collab/block-comment-icon-toolbar-slot.js

const CommentIconToolbarSlotFill = (0,external_wp_components_namespaceObject.createSlotFill)(
  Symbol("CommentIconToolbarSlotFill")
);
var block_comment_icon_toolbar_slot_default = CommentIconToolbarSlotFill;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js




function BlockSettingsMenu({ clientIds, ...props }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.ToolbarGroup, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_comment_icon_toolbar_slot_default.Slot, {}),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_settings_dropdown_default,
      {
        clientIds,
        toggleProps,
        ...props
      }
    ) })
  ] });
}
var block_settings_menu_default = BlockSettingsMenu;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-lock/toolbar.js







function BlockLockToolbar({ clientId }) {
  const { canLock, isLocked } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,external_wp_element_namespaceObject.useReducer)(
    (isActive) => !isActive,
    false
  );
  const hasLockButtonShownRef = (0,external_wp_element_namespaceObject.useRef)(false);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (isLocked) {
      hasLockButtonShownRef.current = true;
    }
  }, [isLocked]);
  if (!isLocked && !hasLockButtonShownRef.current) {
    return null;
  }
  let label = isLocked ? (0,external_wp_i18n_namespaceObject.__)("Unlock") : (0,external_wp_i18n_namespaceObject.__)("Lock");
  if (!canLock && isLocked) {
    label = (0,external_wp_i18n_namespaceObject.__)("Locked");
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { className: "block-editor-block-lock-toolbar", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        disabled: !canLock,
        icon: isLocked ? lock_default : unlock_default,
        label,
        onClick: toggleModal,
        "aria-expanded": isModalOpen,
        "aria-haspopup": "dialog"
      }
    ) }),
    isModalOpen && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockLockModal, { clientId, onClose: toggleModal })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-visibility/toolbar.js









function BlockVisibilityToolbar({ clientIds }) {
  const { blocks, canToggleBlockVisibility } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockName, getBlocksByClientId } = select(store);
      const _blocks = getBlocksByClientId(clientIds);
      return {
        blocks: _blocks,
        canToggleBlockVisibility: _blocks.every(
          ({ clientId }) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
            getBlockName(clientId),
            "visibility",
            true
          )
        )
      };
    },
    [clientIds]
  );
  const hasHiddenBlock = blocks.some(
    (block) => block.attributes.metadata?.blockVisibility === false
  );
  const hasBlockVisibilityButtonShownRef = (0,external_wp_element_namespaceObject.useRef)(false);
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (hasHiddenBlock) {
      hasBlockVisibilityButtonShownRef.current = true;
    }
  }, [hasHiddenBlock]);
  if (!hasHiddenBlock && !hasBlockVisibilityButtonShownRef.current) {
    return null;
  }
  const toggleBlockVisibility = () => {
    const attributesByClientId = Object.fromEntries(
      blocks?.map(({ clientId, attributes }) => [
        clientId,
        {
          metadata: utils_cleanEmptyObject({
            ...attributes?.metadata,
            blockVisibility: hasHiddenBlock ? void 0 : false
          })
        }
      ])
    );
    updateBlockAttributes(clientIds, attributesByClientId, {
      uniqueByBlock: true
    });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { className: "block-editor-block-lock-toolbar", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      disabled: !canToggleBlockVisibility,
      icon: hasHiddenBlock ? unseen_default : seen_default,
      label: hasHiddenBlock ? (0,external_wp_i18n_namespaceObject.__)("Hidden") : (0,external_wp_i18n_namespaceObject.__)("Visible"),
      onClick: toggleBlockVisibility
    }
  ) }) });
}


;// ./node_modules/@wordpress/icons/build-module/library/group.js


var group_group_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/row.js


var row_row_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M4 6.5h5a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4V16h5a.5.5 0 0 0 .5-.5v-7A.5.5 0 0 0 9 8H4V6.5Zm16 0h-5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h5V16h-5a.5.5 0 0 1-.5-.5v-7A.5.5 0 0 1 15 8h5V6.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/stack.js


var stack_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17.5 4v5a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V4H8v5a.5.5 0 0 0 .5.5h7A.5.5 0 0 0 16 9V4h1.5Zm0 16v-5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v5H8v-5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v5h1.5Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/grid.js


var grid_grid_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    d: "m3 5c0-1.10457.89543-2 2-2h13.5c1.1046 0 2 .89543 2 2v13.5c0 1.1046-.8954 2-2 2h-13.5c-1.10457 0-2-.8954-2-2zm2-.5h6v6.5h-6.5v-6c0-.27614.22386-.5.5-.5zm-.5 8v6c0 .2761.22386.5.5.5h6v-6.5zm8 0v6.5h6c.2761 0 .5-.2239.5-.5v-6zm0-8v6.5h6.5v-6c0-.27614-.2239-.5-.5-.5z",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/toolbar.js








const layouts = {
  group: { type: "constrained" },
  row: { type: "flex", flexWrap: "nowrap" },
  stack: { type: "flex", orientation: "vertical" },
  grid: { type: "grid" }
};
function BlockGroupToolbar() {
  const { blocksSelection, clientIds, groupingBlockName, isGroupable } = useConvertToGroupButtonProps();
  const { replaceBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { canRemove, variations } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { canRemoveBlocks } = select(store);
      const { getBlockVariations } = select(external_wp_blocks_namespaceObject.store);
      return {
        canRemove: canRemoveBlocks(clientIds),
        variations: getBlockVariations(
          groupingBlockName,
          "transform"
        )
      };
    },
    [clientIds, groupingBlockName]
  );
  const onConvertToGroup = (layout) => {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
      blocksSelection,
      groupingBlockName
    );
    if (typeof layout !== "string") {
      layout = "group";
    }
    if (newBlocks && newBlocks.length > 0) {
      newBlocks[0].attributes.layout = layouts[layout];
      replaceBlocks(clientIds, newBlocks);
    }
  };
  const onConvertToRow = () => onConvertToGroup("row");
  const onConvertToStack = () => onConvertToGroup("stack");
  const onConvertToGrid = () => onConvertToGroup("grid");
  if (!isGroupable || !canRemove) {
    return null;
  }
  const canInsertRow = !!variations.find(
    ({ name }) => name === "group-row"
  );
  const canInsertStack = !!variations.find(
    ({ name }) => name === "group-stack"
  );
  const canInsertGrid = !!variations.find(
    ({ name }) => name === "group-grid"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.ToolbarGroup, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        icon: group_group_default,
        label: (0,external_wp_i18n_namespaceObject._x)("Group", "action: convert blocks to group"),
        onClick: onConvertToGroup
      }
    ),
    canInsertRow && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        icon: row_row_default,
        label: (0,external_wp_i18n_namespaceObject._x)("Row", "action: convert blocks to row"),
        onClick: onConvertToRow
      }
    ),
    canInsertStack && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        icon: stack_default,
        label: (0,external_wp_i18n_namespaceObject._x)("Stack", "action: convert blocks to stack"),
        onClick: onConvertToStack
      }
    ),
    canInsertGrid && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        icon: grid_grid_default,
        label: (0,external_wp_i18n_namespaceObject._x)("Grid", "action: convert blocks to grid"),
        onClick: onConvertToGrid
      }
    )
  ] });
}
var toolbar_default = BlockGroupToolbar;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-edit-visually-button/index.js





function BlockEditVisuallyButton({ clientIds }) {
  const clientId = clientIds.length === 1 ? clientIds[0] : void 0;
  const canEditVisually = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => !!clientId && select(store).getBlockMode(clientId) === "html",
    [clientId]
  );
  const { toggleBlockMode } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  if (!canEditVisually) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      onClick: () => {
        toggleBlockMode(clientId);
      },
      children: (0,external_wp_i18n_namespaceObject.__)("Edit visually")
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-name-context.js

const __unstableBlockNameContext = (0,external_wp_element_namespaceObject.createContext)("");
__unstableBlockNameContext.displayName = "__unstableBlockNameContext";
var block_name_context_default = __unstableBlockNameContext;


;// ./node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js










function hasOnlyToolbarItem(elements) {
  const dataProp = "toolbarItem";
  return !elements.some((element) => !(dataProp in element.dataset));
}
function getAllFocusableToolbarItemsIn(container) {
  return Array.from(
    container.querySelectorAll("[data-toolbar-item]:not([disabled])")
  );
}
function hasFocusWithin(container) {
  return container.contains(container.ownerDocument.activeElement);
}
function focusFirstTabbableIn(container) {
  const [firstTabbable] = external_wp_dom_namespaceObject.focus.tabbable.find(container);
  if (firstTabbable) {
    firstTabbable.focus({
      // When focusing newly mounted toolbars,
      // the position of the popover is often not right on the first render
      // This prevents the layout shifts when focusing the dialogs.
      preventScroll: true
    });
  }
}
function useIsAccessibleToolbar(toolbarRef) {
  const initialAccessibleToolbarState = true;
  const [isAccessibleToolbar, setIsAccessibleToolbar] = (0,external_wp_element_namespaceObject.useState)(
    initialAccessibleToolbarState
  );
  const determineIsAccessibleToolbar = (0,external_wp_element_namespaceObject.useCallback)(() => {
    const tabbables = external_wp_dom_namespaceObject.focus.tabbable.find(toolbarRef.current);
    const onlyToolbarItem = hasOnlyToolbarItem(tabbables);
    if (!onlyToolbarItem) {
      external_wp_deprecated_default()("Using custom components as toolbar controls", {
        since: "5.6",
        alternative: "ToolbarItem, ToolbarButton or ToolbarDropdownMenu components",
        link: "https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols"
      });
    }
    setIsAccessibleToolbar(onlyToolbarItem);
  }, [toolbarRef]);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    const observer = new window.MutationObserver(
      determineIsAccessibleToolbar
    );
    observer.observe(toolbarRef.current, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [determineIsAccessibleToolbar, isAccessibleToolbar, toolbarRef]);
  return isAccessibleToolbar;
}
function useToolbarFocus({
  toolbarRef,
  focusOnMount,
  isAccessibleToolbar,
  defaultIndex,
  onIndexChange,
  shouldUseKeyboardFocusShortcut,
  focusEditorOnEscape
}) {
  const [initialFocusOnMount] = (0,external_wp_element_namespaceObject.useState)(focusOnMount);
  const [initialIndex] = (0,external_wp_element_namespaceObject.useState)(defaultIndex);
  const focusToolbar = (0,external_wp_element_namespaceObject.useCallback)(() => {
    focusFirstTabbableIn(toolbarRef.current);
  }, [toolbarRef]);
  const focusToolbarViaShortcut = () => {
    if (shouldUseKeyboardFocusShortcut) {
      focusToolbar();
    }
  };
  (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)("core/block-editor/focus-toolbar", focusToolbarViaShortcut);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (initialFocusOnMount) {
      focusToolbar();
    }
  }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const navigableToolbarRef = toolbarRef.current;
    let raf = 0;
    if (!initialFocusOnMount && !hasFocusWithin(navigableToolbarRef)) {
      raf = window.requestAnimationFrame(() => {
        const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
        const index = initialIndex || 0;
        if (items[index] && hasFocusWithin(navigableToolbarRef)) {
          items[index].focus({
            // When focusing newly mounted toolbars,
            // the position of the popover is often not right on the first render
            // This prevents the layout shifts when focusing the dialogs.
            preventScroll: true
          });
        }
      });
    }
    return () => {
      window.cancelAnimationFrame(raf);
      if (!onIndexChange || !navigableToolbarRef) {
        return;
      }
      const items = getAllFocusableToolbarItemsIn(navigableToolbarRef);
      const index = items.findIndex((item) => item.tabIndex === 0);
      onIndexChange(index);
    };
  }, [initialIndex, initialFocusOnMount, onIndexChange, toolbarRef]);
  const { getLastFocus } = unlock((0,external_wp_data_namespaceObject.useSelect)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const navigableToolbarRef = toolbarRef.current;
    if (focusEditorOnEscape) {
      const handleKeyDown = (event) => {
        const lastFocus = getLastFocus();
        if (event.keyCode === external_wp_keycodes_namespaceObject.ESCAPE && lastFocus?.current) {
          event.preventDefault();
          lastFocus.current.focus();
        }
      };
      navigableToolbarRef.addEventListener("keydown", handleKeyDown);
      return () => {
        navigableToolbarRef.removeEventListener(
          "keydown",
          handleKeyDown
        );
      };
    }
  }, [focusEditorOnEscape, getLastFocus, toolbarRef]);
}
function NavigableToolbar({
  children,
  focusOnMount,
  focusEditorOnEscape = false,
  shouldUseKeyboardFocusShortcut = true,
  __experimentalInitialIndex: initialIndex,
  __experimentalOnIndexChange: onIndexChange,
  orientation = "horizontal",
  ...props
}) {
  const toolbarRef = (0,external_wp_element_namespaceObject.useRef)();
  const isAccessibleToolbar = useIsAccessibleToolbar(toolbarRef);
  useToolbarFocus({
    toolbarRef,
    focusOnMount,
    defaultIndex: initialIndex,
    onIndexChange,
    isAccessibleToolbar,
    shouldUseKeyboardFocusShortcut,
    focusEditorOnEscape
  });
  if (isAccessibleToolbar) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Toolbar,
      {
        label: props["aria-label"],
        ref: toolbarRef,
        orientation,
        ...props,
        children
      }
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.NavigableMenu,
    {
      orientation,
      role: "toolbar",
      ref: toolbarRef,
      ...props,
      children
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/use-has-block-toolbar.js



function useHasBlockToolbar() {
  const enabled = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getBlockEditingMode, getBlockName, getBlockSelectionStart } = select(store);
    const selectedBlockClientId = getBlockSelectionStart();
    const blockType = selectedBlockClientId && (0,external_wp_blocks_namespaceObject.getBlockType)(getBlockName(selectedBlockClientId));
    return blockType && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockType, "__experimentalToolbar", true) && getBlockEditingMode(selectedBlockClientId) !== "disabled";
  }, []);
  return enabled;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/change-design.js








const change_design_EMPTY_ARRAY = [];
const MAX_PATTERNS_TO_SHOW = 6;
const change_design_POPOVER_PROPS = {
  placement: "bottom-start"
};
function ChangeDesign({ clientId }) {
  const { categories, currentPatternName, patterns } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockAttributes,
        getBlockRootClientId,
        __experimentalGetAllowedPatterns
      } = select(store);
      const attributes = getBlockAttributes(clientId);
      const _categories = attributes?.metadata?.categories || change_design_EMPTY_ARRAY;
      const rootBlock = getBlockRootClientId(clientId);
      const _patterns = _categories.length > 0 ? __experimentalGetAllowedPatterns(rootBlock) : change_design_EMPTY_ARRAY;
      return {
        categories: _categories,
        currentPatternName: attributes?.metadata?.patternName,
        patterns: _patterns
      };
    },
    [clientId]
  );
  const { replaceBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const sameCategoryPatternsWithSingleWrapper = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (categories.length === 0 || !patterns || patterns.length === 0) {
      return change_design_EMPTY_ARRAY;
    }
    return patterns.filter((pattern) => {
      const isCorePattern = pattern.source === "core" || pattern.source?.startsWith("pattern-directory") && pattern.source !== "pattern-directory/theme";
      return (
        // Check if the pattern has only one top level block,
        // otherwise we may switch to a pattern that doesn't have replacement suggestions.
        pattern.blocks.length === 1 && // We exclude the core patterns and pattern directory patterns that are not theme patterns.
        !isCorePattern && // Exclude current pattern.
        currentPatternName !== pattern.name && pattern.categories?.some((category) => {
          return categories.includes(category);
        }) && // Check if the pattern is not a synced pattern.
        (pattern.syncStatus === "unsynced" || !pattern.id)
      );
    }).slice(0, MAX_PATTERNS_TO_SHOW);
  }, [categories, currentPatternName, patterns]);
  if (sameCategoryPatternsWithSingleWrapper.length < 2) {
    return null;
  }
  const onClickPattern = (pattern) => {
    const newBlocks = (pattern.blocks ?? []).map((block) => {
      return (0,external_wp_blocks_namespaceObject.cloneBlock)(block);
    });
    newBlocks[0].attributes.metadata = {
      ...newBlocks[0].attributes.metadata,
      categories
    };
    replaceBlocks(clientId, newBlocks);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps: change_design_POPOVER_PROPS,
      renderToggle: ({ onToggle, isOpen }) => {
        return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.ToolbarButton,
          {
            onClick: () => onToggle(!isOpen),
            "aria-expanded": isOpen,
            children: (0,external_wp_i18n_namespaceObject.__)("Change design")
          }
        ) });
      },
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalDropdownContentWrapper,
        {
          className: "block-editor-block-toolbar-change-design-content-wrapper",
          paddingSize: "none",
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_patterns_list_default,
            {
              blockPatterns: sameCategoryPatternsWithSingleWrapper,
              onClickPattern,
              showTitlesAsTooltip: true
            }
          )
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/switch-section-style.js











const styleIcon = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
  external_wp_components_namespaceObject.SVG,
  {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    "aria-hidden": "true",
    focusable: "false",
    children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Path, { d: "M17.2 10.9c-.5-1-1.2-2.1-2.1-3.2-.6-.9-1.3-1.7-2.1-2.6L12 4l-1 1.1c-.6.9-1.3 1.7-2 2.6-.8 1.2-1.5 2.3-2 3.2-.6 1.2-1 2.2-1 3 0 3.4 2.7 6.1 6.1 6.1s6.1-2.7 6.1-6.1c0-.8-.3-1.8-1-3z" }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Path,
        {
          stroke: "currentColor",
          strokeWidth: "1.5",
          d: "M17.2 10.9c-.5-1-1.2-2.1-2.1-3.2-.6-.9-1.3-1.7-2.1-2.6L12 4l-1 1.1c-.6.9-1.3 1.7-2 2.6-.8 1.2-1.5 2.3-2 3.2-.6 1.2-1 2.2-1 3 0 3.4 2.7 6.1 6.1 6.1s6.1-2.7 6.1-6.1c0-.8-.3-1.8-1-3z"
        }
      )
    ]
  }
);
function SwitchSectionStyle({ clientId }) {
  const { stylesToRender, activeStyle, className } = useStylesForBlocks({
    clientId
  });
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { merged: mergedConfig } = (0,external_wp_element_namespaceObject.useContext)(GlobalStylesContext);
  const { globalSettings, globalStyles, blockName } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const settings = select(store).getSettings();
      return {
        globalSettings: settings.__experimentalFeatures,
        globalStyles: settings[globalStylesDataKey],
        blockName: select(store).getBlockName(clientId)
      };
    },
    [clientId]
  );
  const activeStyleBackground = activeStyle?.name ? getVariationStylesWithRefValues(
    {
      settings: mergedConfig?.settings ?? globalSettings,
      styles: mergedConfig?.styles ?? globalStyles
    },
    blockName,
    activeStyle.name
  )?.color?.background : void 0;
  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }
  const handleStyleSwitch = () => {
    const currentIndex = stylesToRender.findIndex(
      (style) => style.name === activeStyle.name
    );
    const nextIndex = (currentIndex + 1) % stylesToRender.length;
    const nextStyle = stylesToRender[nextIndex];
    const styleClassName = replaceActiveStyle(
      className,
      activeStyle,
      nextStyle
    );
    updateBlockAttributes(clientId, {
      className: styleClassName
    });
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      onClick: handleStyleSwitch,
      label: (0,external_wp_i18n_namespaceObject.__)("Shuffle styles"),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Icon,
        {
          icon: styleIcon,
          style: {
            fill: activeStyleBackground || "transparent"
          }
        }
      )
    }
  ) });
}
var switch_section_style_default = SwitchSectionStyle;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js


























function PrivateBlockToolbar({
  hideDragHandle,
  focusOnMount,
  __experimentalInitialIndex,
  __experimentalOnIndexChange,
  variant = "unstyled"
}) {
  const {
    blockClientId,
    blockClientIds,
    isDefaultEditingMode,
    blockType,
    toolbarKey,
    shouldShowVisualToolbar,
    showParentSelector,
    isUsingBindings,
    hasParentPattern,
    hasContentOnlyLocking,
    showShuffleButton,
    showSlots,
    showGroupButtons,
    showLockButtons,
    showBlockVisibilityButton,
    showSwitchSectionStyleButton
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getBlockName,
      getBlockMode,
      getBlockParents,
      getSelectedBlockClientIds,
      isBlockValid,
      getBlockEditingMode,
      getBlockAttributes,
      getBlockParentsByBlockName,
      getTemplateLock,
      getParentSectionBlock,
      isZoomOut,
      isSectionBlock
    } = unlock(select(store));
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const parents = getBlockParents(selectedBlockClientId);
    const parentSection = getParentSectionBlock(selectedBlockClientId);
    const parentClientId = parentSection ?? parents[parents.length - 1];
    const parentBlockName = getBlockName(parentClientId);
    const parentBlockType = (0,external_wp_blocks_namespaceObject.getBlockType)(parentBlockName);
    const editingMode = getBlockEditingMode(selectedBlockClientId);
    const _isDefaultEditingMode = editingMode === "default";
    const _blockName = getBlockName(selectedBlockClientId);
    const isValid = selectedBlockClientIds.every(
      (id) => isBlockValid(id)
    );
    const isVisual = selectedBlockClientIds.every(
      (id) => getBlockMode(id) === "visual"
    );
    const _isUsingBindings = selectedBlockClientIds.every(
      (clientId) => !!getBlockAttributes(clientId)?.metadata?.bindings
    );
    const _hasParentPattern = selectedBlockClientIds.every(
      (clientId) => getBlockParentsByBlockName(clientId, "core/block", true).length > 0
    );
    const _hasTemplateLock = selectedBlockClientIds.some(
      (id) => getTemplateLock(id) === "contentOnly"
    );
    const _isZoomOut = isZoomOut();
    const _showSwitchSectionStyleButton = window?.__experimentalContentOnlyPatternInsertion && (_isZoomOut || isSectionBlock(selectedBlockClientId));
    return {
      blockClientId: selectedBlockClientId,
      blockClientIds: selectedBlockClientIds,
      isDefaultEditingMode: _isDefaultEditingMode,
      blockType: selectedBlockClientId && (0,external_wp_blocks_namespaceObject.getBlockType)(_blockName),
      shouldShowVisualToolbar: isValid && isVisual,
      toolbarKey: `${selectedBlockClientId}${parentClientId}`,
      showParentSelector: !_isZoomOut && parentBlockType && editingMode !== "contentOnly" && getBlockEditingMode(parentClientId) !== "disabled" && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
        parentBlockType,
        "__experimentalParentSelector",
        true
      ) && selectedBlockClientIds.length === 1,
      isUsingBindings: _isUsingBindings,
      hasParentPattern: _hasParentPattern,
      hasContentOnlyLocking: _hasTemplateLock,
      showShuffleButton: _isZoomOut,
      showSlots: !_isZoomOut,
      showGroupButtons: !_isZoomOut,
      showLockButtons: !_isZoomOut,
      showBlockVisibilityButton: !_isZoomOut,
      showSwitchSectionStyleButton: _showSwitchSectionStyleButton
    };
  }, []);
  const toolbarWrapperRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const nodeRef = (0,external_wp_element_namespaceObject.useRef)();
  const showHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures({
    ref: nodeRef
  });
  const isLargeViewport = !(0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  const hasBlockToolbar = useHasBlockToolbar();
  if (!hasBlockToolbar) {
    return null;
  }
  const isMultiToolbar = blockClientIds.length > 1;
  const isSynced = (0,external_wp_blocks_namespaceObject.isReusableBlock)(blockType) || (0,external_wp_blocks_namespaceObject.isTemplatePart)(blockType);
  const classes = dist_clsx("block-editor-block-contextual-toolbar", {
    "has-parent": showParentSelector
  });
  const innerClasses = dist_clsx("block-editor-block-toolbar", {
    "is-synced": isSynced,
    "is-connected": isUsingBindings
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    NavigableToolbar,
    {
      focusEditorOnEscape: true,
      className: classes,
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Block tools"),
      variant: variant === "toolbar" ? void 0 : variant,
      focusOnMount,
      __experimentalInitialIndex,
      __experimentalOnIndexChange,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { ref: toolbarWrapperRef, className: innerClasses, children: [
        showParentSelector && !isMultiToolbar && isLargeViewport && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockParentSelector, {}),
        (shouldShowVisualToolbar || isMultiToolbar) && !hasParentPattern && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "div",
          {
            ref: nodeRef,
            ...showHoveredOrFocusedGestures,
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.ToolbarGroup, { className: "block-editor-block-toolbar__block-controls", children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_switcher_default, { clientIds: blockClientIds }),
              isDefaultEditingMode && showBlockVisibilityButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                BlockVisibilityToolbar,
                {
                  clientIds: blockClientIds
                }
              ),
              !isMultiToolbar && isDefaultEditingMode && showLockButtons && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                BlockLockToolbar,
                {
                  clientId: blockClientId
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                block_mover_default,
                {
                  clientIds: blockClientIds,
                  hideDragHandle
                }
              )
            ] })
          }
        ),
        !hasContentOnlyLocking && shouldShowVisualToolbar && isMultiToolbar && showGroupButtons && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(toolbar_default, {}),
        showShuffleButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ChangeDesign, { clientId: blockClientIds[0] }),
        showSwitchSectionStyleButton && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(switch_section_style_default, { clientId: blockClientIds[0] }),
        shouldShowVisualToolbar && showSlots && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_controls_default.Slot,
            {
              group: "parent",
              className: "block-editor-block-toolbar__slot"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_controls_default.Slot,
            {
              group: "block",
              className: "block-editor-block-toolbar__slot"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default.Slot, { className: "block-editor-block-toolbar__slot" }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_controls_default.Slot,
            {
              group: "inline",
              className: "block-editor-block-toolbar__slot"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_controls_default.Slot,
            {
              group: "other",
              className: "block-editor-block-toolbar__slot"
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_name_context_default.Provider,
            {
              value: blockType?.name,
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_toolbar_last_item_default.Slot, {})
            }
          )
        ] }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockEditVisuallyButton, { clientIds: blockClientIds }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_settings_menu_default, { clientIds: blockClientIds })
      ] })
    },
    toolbarKey
  );
}
function BlockToolbar({ hideDragHandle, variant }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateBlockToolbar,
    {
      hideDragHandle,
      variant,
      focusOnMount: void 0,
      __experimentalInitialIndex: void 0,
      __experimentalOnIndexChange: void 0
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/block-toolbar-popover.js










function BlockToolbarPopover({
  clientId,
  isTyping,
  __unstableContentRef
}) {
  const { capturingClientId, isInsertionPointVisible, lastClientId } = useSelectedBlockToolProps(clientId);
  const initialToolbarItemIndexRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    initialToolbarItemIndexRef.current = void 0;
  }, [clientId]);
  const { stopTyping } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const isToolbarForcedRef = (0,external_wp_element_namespaceObject.useRef)(false);
  (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)("core/block-editor/focus-toolbar", () => {
    isToolbarForcedRef.current = true;
    stopTyping(true);
  });
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    isToolbarForcedRef.current = false;
  });
  const clientIdToPositionOver = capturingClientId || clientId;
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef?.current,
    clientId: clientIdToPositionOver
  });
  return !isTyping && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateBlockPopover,
    {
      clientId: clientIdToPositionOver,
      bottomClientId: lastClientId,
      className: dist_clsx("block-editor-block-list__block-popover", {
        "is-insertion-point-visible": isInsertionPointVisible
      }),
      resize: false,
      ...popoverProps,
      __unstableContentRef,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        PrivateBlockToolbar,
        {
          focusOnMount: isToolbarForcedRef.current,
          __experimentalInitialIndex: initialToolbarItemIndexRef.current,
          __experimentalOnIndexChange: (index) => {
            initialToolbarItemIndexRef.current = index;
          },
          variant: "toolbar"
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/zoom-out-mode-inserter-button.js





function ZoomOutModeInserterButton({ onClick }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      variant: "primary",
      icon: plus_default,
      size: "compact",
      className: dist_clsx(
        "block-editor-button-pattern-inserter__button",
        "block-editor-block-tools__zoom-out-mode-inserter-button"
      ),
      onClick,
      label: (0,external_wp_i18n_namespaceObject._x)(
        "Add pattern",
        "Generic label for pattern inserter button"
      )
    }
  );
}
var zoom_out_mode_inserter_button_default = ZoomOutModeInserterButton;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/zoom-out-mode-inserters.js







function ZoomOutModeInserters() {
  const [isReady, setIsReady] = (0,external_wp_element_namespaceObject.useState)(false);
  const {
    hasSelection,
    blockOrder,
    setInserterIsOpened,
    sectionRootClientId,
    selectedBlockClientId,
    blockInsertionPoint,
    insertionPointVisible
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getSettings,
      getBlockOrder,
      getSelectionStart,
      getSelectedBlockClientId,
      getSectionRootClientId,
      getBlockInsertionPoint,
      isBlockInsertionPointVisible
    } = unlock(select(store));
    const root = getSectionRootClientId();
    return {
      hasSelection: !!getSelectionStart().clientId,
      blockOrder: getBlockOrder(root),
      sectionRootClientId: root,
      setInserterIsOpened: getSettings().__experimentalSetIsInserterOpened,
      selectedBlockClientId: getSelectedBlockClientId(),
      blockInsertionPoint: getBlockInsertionPoint(),
      insertionPointVisible: isBlockInsertionPointVisible()
    };
  }, []);
  const { showInsertionPoint } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    const timeout = setTimeout(() => {
      setIsReady(true);
    }, 500);
    return () => {
      clearTimeout(timeout);
    };
  }, []);
  if (!isReady || !hasSelection) {
    return null;
  }
  const previousClientId = selectedBlockClientId;
  const index = blockOrder.findIndex(
    (clientId) => selectedBlockClientId === clientId
  );
  const insertionIndex = index + 1;
  const nextClientId = blockOrder[insertionIndex];
  if (insertionPointVisible && blockInsertionPoint?.index === insertionIndex) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    inbetween_default,
    {
      previousClientId,
      nextClientId,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        zoom_out_mode_inserter_button_default,
        {
          onClick: () => {
            setInserterIsOpened({
              rootClientId: sectionRootClientId,
              insertionIndex,
              tab: "patterns",
              category: "all"
            });
            showInsertionPoint(sectionRootClientId, insertionIndex, {
              operation: "insert"
            });
          }
        }
      )
    }
  );
}
var zoom_out_mode_inserters_default = ZoomOutModeInserters;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/use-show-block-tools.js




function useShowBlockTools() {
  return (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getSelectedBlockClientId,
      getFirstMultiSelectedBlockClientId,
      getBlock,
      getBlockMode,
      getSettings,
      isTyping,
      isBlockInterfaceHidden
    } = unlock(select(store));
    const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();
    const block = getBlock(clientId);
    const hasSelectedBlock = !!clientId && !!block;
    const isEmptyDefaultBlock = hasSelectedBlock && (0,external_wp_blocks_namespaceObject.isUnmodifiedDefaultBlock)(block, "content") && getBlockMode(clientId) !== "html";
    const _showEmptyBlockSideInserter = clientId && !isTyping() && isEmptyDefaultBlock;
    const _showBlockToolbarPopover = !isBlockInterfaceHidden() && !getSettings().hasFixedToolbar && !_showEmptyBlockSideInserter && hasSelectedBlock && !isEmptyDefaultBlock;
    return {
      showEmptyBlockSideInserter: _showEmptyBlockSideInserter,
      showBlockToolbarPopover: _showBlockToolbarPopover
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-tools/index.js




















function block_tools_selector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getSettings,
    isTyping,
    isDragging,
    isZoomOut
  } = unlock(select(store));
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();
  return {
    clientId,
    hasFixedToolbar: getSettings().hasFixedToolbar,
    isTyping: isTyping(),
    isZoomOutMode: isZoomOut(),
    isDragging: isDragging()
  };
}
function BlockTools({
  children,
  __unstableContentRef,
  ...props
}) {
  const { clientId, hasFixedToolbar, isTyping, isZoomOutMode, isDragging } = (0,external_wp_data_namespaceObject.useSelect)(block_tools_selector, []);
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    getBlockRootClientId,
    isGroupable,
    getBlockName
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const { showEmptyBlockSideInserter, showBlockToolbarPopover } = useShowBlockTools();
  const pasteStyles = usePasteStyles();
  const {
    duplicateBlocks,
    removeBlocks,
    replaceBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    selectBlock,
    moveBlocksUp,
    moveBlocksDown,
    expandBlock,
    updateBlockAttributes
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  function onKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (isMatch("core/block-editor/move-up", event) || isMatch("core/block-editor/move-down", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId(clientIds[0]);
        const direction = isMatch("core/block-editor/move-up", event) ? "up" : "down";
        if (direction === "up") {
          moveBlocksUp(clientIds, rootClientId);
        } else {
          moveBlocksDown(clientIds, rootClientId);
        }
        const blockLength = Array.isArray(clientIds) ? clientIds.length : 1;
        const message = (0,external_wp_i18n_namespaceObject.sprintf)(
          // translators: %d: the name of the block that has been moved
          (0,external_wp_i18n_namespaceObject._n)(
            "%d block moved.",
            "%d blocks moved.",
            clientIds.length
          ),
          blockLength
        );
        (0,external_wp_a11y_namespaceObject.speak)(message);
      }
    } else if (isMatch("core/block-editor/duplicate", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        duplicateBlocks(clientIds);
      }
    } else if (isMatch("core/block-editor/remove", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        removeBlocks(clientIds);
      }
    } else if (isMatch("core/block-editor/paste-styles", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        const blocks = getBlocksByClientId(clientIds);
        pasteStyles(blocks);
      }
    } else if (isMatch("core/block-editor/insert-after", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        insertAfterBlock(clientIds[clientIds.length - 1]);
      }
    } else if (isMatch("core/block-editor/insert-before", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        insertBeforeBlock(clientIds[0]);
      }
    } else if (isMatch("core/block-editor/unselect", event)) {
      if (event.target.closest("[role=toolbar]")) {
        return;
      }
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length > 1) {
        event.preventDefault();
        selectBlock(clientIds[0]);
      }
    } else if (isMatch("core/block-editor/collapse-list-view", event)) {
      if ((0,external_wp_dom_namespaceObject.isTextField)(event.target) || (0,external_wp_dom_namespaceObject.isTextField)(
        event.target?.contentWindow?.document?.activeElement
      )) {
        return;
      }
      event.preventDefault();
      expandBlock(clientId);
    } else if (isMatch("core/block-editor/group", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length > 1 && isGroupable(clientIds)) {
        event.preventDefault();
        const blocks = getBlocksByClientId(clientIds);
        const groupingBlockName = getGroupingBlockName();
        const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
          blocks,
          groupingBlockName
        );
        replaceBlocks(clientIds, newBlocks);
        (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("Selected blocks are grouped."));
      }
    } else if (isMatch("core/block-editor/toggle-block-visibility", event)) {
      const clientIds = getSelectedBlockClientIds();
      if (clientIds.length) {
        event.preventDefault();
        const blocks = getBlocksByClientId(clientIds);
        const canToggleBlockVisibility = blocks.every(
          (block) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
            getBlockName(block.clientId),
            "visibility",
            true
          )
        );
        if (!canToggleBlockVisibility) {
          return;
        }
        const hasHiddenBlock = blocks.some(
          (block) => block.attributes.metadata?.blockVisibility === false
        );
        const attributesByClientId = Object.fromEntries(
          blocks.map(({ clientId: mapClientId, attributes }) => [
            mapClientId,
            {
              metadata: utils_cleanEmptyObject({
                ...attributes?.metadata,
                blockVisibility: hasHiddenBlock ? void 0 : false
              })
            }
          ])
        );
        updateBlockAttributes(clientIds, attributesByClientId, {
          uniqueByBlock: true
        });
      }
    }
  }
  const blockToolbarRef = use_popover_scroll_default(__unstableContentRef);
  const blockToolbarAfterRef = use_popover_scroll_default(__unstableContentRef);
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "div",
      {
        ...props,
        onKeyDown,
        className: dist_clsx(props.className, {
          "block-editor-block-tools--is-dragging": isDragging
        }),
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(InsertionPointOpenRef.Provider, { value: (0,external_wp_element_namespaceObject.useRef)(false), children: [
          !isTyping && !isZoomOutMode && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            InsertionPoint,
            {
              __unstableContentRef
            }
          ),
          showEmptyBlockSideInserter && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            EmptyBlockInserter,
            {
              __unstableContentRef,
              clientId
            }
          ),
          showBlockToolbarPopover && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            BlockToolbarPopover,
            {
              __unstableContentRef,
              clientId,
              isTyping
            }
          ),
          !isZoomOutMode && !hasFixedToolbar && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Popover.Slot,
            {
              name: "block-toolbar",
              ref: blockToolbarRef
            }
          ),
          children,
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Popover.Slot,
            {
              name: "__unstable-block-tools-after",
              ref: blockToolbarAfterRef
            }
          ),
          isZoomOutMode && !isDragging && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            zoom_out_mode_inserters_default,
            {
              __unstableContentRef
            }
          )
        ] })
      }
    )
  );
}


;// external ["wp","commands"]
const external_wp_commands_namespaceObject = window["wp"]["commands"];
;// ./node_modules/@wordpress/icons/build-module/library/ungroup.js


var ungroup_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18 4h-7c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm.5 9c0 .3-.2.5-.5.5h-7c-.3 0-.5-.2-.5-.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7zm-5 5c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h1V9H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-1h-1.5v1z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/trash.js


var trash_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M12 5.5A2.25 2.25 0 0 0 9.878 7h4.244A2.251 2.251 0 0 0 12 5.5ZM12 4a3.751 3.751 0 0 0-3.675 3H5v1.5h1.27l.818 8.997a2.75 2.75 0 0 0 2.739 2.501h4.347a2.75 2.75 0 0 0 2.738-2.5L17.73 8.5H19V7h-3.325A3.751 3.751 0 0 0 12 4Zm4.224 4.5H7.776l.806 8.861a1.25 1.25 0 0 0 1.245 1.137h4.347a1.25 1.25 0 0 0 1.245-1.137l.805-8.861Z"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/use-block-commands/index.js









const getTransformCommands = () => function useTransformCommands() {
  const { replaceBlocks, multiSelect } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    blocks,
    clientIds,
    canRemove,
    possibleBlockTransformations,
    invalidSelection
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getBlockRootClientId,
      getBlockTransformItems,
      getSelectedBlockClientIds,
      getBlocksByClientId,
      canRemoveBlocks
    } = select(store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlocks = getBlocksByClientId(
      selectedBlockClientIds
    );
    if (selectedBlocks.filter((block) => !block).length > 0) {
      return {
        invalidSelection: true
      };
    }
    const rootClientId = getBlockRootClientId(
      selectedBlockClientIds[0]
    );
    return {
      blocks: selectedBlocks,
      clientIds: selectedBlockClientIds,
      possibleBlockTransformations: getBlockTransformItems(
        selectedBlocks,
        rootClientId
      ),
      canRemove: canRemoveBlocks(selectedBlockClientIds),
      invalidSelection: false
    };
  }, []);
  if (invalidSelection) {
    return {
      isLoading: false,
      commands: []
    };
  }
  const isTemplate = blocks.length === 1 && (0,external_wp_blocks_namespaceObject.isTemplatePart)(blocks[0]);
  function selectForMultipleBlocks(insertedBlocks) {
    if (insertedBlocks.length > 1) {
      multiSelect(
        insertedBlocks[0].clientId,
        insertedBlocks[insertedBlocks.length - 1].clientId
      );
    }
  }
  function onBlockTransform(name) {
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, name);
    replaceBlocks(clientIds, newBlocks);
    selectForMultipleBlocks(newBlocks);
  }
  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
  if (!clientIds || clientIds.length < 1 || !hasPossibleBlockTransformations) {
    return { isLoading: false, commands: [] };
  }
  const commands = possibleBlockTransformations.map(
    (transformation) => {
      const { name, title, icon } = transformation;
      return {
        name: "core/block-editor/transform-to-" + name.replace("/", "-"),
        /* translators: %s: Block or block variation name. */
        label: (0,external_wp_i18n_namespaceObject.sprintf)((0,external_wp_i18n_namespaceObject.__)("Transform to %s"), title),
        icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon }),
        callback: ({ close }) => {
          onBlockTransform(name);
          close();
        }
      };
    }
  );
  return { isLoading: false, commands };
};
const getQuickActionsCommands = () => function useQuickActionsCommands() {
  const { clientIds, isUngroupable, isGroupable } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getSelectedBlockClientIds,
        isUngroupable: _isUngroupable,
        isGroupable: _isGroupable
      } = select(store);
      const selectedBlockClientIds = getSelectedBlockClientIds();
      return {
        clientIds: selectedBlockClientIds,
        isUngroupable: _isUngroupable(),
        isGroupable: _isGroupable()
      };
    },
    []
  );
  const {
    canInsertBlockType,
    getBlockRootClientId,
    getBlocksByClientId,
    canRemoveBlocks,
    getBlockName
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getDefaultBlockName, getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const blocks = getBlocksByClientId(clientIds);
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    updateBlockAttributes
  } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const onGroup = () => {
    if (!blocks.length) {
      return;
    }
    const groupingBlockName = getGroupingBlockName();
    const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(blocks, groupingBlockName);
    if (!newBlocks) {
      return;
    }
    replaceBlocks(clientIds, newBlocks);
  };
  const onUngroup = () => {
    if (!blocks.length) {
      return;
    }
    const innerBlocks = blocks[0].innerBlocks;
    if (!innerBlocks.length) {
      return;
    }
    replaceBlocks(clientIds, innerBlocks);
  };
  if (!clientIds || clientIds.length < 1) {
    return { isLoading: false, commands: [] };
  }
  const rootClientId = getBlockRootClientId(clientIds[0]);
  const canInsertDefaultBlock = canInsertBlockType(
    getDefaultBlockName(),
    rootClientId
  );
  const canDuplicate = blocks.every((block) => {
    return !!block && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(block.name, "multiple", true) && canInsertBlockType(block.name, rootClientId);
  });
  const canRemove = canRemoveBlocks(clientIds);
  const canToggleBlockVisibility = blocks.every(
    ({ clientId }) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(getBlockName(clientId), "visibility", true)
  );
  const commands = [];
  if (canDuplicate) {
    commands.push({
      name: "duplicate",
      label: (0,external_wp_i18n_namespaceObject.__)("Duplicate"),
      callback: () => duplicateBlocks(clientIds, true),
      icon: copy_default
    });
  }
  if (canInsertDefaultBlock) {
    commands.push(
      {
        name: "add-before",
        label: (0,external_wp_i18n_namespaceObject.__)("Add before"),
        callback: () => {
          const clientId = Array.isArray(clientIds) ? clientIds[0] : clientId;
          insertBeforeBlock(clientId);
        },
        icon: plus_default
      },
      {
        name: "add-after",
        label: (0,external_wp_i18n_namespaceObject.__)("Add after"),
        callback: () => {
          const clientId = Array.isArray(clientIds) ? clientIds[clientIds.length - 1] : clientId;
          insertAfterBlock(clientId);
        },
        icon: plus_default
      }
    );
  }
  if (isGroupable) {
    commands.push({
      name: "Group",
      label: (0,external_wp_i18n_namespaceObject.__)("Group"),
      callback: onGroup,
      icon: group_group_default
    });
  }
  if (isUngroupable) {
    commands.push({
      name: "ungroup",
      label: (0,external_wp_i18n_namespaceObject.__)("Ungroup"),
      callback: onUngroup,
      icon: ungroup_default
    });
  }
  if (canRemove) {
    commands.push({
      name: "remove",
      label: (0,external_wp_i18n_namespaceObject.__)("Delete"),
      callback: () => removeBlocks(clientIds, true),
      icon: trash_default
    });
  }
  if (canToggleBlockVisibility) {
    const hasHiddenBlock = blocks.some(
      (block) => block.attributes.metadata?.blockVisibility === false
    );
    commands.push({
      name: "core/toggle-block-visibility",
      label: hasHiddenBlock ? (0,external_wp_i18n_namespaceObject.__)("Show") : (0,external_wp_i18n_namespaceObject.__)("Hide"),
      callback: () => {
        const attributesByClientId = Object.fromEntries(
          blocks?.map(({ clientId, attributes }) => [
            clientId,
            {
              metadata: utils_cleanEmptyObject({
                ...attributes?.metadata,
                blockVisibility: hasHiddenBlock ? void 0 : false
              })
            }
          ])
        );
        updateBlockAttributes(clientIds, attributesByClientId, {
          uniqueByBlock: true
        });
      },
      icon: hasHiddenBlock ? seen_default : unseen_default
    });
  }
  return {
    isLoading: false,
    commands: commands.map((command) => ({
      ...command,
      name: "core/block-editor/action-" + command.name,
      callback: ({ close }) => {
        command.callback();
        close();
      }
    }))
  };
};
const useBlockCommands = () => {
  (0,external_wp_commands_namespaceObject.useCommandLoader)({
    name: "core/block-editor/blockTransforms",
    hook: getTransformCommands()
  });
  (0,external_wp_commands_namespaceObject.useCommandLoader)({
    name: "core/block-editor/blockQuickActions",
    hook: getQuickActionsCommands(),
    context: "block-selection-edit"
  });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/block-canvas/index.js














const EDITOR_STYLE_TRANSFORM_OPTIONS = {
  // Don't transform selectors that already specify `.editor-styles-wrapper`.
  ignoredSelectors: [/\.editor-styles-wrapper/gi]
};
function ExperimentalBlockCanvas({
  shouldIframe = true,
  height = "300px",
  children = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockList, {}),
  styles,
  contentRef: contentRefProp,
  iframeProps
}) {
  useBlockCommands();
  const isTabletViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  const resetTypingRef = useMouseMoveTypingReset();
  const clearerRef = useBlockSelectionClearer();
  const localRef = (0,external_wp_element_namespaceObject.useRef)();
  const contentRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([contentRefProp, clearerRef, localRef]);
  const zoomLevel = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(store)).getZoomLevel(),
    []
  );
  const zoomOutIframeProps = zoomLevel !== 100 && !isTabletViewport ? {
    scale: zoomLevel,
    frameSize: "40px"
  } : {};
  if (!shouldIframe) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      BlockTools,
      {
        __unstableContentRef: localRef,
        style: { height, display: "flex" },
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            editor_styles_default,
            {
              styles,
              scope: ":where(.editor-styles-wrapper)",
              transformOptions: EDITOR_STYLE_TRANSFORM_OPTIONS
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            writing_flow_default,
            {
              ref: contentRef,
              className: "editor-styles-wrapper",
              tabIndex: -1,
              style: {
                height: "100%",
                width: "100%"
              },
              children
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockTools,
    {
      __unstableContentRef: localRef,
      style: { height, display: "flex" },
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        iframe_default,
        {
          ...iframeProps,
          ...zoomOutIframeProps,
          ref: resetTypingRef,
          contentRef,
          style: {
            ...iframeProps?.style
          },
          name: "editor-canvas",
          children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(editor_styles_default, { styles }),
            children
          ]
        }
      )
    }
  );
}
function BlockCanvas({ children, height, styles }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ExperimentalBlockCanvas, { height, styles, children });
}
var block_canvas_default = BlockCanvas;


;// ./node_modules/@wordpress/block-editor/build-module/components/color-style-selector/index.js





const ColorSelectorSVGIcon = () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Path, { d: "M7.434 5l3.18 9.16H8.538l-.692-2.184H4.628l-.705 2.184H2L5.18 5h2.254zm-1.13 1.904h-.115l-1.148 3.593H7.44L6.304 6.904zM14.348 7.006c1.853 0 2.9.876 2.9 2.374v4.78h-1.79v-.914h-.114c-.362.64-1.123 1.022-2.031 1.022-1.346 0-2.292-.826-2.292-2.108 0-1.27.972-2.006 2.71-2.107l1.696-.102V9.38c0-.584-.42-.914-1.18-.914-.667 0-1.112.228-1.264.647h-1.701c.12-1.295 1.307-2.107 3.066-2.107zm1.079 4.1l-1.416.09c-.793.056-1.18.342-1.18.844 0 .52.45.837 1.091.837.857 0 1.505-.545 1.505-1.256v-.515z" }) });
const ColorSelectorIcon = ({ style, className }) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-library-colors-selector__icon-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    "div",
    {
      className: `${className} block-library-colors-selector__state-selection`,
      style,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ColorSelectorSVGIcon, {})
    }
  ) });
};
const renderToggleComponent = ({ TextColor, BackgroundColor }) => ({ onToggle, isOpen }) => {
  const openOnArrowDown = (event) => {
    if (!isOpen && event.keyCode === external_wp_keycodes_namespaceObject.DOWN) {
      event.preventDefault();
      onToggle();
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      className: "components-toolbar__control block-library-colors-selector__toggle",
      label: (0,external_wp_i18n_namespaceObject.__)("Open Colors Selector"),
      onClick: onToggle,
      onKeyDown: openOnArrowDown,
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BackgroundColor, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(TextColor, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ColorSelectorIcon, {}) }) })
    }
  ) });
};
const BlockColorsStyleSelector = ({ children, ...other }) => {
  external_wp_deprecated_default()(`wp.blockEditor.BlockColorsStyleSelector`, {
    alternative: "block supports API",
    since: "6.1",
    version: "6.3"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      popoverProps: { placement: "bottom-start" },
      className: "block-library-colors-selector",
      contentClassName: "block-library-colors-selector__popover",
      renderToggle: renderToggleComponent(other),
      renderContent: () => children
    }
  );
};
var color_style_selector_default = BlockColorsStyleSelector;


;// ./node_modules/@wordpress/icons/build-module/library/list-view.js


var list_view_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M3 6h11v1.5H3V6Zm3.5 5.5h11V13h-11v-1.5ZM21 17H10v1.5h11V17Z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/context.js

const ListViewContext = (0,external_wp_element_namespaceObject.createContext)({});
ListViewContext.displayName = "ListViewContext";
const useListViewContext = () => (0,external_wp_element_namespaceObject.useContext)(ListViewContext);


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/aria-referenced-text.js


function AriaReferencedText({ children, ...props }) {
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (ref.current) {
      ref.current.textContent = ref.current.textContent;
    }
  }, [children]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { hidden: true, ...props, ref, children });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/appender.js












const Appender = (0,external_wp_element_namespaceObject.forwardRef)(
  ({ nestingLevel, blockCount, clientId, ...props }, ref) => {
    const { insertedBlock, setInsertedBlock } = useListViewContext();
    const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(Appender);
    const { directInsert, hideInserter } = (0,external_wp_data_namespaceObject.useSelect)(
      (select) => {
        const { getBlockListSettings, getTemplateLock, isZoomOut } = unlock(select(store));
        const settings = getBlockListSettings(clientId);
        const directInsertValue = settings?.directInsert || false;
        const hideInserterValue = !!getTemplateLock(clientId) || isZoomOut();
        return {
          directInsert: directInsertValue,
          hideInserter: hideInserterValue
        };
      },
      [clientId]
    );
    const blockTitle = useBlockDisplayTitle({
      clientId,
      context: "list-view"
    });
    const insertedBlockTitle = useBlockDisplayTitle({
      clientId: insertedBlock?.clientId,
      context: "list-view"
    });
    (0,external_wp_element_namespaceObject.useEffect)(() => {
      if (!insertedBlockTitle?.length) {
        return;
      }
      (0,external_wp_a11y_namespaceObject.speak)(
        (0,external_wp_i18n_namespaceObject.sprintf)(
          // translators: %s: name of block being inserted (i.e. Paragraph, Image, Group etc)
          (0,external_wp_i18n_namespaceObject.__)("%s block inserted"),
          insertedBlockTitle
        ),
        "assertive"
      );
    }, [insertedBlockTitle]);
    if (hideInserter) {
      return null;
    }
    const descriptionId = `list-view-appender__${instanceId}`;
    const description = (0,external_wp_i18n_namespaceObject.sprintf)(
      /* translators: 1: The name of the block. 2: The numerical position of the block. 3: The level of nesting for the block. */
      (0,external_wp_i18n_namespaceObject.__)("Append to %1$s block at position %2$d, Level %3$d"),
      blockTitle,
      blockCount + 1,
      nestingLevel
    );
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "list-view-appender", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inserter_default,
        {
          ref,
          rootClientId: clientId,
          position: "bottom right",
          isAppender: true,
          selectBlockOnInsert: false,
          shouldDirectInsert: directInsert,
          __experimentalIsQuick: true,
          ...props,
          toggleProps: { "aria-describedby": descriptionId },
          onSelectOrClose: (maybeInsertedBlock) => {
            if (maybeInsertedBlock?.clientId) {
              setInsertedBlock(maybeInsertedBlock);
            }
          }
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(AriaReferencedText, { id: descriptionId, children: description })
    ] });
  }
);


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/leaf.js







const AnimatedTreeGridRow = dist_esm_it(external_wp_components_namespaceObject.__experimentalTreeGridRow);
const ListViewLeaf = (0,external_wp_element_namespaceObject.forwardRef)(
  ({
    isDragged,
    isSelected,
    position,
    level,
    rowCount,
    children,
    className,
    path,
    ...props
  }, ref) => {
    const animationRef = use_moving_animation_default({
      clientId: props["data-block"],
      enableAnimation: true,
      triggerAnimationOnChange: path
    });
    const mergedRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([ref, animationRef]);
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      AnimatedTreeGridRow,
      {
        ref: mergedRef,
        className: dist_clsx("block-editor-list-view-leaf", className),
        level,
        positionInSet: position,
        setSize: rowCount,
        isExpanded: void 0,
        ...props,
        children
      }
    );
  }
);
var leaf_default = ListViewLeaf;


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-scroll-into-view.js


function useListViewScrollIntoView({
  isSelected,
  selectedClientIds,
  rowItemRef
}) {
  const isSingleSelection = selectedClientIds.length === 1;
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!isSelected || !isSingleSelection || !rowItemRef.current) {
      return;
    }
    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(rowItemRef.current);
    const { ownerDocument } = rowItemRef.current;
    const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
    if (windowScroll || !scrollContainer) {
      return;
    }
    const rowRect = rowItemRef.current.getBoundingClientRect();
    const scrollContainerRect = scrollContainer.getBoundingClientRect();
    if (rowRect.top < scrollContainerRect.top || rowRect.bottom > scrollContainerRect.bottom) {
      rowItemRef.current.scrollIntoView();
    }
  }, [isSelected, isSingleSelection, rowItemRef]);
}


;// ./node_modules/@wordpress/icons/build-module/library/pin-small.js


var pin_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M10.97 10.159a3.382 3.382 0 0 0-2.857.955l1.724 1.723-2.836 2.913L7 17h1.25l2.913-2.837 1.723 1.723a3.38 3.38 0 0 0 .606-.825c.33-.63.446-1.343.35-2.032L17 10.695 13.305 7l-2.334 3.159Z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/lock-small.js


var lock_small_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M15 11h-.2V9c0-1.5-1.2-2.8-2.8-2.8S9.2 7.5 9.2 9v2H9c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1h6c.6 0 1-.4 1-1v-4c0-.6-.4-1-1-1zm-1.8 0h-2.5V9c0-.7.6-1.2 1.2-1.2s1.2.6 1.2 1.2v2z"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/expander.js



function ListViewExpander({ onClick }) {
  return (
    // Keyboard events are handled by TreeGrid see: components/src/tree-grid/index.js
    //
    // The expander component is implemented as a pseudo element in the w3 example
    // https://www.w3.org/TR/wai-aria-practices/examples/treegrid/treegrid-1.html
    //
    // We've mimicked this by adding an icon with aria-hidden set to true to hide this from the accessibility tree.
    // For the current tree grid implementation, please do not try to make this a button.
    //
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "span",
      {
        className: "block-editor-list-view__expander",
        onClick: (event) => onClick(event, { forceToggle: true }),
        "aria-hidden": "true",
        "data-testid": "list-view-expander",
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_small_default : chevron_right_small_default })
      }
    )
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-images.js



const MAX_IMAGES = 3;
const IMAGE_GETTERS = {
  "core/image": ({ clientId, attributes }) => {
    if (attributes.url) {
      return {
        url: attributes.url,
        alt: attributes.alt || "",
        clientId
      };
    }
  },
  "core/cover": ({ clientId, attributes }) => {
    if (attributes.backgroundType === "image" && attributes.url) {
      return {
        url: attributes.url,
        alt: attributes.alt || "",
        clientId
      };
    }
  },
  "core/media-text": ({ clientId, attributes }) => {
    if (attributes.mediaType === "image" && attributes.mediaUrl) {
      return {
        url: attributes.mediaUrl,
        alt: attributes.mediaAlt || "",
        clientId
      };
    }
  },
  "core/gallery": ({ innerBlocks }) => {
    const images = [];
    const getValues = !!innerBlocks?.length ? IMAGE_GETTERS[innerBlocks[0].name] : void 0;
    if (!getValues) {
      return images;
    }
    for (const innerBlock of innerBlocks) {
      const img = getValues(innerBlock);
      if (img) {
        images.push(img);
      }
      if (images.length >= MAX_IMAGES) {
        return images;
      }
    }
    return images;
  }
};
function getImagesFromBlock(block, isExpanded) {
  const getImages = IMAGE_GETTERS[block.name];
  const images = !!getImages ? getImages(block) : void 0;
  if (!images) {
    return [];
  }
  if (!Array.isArray(images)) {
    return [images];
  }
  return isExpanded ? [] : images;
}
function useListViewImages({ clientId, isExpanded }) {
  const { block } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return { block: select(store).getBlock(clientId) };
    },
    [clientId]
  );
  const images = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return getImagesFromBlock(block, isExpanded);
  }, [block, isExpanded]);
  return images;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/block-select-button.js
















const { Badge: block_select_button_Badge } = unlock(external_wp_components_namespaceObject.privateApis);
function ListViewBlockSelectButton({
  className,
  block: { clientId },
  onClick,
  onContextMenu,
  onMouseDown,
  onToggleExpanded,
  tabIndex,
  onFocus,
  onDragStart,
  onDragEnd,
  draggable,
  isExpanded,
  ariaDescribedBy
}, ref) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const blockTitle = useBlockDisplayTitle({
    clientId,
    context: "list-view"
  });
  const { isLocked } = useBlockLock(clientId);
  const { canToggleBlockVisibility, isBlockHidden, isContentOnly } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockName } = select(store);
      const { isBlockHidden: _isBlockHidden } = unlock(
        select(store)
      );
      return {
        canToggleBlockVisibility: (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
          getBlockName(clientId),
          "visibility",
          true
        ),
        isBlockHidden: _isBlockHidden(clientId),
        isContentOnly: select(store).getBlockEditingMode(
          clientId
        ) === "contentOnly"
      };
    },
    [clientId]
  );
  const shouldShowLockIcon = isLocked && !isContentOnly;
  const shouldShowBlockVisibilityIcon = canToggleBlockVisibility && isBlockHidden;
  const isSticky = blockInformation?.positionType === "sticky";
  const images = useListViewImages({ clientId, isExpanded });
  const onDragStartHandler = (event) => {
    event.dataTransfer.clearData();
    onDragStart?.(event);
  };
  function onKeyDown(event) {
    if (event.keyCode === external_wp_keycodes_namespaceObject.ENTER || event.keyCode === external_wp_keycodes_namespaceObject.SPACE) {
      onClick(event);
    }
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "a",
    {
      className: dist_clsx(
        "block-editor-list-view-block-select-button",
        className
      ),
      onClick,
      onContextMenu,
      onKeyDown,
      onMouseDown,
      ref,
      tabIndex,
      onFocus,
      onDragStart: onDragStartHandler,
      onDragEnd,
      draggable,
      href: `#block-${clientId}`,
      "aria-describedby": ariaDescribedBy,
      "aria-expanded": isExpanded,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ListViewExpander, { onClick: onToggleExpanded }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          block_icon_default,
          {
            icon: blockInformation?.icon,
            showColors: true,
            context: "list-view"
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalHStack,
          {
            alignment: "center",
            className: "block-editor-list-view-block-select-button__label-wrapper",
            justify: "flex-start",
            spacing: 1,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__title", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { ellipsizeMode: "auto", children: blockTitle }) }),
              blockInformation?.anchor && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__anchor-wrapper", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_select_button_Badge, { className: "block-editor-list-view-block-select-button__anchor", children: blockInformation.anchor }) }),
              isSticky && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__sticky", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: pin_small_default }) }),
              images.length ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                "span",
                {
                  className: "block-editor-list-view-block-select-button__images",
                  "aria-hidden": true,
                  children: images.map((image, index) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                    "span",
                    {
                      className: "block-editor-list-view-block-select-button__image",
                      style: {
                        backgroundImage: `url(${image.url})`,
                        zIndex: images.length - index
                        // Ensure the first image is on top, and subsequent images are behind.
                      }
                    },
                    image.clientId
                  ))
                }
              ) : null,
              shouldShowBlockVisibilityIcon && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__block-visibility", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: unseen_default }) }),
              shouldShowLockIcon && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__lock", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: lock_small_default }) })
            ]
          }
        )
      ]
    }
  );
}
var block_select_button_default = (0,external_wp_element_namespaceObject.forwardRef)(ListViewBlockSelectButton);


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/block-contents.js





const ListViewBlockContents = (0,external_wp_element_namespaceObject.forwardRef)(
  ({
    onClick,
    onToggleExpanded,
    block,
    isSelected,
    position,
    siblingBlockCount,
    level,
    isExpanded,
    selectedClientIds,
    ...props
  }, ref) => {
    const { clientId } = block;
    const { AdditionalBlockContent, insertedBlock, setInsertedBlock } = useListViewContext();
    const draggableClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      AdditionalBlockContent && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        AdditionalBlockContent,
        {
          block,
          insertedBlock,
          setInsertedBlock
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_draggable_default,
        {
          appendToOwnerDocument: true,
          clientIds: draggableClientIds,
          cloneClassname: "block-editor-list-view-draggable-chip",
          children: ({ draggable, onDragStart, onDragEnd }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            block_select_button_default,
            {
              ref,
              className: "block-editor-list-view-block-contents",
              block,
              onClick,
              onToggleExpanded,
              isSelected,
              position,
              siblingBlockCount,
              level,
              draggable,
              onDragStart,
              onDragEnd,
              isExpanded,
              ...props
            }
          )
        }
      )
    ] });
  }
);
var block_contents_default = ListViewBlockContents;


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/utils.js


const getBlockPositionDescription = (position, siblingCount, level) => (0,external_wp_i18n_namespaceObject.sprintf)(
  /* translators: 1: The numerical position of the block. 2: The total number of blocks. 3. The level of nesting for the block. */
  (0,external_wp_i18n_namespaceObject.__)("Block %1$d of %2$d, Level %3$d."),
  position,
  siblingCount,
  level
);
const getBlockPropertiesDescription = (blockInformation, isLocked) => [
  blockInformation?.positionLabel ? `${(0,external_wp_i18n_namespaceObject.sprintf)(
    // translators: %s: Position of selected block, e.g. "Sticky" or "Fixed".
    (0,external_wp_i18n_namespaceObject.__)("Position: %s"),
    blockInformation.positionLabel
  )}.` : void 0,
  isLocked ? (0,external_wp_i18n_namespaceObject.__)("This block is locked.") : void 0
].filter(Boolean).join(" ");
const isClientIdSelected = (clientId, selectedBlockClientIds) => Array.isArray(selectedBlockClientIds) && selectedBlockClientIds.length ? selectedBlockClientIds.indexOf(clientId) !== -1 : selectedBlockClientIds === clientId;
function getCommonDepthClientIds(startId, endId, startParents, endParents) {
  const startPath = [...startParents, startId];
  const endPath = [...endParents, endId];
  const depth = Math.min(startPath.length, endPath.length) - 1;
  const start = startPath[depth];
  const end = endPath[depth];
  return {
    start,
    end
  };
}
function focusListItem(focusClientId, treeGridElement) {
  const getFocusElement = () => {
    const row = treeGridElement?.querySelector(
      `[role=row][data-block="${focusClientId}"]`
    );
    if (!row) {
      return null;
    }
    return external_wp_dom_namespaceObject.focus.focusable.find(row)[0];
  };
  let focusElement = getFocusElement();
  if (focusElement) {
    focusElement.focus();
  } else {
    window.requestAnimationFrame(() => {
      focusElement = getFocusElement();
      if (focusElement) {
        focusElement.focus();
      }
    });
  }
}
function getDragDisplacementValues({
  blockIndexes,
  blockDropTargetIndex,
  blockDropPosition,
  clientId,
  firstDraggedBlockIndex,
  isDragged
}) {
  let displacement;
  let isNesting;
  let isAfterDraggedBlocks;
  if (!isDragged) {
    isNesting = false;
    const thisBlockIndex = blockIndexes[clientId];
    isAfterDraggedBlocks = thisBlockIndex > firstDraggedBlockIndex;
    if (blockDropTargetIndex !== void 0 && blockDropTargetIndex !== null && firstDraggedBlockIndex !== void 0) {
      if (thisBlockIndex !== void 0) {
        if (thisBlockIndex >= firstDraggedBlockIndex && thisBlockIndex < blockDropTargetIndex) {
          displacement = "up";
        } else if (thisBlockIndex < firstDraggedBlockIndex && thisBlockIndex >= blockDropTargetIndex) {
          displacement = "down";
        } else {
          displacement = "normal";
        }
        isNesting = typeof blockDropTargetIndex === "number" && blockDropTargetIndex - 1 === thisBlockIndex && blockDropPosition === "inside";
      }
    } else if (blockDropTargetIndex === null && firstDraggedBlockIndex !== void 0) {
      if (thisBlockIndex !== void 0 && thisBlockIndex >= firstDraggedBlockIndex) {
        displacement = "up";
      } else {
        displacement = "normal";
      }
    } else if (blockDropTargetIndex !== void 0 && blockDropTargetIndex !== null && firstDraggedBlockIndex === void 0) {
      if (thisBlockIndex !== void 0) {
        if (thisBlockIndex < blockDropTargetIndex) {
          displacement = "normal";
        } else {
          displacement = "down";
        }
      }
    } else if (blockDropTargetIndex === null) {
      displacement = "normal";
    }
  }
  return {
    displacement,
    isNesting,
    isAfterDraggedBlocks
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/block.js


























function ListViewBlock({
  block: { clientId },
  displacement,
  isAfterDraggedBlocks,
  isDragged,
  isNesting,
  isSelected,
  isBranchSelected,
  selectBlock,
  position,
  level,
  rowCount,
  siblingBlockCount,
  showBlockMovers,
  path,
  isExpanded,
  selectedClientIds,
  isSyncedBranch
}) {
  const cellRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const rowRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const settingsRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const [isHovered, setIsHovered] = (0,external_wp_element_namespaceObject.useState)(false);
  const [settingsAnchorRect, setSettingsAnchorRect] = (0,external_wp_element_namespaceObject.useState)();
  const { isLocked, canEdit, canMove } = useBlockLock(clientId);
  const isFirstSelectedBlock = isSelected && selectedClientIds[0] === clientId;
  const isLastSelectedBlock = isSelected && selectedClientIds[selectedClientIds.length - 1] === clientId;
  const {
    toggleBlockHighlight,
    duplicateBlocks,
    multiSelect,
    replaceBlocks,
    removeBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    setOpenedBlockSettingsMenu,
    updateBlockAttributes
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  const debouncedToggleBlockHighlight = (0,external_wp_compose_namespaceObject.useDebounce)(
    toggleBlockHighlight,
    50
  );
  const {
    canInsertBlockType,
    getSelectedBlockClientIds,
    getPreviousBlockClientId,
    getBlockRootClientId,
    getBlockOrder,
    getBlockParents,
    getBlocksByClientId,
    canRemoveBlocks,
    isGroupable
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getGroupingBlockName } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const blockInformation = useBlockDisplayInformation(clientId);
  const pasteStyles = usePasteStyles();
  const { block, blockName, allowRightClickOverrides, isBlockHidden } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlock, getBlockName, getSettings } = select(store);
      const { isBlockHidden: _isBlockHidden } = unlock(
        select(store)
      );
      return {
        block: getBlock(clientId),
        blockName: getBlockName(clientId),
        allowRightClickOverrides: getSettings().allowRightClickOverrides,
        isBlockHidden: _isBlockHidden(clientId)
      };
    },
    [clientId]
  );
  const showBlockActions = (
    // When a block hides its toolbar it also hides the block settings menu,
    // since that menu is part of the toolbar in the editor canvas.
    // List View respects this by also hiding the block settings menu.
    (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockName, "__experimentalToolbar", true)
  );
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ListViewBlock);
  const descriptionId = `list-view-block-select-button__description-${instanceId}`;
  const {
    expand,
    collapse,
    collapseAll,
    BlockSettingsMenu,
    listViewInstanceId,
    expandedState,
    setInsertedBlock,
    treeGridElementRef,
    rootClientId
  } = useListViewContext();
  const isMatch = (0,external_wp_keyboardShortcuts_namespaceObject.__unstableUseShortcutEventMatch)();
  function getBlocksToUpdate() {
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const isUpdatingSelectedBlocks = selectedBlockClientIds.includes(clientId);
    const firstBlockClientId = isUpdatingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
    const firstBlockRootClientId = getBlockRootClientId(firstBlockClientId);
    const blocksToUpdate = isUpdatingSelectedBlocks ? selectedBlockClientIds : [clientId];
    return {
      blocksToUpdate,
      firstBlockClientId,
      firstBlockRootClientId,
      selectedBlockClientIds
    };
  }
  async function onKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.target.closest("[role=dialog]")) {
      return;
    }
    const isDeleteKey = [external_wp_keycodes_namespaceObject.BACKSPACE, external_wp_keycodes_namespaceObject.DELETE].includes(event.keyCode);
    if (isMatch("core/block-editor/unselect", event) && selectedClientIds.length > 0) {
      event.stopPropagation();
      event.preventDefault();
      selectBlock(event, void 0);
    } else if (isDeleteKey || isMatch("core/block-editor/remove", event)) {
      const {
        blocksToUpdate: blocksToDelete,
        firstBlockClientId,
        firstBlockRootClientId,
        selectedBlockClientIds
      } = getBlocksToUpdate();
      if (!canRemoveBlocks(blocksToDelete)) {
        return;
      }
      let blockToFocus = getPreviousBlockClientId(firstBlockClientId) ?? // If the previous block is not found (when the first block is deleted),
      // fallback to focus the parent block.
      firstBlockRootClientId;
      removeBlocks(blocksToDelete, false);
      const shouldUpdateSelection = selectedBlockClientIds.length > 0 && getSelectedBlockClientIds().length === 0;
      if (!blockToFocus) {
        blockToFocus = getBlockOrder()[0];
      }
      updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
    } else if (isMatch("core/block-editor/paste-styles", event)) {
      event.preventDefault();
      const { blocksToUpdate } = getBlocksToUpdate();
      const blocks = getBlocksByClientId(blocksToUpdate);
      pasteStyles(blocks);
    } else if (isMatch("core/block-editor/duplicate", event)) {
      event.preventDefault();
      const { blocksToUpdate, firstBlockRootClientId } = getBlocksToUpdate();
      const canDuplicate = getBlocksByClientId(blocksToUpdate).every(
        (blockToUpdate) => {
          return !!blockToUpdate && (0,external_wp_blocks_namespaceObject.hasBlockSupport)(
            blockToUpdate.name,
            "multiple",
            true
          ) && canInsertBlockType(
            blockToUpdate.name,
            firstBlockRootClientId
          );
        }
      );
      if (canDuplicate) {
        const updatedBlocks = await duplicateBlocks(
          blocksToUpdate,
          false
        );
        if (updatedBlocks?.length) {
          updateFocusAndSelection(updatedBlocks[0], false);
        }
      }
    } else if (isMatch("core/block-editor/insert-before", event)) {
      event.preventDefault();
      const { blocksToUpdate } = getBlocksToUpdate();
      await insertBeforeBlock(blocksToUpdate[0]);
      const newlySelectedBlocks = getSelectedBlockClientIds();
      setOpenedBlockSettingsMenu(void 0);
      updateFocusAndSelection(newlySelectedBlocks[0], false);
    } else if (isMatch("core/block-editor/insert-after", event)) {
      event.preventDefault();
      const { blocksToUpdate } = getBlocksToUpdate();
      await insertAfterBlock(blocksToUpdate.at(-1));
      const newlySelectedBlocks = getSelectedBlockClientIds();
      setOpenedBlockSettingsMenu(void 0);
      updateFocusAndSelection(newlySelectedBlocks[0], false);
    } else if (isMatch("core/block-editor/select-all", event)) {
      event.preventDefault();
      const { firstBlockRootClientId, selectedBlockClientIds } = getBlocksToUpdate();
      const blockClientIds = getBlockOrder(firstBlockRootClientId);
      if (!blockClientIds.length) {
        return;
      }
      if (external_wp_isShallowEqual_default()(selectedBlockClientIds, blockClientIds)) {
        if (firstBlockRootClientId && firstBlockRootClientId !== rootClientId) {
          updateFocusAndSelection(firstBlockRootClientId, true);
          return;
        }
      }
      multiSelect(
        blockClientIds[0],
        blockClientIds[blockClientIds.length - 1],
        null
      );
    } else if (isMatch("core/block-editor/collapse-list-view", event)) {
      event.preventDefault();
      const { firstBlockClientId } = getBlocksToUpdate();
      const blockParents = getBlockParents(firstBlockClientId, false);
      collapseAll();
      expand(blockParents);
    } else if (isMatch("core/block-editor/group", event)) {
      const { blocksToUpdate } = getBlocksToUpdate();
      if (blocksToUpdate.length > 1 && isGroupable(blocksToUpdate)) {
        event.preventDefault();
        const blocks = getBlocksByClientId(blocksToUpdate);
        const groupingBlockName = getGroupingBlockName();
        const newBlocks = (0,external_wp_blocks_namespaceObject.switchToBlockType)(
          blocks,
          groupingBlockName
        );
        replaceBlocks(blocksToUpdate, newBlocks);
        (0,external_wp_a11y_namespaceObject.speak)((0,external_wp_i18n_namespaceObject.__)("Selected blocks are grouped."));
        const newlySelectedBlocks = getSelectedBlockClientIds();
        setOpenedBlockSettingsMenu(void 0);
        updateFocusAndSelection(newlySelectedBlocks[0], false);
      }
    } else if (isMatch("core/block-editor/toggle-block-visibility", event)) {
      event.preventDefault();
      const { blocksToUpdate } = getBlocksToUpdate();
      const blocks = getBlocksByClientId(blocksToUpdate);
      const canToggleVisibility = blocks.every(
        (blockToUpdate) => (0,external_wp_blocks_namespaceObject.hasBlockSupport)(blockToUpdate.name, "visibility", true)
      );
      if (!canToggleVisibility) {
        return;
      }
      const hasHiddenBlock = blocks.some(
        (blockToUpdate) => blockToUpdate.attributes.metadata?.blockVisibility === false
      );
      const attributesByClientId = Object.fromEntries(
        blocks.map(({ clientId: mapClientId, attributes }) => [
          mapClientId,
          {
            metadata: utils_cleanEmptyObject({
              ...attributes?.metadata,
              blockVisibility: hasHiddenBlock ? void 0 : false
            })
          }
        ])
      );
      updateBlockAttributes(blocksToUpdate, attributesByClientId, {
        uniqueByBlock: true
      });
    }
  }
  const onMouseEnter = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsHovered(true);
    debouncedToggleBlockHighlight(clientId, true);
  }, [clientId, setIsHovered, debouncedToggleBlockHighlight]);
  const onMouseLeave = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsHovered(false);
    debouncedToggleBlockHighlight(clientId, false);
  }, [clientId, setIsHovered, debouncedToggleBlockHighlight]);
  const selectEditorBlock = (0,external_wp_element_namespaceObject.useCallback)(
    (event) => {
      selectBlock(event, clientId);
      event.preventDefault();
    },
    [clientId, selectBlock]
  );
  const updateFocusAndSelection = (0,external_wp_element_namespaceObject.useCallback)(
    (focusClientId, shouldSelectBlock) => {
      if (shouldSelectBlock) {
        selectBlock(void 0, focusClientId, null, null);
      }
      focusListItem(focusClientId, treeGridElementRef?.current);
    },
    [selectBlock, treeGridElementRef]
  );
  const toggleExpanded = (0,external_wp_element_namespaceObject.useCallback)(
    (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (isExpanded === true) {
        collapse(clientId);
      } else if (isExpanded === false) {
        expand(clientId);
      }
    },
    [clientId, expand, collapse, isExpanded]
  );
  const onContextMenu = (0,external_wp_element_namespaceObject.useCallback)(
    (event) => {
      if (showBlockActions && allowRightClickOverrides) {
        settingsRef.current?.click();
        setSettingsAnchorRect(
          new window.DOMRect(event.clientX, event.clientY, 0, 0)
        );
        event.preventDefault();
      }
    },
    [allowRightClickOverrides, settingsRef, showBlockActions]
  );
  const onMouseDown = (0,external_wp_element_namespaceObject.useCallback)(
    (event) => {
      if (allowRightClickOverrides && event.button === 2) {
        event.preventDefault();
      }
    },
    [allowRightClickOverrides]
  );
  const settingsPopoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const { ownerDocument } = rowRef?.current || {};
    if (!settingsAnchorRect || !ownerDocument) {
      return void 0;
    }
    return {
      ownerDocument,
      getBoundingClientRect() {
        return settingsAnchorRect;
      }
    };
  }, [settingsAnchorRect]);
  const clearSettingsAnchorRect = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setSettingsAnchorRect(void 0);
  }, [setSettingsAnchorRect]);
  useListViewScrollIntoView({
    isSelected,
    rowItemRef: rowRef,
    selectedClientIds
  });
  if (!block) {
    return null;
  }
  const blockPositionDescription = getBlockPositionDescription(
    position,
    siblingBlockCount,
    level
  );
  const blockPropertiesDescription = getBlockPropertiesDescription(
    blockInformation,
    isLocked
  );
  const blockVisibilityDescription = isBlockHidden ? (0,external_wp_i18n_namespaceObject.__)("Block is hidden.") : null;
  const hasSiblings = siblingBlockCount > 0;
  const hasRenderedMovers = showBlockMovers && hasSiblings;
  const moverCellClassName = dist_clsx(
    "block-editor-list-view-block__mover-cell",
    { "is-visible": isHovered || isSelected }
  );
  const listViewBlockSettingsClassName = dist_clsx(
    "block-editor-list-view-block__menu-cell",
    { "is-visible": isHovered || isFirstSelectedBlock }
  );
  let colSpan;
  if (hasRenderedMovers) {
    colSpan = 2;
  } else if (!showBlockActions) {
    colSpan = 3;
  }
  const classes = dist_clsx({
    "is-selected": isSelected,
    "is-first-selected": isFirstSelectedBlock,
    "is-last-selected": isLastSelectedBlock,
    "is-branch-selected": isBranchSelected,
    "is-synced-branch": isSyncedBranch,
    "is-dragging": isDragged,
    "has-single-cell": !showBlockActions,
    "is-synced": blockInformation?.isSynced,
    "is-draggable": canMove,
    "is-displacement-normal": displacement === "normal",
    "is-displacement-up": displacement === "up",
    "is-displacement-down": displacement === "down",
    "is-after-dragged-blocks": isAfterDraggedBlocks,
    "is-nesting": isNesting
  });
  const dropdownClientIds = selectedClientIds.includes(clientId) ? selectedClientIds : [clientId];
  const currentlyEditingBlockInCanvas = isSelected && selectedClientIds.length === 1;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    leaf_default,
    {
      className: classes,
      isDragged,
      onKeyDown,
      onMouseEnter,
      onMouseLeave,
      onFocus: onMouseEnter,
      onBlur: onMouseLeave,
      level,
      position,
      rowCount,
      path,
      id: `list-view-${listViewInstanceId}-block-${clientId}`,
      "data-block": clientId,
      "data-expanded": canEdit ? isExpanded : void 0,
      ref: rowRef,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalTreeGridCell,
          {
            className: "block-editor-list-view-block__contents-cell",
            colSpan,
            ref: cellRef,
            "aria-selected": !!isSelected,
            children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-list-view-block__contents-container", children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                block_contents_default,
                {
                  block,
                  onClick: selectEditorBlock,
                  onContextMenu,
                  onMouseDown,
                  onToggleExpanded: toggleExpanded,
                  isSelected,
                  position,
                  siblingBlockCount,
                  level,
                  ref,
                  tabIndex: currentlyEditingBlockInCanvas ? 0 : tabIndex,
                  onFocus,
                  isExpanded: canEdit ? isExpanded : void 0,
                  selectedClientIds,
                  ariaDescribedBy: descriptionId
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(AriaReferencedText, { id: descriptionId, children: [
                blockPositionDescription,
                blockPropertiesDescription,
                blockVisibilityDescription
              ].filter(Boolean).join(" ") })
            ] })
          }
        ),
        hasRenderedMovers && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
          external_wp_components_namespaceObject.__experimentalTreeGridCell,
          {
            className: moverCellClassName,
            withoutGridItem: true,
            children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTreeGridItem, { children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                BlockMoverUpButton,
                {
                  orientation: "vertical",
                  clientIds: [clientId],
                  ref,
                  tabIndex,
                  onFocus
                }
              ) }),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTreeGridItem, { children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                BlockMoverDownButton,
                {
                  orientation: "vertical",
                  clientIds: [clientId],
                  ref,
                  tabIndex,
                  onFocus
                }
              ) })
            ]
          }
        ) }),
        showBlockActions && BlockSettingsMenu && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalTreeGridCell,
          {
            className: listViewBlockSettingsClassName,
            "aria-selected": !!isSelected,
            ref: settingsRef,
            children: ({ ref, tabIndex, onFocus }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BlockSettingsMenu,
              {
                clientIds: dropdownClientIds,
                block,
                icon: more_vertical_default,
                label: (0,external_wp_i18n_namespaceObject.__)("Options"),
                popoverProps: {
                  anchor: settingsPopoverAnchor
                  // Used to position the settings at the cursor on right-click.
                },
                toggleProps: {
                  ref,
                  className: "block-editor-list-view-block__menu",
                  tabIndex,
                  onClick: clearSettingsAnchorRect,
                  onFocus,
                  size: "small"
                },
                disableOpenOnArrowDown: true,
                expand,
                expandedState,
                setInsertedBlock,
                __experimentalSelectBlock: updateFocusAndSelection
              }
            )
          }
        )
      ]
    }
  );
}
var list_view_block_block_default = (0,external_wp_element_namespaceObject.memo)(ListViewBlock);


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/branch.js










function countBlocks(block, expandedState, draggedClientIds, isExpandedByDefault) {
  const isDragged = draggedClientIds?.includes(block.clientId);
  if (isDragged) {
    return 0;
  }
  const isExpanded = expandedState[block.clientId] ?? isExpandedByDefault;
  if (isExpanded) {
    return 1 + block.innerBlocks.reduce(
      countReducer(
        expandedState,
        draggedClientIds,
        isExpandedByDefault
      ),
      0
    );
  }
  return 1;
}
const countReducer = (expandedState, draggedClientIds, isExpandedByDefault) => (count, block) => {
  const isDragged = draggedClientIds?.includes(block.clientId);
  if (isDragged) {
    return count;
  }
  const isExpanded = expandedState[block.clientId] ?? isExpandedByDefault;
  if (isExpanded && block.innerBlocks.length > 0) {
    return count + countBlocks(
      block,
      expandedState,
      draggedClientIds,
      isExpandedByDefault
    );
  }
  return count + 1;
};
const branch_noop = () => {
};
function ListViewBranch(props) {
  const {
    blocks,
    selectBlock = branch_noop,
    showBlockMovers,
    selectedClientIds,
    level = 1,
    path = "",
    isBranchSelected = false,
    listPosition = 0,
    fixedListWindow,
    isExpanded,
    parentId,
    shouldShowInnerBlocks = true,
    isSyncedBranch = false,
    showAppender: showAppenderProp = true
  } = props;
  const parentBlockInformation = useBlockDisplayInformation(parentId);
  const syncedBranch = isSyncedBranch || !!parentBlockInformation?.isSynced;
  const canParentExpand = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!parentId) {
        return true;
      }
      return select(store).canEditBlock(parentId);
    },
    [parentId]
  );
  const {
    blockDropPosition,
    blockDropTargetIndex,
    firstDraggedBlockIndex,
    blockIndexes,
    expandedState,
    draggedClientIds
  } = useListViewContext();
  const nextPositionRef = (0,external_wp_element_namespaceObject.useRef)();
  if (!canParentExpand) {
    return null;
  }
  const showAppender = showAppenderProp && level === 1;
  const filteredBlocks = blocks.filter(Boolean);
  const blockCount = filteredBlocks.length;
  const rowCount = showAppender ? blockCount + 1 : blockCount;
  nextPositionRef.current = listPosition;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    filteredBlocks.map((block, index) => {
      const { clientId, innerBlocks } = block;
      if (index > 0) {
        nextPositionRef.current += countBlocks(
          filteredBlocks[index - 1],
          expandedState,
          draggedClientIds,
          isExpanded
        );
      }
      const isDragged = !!draggedClientIds?.includes(clientId);
      const { displacement, isAfterDraggedBlocks, isNesting } = getDragDisplacementValues({
        blockIndexes,
        blockDropTargetIndex,
        blockDropPosition,
        clientId,
        firstDraggedBlockIndex,
        isDragged
      });
      const { itemInView } = fixedListWindow;
      const blockInView = itemInView(nextPositionRef.current);
      const position = index + 1;
      const updatedPath = path.length > 0 ? `${path}_${position}` : `${position}`;
      const hasNestedBlocks = !!innerBlocks?.length;
      const shouldExpand = hasNestedBlocks && shouldShowInnerBlocks ? expandedState[clientId] ?? isExpanded : void 0;
      const isSelected = isClientIdSelected(
        clientId,
        selectedClientIds
      );
      const isSelectedBranch = isBranchSelected || isSelected && hasNestedBlocks;
      const showBlock = isDragged || blockInView || isSelected && clientId === selectedClientIds[0] || index === 0 || index === blockCount - 1;
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_data_namespaceObject.AsyncModeProvider, { value: !isSelected, children: [
        showBlock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          list_view_block_block_default,
          {
            block,
            selectBlock,
            isSelected,
            isBranchSelected: isSelectedBranch,
            isDragged,
            level,
            position,
            rowCount,
            siblingBlockCount: blockCount,
            showBlockMovers,
            path: updatedPath,
            isExpanded: isDragged ? false : shouldExpand,
            listPosition: nextPositionRef.current,
            selectedClientIds,
            isSyncedBranch: syncedBranch,
            displacement,
            isAfterDraggedBlocks,
            isNesting
          }
        ),
        !showBlock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("tr", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("td", { className: "block-editor-list-view-placeholder" }) }),
        hasNestedBlocks && shouldExpand && !isDragged && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          ListViewBranch,
          {
            parentId: clientId,
            blocks: innerBlocks,
            selectBlock,
            showBlockMovers,
            level: level + 1,
            path: updatedPath,
            listPosition: nextPositionRef.current + 1,
            fixedListWindow,
            isBranchSelected: isSelectedBranch,
            selectedClientIds,
            isExpanded,
            isSyncedBranch: syncedBranch
          }
        )
      ] }, clientId);
    }),
    showAppender && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.__experimentalTreeGridRow,
      {
        level,
        setSize: rowCount,
        positionInSet: rowCount,
        isExpanded: true,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTreeGridCell, { children: (treeGridCellProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          Appender,
          {
            clientId: parentId,
            nestingLevel: level,
            blockCount,
            ...treeGridCellProps
          }
        ) })
      }
    )
  ] });
}
var branch_default = (0,external_wp_element_namespaceObject.memo)(ListViewBranch);


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/drop-indicator.js










function ListViewDropIndicatorPreview({
  draggedBlockClientId,
  listViewRef,
  blockDropTarget
}) {
  const blockInformation = useBlockDisplayInformation(draggedBlockClientId);
  const blockTitle = useBlockDisplayTitle({
    clientId: draggedBlockClientId,
    context: "list-view"
  });
  const { rootClientId, clientId, dropPosition } = blockDropTarget || {};
  const [rootBlockElement, blockElement] = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!listViewRef.current) {
      return [];
    }
    const _rootBlockElement = rootClientId ? listViewRef.current.querySelector(
      `[data-block="${rootClientId}"]`
    ) : void 0;
    const _blockElement = clientId ? listViewRef.current.querySelector(
      `[data-block="${clientId}"]`
    ) : void 0;
    return [_rootBlockElement, _blockElement];
  }, [listViewRef, rootClientId, clientId]);
  const targetElement = blockElement || rootBlockElement;
  const rtl = (0,external_wp_i18n_namespaceObject.isRTL)();
  const getDropIndicatorWidth = (0,external_wp_element_namespaceObject.useCallback)(
    (targetElementRect, indent) => {
      if (!targetElement) {
        return 0;
      }
      let width = targetElement.offsetWidth;
      const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(
        targetElement,
        "horizontal"
      );
      const ownerDocument = targetElement.ownerDocument;
      const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
      if (scrollContainer && !windowScroll) {
        const scrollContainerRect = scrollContainer.getBoundingClientRect();
        const distanceBetweenContainerAndTarget = (0,external_wp_i18n_namespaceObject.isRTL)() ? scrollContainerRect.right - targetElementRect.right : targetElementRect.left - scrollContainerRect.left;
        const scrollContainerWidth = scrollContainer.clientWidth;
        if (scrollContainerWidth < width + distanceBetweenContainerAndTarget) {
          width = scrollContainerWidth - distanceBetweenContainerAndTarget;
        }
        if (!rtl && targetElementRect.left + indent < scrollContainerRect.left) {
          width -= scrollContainerRect.left - targetElementRect.left;
          return width;
        }
        if (rtl && targetElementRect.right - indent > scrollContainerRect.right) {
          width -= targetElementRect.right - scrollContainerRect.right;
          return width;
        }
      }
      return width - indent;
    },
    [rtl, targetElement]
  );
  const style = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!targetElement) {
      return {};
    }
    const targetElementRect = targetElement.getBoundingClientRect();
    return {
      width: getDropIndicatorWidth(targetElementRect, 0)
    };
  }, [getDropIndicatorWidth, targetElement]);
  const horizontalScrollOffsetStyle = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!targetElement) {
      return {};
    }
    const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(targetElement);
    const ownerDocument = targetElement.ownerDocument;
    const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
    if (scrollContainer && !windowScroll) {
      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      const targetElementRect = targetElement.getBoundingClientRect();
      const distanceBetweenContainerAndTarget = rtl ? scrollContainerRect.right - targetElementRect.right : targetElementRect.left - scrollContainerRect.left;
      if (!rtl && scrollContainerRect.left > targetElementRect.left) {
        return {
          transform: `translateX( ${distanceBetweenContainerAndTarget}px )`
        };
      }
      if (rtl && scrollContainerRect.right < targetElementRect.right) {
        return {
          transform: `translateX( ${distanceBetweenContainerAndTarget * -1}px )`
        };
      }
    }
    return {};
  }, [rtl, targetElement]);
  const ariaLevel = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!rootBlockElement) {
      return 1;
    }
    const _ariaLevel = parseInt(
      rootBlockElement.getAttribute("aria-level"),
      10
    );
    return _ariaLevel ? _ariaLevel + 1 : 1;
  }, [rootBlockElement]);
  const hasAdjacentSelectedBranch = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (!targetElement) {
      return false;
    }
    return targetElement.classList.contains("is-branch-selected");
  }, [targetElement]);
  const popoverAnchor = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const isValidDropPosition = dropPosition === "top" || dropPosition === "bottom" || dropPosition === "inside";
    if (!targetElement || !isValidDropPosition) {
      return void 0;
    }
    return {
      contextElement: targetElement,
      getBoundingClientRect() {
        const rect = targetElement.getBoundingClientRect();
        let left = rect.left;
        let top = 0;
        const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(
          targetElement,
          "horizontal"
        );
        const doc = targetElement.ownerDocument;
        const windowScroll = scrollContainer === doc.body || scrollContainer === doc.documentElement;
        if (scrollContainer && !windowScroll) {
          const scrollContainerRect = scrollContainer.getBoundingClientRect();
          const scrollbarWidth = rtl ? scrollContainer.offsetWidth - scrollContainer.clientWidth : 0;
          if (left < scrollContainerRect.left + scrollbarWidth) {
            left = scrollContainerRect.left + scrollbarWidth;
          }
        }
        if (dropPosition === "top") {
          top = rect.top - rect.height * 2;
        } else {
          top = rect.top;
        }
        const width = getDropIndicatorWidth(rect, 0);
        const height = rect.height;
        return new window.DOMRect(left, top, width, height);
      }
    };
  }, [targetElement, dropPosition, getDropIndicatorWidth, rtl]);
  if (!targetElement) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      animate: false,
      anchor: popoverAnchor,
      focusOnMount: false,
      className: "block-editor-list-view-drop-indicator--preview",
      variant: "unstyled",
      flip: false,
      resize: true,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "div",
        {
          style,
          className: dist_clsx(
            "block-editor-list-view-drop-indicator__line",
            {
              "block-editor-list-view-drop-indicator__line--darker": hasAdjacentSelectedBranch
            }
          ),
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
            "div",
            {
              className: "block-editor-list-view-leaf",
              "aria-level": ariaLevel,
              children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
                  "div",
                  {
                    className: dist_clsx(
                      "block-editor-list-view-block-select-button",
                      "block-editor-list-view-block-contents"
                    ),
                    style: horizontalScrollOffsetStyle,
                    children: [
                      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ListViewExpander, { onClick: () => {
                      } }),
                      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                        block_icon_default,
                        {
                          icon: blockInformation?.icon,
                          showColors: true,
                          context: "list-view"
                        }
                      ),
                      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                        external_wp_components_namespaceObject.__experimentalHStack,
                        {
                          alignment: "center",
                          className: "block-editor-list-view-block-select-button__label-wrapper",
                          justify: "flex-start",
                          spacing: 1,
                          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-list-view-block-select-button__title", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { ellipsizeMode: "auto", children: blockTitle }) })
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-list-view-block__menu-cell" })
              ]
            }
          )
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-block-selection.js








function useBlockSelection() {
  const { clearSelectedBlock, multiSelect, selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    getBlockName,
    getBlockParents,
    getBlockSelectionStart,
    getSelectedBlockClientIds,
    hasMultiSelection,
    hasSelectedBlock
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { getBlockType } = (0,external_wp_data_namespaceObject.useSelect)(external_wp_blocks_namespaceObject.store);
  const updateBlockSelection = (0,external_wp_element_namespaceObject.useCallback)(
    async (event, clientId, destinationClientId, focusPosition) => {
      if (!event?.shiftKey && event?.keyCode !== external_wp_keycodes_namespaceObject.ESCAPE) {
        selectBlock(clientId, focusPosition);
        return;
      }
      event.preventDefault();
      const isOnlyDeselection = event.type === "keydown" && event.keyCode === external_wp_keycodes_namespaceObject.ESCAPE;
      const isKeyPress = event.type === "keydown" && (event.keyCode === external_wp_keycodes_namespaceObject.UP || event.keyCode === external_wp_keycodes_namespaceObject.DOWN || event.keyCode === external_wp_keycodes_namespaceObject.HOME || event.keyCode === external_wp_keycodes_namespaceObject.END);
      if (!isKeyPress && !hasSelectedBlock() && !hasMultiSelection()) {
        selectBlock(clientId, null);
        return;
      }
      const selectedBlocks = getSelectedBlockClientIds();
      const clientIdWithParents = [
        ...getBlockParents(clientId),
        clientId
      ];
      if (isOnlyDeselection || isKeyPress && !selectedBlocks.some(
        (blockId) => clientIdWithParents.includes(blockId)
      )) {
        await clearSelectedBlock();
      }
      if (!isOnlyDeselection) {
        let startTarget = getBlockSelectionStart();
        let endTarget = clientId;
        if (isKeyPress) {
          if (!hasSelectedBlock() && !hasMultiSelection()) {
            startTarget = clientId;
          }
          if (destinationClientId) {
            endTarget = destinationClientId;
          }
        }
        const startParents = getBlockParents(startTarget);
        const endParents = getBlockParents(endTarget);
        const { start, end } = getCommonDepthClientIds(
          startTarget,
          endTarget,
          startParents,
          endParents
        );
        await multiSelect(start, end, null);
      }
      const updatedSelectedBlocks = getSelectedBlockClientIds();
      if ((event.keyCode === external_wp_keycodes_namespaceObject.HOME || event.keyCode === external_wp_keycodes_namespaceObject.END) && updatedSelectedBlocks.length > 1) {
        return;
      }
      const selectionDiff = selectedBlocks.filter(
        (blockId) => !updatedSelectedBlocks.includes(blockId)
      );
      let label;
      if (selectionDiff.length === 1) {
        const title = getBlockType(
          getBlockName(selectionDiff[0])
        )?.title;
        if (title) {
          label = (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %s: block name */
            (0,external_wp_i18n_namespaceObject.__)("%s deselected."),
            title
          );
        }
      } else if (selectionDiff.length > 1) {
        label = (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %s: number of deselected blocks */
          (0,external_wp_i18n_namespaceObject.__)("%s blocks deselected."),
          selectionDiff.length
        );
      }
      if (label) {
        (0,external_wp_a11y_namespaceObject.speak)(label, "assertive");
      }
    },
    [
      clearSelectedBlock,
      getBlockName,
      getBlockType,
      getBlockParents,
      getBlockSelectionStart,
      getSelectedBlockClientIds,
      hasMultiSelection,
      hasSelectedBlock,
      multiSelect,
      selectBlock
    ]
  );
  return {
    updateBlockSelection
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-block-indexes.js

function useListViewBlockIndexes(blocks) {
  const blockIndexes = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const indexes = {};
    let currentGlobalIndex = 0;
    const traverseBlocks = (blockList) => {
      blockList.forEach((block) => {
        indexes[block.clientId] = currentGlobalIndex;
        currentGlobalIndex++;
        if (block.innerBlocks.length > 0) {
          traverseBlocks(block.innerBlocks);
        }
      });
    };
    traverseBlocks(blocks);
    return indexes;
  }, [blocks]);
  return blockIndexes;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-client-ids.js



function useListViewClientIds({ blocks, rootClientId }) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getDraggedBlockClientIds,
        getSelectedBlockClientIds,
        getEnabledClientIdsTree
      } = unlock(select(store));
      return {
        selectedClientIds: getSelectedBlockClientIds(),
        draggedClientIds: getDraggedBlockClientIds(),
        clientIdsTree: blocks ?? getEnabledClientIdsTree(rootClientId)
      };
    },
    [blocks, rootClientId]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-collapse-items.js




function useListViewCollapseItems({ collapseAll, expand }) {
  const { expandedBlock, getBlockParents } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getBlockParents: _getBlockParents, getExpandedBlock } = unlock(
      select(store)
    );
    return {
      expandedBlock: getExpandedBlock(),
      getBlockParents: _getBlockParents
    };
  }, []);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (expandedBlock) {
      const blockParents = getBlockParents(expandedBlock, false);
      collapseAll();
      expand(blockParents);
    }
  }, [collapseAll, expand, expandedBlock, getBlockParents]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-drop-zone.js







const NESTING_LEVEL_INDENTATION = 24;
function isUpGesture(point, rect, nestingLevel = 1, rtl = false) {
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  return rtl ? point.x > blockIndentPosition : point.x < blockIndentPosition;
}
function getDesiredRelativeParentLevel(point, rect, nestingLevel = 1, rtl = false) {
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  const distanceBetweenPointAndBlockIndentPosition = rtl ? blockIndentPosition - point.x : point.x - blockIndentPosition;
  const desiredParentLevel = Math.round(
    distanceBetweenPointAndBlockIndentPosition / NESTING_LEVEL_INDENTATION
  );
  return Math.abs(desiredParentLevel);
}
function getCandidateBlockParents(candidateBlockData, blocksData) {
  const candidateBlockParents = [];
  let currentBlockData = candidateBlockData;
  while (currentBlockData) {
    candidateBlockParents.push({ ...currentBlockData });
    currentBlockData = blocksData.find(
      (blockData) => blockData.clientId === currentBlockData.rootClientId
    );
  }
  return candidateBlockParents;
}
function getNextNonDraggedBlock(blocksData, index) {
  const nextBlockData = blocksData[index + 1];
  if (nextBlockData && nextBlockData.isDraggedBlock) {
    return getNextNonDraggedBlock(blocksData, index + 1);
  }
  return nextBlockData;
}
function isNestingGesture(point, rect, nestingLevel = 1, rtl = false) {
  const blockIndentPosition = rtl ? rect.right - nestingLevel * NESTING_LEVEL_INDENTATION : rect.left + nestingLevel * NESTING_LEVEL_INDENTATION;
  const isNestingHorizontalGesture = rtl ? point.x < blockIndentPosition - NESTING_LEVEL_INDENTATION : point.x > blockIndentPosition + NESTING_LEVEL_INDENTATION;
  return isNestingHorizontalGesture && point.y < rect.bottom;
}
const ALLOWED_DROP_EDGES = ["top", "bottom"];
function getListViewDropTarget(blocksData, position, rtl = false) {
  let candidateEdge;
  let candidateBlockData;
  let candidateDistance;
  let candidateRect;
  let candidateBlockIndex;
  for (let i = 0; i < blocksData.length; i++) {
    const blockData = blocksData[i];
    if (blockData.isDraggedBlock) {
      continue;
    }
    const rect = blockData.element.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(
      position,
      rect,
      ALLOWED_DROP_EDGES
    );
    const isCursorWithinBlock = isPointContainedByRect(position, rect);
    if (candidateDistance === void 0 || distance < candidateDistance || isCursorWithinBlock) {
      candidateDistance = distance;
      const index = blocksData.indexOf(blockData);
      const previousBlockData = blocksData[index - 1];
      if (edge === "top" && previousBlockData && previousBlockData.rootClientId === blockData.rootClientId && !previousBlockData.isDraggedBlock) {
        candidateBlockData = previousBlockData;
        candidateEdge = "bottom";
        candidateRect = previousBlockData.element.getBoundingClientRect();
        candidateBlockIndex = index - 1;
      } else {
        candidateBlockData = blockData;
        candidateEdge = edge;
        candidateRect = rect;
        candidateBlockIndex = index;
      }
      if (isCursorWithinBlock) {
        break;
      }
    }
  }
  if (!candidateBlockData) {
    return;
  }
  const candidateBlockParents = getCandidateBlockParents(
    candidateBlockData,
    blocksData
  );
  const isDraggingBelow = candidateEdge === "bottom";
  if (isDraggingBelow && candidateBlockData.canInsertDraggedBlocksAsChild && (candidateBlockData.innerBlockCount > 0 && candidateBlockData.isExpanded || isNestingGesture(
    position,
    candidateRect,
    candidateBlockParents.length,
    rtl
  ))) {
    const newBlockIndex = candidateBlockData.isExpanded ? 0 : candidateBlockData.innerBlockCount || 0;
    return {
      rootClientId: candidateBlockData.clientId,
      clientId: candidateBlockData.clientId,
      blockIndex: newBlockIndex,
      dropPosition: "inside"
    };
  }
  if (isDraggingBelow && candidateBlockData.rootClientId && isUpGesture(
    position,
    candidateRect,
    candidateBlockParents.length,
    rtl
  )) {
    const nextBlock = getNextNonDraggedBlock(
      blocksData,
      candidateBlockIndex
    );
    const currentLevel = candidateBlockData.nestingLevel;
    const nextLevel = nextBlock ? nextBlock.nestingLevel : 1;
    if (currentLevel && nextLevel) {
      const desiredRelativeLevel = getDesiredRelativeParentLevel(
        position,
        candidateRect,
        candidateBlockParents.length,
        rtl
      );
      const targetParentIndex = Math.max(
        Math.min(desiredRelativeLevel, currentLevel - nextLevel),
        0
      );
      if (candidateBlockParents[targetParentIndex]) {
        let newBlockIndex = candidateBlockData.blockIndex;
        if (candidateBlockParents[targetParentIndex].nestingLevel === nextBlock?.nestingLevel) {
          newBlockIndex = nextBlock?.blockIndex;
        } else {
          for (let i = candidateBlockIndex; i >= 0; i--) {
            const blockData = blocksData[i];
            if (blockData.rootClientId === candidateBlockParents[targetParentIndex].rootClientId) {
              newBlockIndex = blockData.blockIndex + 1;
              break;
            }
          }
        }
        return {
          rootClientId: candidateBlockParents[targetParentIndex].rootClientId,
          clientId: candidateBlockData.clientId,
          blockIndex: newBlockIndex,
          dropPosition: candidateEdge
        };
      }
    }
  }
  if (!candidateBlockData.canInsertDraggedBlocksAsSibling) {
    return;
  }
  const offset = isDraggingBelow ? 1 : 0;
  return {
    rootClientId: candidateBlockData.rootClientId,
    clientId: candidateBlockData.clientId,
    blockIndex: candidateBlockData.blockIndex + offset,
    dropPosition: candidateEdge
  };
}
const EXPAND_THROTTLE_OPTIONS = {
  leading: false,
  // Don't call the function immediately on the first call.
  trailing: true
  // Do call the function on the last call.
};
function useListViewDropZone({
  dropZoneElement,
  expandedState,
  setExpandedState
}) {
  const {
    getBlockRootClientId,
    getBlockIndex,
    getBlockCount,
    getDraggedBlockClientIds,
    canInsertBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const [target, setTarget] = (0,external_wp_element_namespaceObject.useState)();
  const { rootClientId: targetRootClientId, blockIndex: targetBlockIndex } = target || {};
  const onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  const rtl = (0,external_wp_i18n_namespaceObject.isRTL)();
  const previousRootClientId = (0,external_wp_compose_namespaceObject.usePrevious)(targetRootClientId);
  const maybeExpandBlock = (0,external_wp_element_namespaceObject.useCallback)(
    (_expandedState, _target) => {
      const { rootClientId } = _target || {};
      if (!rootClientId) {
        return;
      }
      if (_target?.dropPosition === "inside" && !_expandedState[rootClientId]) {
        setExpandedState({
          type: "expand",
          clientIds: [rootClientId]
        });
      }
    },
    [setExpandedState]
  );
  const throttledMaybeExpandBlock = (0,external_wp_compose_namespaceObject.useThrottle)(
    maybeExpandBlock,
    500,
    EXPAND_THROTTLE_OPTIONS
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (target?.dropPosition !== "inside" || previousRootClientId !== target?.rootClientId) {
      throttledMaybeExpandBlock.cancel();
      return;
    }
    throttledMaybeExpandBlock(expandedState, target);
  }, [
    expandedState,
    previousRootClientId,
    target,
    throttledMaybeExpandBlock
  ]);
  const draggedBlockClientIds = getDraggedBlockClientIds();
  const throttled = (0,external_wp_compose_namespaceObject.useThrottle)(
    (0,external_wp_element_namespaceObject.useCallback)(
      (event, currentTarget) => {
        const position = { x: event.clientX, y: event.clientY };
        const isBlockDrag = !!draggedBlockClientIds?.length;
        const blockElements = Array.from(
          currentTarget.querySelectorAll("[data-block]")
        );
        const blocksData = blockElements.map((blockElement) => {
          const clientId = blockElement.dataset.block;
          const isExpanded = blockElement.dataset.expanded === "true";
          const isDraggedBlock = blockElement.classList.contains("is-dragging");
          const nestingLevel = parseInt(
            blockElement.getAttribute("aria-level"),
            10
          );
          const rootClientId = getBlockRootClientId(clientId);
          return {
            clientId,
            isExpanded,
            rootClientId,
            blockIndex: getBlockIndex(clientId),
            element: blockElement,
            nestingLevel: nestingLevel || void 0,
            isDraggedBlock: isBlockDrag ? isDraggedBlock : false,
            innerBlockCount: getBlockCount(clientId),
            canInsertDraggedBlocksAsSibling: isBlockDrag ? canInsertBlocks(
              draggedBlockClientIds,
              rootClientId
            ) : true,
            canInsertDraggedBlocksAsChild: isBlockDrag ? canInsertBlocks(draggedBlockClientIds, clientId) : true
          };
        });
        const newTarget = getListViewDropTarget(
          blocksData,
          position,
          rtl
        );
        if (newTarget) {
          setTarget(newTarget);
        }
      },
      [
        canInsertBlocks,
        draggedBlockClientIds,
        getBlockCount,
        getBlockIndex,
        getBlockRootClientId,
        rtl
      ]
    ),
    50
  );
  const ref = (0,external_wp_compose_namespaceObject.__experimentalUseDropZone)({
    dropZoneElement,
    onDrop(event) {
      throttled.cancel();
      if (target) {
        onBlockDrop(event);
      }
      setTarget(void 0);
    },
    onDragLeave() {
      throttled.cancel();
      setTarget(null);
    },
    onDragOver(event) {
      throttled(event, event.currentTarget);
    },
    onDragEnd() {
      throttled.cancel();
      setTarget(void 0);
    }
  });
  return { ref, target };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-list-view-expand-selected-item.js



function useListViewExpandSelectedItem({
  firstSelectedBlockClientId,
  setExpandedState
}) {
  const [selectedTreeId, setSelectedTreeId] = (0,external_wp_element_namespaceObject.useState)(null);
  const { selectedBlockParentClientIds } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockParents } = select(store);
      return {
        selectedBlockParentClientIds: getBlockParents(
          firstSelectedBlockClientId,
          false
        )
      };
    },
    [firstSelectedBlockClientId]
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (selectedTreeId === firstSelectedBlockClientId) {
      return;
    }
    if (selectedBlockParentClientIds?.length) {
      setExpandedState({
        type: "expand",
        clientIds: selectedBlockParentClientIds
      });
    }
  }, [
    firstSelectedBlockClientId,
    selectedBlockParentClientIds,
    selectedTreeId,
    setExpandedState
  ]);
  return {
    setSelectedTreeId
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/use-clipboard-handler.js






function use_clipboard_handler_useClipboardHandler({ selectBlock }) {
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const {
    getBlockOrder,
    getBlockRootClientId,
    getBlocksByClientId,
    getPreviousBlockClientId,
    getSelectedBlockClientIds,
    getSettings,
    canInsertBlockType,
    canRemoveBlocks
  } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { flashBlock, removeBlocks, replaceBlocks, insertBlocks } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const notifyCopy = useNotifyCopy();
  return (0,external_wp_compose_namespaceObject.useRefEffect)((node) => {
    function updateFocusAndSelection(focusClientId, shouldSelectBlock) {
      if (shouldSelectBlock) {
        selectBlock(void 0, focusClientId, null, null);
      }
      focusListItem(focusClientId, node);
    }
    function getBlocksToUpdate(clientId) {
      const selectedBlockClientIds = getSelectedBlockClientIds();
      const isUpdatingSelectedBlocks = selectedBlockClientIds.includes(clientId);
      const firstBlockClientId = isUpdatingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
      const firstBlockRootClientId = getBlockRootClientId(firstBlockClientId);
      const blocksToUpdate = isUpdatingSelectedBlocks ? selectedBlockClientIds : [clientId];
      return {
        blocksToUpdate,
        firstBlockClientId,
        firstBlockRootClientId,
        originallySelectedBlockClientIds: selectedBlockClientIds
      };
    }
    function handler(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (!node.contains(event.target.ownerDocument.activeElement)) {
        return;
      }
      const listViewRow = event.target.ownerDocument.activeElement?.closest(
        "[role=row]"
      );
      const clientId = listViewRow?.dataset?.block;
      if (!clientId) {
        return;
      }
      const {
        blocksToUpdate: selectedBlockClientIds,
        firstBlockClientId,
        firstBlockRootClientId,
        originallySelectedBlockClientIds
      } = getBlocksToUpdate(clientId);
      if (selectedBlockClientIds.length === 0) {
        return;
      }
      event.preventDefault();
      if (event.type === "copy" || event.type === "cut") {
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        }
        notifyCopy(event.type, selectedBlockClientIds);
        const blocks = getBlocksByClientId(selectedBlockClientIds);
        setClipboardBlocks(event, blocks, registry);
      }
      if (event.type === "cut") {
        if (!canRemoveBlocks(selectedBlockClientIds)) {
          return;
        }
        let blockToFocus = getPreviousBlockClientId(firstBlockClientId) ?? // If the previous block is not found (when the first block is deleted),
        // fallback to focus the parent block.
        firstBlockRootClientId;
        removeBlocks(selectedBlockClientIds, false);
        const shouldUpdateSelection = originallySelectedBlockClientIds.length > 0 && getSelectedBlockClientIds().length === 0;
        if (!blockToFocus) {
          blockToFocus = getBlockOrder()[0];
        }
        updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
      } else if (event.type === "paste") {
        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
        } = getSettings();
        const blocks = getPasteBlocks(
          event,
          canUserUseUnfilteredHTML
        );
        if (selectedBlockClientIds.length === 1) {
          const [selectedBlockClientId] = selectedBlockClientIds;
          if (blocks.every(
            (block) => canInsertBlockType(
              block.name,
              selectedBlockClientId
            )
          )) {
            insertBlocks(
              blocks,
              void 0,
              selectedBlockClientId
            );
            updateFocusAndSelection(blocks[0]?.clientId, false);
            return;
          }
        }
        replaceBlocks(
          selectedBlockClientIds,
          blocks,
          blocks.length - 1,
          -1
        );
        updateFocusAndSelection(blocks[0]?.clientId, false);
      }
    }
    node.ownerDocument.addEventListener("copy", handler);
    node.ownerDocument.addEventListener("cut", handler);
    node.ownerDocument.addEventListener("paste", handler);
    return () => {
      node.ownerDocument.removeEventListener("copy", handler);
      node.ownerDocument.removeEventListener("cut", handler);
      node.ownerDocument.removeEventListener("paste", handler);
    };
  }, []);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/list-view/index.js





















const expanded = (state, action) => {
  if (action.type === "clear") {
    return {};
  }
  if (Array.isArray(action.clientIds)) {
    return {
      ...state,
      ...action.clientIds.reduce(
        (newState, id) => ({
          ...newState,
          [id]: action.type === "expand"
        }),
        {}
      )
    };
  }
  return state;
};
const BLOCK_LIST_ITEM_HEIGHT = 32;
function ListViewComponent({
  id,
  blocks,
  dropZoneElement,
  showBlockMovers = false,
  isExpanded = false,
  showAppender = false,
  blockSettingsMenu: BlockSettingsMenu = BlockSettingsDropdown,
  rootClientId,
  description,
  onSelect,
  additionalBlockContent: AdditionalBlockContent
}, ref) {
  if (blocks) {
    external_wp_deprecated_default()(
      "`blocks` property in `wp.blockEditor.__experimentalListView`",
      {
        since: "6.3",
        alternative: "`rootClientId` property"
      }
    );
  }
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ListViewComponent);
  const { clientIdsTree, draggedClientIds, selectedClientIds } = useListViewClientIds({ blocks, rootClientId });
  const blockIndexes = useListViewBlockIndexes(clientIdsTree);
  const { getBlock } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { visibleBlockCount } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getGlobalBlockCount, getClientIdsOfDescendants } = select(store);
      const draggedBlockCount = draggedClientIds?.length > 0 ? getClientIdsOfDescendants(draggedClientIds).length + 1 : 0;
      return {
        visibleBlockCount: getGlobalBlockCount() - draggedBlockCount
      };
    },
    [draggedClientIds]
  );
  const { updateBlockSelection } = useBlockSelection();
  const [expandedState, setExpandedState] = (0,external_wp_element_namespaceObject.useReducer)(expanded, {});
  const [insertedBlock, setInsertedBlock] = (0,external_wp_element_namespaceObject.useState)(null);
  const { setSelectedTreeId } = useListViewExpandSelectedItem({
    firstSelectedBlockClientId: selectedClientIds[0],
    setExpandedState
  });
  const selectEditorBlock = (0,external_wp_element_namespaceObject.useCallback)(
    /**
     * @param {MouseEvent | KeyboardEvent | undefined} event
     * @param {string}                                 blockClientId
     * @param {null | undefined | -1 | 1}              focusPosition
     */
    (event, blockClientId, focusPosition) => {
      updateBlockSelection(event, blockClientId, null, focusPosition);
      setSelectedTreeId(blockClientId);
      if (onSelect) {
        onSelect(getBlock(blockClientId));
      }
    },
    [setSelectedTreeId, updateBlockSelection, onSelect, getBlock]
  );
  const { ref: dropZoneRef, target: blockDropTarget } = useListViewDropZone({
    dropZoneElement,
    expandedState,
    setExpandedState
  });
  const elementRef = (0,external_wp_element_namespaceObject.useRef)();
  const clipBoardRef = use_clipboard_handler_useClipboardHandler({
    selectBlock: selectEditorBlock
  });
  const treeGridRef = (0,external_wp_compose_namespaceObject.useMergeRefs)([
    clipBoardRef,
    elementRef,
    dropZoneRef,
    ref
  ]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (selectedClientIds?.length) {
      focusListItem(selectedClientIds[0], elementRef?.current);
    }
  }, []);
  const expand = (0,external_wp_element_namespaceObject.useCallback)(
    (clientId) => {
      if (!clientId) {
        return;
      }
      const clientIds = Array.isArray(clientId) ? clientId : [clientId];
      setExpandedState({ type: "expand", clientIds });
    },
    [setExpandedState]
  );
  const collapse = (0,external_wp_element_namespaceObject.useCallback)(
    (clientId) => {
      if (!clientId) {
        return;
      }
      setExpandedState({ type: "collapse", clientIds: [clientId] });
    },
    [setExpandedState]
  );
  const collapseAll = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setExpandedState({ type: "clear" });
  }, [setExpandedState]);
  const expandRow = (0,external_wp_element_namespaceObject.useCallback)(
    (row) => {
      expand(row?.dataset?.block);
    },
    [expand]
  );
  const collapseRow = (0,external_wp_element_namespaceObject.useCallback)(
    (row) => {
      collapse(row?.dataset?.block);
    },
    [collapse]
  );
  const focusRow = (0,external_wp_element_namespaceObject.useCallback)(
    (event, startRow, endRow) => {
      if (event.shiftKey) {
        updateBlockSelection(
          event,
          startRow?.dataset?.block,
          endRow?.dataset?.block
        );
      }
    },
    [updateBlockSelection]
  );
  useListViewCollapseItems({
    collapseAll,
    expand
  });
  const firstDraggedBlockClientId = draggedClientIds?.[0];
  const { blockDropTargetIndex, blockDropPosition, firstDraggedBlockIndex } = (0,external_wp_element_namespaceObject.useMemo)(() => {
    let _blockDropTargetIndex, _firstDraggedBlockIndex;
    if (blockDropTarget?.clientId) {
      const foundBlockIndex = blockIndexes[blockDropTarget.clientId];
      _blockDropTargetIndex = foundBlockIndex === void 0 || blockDropTarget?.dropPosition === "top" ? foundBlockIndex : foundBlockIndex + 1;
    } else if (blockDropTarget === null) {
      _blockDropTargetIndex = null;
    }
    if (firstDraggedBlockClientId) {
      const foundBlockIndex = blockIndexes[firstDraggedBlockClientId];
      _firstDraggedBlockIndex = foundBlockIndex === void 0 || blockDropTarget?.dropPosition === "top" ? foundBlockIndex : foundBlockIndex + 1;
    }
    return {
      blockDropTargetIndex: _blockDropTargetIndex,
      blockDropPosition: blockDropTarget?.dropPosition,
      firstDraggedBlockIndex: _firstDraggedBlockIndex
    };
  }, [blockDropTarget, blockIndexes, firstDraggedBlockClientId]);
  const contextValue = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      blockDropPosition,
      blockDropTargetIndex,
      blockIndexes,
      draggedClientIds,
      expandedState,
      expand,
      firstDraggedBlockIndex,
      collapse,
      collapseAll,
      BlockSettingsMenu,
      listViewInstanceId: instanceId,
      AdditionalBlockContent,
      insertedBlock,
      setInsertedBlock,
      treeGridElementRef: elementRef,
      rootClientId
    }),
    [
      blockDropPosition,
      blockDropTargetIndex,
      blockIndexes,
      draggedClientIds,
      expandedState,
      expand,
      firstDraggedBlockIndex,
      collapse,
      collapseAll,
      BlockSettingsMenu,
      instanceId,
      AdditionalBlockContent,
      insertedBlock,
      setInsertedBlock,
      rootClientId
    ]
  );
  const [fixedListWindow] = (0,external_wp_compose_namespaceObject.__experimentalUseFixedWindowList)(
    elementRef,
    BLOCK_LIST_ITEM_HEIGHT,
    visibleBlockCount,
    {
      // Ensure that the windowing logic is recalculated when the expanded state changes.
      // This is necessary because expanding a collapsed block in a short list view can
      // switch the list view to a tall list view with a scrollbar, and vice versa.
      // When this happens, the windowing logic needs to be recalculated to ensure that
      // the correct number of blocks are rendered, by rechecking for a scroll container.
      expandedState,
      useWindowing: true,
      windowOverscan: 40
    }
  );
  if (!clientIdsTree.length && !showAppender) {
    return null;
  }
  const describedById = description && `block-editor-list-view-description-${instanceId}`;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_data_namespaceObject.AsyncModeProvider, { value: true, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ListViewDropIndicatorPreview,
      {
        draggedBlockClientId: firstDraggedBlockClientId,
        listViewRef: elementRef,
        blockDropTarget
      }
    ),
    description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: describedById, children: description }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.__experimentalTreeGrid,
      {
        id,
        className: dist_clsx("block-editor-list-view-tree", {
          "is-dragging": draggedClientIds?.length > 0 && blockDropTargetIndex !== void 0
        }),
        "aria-label": (0,external_wp_i18n_namespaceObject.__)("Block navigation structure"),
        ref: treeGridRef,
        onCollapseRow: collapseRow,
        onExpandRow: expandRow,
        onFocusRow: focusRow,
        applicationAriaLabel: (0,external_wp_i18n_namespaceObject.__)("Block navigation structure"),
        "aria-describedby": describedById,
        style: {
          "--wp-admin--list-view-dragged-items-height": draggedClientIds?.length ? `${BLOCK_LIST_ITEM_HEIGHT * (draggedClientIds.length - 1)}px` : null
        },
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ListViewContext.Provider, { value: contextValue, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          branch_default,
          {
            blocks: clientIdsTree,
            parentId: rootClientId,
            selectBlock: selectEditorBlock,
            showBlockMovers,
            fixedListWindow,
            selectedClientIds,
            isExpanded,
            showAppender
          }
        ) })
      }
    )
  ] });
}
const PrivateListView = (0,external_wp_element_namespaceObject.forwardRef)(ListViewComponent);
var list_view_list_view_default = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateListView,
    {
      ref,
      ...props,
      showAppender: false,
      rootClientId: null,
      onSelect: null,
      additionalBlockContent: null,
      blockSettingsMenu: void 0
    }
  );
});


;// ./node_modules/@wordpress/block-editor/build-module/components/block-navigation/dropdown.js









function BlockNavigationDropdownToggle({
  isEnabled,
  onToggle,
  isOpen,
  innerRef,
  ...props
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      __next40pxDefaultSize: true,
      ...props,
      ref: innerRef,
      icon: list_view_default,
      "aria-expanded": isOpen,
      "aria-haspopup": "true",
      onClick: isEnabled ? onToggle : void 0,
      label: (0,external_wp_i18n_namespaceObject.__)("List view"),
      className: "block-editor-block-navigation",
      "aria-disabled": !isEnabled
    }
  );
}
function BlockNavigationDropdown({ isDisabled, ...props }, ref) {
  external_wp_deprecated_default()("wp.blockEditor.BlockNavigationDropdown", {
    since: "6.1",
    alternative: "wp.components.Dropdown and wp.blockEditor.ListView"
  });
  const hasBlocks = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => !!select(store).getBlockCount(),
    []
  );
  const isEnabled = hasBlocks && !isDisabled;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      contentClassName: "block-editor-block-navigation__popover",
      popoverProps: { placement: "bottom-start" },
      renderToggle: ({ isOpen, onToggle }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockNavigationDropdownToggle,
        {
          ...props,
          innerRef: ref,
          isOpen,
          onToggle,
          isEnabled
        }
      ),
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-navigation__container", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "block-editor-block-navigation__label", children: (0,external_wp_i18n_namespaceObject.__)("List view") }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(list_view_list_view_default, {})
      ] })
    }
  );
}
var dropdown_default = (0,external_wp_element_namespaceObject.forwardRef)(BlockNavigationDropdown);


;// ./node_modules/@wordpress/block-editor/build-module/components/block-styles/preview-panel.js





function BlockStylesPreviewPanel({
  genericPreviewBlock,
  style,
  className,
  activeStyle
}) {
  const example = (0,external_wp_blocks_namespaceObject.getBlockType)(genericPreviewBlock.name)?.example;
  const styleClassName = replaceActiveStyle(className, activeStyle, style);
  const previewBlocks = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return {
      ...genericPreviewBlock,
      title: style.label || style.name,
      description: style.description,
      initialAttributes: {
        ...genericPreviewBlock.attributes,
        className: styleClassName + " block-editor-block-styles__block-preview-container"
      },
      example
    };
  }, [genericPreviewBlock, styleClassName]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(preview_panel_default, { item: previewBlocks });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-styles/index.js







const block_styles_noop = () => {
};
function BlockStyles({ clientId, onSwitch = block_styles_noop, onHoverClassName = block_styles_noop }) {
  const {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className: previewClassName
  } = useStylesForBlocks({
    clientId,
    onSwitch
  });
  const [hoveredStyle, setHoveredStyle] = (0,external_wp_element_namespaceObject.useState)(null);
  const isMobileViewport = (0,external_wp_compose_namespaceObject.useViewportMatch)("medium", "<");
  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }
  const debouncedSetHoveredStyle = (0,external_wp_compose_namespaceObject.debounce)(setHoveredStyle, 250);
  const onSelectStylePreview = (style) => {
    onSelect(style);
    onHoverClassName(null);
    setHoveredStyle(null);
    debouncedSetHoveredStyle.cancel();
  };
  const styleItemHandler = (item) => {
    if (hoveredStyle === item) {
      debouncedSetHoveredStyle.cancel();
      return;
    }
    debouncedSetHoveredStyle(item);
    onHoverClassName(item?.name ?? null);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-styles", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-styles__variants", children: stylesToRender.map((style) => {
      const buttonText = style.label || style.name;
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          __next40pxDefaultSize: true,
          className: dist_clsx(
            "block-editor-block-styles__item",
            {
              "is-active": activeStyle.name === style.name
            }
          ),
          variant: "secondary",
          label: buttonText,
          onMouseEnter: () => styleItemHandler(style),
          onFocus: () => styleItemHandler(style),
          onMouseLeave: () => styleItemHandler(null),
          onBlur: () => styleItemHandler(null),
          onClick: () => onSelectStylePreview(style),
          "aria-current": activeStyle.name === style.name,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalTruncate,
            {
              numberOfLines: 1,
              className: "block-editor-block-styles__item-text",
              children: buttonText
            }
          )
        },
        style.name
      );
    }) }),
    hoveredStyle && !isMobileViewport && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Popover,
      {
        placement: "left-start",
        offset: 34,
        focusOnMount: false,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "div",
          {
            className: "block-editor-block-styles__preview-panel",
            onMouseLeave: () => styleItemHandler(null),
            children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              BlockStylesPreviewPanel,
              {
                activeStyle,
                className: previewClassName,
                genericPreviewBlock,
                style: hoveredStyle
              }
            )
          }
        )
      }
    )
  ] });
}
var block_styles_default = BlockStyles;


;// ./node_modules/@wordpress/icons/build-module/library/paragraph.js


var paragraph_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "m9.99609 14v-.2251l.00391.0001v6.225h1.5v-14.5h2.5v14.5h1.5v-14.5h3v-1.5h-8.50391c-2.76142 0-5 2.23858-5 5 0 2.7614 2.23858 5 5 5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-1.js


var heading_level_1_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M17.6 7c-.6.9-1.5 1.7-2.6 2v1h2v7h2V7h-1.4zM11 11H7V7H5v10h2v-4h4v4h2V7h-2v4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-2.js


var heading_level_2_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 11.1H5v-4H3v10h2v-4h4v4h2v-10H9v4zm8 4c.5-.4.6-.6 1.1-1.1.4-.4.8-.8 1.2-1.3.3-.4.6-.8.9-1.3.2-.4.3-.8.3-1.3 0-.4-.1-.9-.3-1.3-.2-.4-.4-.7-.8-1-.3-.3-.7-.5-1.2-.6-.5-.2-1-.2-1.5-.2-.4 0-.7 0-1.1.1-.3.1-.7.2-1 .3-.3.1-.6.3-.9.5-.3.2-.6.4-.8.7l1.2 1.2c.3-.3.6-.5 1-.7.4-.2.7-.3 1.2-.3s.9.1 1.3.4c.3.3.5.7.5 1.1 0 .4-.1.8-.4 1.1-.3.5-.6.9-1 1.2-.4.4-1 .9-1.6 1.4-.6.5-1.4 1.1-2.2 1.6v1.5h8v-2H17z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-3.js


var heading_level_3_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.3 1.7c-.4-.4-1-.7-1.6-.8v-.1c.6-.2 1.1-.5 1.5-.9.3-.4.5-.8.5-1.3 0-.4-.1-.8-.3-1.1-.2-.3-.5-.6-.8-.8-.4-.2-.8-.4-1.2-.5-.6-.1-1.1-.2-1.6-.2-.6 0-1.3.1-1.8.3s-1.1.5-1.6.9l1.2 1.4c.4-.2.7-.4 1.1-.6.3-.2.7-.3 1.1-.3.4 0 .8.1 1.1.3.3.2.4.5.4.8 0 .4-.2.7-.6.9-.7.3-1.5.5-2.2.4v1.6c.5 0 1 0 1.5.1.3.1.7.2 1 .3.2.1.4.2.5.4s.1.4.1.6c0 .3-.2.7-.5.8-.4.2-.9.3-1.4.3s-1-.1-1.4-.3c-.4-.2-.8-.4-1.2-.7L13 15.6c.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.6 0 1.1-.1 1.6-.2.4-.1.9-.2 1.3-.5.4-.2.7-.5.9-.9.2-.4.3-.8.3-1.2 0-.6-.3-1.1-.7-1.5z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-4.js


var heading_level_4_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M20 13V7h-3l-4 6v2h5v2h2v-2h1v-2h-1zm-2 0h-2.8L18 9v4zm-9-2H5V7H3v10h2v-4h4v4h2V7H9v4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-5.js


var heading_level_5_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M9 11H5V7H3v10h2v-4h4v4h2V7H9v4zm11.7 1.2c-.2-.3-.5-.7-.8-.9-.3-.3-.7-.5-1.1-.6-.5-.1-.9-.2-1.4-.2-.2 0-.5.1-.7.1-.2.1-.5.1-.7.2l.1-1.9h4.3V7H14l-.3 5 1 .6.5-.2.4-.1c.1-.1.3-.1.4-.1h.5c.5 0 1 .1 1.4.4.4.2.6.7.6 1.1 0 .4-.2.8-.6 1.1-.4.3-.9.4-1.4.4-.4 0-.9-.1-1.3-.3-.4-.2-.7-.4-1.1-.7 0 0-1.1 1.4-1 1.5.5.4 1 .8 1.6 1 .7.3 1.5.4 2.3.4.5 0 1-.1 1.5-.3s.9-.4 1.3-.7c.4-.3.7-.7.9-1.1s.3-.9.3-1.4-.1-1-.3-1.4z" }) });


;// ./node_modules/@wordpress/icons/build-module/library/heading-level-6.js


var heading_level_6_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M20.7 12.4c-.2-.3-.4-.6-.7-.9s-.6-.5-1-.6c-.4-.2-.8-.2-1.2-.2-.5 0-.9.1-1.3.3s-.8.5-1.2.8c0-.5 0-.9.2-1.4l.6-.9c.2-.2.5-.4.8-.5.6-.2 1.3-.2 1.9 0 .3.1.6.3.8.5 0 0 1.3-1.3 1.3-1.4-.4-.3-.9-.6-1.4-.8-.6-.2-1.3-.3-2-.3-.6 0-1.1.1-1.7.4-.5.2-1 .5-1.4.9-.4.4-.8 1-1 1.6-.3.7-.4 1.5-.4 2.3s.1 1.5.3 2.1c.2.6.6 1.1 1 1.5.4.4.9.7 1.4.9 1 .3 2 .3 3 0 .4-.1.8-.3 1.2-.6.3-.3.6-.6.8-1 .2-.5.3-.9.3-1.4s-.1-.9-.3-1.3zm-2 2.1c-.1.2-.3.4-.4.5-.1.1-.3.2-.5.2-.2.1-.4.1-.6.1-.2.1-.5 0-.7-.1-.2 0-.3-.2-.5-.3-.1-.2-.3-.4-.4-.6-.2-.3-.3-.7-.3-1 .3-.3.6-.5 1-.7.3-.1.7-.2 1-.2.4 0 .8.1 1.1.3.3.3.4.7.4 1.1 0 .2 0 .5-.1.7zM9 11H5V7H3v10h2v-4h4v4h2V7H9v4z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-heading-level-dropdown/heading-level-icon.js



const LEVEL_TO_PATH = {
  0: paragraph_default,
  1: heading_level_1_default,
  2: heading_level_2_default,
  3: heading_level_3_default,
  4: heading_level_4_default,
  5: heading_level_5_default,
  6: heading_level_6_default
};
function HeadingLevelIcon({ level }) {
  if (LEVEL_TO_PATH[level]) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Icon, { icon: LEVEL_TO_PATH[level] });
  }
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-heading-level-dropdown/index.js




const HEADING_LEVELS = [1, 2, 3, 4, 5, 6];
const block_heading_level_dropdown_POPOVER_PROPS = {
  className: "block-library-heading-level-dropdown"
};
function HeadingLevelDropdown({
  options = HEADING_LEVELS,
  value,
  onChange
}) {
  const validOptions = options.filter(
    (option) => option === 0 || HEADING_LEVELS.includes(option)
  ).sort((a, b) => a - b);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarDropdownMenu,
    {
      popoverProps: block_heading_level_dropdown_POPOVER_PROPS,
      icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(HeadingLevelIcon, { level: value }),
      label: (0,external_wp_i18n_namespaceObject.__)("Change level"),
      controls: validOptions.map((targetLevel) => {
        const isActive = targetLevel === value;
        return {
          icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(HeadingLevelIcon, { level: targetLevel }),
          title: targetLevel === 0 ? (0,external_wp_i18n_namespaceObject.__)("Paragraph") : (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %d: heading level e.g: "1", "2", "3"
            (0,external_wp_i18n_namespaceObject.__)("Heading %d"),
            targetLevel
          ),
          isActive,
          onClick() {
            onChange(targetLevel);
          },
          role: "menuitemradio"
        };
      })
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/layout.js


var layout_layout_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18 5.5H6a.5.5 0 00-.5.5v3h13V6a.5.5 0 00-.5-.5zm.5 5H10v8h8a.5.5 0 00.5-.5v-7.5zm-10 0h-3V18a.5.5 0 00.5.5h2.5v-8zM6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/block-variation-picker/index.js





function BlockVariationPicker({
  icon = layout_layout_default,
  label = (0,external_wp_i18n_namespaceObject.__)("Choose variation"),
  instructions = (0,external_wp_i18n_namespaceObject.__)("Select a variation to start with:"),
  variations,
  onSelect,
  allowSkip
}) {
  const classes = dist_clsx("block-editor-block-variation-picker", {
    "has-many-variations": variations.length > 4
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Placeholder,
    {
      icon,
      label,
      instructions,
      className: classes,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          "ul",
          {
            className: "block-editor-block-variation-picker__variations",
            role: "list",
            "aria-label": (0,external_wp_i18n_namespaceObject.__)("Block variations"),
            children: variations.map((variation) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("li", { children: [
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  __next40pxDefaultSize: true,
                  variant: "tertiary",
                  icon: variation.icon && variation.icon.src ? variation.icon.src : variation.icon,
                  iconSize: 48,
                  onClick: () => onSelect(variation),
                  className: "block-editor-block-variation-picker__variation",
                  label: variation.description || variation.title
                }
              ),
              /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-block-variation-picker__variation-label", children: variation.title })
            ] }, variation.name))
          }
        ),
        allowSkip && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-variation-picker__skip", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            __next40pxDefaultSize: true,
            variant: "link",
            onClick: () => onSelect(),
            children: (0,external_wp_i18n_namespaceObject.__)("Skip")
          }
        ) })
      ]
    }
  );
}
var block_variation_picker_default = BlockVariationPicker;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/constants.js
const VIEWMODES = {
  carousel: "carousel",
  grid: "grid"
};


;// ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/setup-toolbar.js





const Actions = ({ onBlockPatternSelect }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-pattern-setup__actions", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_components_namespaceObject.Button,
  {
    __next40pxDefaultSize: true,
    variant: "primary",
    onClick: onBlockPatternSelect,
    children: (0,external_wp_i18n_namespaceObject.__)("Choose")
  }
) });
const CarouselNavigation = ({
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides
}) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-pattern-setup__navigation", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      size: "compact",
      icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_right_default : chevron_left_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Previous pattern"),
      onClick: handlePrevious,
      disabled: activeSlide === 0,
      accessibleWhenDisabled: true
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      size: "compact",
      icon: (0,external_wp_i18n_namespaceObject.isRTL)() ? chevron_left_default : chevron_right_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Next pattern"),
      onClick: handleNext,
      disabled: activeSlide === totalSlides - 1,
      accessibleWhenDisabled: true
    }
  )
] });
const SetupToolbar = ({
  viewMode,
  setViewMode,
  handlePrevious,
  handleNext,
  activeSlide,
  totalSlides,
  onBlockPatternSelect
}) => {
  const isCarouselView = viewMode === VIEWMODES.carousel;
  const displayControls = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-pattern-setup__display-controls", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        size: "compact",
        icon: stretch_full_width_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Carousel view"),
        onClick: () => setViewMode(VIEWMODES.carousel),
        isPressed: isCarouselView
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        size: "compact",
        icon: grid_grid_default,
        label: (0,external_wp_i18n_namespaceObject.__)("Grid view"),
        onClick: () => setViewMode(VIEWMODES.grid),
        isPressed: viewMode === VIEWMODES.grid
      }
    )
  ] });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-pattern-setup__toolbar", children: [
    isCarouselView && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      CarouselNavigation,
      {
        handlePrevious,
        handleNext,
        activeSlide,
        totalSlides
      }
    ),
    displayControls,
    isCarouselView && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Actions, { onBlockPatternSelect })
  ] });
};
var setup_toolbar_default = SetupToolbar;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/use-patterns-setup.js


function usePatternsSetup(clientId, blockName, filterPatternsFn) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const {
        getBlockRootClientId,
        getPatternsByBlockTypes,
        __experimentalGetAllowedPatterns
      } = select(store);
      const rootClientId = getBlockRootClientId(clientId);
      if (filterPatternsFn) {
        return __experimentalGetAllowedPatterns(rootClientId).filter(
          filterPatternsFn
        );
      }
      return getPatternsByBlockTypes(blockName, rootClientId);
    },
    [clientId, blockName, filterPatternsFn]
  );
}
var use_patterns_setup_default = usePatternsSetup;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-pattern-setup/index.js












const SetupContent = ({
  viewMode,
  activeSlide,
  patterns,
  onBlockPatternSelect,
  showTitles
}) => {
  const containerClass = "block-editor-block-pattern-setup__container";
  if (viewMode === VIEWMODES.carousel) {
    const slideClass = /* @__PURE__ */ new Map([
      [activeSlide, "active-slide"],
      [activeSlide - 1, "previous-slide"],
      [activeSlide + 1, "next-slide"]
    ]);
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-pattern-setup__carousel", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: containerClass, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "carousel-container", children: patterns.map((pattern, index) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      BlockPatternSlide,
      {
        active: index === activeSlide,
        className: slideClass.get(index) || "",
        pattern
      },
      pattern.name
    )) }) }) });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-pattern-setup__grid", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Composite,
    {
      role: "listbox",
      className: containerClass,
      "aria-label": (0,external_wp_i18n_namespaceObject.__)("Patterns list"),
      children: patterns.map((pattern) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        block_pattern_setup_BlockPattern,
        {
          pattern,
          onSelect: onBlockPatternSelect,
          showTitles
        },
        pattern.name
      ))
    }
  ) });
};
function block_pattern_setup_BlockPattern({ pattern, onSelect, showTitles }) {
  const baseClassName = "block-editor-block-pattern-setup-list";
  const { blocks, description, viewportWidth = 700 } = pattern;
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(
    block_pattern_setup_BlockPattern,
    `${baseClassName}__item-description`
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: `${baseClassName}__list-item`, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Composite.Item,
    {
      render: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        "div",
        {
          "aria-describedby": description ? descriptionId : void 0,
          "aria-label": pattern.title,
          className: `${baseClassName}__item`
        }
      ),
      id: `${baseClassName}__pattern__${pattern.name}`,
      role: "option",
      onClick: () => onSelect(blocks),
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          block_preview_default,
          {
            blocks,
            viewportWidth
          }
        ),
        showTitles && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: `${baseClassName}__item-title`, children: pattern.title }),
        !!description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: description })
      ]
    }
  ) });
}
function BlockPatternSlide({ active, className, pattern, minHeight }) {
  const { blocks, title, description } = pattern;
  const descriptionId = (0,external_wp_compose_namespaceObject.useInstanceId)(
    BlockPatternSlide,
    "block-editor-block-pattern-setup-list__item-description"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      "aria-hidden": !active,
      role: "img",
      className: `pattern-slide ${className}`,
      "aria-label": title,
      "aria-describedby": description ? descriptionId : void 0,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_preview_default, { blocks, minHeight }),
        !!description && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { id: descriptionId, children: description })
      ]
    }
  );
}
const BlockPatternSetup = ({
  clientId,
  blockName,
  filterPatternsFn,
  onBlockPatternSelect,
  initialViewMode = VIEWMODES.carousel,
  showTitles = false
}) => {
  const [viewMode, setViewMode] = (0,external_wp_element_namespaceObject.useState)(initialViewMode);
  const [activeSlide, setActiveSlide] = (0,external_wp_element_namespaceObject.useState)(0);
  const { replaceBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const patterns = use_patterns_setup_default(clientId, blockName, filterPatternsFn);
  if (!patterns?.length) {
    return null;
  }
  const onBlockPatternSelectDefault = (blocks) => {
    const clonedBlocks = blocks.map((block) => (0,external_wp_blocks_namespaceObject.cloneBlock)(block));
    replaceBlock(clientId, clonedBlocks);
  };
  const onPatternSelectCallback = onBlockPatternSelect || onBlockPatternSelectDefault;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: `block-editor-block-pattern-setup view-mode-${viewMode}`,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          SetupContent,
          {
            viewMode,
            activeSlide,
            patterns,
            onBlockPatternSelect: onPatternSelectCallback,
            showTitles
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          setup_toolbar_default,
          {
            viewMode,
            setViewMode,
            activeSlide,
            totalSlides: patterns.length,
            handleNext: () => {
              setActiveSlide(
                (active) => Math.min(active + 1, patterns.length - 1)
              );
            },
            handlePrevious: () => {
              setActiveSlide(
                (active) => Math.max(active - 1, 0)
              );
            },
            onBlockPatternSelect: () => {
              onPatternSelectCallback(
                patterns[activeSlide].blocks
              );
            }
          }
        )
      ]
    }
  ) });
};
var block_pattern_setup_default = BlockPatternSetup;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-variation-transforms/index.js










function VariationsButtons({
  className,
  onSelectVariation,
  selectedValue,
  variations
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Transform to variation") }),
    variations.map((variation) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        size: "compact",
        icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: variation.icon, showColors: true }),
        isPressed: selectedValue === variation.name,
        label: selectedValue === variation.name ? variation.title : (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %s: Block or block variation name. */
          (0,external_wp_i18n_namespaceObject.__)("Transform to %s"),
          variation.title
        ),
        onClick: () => onSelectVariation(variation.name),
        "aria-label": variation.title,
        showTooltip: true
      },
      variation.name
    ))
  ] });
}
function VariationsDropdown({
  className,
  onSelectVariation,
  selectedValue,
  variations
}) {
  const selectOptions = variations.map(
    ({ name, title, description }) => ({
      value: name,
      label: title,
      info: description
    })
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.DropdownMenu,
    {
      className,
      label: (0,external_wp_i18n_namespaceObject.__)("Transform to variation"),
      text: (0,external_wp_i18n_namespaceObject.__)("Transform to variation"),
      popoverProps: {
        position: "bottom center",
        className: `${className}__popover`
      },
      icon: chevron_down_default,
      toggleProps: { iconPosition: "right" },
      children: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.MenuItemsChoice,
        {
          choices: selectOptions,
          value: selectedValue,
          onSelect: onSelectVariation
        }
      ) })
    }
  );
}
function VariationsToggleGroupControl({
  className,
  onSelectVariation,
  selectedValue,
  variations
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToggleGroupControl,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Transform to variation"),
      value: selectedValue,
      hideLabelFromVision: true,
      onChange: onSelectVariation,
      __next40pxDefaultSize: true,
      __nextHasNoMarginBottom: true,
      children: variations.map((variation) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToggleGroupControlOptionIcon,
        {
          icon: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: variation.icon, showColors: true }),
          value: variation.name,
          label: selectedValue === variation.name ? variation.title : (0,external_wp_i18n_namespaceObject.sprintf)(
            /* translators: %s: Block or block variation name. */
            (0,external_wp_i18n_namespaceObject.__)("Transform to %s"),
            variation.title
          )
        },
        variation.name
      ))
    }
  ) });
}
function __experimentalBlockVariationTransforms({ blockClientId }) {
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const {
    activeBlockVariation,
    unfilteredVariations,
    blockName,
    isContentOnly,
    isSection
  } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getActiveBlockVariation, getBlockVariations } = select(external_wp_blocks_namespaceObject.store);
      const {
        getBlockName,
        getBlockAttributes,
        getBlockEditingMode,
        isSectionBlock
      } = unlock(select(store));
      const name = blockClientId && getBlockName(blockClientId);
      const { hasContentRoleAttribute } = unlock(select(external_wp_blocks_namespaceObject.store));
      const isContentBlock = hasContentRoleAttribute(name);
      return {
        activeBlockVariation: getActiveBlockVariation(
          name,
          getBlockAttributes(blockClientId),
          "transform"
        ),
        unfilteredVariations: name && getBlockVariations(name, "transform"),
        blockName: name,
        isContentOnly: getBlockEditingMode(blockClientId) === "contentOnly" && !isContentBlock,
        isSection: isSectionBlock(blockClientId)
      };
    },
    [blockClientId]
  );
  const variations = (0,external_wp_element_namespaceObject.useMemo)(() => {
    if (blockName === "core/paragraph") {
      if (activeBlockVariation?.name === "stretchy-paragraph" || unfilteredVariations.every(
        (v) => ["paragraph", "stretchy-paragraph"].includes(v.name)
      )) {
        return [];
      }
      return unfilteredVariations.filter(
        (v) => v.name !== "stretchy-paragraph"
      );
    } else if (blockName === "core/heading") {
      if (activeBlockVariation?.name === "stretchy-heading" || unfilteredVariations.every(
        (v) => ["heading", "stretchy-heading"].includes(v.name)
      )) {
        return [];
      }
      return unfilteredVariations.filter(
        (v) => v.name !== "stretchy-heading"
      );
    }
    return unfilteredVariations;
  }, [activeBlockVariation?.name, blockName, unfilteredVariations]);
  const selectedValue = activeBlockVariation?.name;
  const hasUniqueIcons = (0,external_wp_element_namespaceObject.useMemo)(() => {
    const variationIcons = /* @__PURE__ */ new Set();
    if (!variations) {
      return false;
    }
    variations.forEach((variation) => {
      if (variation.icon) {
        variationIcons.add(variation.icon?.src || variation.icon);
      }
    });
    return variationIcons.size === variations.length;
  }, [variations]);
  const onSelectVariation = (variationName) => {
    updateBlockAttributes(blockClientId, {
      ...variations.find(({ name }) => name === variationName).attributes
    });
  };
  const hideVariationsForSections = window?.__experimentalContentOnlyPatternInsertion && isSection;
  if (!variations?.length || isContentOnly || hideVariationsForSections) {
    return null;
  }
  const baseClass = "block-editor-block-variation-transforms";
  const showButtons = variations.length > 5;
  const ButtonComponent = showButtons ? VariationsButtons : VariationsToggleGroupControl;
  const Component = hasUniqueIcons ? ButtonComponent : VariationsDropdown;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    Component,
    {
      className: baseClass,
      onSelectVariation,
      selectedValue,
      variations
    }
  );
}
var block_variation_transforms_default = __experimentalBlockVariationTransforms;


;// ./node_modules/@wordpress/block-editor/build-module/components/color-palette/with-color-context.js



var with_color_context_default = (0,external_wp_compose_namespaceObject.createHigherOrderComponent)((WrappedComponent) => {
  return (props) => {
    const [
      defaultColors,
      themeColors,
      customColors,
      enableCustomColors,
      enableDefaultColors
    ] = use_settings_useSettings(
      "color.palette.default",
      "color.palette.theme",
      "color.palette.custom",
      "color.custom",
      "color.defaultPalette"
    );
    const _colors = enableDefaultColors ? [
      ...themeColors || [],
      ...defaultColors || [],
      ...customColors || []
    ] : [...themeColors || [], ...customColors || []];
    const { colors = _colors, disableCustomColors = !enableCustomColors } = props;
    const hasColorsToChoose = colors && colors.length > 0 || !disableCustomColors;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      WrappedComponent,
      {
        ...{
          ...props,
          colors,
          disableCustomColors,
          hasColorsToChoose
        }
      }
    );
  };
}, "withColorContext");


;// ./node_modules/@wordpress/block-editor/build-module/components/color-palette/index.js


var color_palette_default = with_color_context_default(external_wp_components_namespaceObject.ColorPalette);


;// ./node_modules/@wordpress/block-editor/build-module/components/color-palette/control.js


function ColorPaletteControl({
  onChange,
  value,
  ...otherProps
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    control_default,
    {
      ...otherProps,
      onColorChange: onChange,
      colorValue: value,
      gradients: [],
      disableCustomGradients: true
    }
  );
}


;// external ["wp","date"]
const external_wp_date_namespaceObject = window["wp"]["date"];
;// ./node_modules/@wordpress/block-editor/build-module/components/date-format-picker/index.js





const exampleDate = /* @__PURE__ */ new Date();
exampleDate.setDate(20);
exampleDate.setMonth(exampleDate.getMonth() - 3);
if (exampleDate.getMonth() === 4) {
  exampleDate.setMonth(3);
}
function DateFormatPicker({
  format,
  defaultFormat,
  onChange
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalVStack,
    {
      as: "fieldset",
      spacing: 4,
      className: "block-editor-date-format-picker",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "legend", children: (0,external_wp_i18n_namespaceObject.__)("Date format") }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.ToggleControl,
          {
            __nextHasNoMarginBottom: true,
            label: (0,external_wp_i18n_namespaceObject.__)("Default format"),
            help: `${(0,external_wp_i18n_namespaceObject.__)("Example:")}  ${(0,external_wp_date_namespaceObject.dateI18n)(
              defaultFormat,
              exampleDate
            )}`,
            checked: !format,
            onChange: (checked) => onChange(checked ? null : defaultFormat)
          }
        ),
        format && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(NonDefaultControls, { format, onChange })
      ]
    }
  );
}
function NonDefaultControls({ format, onChange }) {
  const suggestedFormats = [
    .../* @__PURE__ */ new Set([
      /* translators: See https://www.php.net/manual/datetime.format.php */
      "Y-m-d",
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("n/j/Y", "short date format"),
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("n/j/Y g:i A", "short date format with time"),
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("M j, Y", "medium date format"),
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("M j, Y g:i A", "medium date format with time"),
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("F j, Y", "long date format"),
      /* translators: See https://www.php.net/manual/datetime.format.php */
      (0,external_wp_i18n_namespaceObject._x)("M j", "short date format without the year")
    ])
  ];
  const suggestedOptions = [
    ...suggestedFormats.map((suggestedFormat, index) => ({
      key: `suggested-${index}`,
      name: (0,external_wp_date_namespaceObject.dateI18n)(suggestedFormat, exampleDate),
      format: suggestedFormat
    })),
    {
      key: "human-diff",
      name: (0,external_wp_date_namespaceObject.humanTimeDiff)(exampleDate),
      format: "human-diff"
    }
  ];
  const customOption = {
    key: "custom",
    name: (0,external_wp_i18n_namespaceObject.__)("Custom"),
    className: "block-editor-date-format-picker__custom-format-select-control__custom-option",
    hint: (0,external_wp_i18n_namespaceObject.__)("Enter your own date format")
  };
  const [isCustom, setIsCustom] = (0,external_wp_element_namespaceObject.useState)(
    () => !!format && !suggestedOptions.some((option) => option.format === format)
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.CustomSelectControl,
      {
        __next40pxDefaultSize: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Choose a format"),
        options: [...suggestedOptions, customOption],
        value: isCustom ? customOption : suggestedOptions.find(
          (option) => option.format === format
        ) ?? customOption,
        onChange: ({ selectedItem }) => {
          if (selectedItem === customOption) {
            setIsCustom(true);
          } else {
            setIsCustom(false);
            onChange(selectedItem.format);
          }
        }
      }
    ),
    isCustom && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.TextControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Custom format"),
        hideLabelFromVision: true,
        help: (0,external_wp_element_namespaceObject.createInterpolateElement)(
          (0,external_wp_i18n_namespaceObject.__)(
            "Enter a date or time <Link>format string</Link>."
          ),
          {
            Link: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.ExternalLink,
              {
                href: (0,external_wp_i18n_namespaceObject.__)(
                  "https://wordpress.org/documentation/article/customize-date-and-time-format/"
                )
              }
            )
          }
        ),
        value: format,
        onChange: (value) => onChange(value)
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/dropdown.js







const WithToolsPanelItem = ({ setting, children, panelId, ...props }) => {
  const clearValue = () => {
    if (setting.colorValue) {
      setting.onColorChange();
    } else if (setting.gradientValue) {
      setting.onGradientChange();
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      hasValue: () => {
        return !!setting.colorValue || !!setting.gradientValue;
      },
      label: setting.label,
      onDeselect: clearValue,
      isShownByDefault: setting.isShownByDefault !== void 0 ? setting.isShownByDefault : true,
      ...props,
      className: "block-editor-tools-panel-color-gradient-settings__item",
      panelId,
      resetAllFilter: setting.resetAllFilter,
      children
    }
  );
};
const dropdown_LabeledColorIndicator = ({ colorValue, label }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "flex-start", children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ColorIndicator,
    {
      className: "block-editor-panel-color-gradient-settings__color-indicator",
      colorValue
    }
  ),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.FlexItem,
    {
      className: "block-editor-panel-color-gradient-settings__color-name",
      title: label,
      children: label
    }
  )
] });
const dropdown_renderToggle = (settings) => ({ onToggle, isOpen }) => {
  const {
    clearable,
    colorValue,
    gradientValue,
    onColorChange,
    onGradientChange,
    label
  } = settings;
  const colorButtonRef = (0,external_wp_element_namespaceObject.useRef)(void 0);
  const toggleProps = {
    onClick: onToggle,
    className: dist_clsx(
      "block-editor-panel-color-gradient-settings__dropdown",
      { "is-open": isOpen }
    ),
    "aria-expanded": isOpen,
    ref: colorButtonRef
  };
  const clearValue = () => {
    if (colorValue) {
      onColorChange();
    } else if (gradientValue) {
      onGradientChange();
    }
  };
  const value = colorValue ?? gradientValue;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Button, { __next40pxDefaultSize: true, ...toggleProps, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      dropdown_LabeledColorIndicator,
      {
        colorValue: value,
        label
      }
    ) }),
    clearable && value && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Reset"),
        className: "block-editor-panel-color-gradient-settings__reset",
        size: "small",
        icon: reset_default,
        onClick: () => {
          clearValue();
          if (isOpen) {
            onToggle();
          }
          colorButtonRef.current?.focus();
        }
      }
    )
  ] });
};
function ColorGradientSettingsDropdown({
  colors,
  disableCustomColors,
  disableCustomGradients,
  enableAlpha,
  gradients,
  settings,
  __experimentalIsRenderedInSidebar,
  ...props
}) {
  let popoverProps;
  if (__experimentalIsRenderedInSidebar) {
    popoverProps = {
      placement: "left-start",
      offset: 36,
      shift: true
    };
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: settings.map((setting, index) => {
    const controlProps = {
      clearable: false,
      colorValue: setting.colorValue,
      colors,
      disableCustomColors,
      disableCustomGradients,
      enableAlpha,
      gradientValue: setting.gradientValue,
      gradients,
      label: setting.label,
      onColorChange: setting.onColorChange,
      onGradientChange: setting.onGradientChange,
      showTitle: false,
      __experimentalIsRenderedInSidebar,
      ...setting
    };
    const toggleSettings = {
      clearable: setting.clearable,
      label: setting.label,
      colorValue: setting.colorValue,
      gradientValue: setting.gradientValue,
      onColorChange: setting.onColorChange,
      onGradientChange: setting.onGradientChange
    };
    return setting && // If not in an `ItemGroup` wrap the dropdown in a
    // `ToolsPanelItem`
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      WithToolsPanelItem,
      {
        setting,
        ...props,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Dropdown,
          {
            popoverProps,
            className: "block-editor-tools-panel-color-gradient-settings__dropdown",
            renderToggle: dropdown_renderToggle(toggleSettings),
            renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, { paddingSize: "none", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-panel-color-gradient-settings__dropdown-content", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              control_default,
              {
                ...controlProps
              }
            ) }) })
          }
        )
      },
      index
    );
  }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/colors-gradients/panel-color-gradient-settings.js







const panel_color_gradient_settings_colorsAndGradientKeys = [
  "colors",
  "disableCustomColors",
  "gradients",
  "disableCustomGradients"
];
const PanelColorGradientSettingsInner = ({
  className,
  colors,
  gradients,
  disableCustomColors,
  disableCustomGradients,
  children,
  settings,
  title,
  showTitle = true,
  __experimentalIsRenderedInSidebar,
  enableAlpha
}) => {
  const panelId = (0,external_wp_compose_namespaceObject.useInstanceId)(PanelColorGradientSettingsInner);
  const { batch } = (0,external_wp_data_namespaceObject.useRegistry)();
  if ((!colors || colors.length === 0) && (!gradients || gradients.length === 0) && disableCustomColors && disableCustomGradients && settings?.every(
    (setting) => (!setting.colors || setting.colors.length === 0) && (!setting.gradients || setting.gradients.length === 0) && (setting.disableCustomColors === void 0 || setting.disableCustomColors) && (setting.disableCustomGradients === void 0 || setting.disableCustomGradients)
  )) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      className: dist_clsx(
        "block-editor-panel-color-gradient-settings",
        className
      ),
      label: showTitle ? title : void 0,
      resetAll: () => {
        batch(() => {
          settings.forEach(
            ({
              colorValue,
              gradientValue,
              onColorChange,
              onGradientChange
            }) => {
              if (colorValue) {
                onColorChange();
              } else if (gradientValue) {
                onGradientChange();
              }
            }
          );
        });
      },
      panelId,
      __experimentalFirstVisibleItemClass: "first",
      __experimentalLastVisibleItemClass: "last",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          ColorGradientSettingsDropdown,
          {
            settings,
            panelId,
            ...{
              colors,
              gradients,
              disableCustomColors,
              disableCustomGradients,
              __experimentalIsRenderedInSidebar,
              enableAlpha
            }
          }
        ),
        !!children && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalSpacer, { marginY: 4 }),
          " ",
          children
        ] })
      ]
    }
  );
};
const PanelColorGradientSettingsSelect = (props) => {
  const colorGradientSettings = useMultipleOriginColorsAndGradients();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PanelColorGradientSettingsInner,
    {
      ...{ ...colorGradientSettings, ...props }
    }
  );
};
const PanelColorGradientSettings = (props) => {
  if (panel_color_gradient_settings_colorsAndGradientKeys.every((key) => props.hasOwnProperty(key))) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PanelColorGradientSettingsInner, { ...props });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PanelColorGradientSettingsSelect, { ...props });
};
var panel_color_gradient_settings_default = PanelColorGradientSettings;


;// ./node_modules/@wordpress/icons/build-module/library/aspect-ratio.js


var aspect_ratio_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M18.5 5.5h-13c-1.1 0-2 .9-2 2v9c0 1.1.9 2 2 2h13c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2zm.5 11c0 .3-.2.5-.5.5h-13c-.3 0-.5-.2-.5-.5v-9c0-.3.2-.5.5-.5h13c.3 0 .5.2.5.5v9zM6.5 12H8v-2h2V8.5H6.5V12zm9.5 2h-2v1.5h3.5V12H16v2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/constants.js
const MIN_ZOOM = 100;
const MAX_ZOOM = 300;
const constants_POPOVER_PROPS = {
  placement: "bottom-start"
};


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/use-save-image.js







const messages = {
  crop: (0,external_wp_i18n_namespaceObject.__)("Image cropped."),
  rotate: (0,external_wp_i18n_namespaceObject.__)("Image rotated."),
  cropAndRotate: (0,external_wp_i18n_namespaceObject.__)("Image cropped and rotated.")
};
function useSaveImage({
  crop,
  rotation,
  url,
  id,
  onSaveImage,
  onFinishEditing
}) {
  const { createErrorNotice, createSuccessNotice } = (0,external_wp_data_namespaceObject.useDispatch)(external_wp_notices_namespaceObject.store);
  const [isInProgress, setIsInProgress] = (0,external_wp_element_namespaceObject.useState)(false);
  const { editMediaEntity } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const settings = select(store).getSettings();
    return {
      editMediaEntity: settings?.[mediaEditKey]
    };
  }, []);
  const cancel = (0,external_wp_element_namespaceObject.useCallback)(() => {
    setIsInProgress(false);
    onFinishEditing();
  }, [onFinishEditing]);
  const apply = (0,external_wp_element_namespaceObject.useCallback)(async () => {
    if (!editMediaEntity) {
      onFinishEditing();
      createErrorNotice(
        (0,external_wp_i18n_namespaceObject.__)("Sorry, you are not allowed to edit images on this site."),
        {
          id: "image-editing-error",
          type: "snackbar"
        }
      );
      return;
    }
    setIsInProgress(true);
    const modifiers = [];
    if (rotation > 0) {
      modifiers.push({
        type: "rotate",
        args: {
          angle: rotation
        }
      });
    }
    if (crop.width < 99.9 || crop.height < 99.9) {
      modifiers.push({
        type: "crop",
        args: {
          left: crop.x,
          top: crop.y,
          width: crop.width,
          height: crop.height
        }
      });
    }
    if (modifiers.length === 0) {
      setIsInProgress(false);
      onFinishEditing();
      return;
    }
    const modifierType = modifiers.length === 1 ? modifiers[0].type : "cropAndRotate";
    try {
      const savedImage = await editMediaEntity(
        id,
        {
          src: url,
          modifiers
        },
        { throwOnError: true }
      );
      if (savedImage) {
        onSaveImage({
          id: savedImage.id,
          url: savedImage.source_url
        });
        createSuccessNotice(messages[modifierType], {
          type: "snackbar",
          actions: [
            {
              label: (0,external_wp_i18n_namespaceObject.__)("Undo"),
              onClick: () => {
                onSaveImage({
                  id,
                  url
                });
              }
            }
          ]
        });
      }
    } catch (error) {
      createErrorNotice(
        (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %s: Error message. */
          (0,external_wp_i18n_namespaceObject.__)("Could not edit image. %s"),
          (0,external_wp_dom_namespaceObject.__unstableStripHTML)(error.message)
        ),
        {
          id: "image-editing-error",
          type: "snackbar"
        }
      );
    } finally {
      setIsInProgress(false);
      onFinishEditing();
    }
  }, [
    crop,
    rotation,
    id,
    url,
    onSaveImage,
    createErrorNotice,
    createSuccessNotice,
    onFinishEditing,
    editMediaEntity
  ]);
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      isInProgress,
      apply,
      cancel
    }),
    [isInProgress, apply, cancel]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/use-transform-image.js


function useTransformImage({
  url,
  naturalWidth,
  naturalHeight
}) {
  const [editedUrl, setEditedUrl] = (0,external_wp_element_namespaceObject.useState)();
  const [crop, setCrop] = (0,external_wp_element_namespaceObject.useState)();
  const [position, setPosition] = (0,external_wp_element_namespaceObject.useState)({ x: 0, y: 0 });
  const [zoom, setZoom] = (0,external_wp_element_namespaceObject.useState)(100);
  const [rotation, setRotation] = (0,external_wp_element_namespaceObject.useState)(0);
  const defaultAspect = naturalWidth / naturalHeight;
  const [aspect, setAspect] = (0,external_wp_element_namespaceObject.useState)(defaultAspect);
  const rotateClockwise = (0,external_wp_element_namespaceObject.useCallback)(() => {
    const angle = (rotation + 90) % 360;
    let naturalAspectRatio = defaultAspect;
    if (rotation % 180 === 90) {
      naturalAspectRatio = 1 / defaultAspect;
    }
    if (angle === 0) {
      setEditedUrl();
      setRotation(angle);
      setAspect(defaultAspect);
      setPosition((prevPosition) => ({
        x: -(prevPosition.y * naturalAspectRatio),
        y: prevPosition.x * naturalAspectRatio
      }));
      return;
    }
    function editImage(event) {
      const canvas = document.createElement("canvas");
      let translateX = 0;
      let translateY = 0;
      if (angle % 180) {
        canvas.width = event.target.height;
        canvas.height = event.target.width;
      } else {
        canvas.width = event.target.width;
        canvas.height = event.target.height;
      }
      if (angle === 90 || angle === 180) {
        translateX = canvas.width;
      }
      if (angle === 270 || angle === 180) {
        translateY = canvas.height;
      }
      const context = canvas.getContext("2d");
      context.translate(translateX, translateY);
      context.rotate(angle * Math.PI / 180);
      context.drawImage(event.target, 0, 0);
      canvas.toBlob((blob) => {
        setEditedUrl(URL.createObjectURL(blob));
        setRotation(angle);
        setAspect(canvas.width / canvas.height);
        setPosition((prevPosition) => ({
          x: -(prevPosition.y * naturalAspectRatio),
          y: prevPosition.x * naturalAspectRatio
        }));
      });
    }
    const el = new window.Image();
    el.src = url;
    el.onload = editImage;
    const imgCrossOrigin = (0,external_wp_hooks_namespaceObject.applyFilters)(
      "media.crossOrigin",
      void 0,
      url
    );
    if (typeof imgCrossOrigin === "string") {
      el.crossOrigin = imgCrossOrigin;
    }
  }, [rotation, defaultAspect, url]);
  return (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      editedUrl,
      setEditedUrl,
      crop,
      setCrop,
      position,
      setPosition,
      zoom,
      setZoom,
      rotation,
      setRotation,
      rotateClockwise,
      aspect,
      setAspect,
      defaultAspect
    }),
    [
      editedUrl,
      crop,
      position,
      zoom,
      rotation,
      rotateClockwise,
      aspect,
      defaultAspect
    ]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/context.js




const ImageEditingContext = (0,external_wp_element_namespaceObject.createContext)({});
ImageEditingContext.displayName = "ImageEditingContext";
const useImageEditingContext = () => (0,external_wp_element_namespaceObject.useContext)(ImageEditingContext);
function ImageEditingProvider({
  id,
  url,
  naturalWidth,
  naturalHeight,
  onFinishEditing,
  onSaveImage,
  children
}) {
  const transformImage = useTransformImage({
    url,
    naturalWidth,
    naturalHeight
  });
  const saveImage = useSaveImage({
    id,
    url,
    onSaveImage,
    onFinishEditing,
    ...transformImage
  });
  const providerValue = (0,external_wp_element_namespaceObject.useMemo)(
    () => ({
      ...transformImage,
      ...saveImage
    }),
    [transformImage, saveImage]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ImageEditingContext.Provider, { value: providerValue, children });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/aspect-ratio-dropdown.js







function AspectRatioGroup({
  aspectRatios,
  isDisabled,
  label,
  onClick,
  value
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.MenuGroup, { label, children: aspectRatios.map(({ name, slug, ratio }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.MenuItem,
    {
      disabled: isDisabled,
      onClick: () => {
        onClick(ratio);
      },
      role: "menuitemradio",
      isSelected: ratio === value,
      icon: ratio === value ? check_check_default : void 0,
      children: name
    },
    slug
  )) });
}
function ratioToNumber(str) {
  const [a, b, ...rest] = str.split("/").map(Number);
  if (a <= 0 || b <= 0 || Number.isNaN(a) || Number.isNaN(b) || rest.length) {
    return NaN;
  }
  return b ? a / b : a;
}
function presetRatioAsNumber({ ratio, ...rest }) {
  return {
    ratio: ratioToNumber(ratio),
    ...rest
  };
}
function AspectRatioDropdown({ toggleProps }) {
  const { isInProgress, aspect, setAspect, defaultAspect } = useImageEditingContext();
  const [defaultRatios, themeRatios, showDefaultRatios] = use_settings_useSettings(
    "dimensions.aspectRatios.default",
    "dimensions.aspectRatios.theme",
    "dimensions.defaultAspectRatios"
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.DropdownMenu,
    {
      icon: aspect_ratio_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Aspect Ratio"),
      popoverProps: constants_POPOVER_PROPS,
      toggleProps,
      children: ({ onClose }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          AspectRatioGroup,
          {
            isDisabled: isInProgress,
            onClick: (newAspect) => {
              setAspect(newAspect);
              onClose();
            },
            value: aspect,
            aspectRatios: [
              // All ratios should be mirrored in AspectRatioTool in @wordpress/block-editor.
              {
                slug: "original",
                name: (0,external_wp_i18n_namespaceObject.__)("Original"),
                ratio: defaultAspect
              },
              ...showDefaultRatios ? defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio === 1) : []
            ]
          }
        ),
        themeRatios?.length > 0 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          AspectRatioGroup,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Theme"),
            isDisabled: isInProgress,
            onClick: (newAspect) => {
              setAspect(newAspect);
              onClose();
            },
            value: aspect,
            aspectRatios: themeRatios
          }
        ),
        showDefaultRatios && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          AspectRatioGroup,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Landscape"),
            isDisabled: isInProgress,
            onClick: (newAspect) => {
              setAspect(newAspect);
              onClose();
            },
            value: aspect,
            aspectRatios: defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio > 1)
          }
        ),
        showDefaultRatios && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          AspectRatioGroup,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Portrait"),
            isDisabled: isInProgress,
            onClick: (newAspect) => {
              setAspect(newAspect);
              onClose();
            },
            value: aspect,
            aspectRatios: defaultRatios.map(presetRatioAsNumber).filter(({ ratio }) => ratio < 1)
          }
        )
      ] })
    }
  );
}


;// ./node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const tslib_es6 = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});

// EXTERNAL MODULE: ./node_modules/normalize-wheel/index.js
var normalize_wheel = __webpack_require__(7520);
var normalize_wheel_default = /*#__PURE__*/__webpack_require__.n(normalize_wheel);
;// ./node_modules/react-easy-crop/index.module.js




/**
 * Compute the dimension of the crop area based on media size,
 * aspect ratio and optionally rotation
 */
function getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var _a = rotateSize(mediaWidth, mediaHeight, rotation),
    width = _a.width,
    height = _a.height;
  var fittingWidth = Math.min(width, containerWidth);
  var fittingHeight = Math.min(height, containerHeight);
  if (fittingWidth > fittingHeight * aspect) {
    return {
      width: fittingHeight * aspect,
      height: fittingHeight
    };
  }
  return {
    width: fittingWidth,
    height: fittingWidth / aspect
  };
}
/**
 * Compute media zoom.
 * We fit the media into the container with "max-width: 100%; max-height: 100%;"
 */
function getMediaZoom(mediaSize) {
  // Take the axis with more pixels to improve accuracy
  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;
}
/**
 * Ensure a new media position stays in the crop area.
 */
function restrictPosition(position, mediaSize, cropSize, zoom, rotation) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),
    width = _a.width,
    height = _a.height;
  return {
    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),
    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)
  };
}
function restrictPositionCoord(position, mediaSize, cropSize, zoom) {
  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;
  return clamp(position, -maxPosition, maxPosition);
}
function getDistanceBetweenPoints(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));
}
function getRotationBetweenPoints(pointA, pointB) {
  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;
}
/**
 * Compute the output cropped area of the media in percentages and pixels.
 * x/y are the top-left coordinates on the src media
 */
function computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {
  if (rotation === void 0) {
    rotation = 0;
  }
  if (restrictPosition === void 0) {
    restrictPosition = true;
  }
  // if the media is rotated by the user, we cannot limit the position anymore
  // as it might need to be negative.
  var limitAreaFn = restrictPosition ? limitArea : noOp;
  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
  // calculate the crop area in percentages
  // in the rotated space
  var croppedAreaPercentages = {
    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),
    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),
    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),
    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)
  };
  // we compute the pixels size naively
  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));
  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));
  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect;
  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)
  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height
  // thus we want to compute the width from the height and aspect for accuracy.
  // Otherwise, we compute the height from width and aspect.
  var sizePixels = isImgWiderThanHigh ? {
    width: Math.round(heightInPixels * aspect),
    height: heightInPixels
  } : {
    width: widthInPixels,
    height: Math.round(widthInPixels / aspect)
  };
  var croppedAreaPixels = __assign(__assign({}, sizePixels), {
    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),
    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))
  });
  return {
    croppedAreaPercentages: croppedAreaPercentages,
    croppedAreaPixels: croppedAreaPixels
  };
}
/**
 * Ensure the returned value is between 0 and max
 */
function limitArea(max, value) {
  return Math.min(max, Math.max(0, value));
}
function noOp(_max, value) {
  return value;
}
/**
 * Compute crop and zoom from the croppedAreaPercentages.
 */
function getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {
  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);
  // This is the inverse process of computeCroppedArea
  var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);
  var crop = {
    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),
    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)
  };
  return {
    crop: crop,
    zoom: zoom
  };
}
/**
 * Compute zoom from the croppedAreaPixels
 */
function getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {
  var mediaZoom = getMediaZoom(mediaSize);
  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);
}
/**
 * Compute crop and zoom from the croppedAreaPixels
 */
function getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {
  if (rotation === void 0) {
    rotation = 0;
  }
  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);
  var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);
  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;
  var crop = {
    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,
    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom
  };
  return {
    crop: crop,
    zoom: zoom
  };
}
/**
 * Return the point that is the center of point a and b
 */
function getCenter(a, b) {
  return {
    x: (b.x + a.x) / 2,
    y: (b.y + a.y) / 2
  };
}
function getRadianAngle(degreeValue) {
  return degreeValue * Math.PI / 180;
}
/**
 * Returns the new bounding area of a rotated rectangle.
 */
function rotateSize(width, height, rotation) {
  var rotRad = getRadianAngle(rotation);
  return {
    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),
    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)
  };
}
/**
 * Clamp value between min and max
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Combine multiple class names into a single string.
 */
function classNames() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.filter(function (value) {
    if (typeof value === 'string' && value.length > 0) {
      return true;
    }
    return false;
  }).join(' ').trim();
}

var css_248z = ".reactEasyCrop_Container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  user-select: none;\n  touch-action: none;\n  cursor: move;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.reactEasyCrop_Image,\n.reactEasyCrop_Video {\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\n}\n\n.reactEasyCrop_Contain {\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.reactEasyCrop_Cover_Horizontal {\n  width: 100%;\n  height: auto;\n}\n.reactEasyCrop_Cover_Vertical {\n  width: auto;\n  height: 100%;\n}\n\n.reactEasyCrop_CropArea {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  box-sizing: border-box;\n  box-shadow: 0 0 0 9999em;\n  color: rgba(0, 0, 0, 0.5);\n  overflow: hidden;\n}\n\n.reactEasyCrop_CropAreaRound {\n  border-radius: 50%;\n}\n\n.reactEasyCrop_CropAreaGrid::before {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 0;\n  bottom: 0;\n  left: 33.33%;\n  right: 33.33%;\n  border-top: 0;\n  border-bottom: 0;\n}\n\n.reactEasyCrop_CropAreaGrid::after {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 33.33%;\n  bottom: 33.33%;\n  left: 0;\n  right: 0;\n  border-left: 0;\n  border-right: 0;\n}\n";

var index_module_MIN_ZOOM = 1;
var index_module_MAX_ZOOM = 3;
var Cropper = /** @class */function (_super) {
  __extends(Cropper, _super);
  function Cropper() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.imageRef = external_React_.createRef();
    _this.videoRef = external_React_.createRef();
    _this.containerPosition = {
      x: 0,
      y: 0
    };
    _this.containerRef = null;
    _this.styleRef = null;
    _this.containerRect = null;
    _this.mediaSize = {
      width: 0,
      height: 0,
      naturalWidth: 0,
      naturalHeight: 0
    };
    _this.dragStartPosition = {
      x: 0,
      y: 0
    };
    _this.dragStartCrop = {
      x: 0,
      y: 0
    };
    _this.gestureZoomStart = 0;
    _this.gestureRotationStart = 0;
    _this.isTouching = false;
    _this.lastPinchDistance = 0;
    _this.lastPinchRotation = 0;
    _this.rafDragTimeout = null;
    _this.rafPinchTimeout = null;
    _this.wheelTimer = null;
    _this.currentDoc = typeof document !== 'undefined' ? document : null;
    _this.currentWindow = typeof window !== 'undefined' ? window : null;
    _this.resizeObserver = null;
    _this.state = {
      cropSize: null,
      hasWheelJustStarted: false,
      mediaObjectFit: undefined
    };
    _this.initResizeObserver = function () {
      if (typeof window.ResizeObserver === 'undefined' || !_this.containerRef) {
        return;
      }
      var isFirstResize = true;
      _this.resizeObserver = new window.ResizeObserver(function (entries) {
        if (isFirstResize) {
          isFirstResize = false; // observe() is called on mount, we don't want to trigger a recompute on mount
          return;
        }
        _this.computeSizes();
      });
      _this.resizeObserver.observe(_this.containerRef);
    };
    // this is to prevent Safari on iOS >= 10 to zoom the page
    _this.preventZoomSafari = function (e) {
      return e.preventDefault();
    };
    _this.cleanEvents = function () {
      if (!_this.currentDoc) return;
      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);
      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);
      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);
      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);
      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);
      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);
      _this.currentDoc.removeEventListener('scroll', _this.onScroll);
    };
    _this.clearScrollEvent = function () {
      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);
      if (_this.wheelTimer) {
        clearTimeout(_this.wheelTimer);
      }
    };
    _this.onMediaLoad = function () {
      var cropSize = _this.computeSizes();
      if (cropSize) {
        _this.emitCropData();
        _this.setInitialCrop(cropSize);
      }
      if (_this.props.onMediaLoaded) {
        _this.props.onMediaLoaded(_this.mediaSize);
      }
    };
    _this.setInitialCrop = function (cropSize) {
      if (_this.props.initialCroppedAreaPercentages) {
        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
          crop = _a.crop,
          zoom = _a.zoom;
        _this.props.onCropChange(crop);
        _this.props.onZoomChange && _this.props.onZoomChange(zoom);
      } else if (_this.props.initialCroppedAreaPixels) {
        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
          crop = _b.crop,
          zoom = _b.zoom;
        _this.props.onCropChange(crop);
        _this.props.onZoomChange && _this.props.onZoomChange(zoom);
      }
    };
    _this.computeSizes = function () {
      var _a, _b, _c, _d, _e, _f;
      var mediaRef = _this.imageRef.current || _this.videoRef.current;
      if (mediaRef && _this.containerRef) {
        _this.containerRect = _this.containerRef.getBoundingClientRect();
        _this.saveContainerPosition();
        var containerAspect = _this.containerRect.width / _this.containerRect.height;
        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;
        var mediaAspect = naturalWidth / naturalHeight;
        // We do not rely on the offsetWidth/offsetHeight if the media is scaled down
        // as the values they report are rounded. That will result in precision losses
        // when calculating zoom. We use the fact that the media is positionned relative
        // to the container. That allows us to use the container's dimensions
        // and natural aspect ratio of the media to calculate accurate media size.
        // However, for this to work, the container should not be rotated
        var renderedMediaSize = void 0;
        if (isMediaScaledDown) {
          switch (_this.state.mediaObjectFit) {
            default:
            case 'contain':
              renderedMediaSize = containerAspect > mediaAspect ? {
                width: _this.containerRect.height * mediaAspect,
                height: _this.containerRect.height
              } : {
                width: _this.containerRect.width,
                height: _this.containerRect.width / mediaAspect
              };
              break;
            case 'horizontal-cover':
              renderedMediaSize = {
                width: _this.containerRect.width,
                height: _this.containerRect.width / mediaAspect
              };
              break;
            case 'vertical-cover':
              renderedMediaSize = {
                width: _this.containerRect.height * mediaAspect,
                height: _this.containerRect.height
              };
              break;
          }
        } else {
          renderedMediaSize = {
            width: mediaRef.offsetWidth,
            height: mediaRef.offsetHeight
          };
        }
        _this.mediaSize = __assign(__assign({}, renderedMediaSize), {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight
        });
        // set media size in the parent
        if (_this.props.setMediaSize) {
          _this.props.setMediaSize(_this.mediaSize);
        }
        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);
        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {
          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);
        }
        _this.setState({
          cropSize: cropSize
        }, _this.recomputeCropPosition);
        // pass crop size to parent
        if (_this.props.setCropSize) {
          _this.props.setCropSize(cropSize);
        }
        return cropSize;
      }
    };
    _this.saveContainerPosition = function () {
      if (_this.containerRef) {
        var bounds = _this.containerRef.getBoundingClientRect();
        _this.containerPosition = {
          x: bounds.left,
          y: bounds.top
        };
      }
    };
    _this.onMouseDown = function (e) {
      if (!_this.currentDoc) return;
      e.preventDefault();
      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);
      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);
      _this.saveContainerPosition();
      _this.onDragStart(Cropper.getMousePoint(e));
    };
    _this.onMouseMove = function (e) {
      return _this.onDrag(Cropper.getMousePoint(e));
    };
    _this.onScroll = function (e) {
      if (!_this.currentDoc) return;
      e.preventDefault();
      _this.saveContainerPosition();
    };
    _this.onTouchStart = function (e) {
      if (!_this.currentDoc) return;
      _this.isTouching = true;
      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {
        return;
      }
      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {
        passive: false
      }); // iOS 11 now defaults to passive: true
      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);
      _this.saveContainerPosition();
      if (e.touches.length === 2) {
        _this.onPinchStart(e);
      } else if (e.touches.length === 1) {
        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));
      }
    };
    _this.onTouchMove = function (e) {
      // Prevent whole page from scrolling on iOS.
      e.preventDefault();
      if (e.touches.length === 2) {
        _this.onPinchMove(e);
      } else if (e.touches.length === 1) {
        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));
      }
    };
    _this.onGestureStart = function (e) {
      if (!_this.currentDoc) return;
      e.preventDefault();
      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);
      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);
      _this.gestureZoomStart = _this.props.zoom;
      _this.gestureRotationStart = _this.props.rotation;
    };
    _this.onGestureMove = function (e) {
      e.preventDefault();
      if (_this.isTouching) {
        // this is to avoid conflict between gesture and touch events
        return;
      }
      var point = Cropper.getMousePoint(e);
      var newZoom = _this.gestureZoomStart - 1 + e.scale;
      _this.setNewZoom(newZoom, point, {
        shouldUpdatePosition: true
      });
      if (_this.props.onRotationChange) {
        var newRotation = _this.gestureRotationStart + e.rotation;
        _this.props.onRotationChange(newRotation);
      }
    };
    _this.onGestureEnd = function (e) {
      _this.cleanEvents();
    };
    _this.onDragStart = function (_a) {
      var _b, _c;
      var x = _a.x,
        y = _a.y;
      _this.dragStartPosition = {
        x: x,
        y: y
      };
      _this.dragStartCrop = __assign({}, _this.props.crop);
      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);
    };
    _this.onDrag = function (_a) {
      var x = _a.x,
        y = _a.y;
      if (!_this.currentWindow) return;
      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);
      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {
        if (!_this.state.cropSize) return;
        if (x === undefined || y === undefined) return;
        var offsetX = x - _this.dragStartPosition.x;
        var offsetY = y - _this.dragStartPosition.y;
        var requestedPosition = {
          x: _this.dragStartCrop.x + offsetX,
          y: _this.dragStartCrop.y + offsetY
        };
        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;
        _this.props.onCropChange(newPosition);
      });
    };
    _this.onDragStopped = function () {
      var _a, _b;
      _this.isTouching = false;
      _this.cleanEvents();
      _this.emitCropData();
      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    _this.onWheel = function (e) {
      if (!_this.currentWindow) return;
      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {
        return;
      }
      e.preventDefault();
      var point = Cropper.getMousePoint(e);
      var pixelY = normalize_wheel_default()(e).pixelY;
      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;
      _this.setNewZoom(newZoom, point, {
        shouldUpdatePosition: true
      });
      if (!_this.state.hasWheelJustStarted) {
        _this.setState({
          hasWheelJustStarted: true
        }, function () {
          var _a, _b;
          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
      }
      if (_this.wheelTimer) {
        clearTimeout(_this.wheelTimer);
      }
      _this.wheelTimer = _this.currentWindow.setTimeout(function () {
        return _this.setState({
          hasWheelJustStarted: false
        }, function () {
          var _a, _b;
          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
      }, 250);
    };
    _this.getPointOnContainer = function (_a, containerTopLeft) {
      var x = _a.x,
        y = _a.y;
      if (!_this.containerRect) {
        throw new Error('The Cropper is not mounted');
      }
      return {
        x: _this.containerRect.width / 2 - (x - containerTopLeft.x),
        y: _this.containerRect.height / 2 - (y - containerTopLeft.y)
      };
    };
    _this.getPointOnMedia = function (_a) {
      var x = _a.x,
        y = _a.y;
      var _b = _this.props,
        crop = _b.crop,
        zoom = _b.zoom;
      return {
        x: (x + crop.x) / zoom,
        y: (y + crop.y) / zoom
      };
    };
    _this.setNewZoom = function (zoom, point, _a) {
      var _b = _a === void 0 ? {} : _a,
        _c = _b.shouldUpdatePosition,
        shouldUpdatePosition = _c === void 0 ? true : _c;
      if (!_this.state.cropSize || !_this.props.onZoomChange) return;
      var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);
      if (shouldUpdatePosition) {
        var zoomPoint = _this.getPointOnContainer(point, _this.containerPosition);
        var zoomTarget = _this.getPointOnMedia(zoomPoint);
        var requestedPosition = {
          x: zoomTarget.x * newZoom - zoomPoint.x,
          y: zoomTarget.y * newZoom - zoomPoint.y
        };
        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;
        _this.props.onCropChange(newPosition);
      }
      _this.props.onZoomChange(newZoom);
    };
    _this.getCropData = function () {
      if (!_this.state.cropSize) {
        return null;
      }
      // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)
      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);
    };
    _this.emitCropData = function () {
      var cropData = _this.getCropData();
      if (!cropData) return;
      var croppedAreaPercentages = cropData.croppedAreaPercentages,
        croppedAreaPixels = cropData.croppedAreaPixels;
      if (_this.props.onCropComplete) {
        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);
      }
      if (_this.props.onCropAreaChange) {
        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
      }
    };
    _this.emitCropAreaChange = function () {
      var cropData = _this.getCropData();
      if (!cropData) return;
      var croppedAreaPercentages = cropData.croppedAreaPercentages,
        croppedAreaPixels = cropData.croppedAreaPixels;
      if (_this.props.onCropAreaChange) {
        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);
      }
    };
    _this.recomputeCropPosition = function () {
      if (!_this.state.cropSize) return;
      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
      _this.props.onCropChange(newPosition);
      _this.emitCropData();
    };
    return _this;
  }
  Cropper.prototype.componentDidMount = function () {
    if (!this.currentDoc || !this.currentWindow) return;
    if (this.containerRef) {
      if (this.containerRef.ownerDocument) {
        this.currentDoc = this.containerRef.ownerDocument;
      }
      if (this.currentDoc.defaultView) {
        this.currentWindow = this.currentDoc.defaultView;
      }
      this.initResizeObserver();
      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant
      if (typeof window.ResizeObserver === 'undefined') {
        this.currentWindow.addEventListener('resize', this.computeSizes);
      }
      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {
        passive: false
      });
      this.containerRef.addEventListener('gesturestart', this.onGestureStart);
    }
    this.currentDoc.addEventListener('scroll', this.onScroll);
    if (!this.props.disableAutomaticStylesInjection) {
      this.styleRef = this.currentDoc.createElement('style');
      this.styleRef.setAttribute('type', 'text/css');
      if (this.props.nonce) {
        this.styleRef.setAttribute('nonce', this.props.nonce);
      }
      this.styleRef.innerHTML = css_248z;
      this.currentDoc.head.appendChild(this.styleRef);
    }
    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called
    if (this.imageRef.current && this.imageRef.current.complete) {
      this.onMediaLoad();
    }
    // set image and video refs in the parent if the callbacks exist
    if (this.props.setImageRef) {
      this.props.setImageRef(this.imageRef);
    }
    if (this.props.setVideoRef) {
      this.props.setVideoRef(this.videoRef);
    }
  };
  Cropper.prototype.componentWillUnmount = function () {
    var _a, _b;
    if (!this.currentDoc || !this.currentWindow) return;
    if (typeof window.ResizeObserver === 'undefined') {
      this.currentWindow.removeEventListener('resize', this.computeSizes);
    }
    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    if (this.containerRef) {
      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);
    }
    if (this.styleRef) {
      (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);
    }
    this.cleanEvents();
    this.props.zoomWithScroll && this.clearScrollEvent();
  };
  Cropper.prototype.componentDidUpdate = function (prevProps) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (prevProps.rotation !== this.props.rotation) {
      this.computeSizes();
      this.recomputeCropPosition();
    } else if (prevProps.aspect !== this.props.aspect) {
      this.computeSizes();
    } else if (prevProps.objectFit !== this.props.objectFit) {
      this.computeSizes();
    } else if (prevProps.zoom !== this.props.zoom) {
      this.recomputeCropPosition();
    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {
      this.computeSizes();
    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {
      this.emitCropAreaChange();
    }
    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {
      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {
        passive: false
      }) : this.clearScrollEvent();
    }
    if (prevProps.video !== this.props.video) {
      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();
    }
    var objectFit = this.getObjectFit();
    if (objectFit !== this.state.mediaObjectFit) {
      this.setState({
        mediaObjectFit: objectFit
      }, this.computeSizes);
    }
  };
  Cropper.prototype.getAspect = function () {
    var _a = this.props,
      cropSize = _a.cropSize,
      aspect = _a.aspect;
    if (cropSize) {
      return cropSize.width / cropSize.height;
    }
    return aspect;
  };
  Cropper.prototype.getObjectFit = function () {
    var _a, _b, _c, _d;
    if (this.props.objectFit === 'cover') {
      var mediaRef = this.imageRef.current || this.videoRef.current;
      if (mediaRef && this.containerRef) {
        this.containerRect = this.containerRef.getBoundingClientRect();
        var containerAspect = this.containerRect.width / this.containerRect.height;
        var naturalWidth = ((_a = this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
        var naturalHeight = ((_c = this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
        var mediaAspect = naturalWidth / naturalHeight;
        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover';
      }
      return 'horizontal-cover';
    }
    return this.props.objectFit;
  };
  Cropper.prototype.onPinchStart = function (e) {
    var pointA = Cropper.getTouchPoint(e.touches[0]);
    var pointB = Cropper.getTouchPoint(e.touches[1]);
    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);
    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);
    this.onDragStart(getCenter(pointA, pointB));
  };
  Cropper.prototype.onPinchMove = function (e) {
    var _this = this;
    if (!this.currentDoc || !this.currentWindow) return;
    var pointA = Cropper.getTouchPoint(e.touches[0]);
    var pointB = Cropper.getTouchPoint(e.touches[1]);
    var center = getCenter(pointA, pointB);
    this.onDrag(center);
    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);
    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {
      var distance = getDistanceBetweenPoints(pointA, pointB);
      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);
      _this.setNewZoom(newZoom, center, {
        shouldUpdatePosition: false
      });
      _this.lastPinchDistance = distance;
      var rotation = getRotationBetweenPoints(pointA, pointB);
      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);
      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);
      _this.lastPinchRotation = rotation;
    });
  };
  Cropper.prototype.render = function () {
    var _this = this;
    var _a = this.props,
      image = _a.image,
      video = _a.video,
      mediaProps = _a.mediaProps,
      transform = _a.transform,
      _b = _a.crop,
      x = _b.x,
      y = _b.y,
      rotation = _a.rotation,
      zoom = _a.zoom,
      cropShape = _a.cropShape,
      showGrid = _a.showGrid,
      _c = _a.style,
      containerStyle = _c.containerStyle,
      cropAreaStyle = _c.cropAreaStyle,
      mediaStyle = _c.mediaStyle,
      _d = _a.classes,
      containerClassName = _d.containerClassName,
      cropAreaClassName = _d.cropAreaClassName,
      mediaClassName = _d.mediaClassName;
    var objectFit = this.state.mediaObjectFit;
    return external_React_.createElement("div", {
      onMouseDown: this.onMouseDown,
      onTouchStart: this.onTouchStart,
      ref: function ref(el) {
        return _this.containerRef = el;
      },
      "data-testid": "container",
      style: containerStyle,
      className: classNames('reactEasyCrop_Container', containerClassName)
    }, image ? external_React_.createElement("img", __assign({
      alt: "",
      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)
    }, mediaProps, {
      src: image,
      ref: this.imageRef,
      style: __assign(__assign({}, mediaStyle), {
        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
      }),
      onLoad: this.onMediaLoad
    })) : video && external_React_.createElement("video", __assign({
      autoPlay: true,
      loop: true,
      muted: true,
      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)
    }, mediaProps, {
      ref: this.videoRef,
      onLoadedMetadata: this.onMediaLoad,
      style: __assign(__assign({}, mediaStyle), {
        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
      }),
      controls: false
    }), (Array.isArray(video) ? video : [{
      src: video
    }]).map(function (item) {
      return external_React_.createElement("source", __assign({
        key: item.src
      }, item));
    })), this.state.cropSize && external_React_.createElement("div", {
      style: __assign(__assign({}, cropAreaStyle), {
        width: this.state.cropSize.width,
        height: this.state.cropSize.height
      }),
      "data-testid": "cropper",
      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)
    }));
  };
  Cropper.defaultProps = {
    zoom: 1,
    rotation: 0,
    aspect: 4 / 3,
    maxZoom: index_module_MAX_ZOOM,
    minZoom: index_module_MIN_ZOOM,
    cropShape: 'rect',
    objectFit: 'contain',
    showGrid: true,
    style: {},
    classes: {},
    mediaProps: {},
    zoomSpeed: 1,
    restrictPosition: true,
    zoomWithScroll: true
  };
  Cropper.getMousePoint = function (e) {
    return {
      x: Number(e.clientX),
      y: Number(e.clientY)
    };
  };
  Cropper.getTouchPoint = function (touch) {
    return {
      x: Number(touch.clientX),
      y: Number(touch.clientY)
    };
  };
  return Cropper;
}(external_React_.Component);



;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/cropper.js







function ImageCropper({
  url,
  width,
  height,
  naturalHeight,
  naturalWidth,
  borderProps
}) {
  const {
    isInProgress,
    editedUrl,
    position,
    zoom,
    aspect,
    setPosition,
    setCrop,
    setZoom,
    rotation
  } = useImageEditingContext();
  const [contentResizeListener, { width: clientWidth }] = (0,external_wp_compose_namespaceObject.useResizeObserver)();
  let editedHeight = height || clientWidth * naturalHeight / naturalWidth;
  if (rotation % 180 === 90) {
    editedHeight = clientWidth * naturalWidth / naturalHeight;
  }
  const area = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: dist_clsx(
        "wp-block-image__crop-area",
        borderProps?.className,
        {
          "is-applying": isInProgress
        }
      ),
      style: {
        ...borderProps?.style,
        width: width || clientWidth,
        height: editedHeight
      },
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          Cropper,
          {
            image: editedUrl || url,
            disabled: isInProgress,
            minZoom: MIN_ZOOM / 100,
            maxZoom: MAX_ZOOM / 100,
            crop: position,
            zoom: zoom / 100,
            aspect,
            onCropChange: (pos) => {
              setPosition(pos);
            },
            onCropComplete: (newCropPercent) => {
              setCrop(newCropPercent);
            },
            onZoomChange: (newZoom) => {
              setZoom(newZoom * 100);
            }
          }
        ),
        isInProgress && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Spinner, {})
      ]
    }
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    contentResizeListener,
    area
  ] });
}


;// ./node_modules/@wordpress/icons/build-module/library/search.js


var search_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/zoom-dropdown.js






function ZoomDropdown() {
  const { isInProgress, zoom, setZoom } = useImageEditingContext();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Dropdown,
    {
      contentClassName: "wp-block-image__zoom",
      popoverProps: constants_POPOVER_PROPS,
      renderToggle: ({ isOpen, onToggle }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ToolbarButton,
        {
          icon: search_default,
          label: (0,external_wp_i18n_namespaceObject.__)("Zoom"),
          onClick: onToggle,
          "aria-expanded": isOpen,
          disabled: isInProgress
        }
      ),
      renderContent: () => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalDropdownContentWrapper, { paddingSize: "medium", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.RangeControl,
        {
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Zoom"),
          min: MIN_ZOOM,
          max: MAX_ZOOM,
          value: Math.round(zoom),
          onChange: setZoom
        }
      ) })
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/rotate-right.js


var rotate_right_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M15.1 4.8l-3-2.5V4c-4.4 0-8 3.6-8 8 0 3.7 2.5 6.9 6 7.7.3.1.6.1 1 .2l.2-1.5c-.4 0-.7-.1-1.1-.2l-.1.2v-.2c-2.6-.8-4.5-3.3-4.5-6.2 0-3.6 2.9-6.5 6.5-6.5v1.8l3-2.5zM20 11c-.2-1.4-.7-2.7-1.6-3.8l-1.2.8c.7.9 1.1 2 1.3 3.1L20 11zm-1.5 1.8c-.1.5-.2 1.1-.4 1.6s-.5 1-.8 1.5l1.2.9c.4-.5.8-1.1 1-1.8s.5-1.3.5-2l-1.5-.2zm-5.6 5.6l.2 1.5c1.4-.2 2.7-.7 3.8-1.6l-.9-1.1c-.9.7-2 1.1-3.1 1.2z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/rotation-button.js





function RotationButton() {
  const { isInProgress, rotateClockwise } = useImageEditingContext();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.ToolbarButton,
    {
      icon: rotate_right_default,
      label: (0,external_wp_i18n_namespaceObject.__)("Rotate"),
      onClick: rotateClockwise,
      disabled: isInProgress
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/form-controls.js




function FormControls() {
  const { isInProgress, apply, cancel } = useImageEditingContext();
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarButton, { onClick: apply, disabled: isInProgress, children: (0,external_wp_i18n_namespaceObject.__)("Apply") }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarButton, { onClick: cancel, children: (0,external_wp_i18n_namespaceObject.__)("Cancel") })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-editor/index.js









function ImageEditor({
  id,
  url,
  width,
  height,
  naturalHeight,
  naturalWidth,
  onSaveImage,
  onFinishEditing,
  borderProps
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    ImageEditingProvider,
    {
      id,
      url,
      naturalWidth,
      naturalHeight,
      onSaveImage,
      onFinishEditing,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          ImageCropper,
          {
            borderProps,
            url,
            width,
            height,
            naturalHeight,
            naturalWidth
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(block_controls_default, { children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.ToolbarGroup, { children: [
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(ZoomDropdown, {}),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(AspectRatioDropdown, { toggleProps }) }),
            /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(RotationButton, {})
          ] }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(FormControls, {}) })
        ] })
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-size-control/use-dimension-handler.js

function useDimensionHandler(customHeight, customWidth, defaultHeight, defaultWidth, onChange) {
  const [currentWidth, setCurrentWidth] = (0,external_wp_element_namespaceObject.useState)(
    customWidth ?? defaultWidth ?? ""
  );
  const [currentHeight, setCurrentHeight] = (0,external_wp_element_namespaceObject.useState)(
    customHeight ?? defaultHeight ?? ""
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (customWidth === void 0 && defaultWidth !== void 0) {
      setCurrentWidth(defaultWidth);
    }
    if (customHeight === void 0 && defaultHeight !== void 0) {
      setCurrentHeight(defaultHeight);
    }
  }, [defaultWidth, defaultHeight]);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (customWidth !== void 0 && Number.parseInt(customWidth) !== Number.parseInt(currentWidth)) {
      setCurrentWidth(customWidth);
    }
    if (customHeight !== void 0 && Number.parseInt(customHeight) !== Number.parseInt(currentHeight)) {
      setCurrentHeight(customHeight);
    }
  }, [customWidth, customHeight]);
  const updateDimension = (dimension, value) => {
    const parsedValue = value === "" ? void 0 : parseInt(value, 10);
    if (dimension === "width") {
      setCurrentWidth(parsedValue);
    } else {
      setCurrentHeight(parsedValue);
    }
    onChange({
      [dimension]: parsedValue
    });
  };
  const updateDimensions = (nextHeight, nextWidth) => {
    setCurrentHeight(nextHeight ?? defaultHeight);
    setCurrentWidth(nextWidth ?? defaultWidth);
    onChange({ height: nextHeight, width: nextWidth });
  };
  return {
    currentHeight,
    currentWidth,
    updateDimension,
    updateDimensions
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/image-size-control/index.js




const IMAGE_SIZE_PRESETS = [25, 50, 75, 100];
const image_size_control_noop = () => {
};
function getScaledWidthAndHeight(scale, imageWidth, imageHeight) {
  const scaledWidth = Math.round(imageWidth * (scale / 100));
  const scaledHeight = Math.round(imageHeight * (scale / 100));
  return {
    scaledWidth,
    scaledHeight
  };
}
function ImageSizeControl({
  imageSizeHelp,
  imageWidth,
  imageHeight,
  imageSizeOptions = [],
  isResizable = true,
  slug,
  width,
  height,
  onChange,
  onChangeImage = image_size_control_noop
}) {
  const { currentHeight, currentWidth, updateDimension, updateDimensions } = useDimensionHandler(height, width, imageHeight, imageWidth, onChange);
  const handleUpdateDimensions = (scale) => {
    if (void 0 === scale) {
      updateDimensions();
      return;
    }
    const { scaledWidth, scaledHeight } = getScaledWidthAndHeight(
      scale,
      imageWidth,
      imageHeight
    );
    updateDimensions(scaledHeight, scaledWidth);
  };
  const selectedValue = IMAGE_SIZE_PRESETS.find((scale) => {
    const { scaledWidth, scaledHeight } = getScaledWidthAndHeight(
      scale,
      imageWidth,
      imageHeight
    );
    return currentWidth === scaledWidth && currentHeight === scaledHeight;
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { className: "block-editor-image-size-control", spacing: "4", children: [
    imageSizeOptions && imageSizeOptions.length > 0 && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.SelectControl,
      {
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Resolution"),
        value: slug,
        options: imageSizeOptions,
        onChange: onChangeImage,
        help: imageSizeHelp,
        size: "__unstable-large"
      }
    ),
    isResizable && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { align: "baseline", spacing: "4", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalNumberControl,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Width"),
            value: currentWidth,
            min: 1,
            onChange: (value) => updateDimension("width", value),
            size: "__unstable-large"
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalNumberControl,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Height"),
            value: currentHeight,
            min: 1,
            onChange: (value) => updateDimension("height", value),
            size: "__unstable-large"
          }
        )
      ] }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToggleGroupControl,
        {
          label: (0,external_wp_i18n_namespaceObject.__)("Image size presets"),
          hideLabelFromVision: true,
          onChange: handleUpdateDimensions,
          value: selectedValue,
          isBlock: true,
          __next40pxDefaultSize: true,
          __nextHasNoMarginBottom: true,
          children: IMAGE_SIZE_PRESETS.map((scale) => {
            return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
              {
                value: scale,
                label: (0,external_wp_i18n_namespaceObject.sprintf)(
                  /* translators: %d: Percentage value. */
                  (0,external_wp_i18n_namespaceObject.__)("%d%%"),
                  scale
                )
              },
              scale
            );
          })
        }
      )
    ] })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer-url.js




function LinkViewerURL({ url, urlLabel, className }) {
  const linkClassName = dist_clsx(
    className,
    "block-editor-url-popover__link-viewer-url"
  );
  if (!url) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: linkClassName });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ExternalLink, { className: linkClassName, href: url, children: urlLabel || (0,external_wp_url_namespaceObject.filterURLForDisplay)((0,external_wp_url_namespaceObject.safeDecodeURI)(url)) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-viewer.js






function LinkViewer({
  className,
  linkClassName,
  onEditLinkClick,
  url,
  urlLabel,
  ...props
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "div",
    {
      className: dist_clsx(
        "block-editor-url-popover__link-viewer",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          LinkViewerURL,
          {
            url,
            urlLabel,
            className: linkClassName
          }
        ),
        onEditLinkClick && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: pencil_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Edit"),
            onClick: onEditLinkClick,
            size: "compact"
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/url-popover/link-editor.js






function LinkEditor({
  autocompleteRef,
  className,
  onChangeInputValue,
  value,
  ...props
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    "form",
    {
      className: dist_clsx(
        "block-editor-url-popover__link-editor",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          url_input_default,
          {
            value,
            onChange: onChangeInputValue,
            autocompleteRef
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: keyboard_return_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Apply"),
            type: "submit",
            size: "compact"
          }
        )
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/url-popover/index.js









const { __experimentalPopoverLegacyPositionToPlacement } = unlock(
  external_wp_components_namespaceObject.privateApis
);
const DEFAULT_PLACEMENT = "bottom";
const URLPopover = (0,external_wp_element_namespaceObject.forwardRef)(
  ({
    additionalControls,
    children,
    renderSettings,
    // The DEFAULT_PLACEMENT value is assigned inside the function's body
    placement,
    focusOnMount = "firstElement",
    // Deprecated
    position,
    // Rest
    ...popoverProps
  }, ref) => {
    if (position !== void 0) {
      external_wp_deprecated_default()("`position` prop in wp.blockEditor.URLPopover", {
        since: "6.2",
        alternative: "`placement` prop"
      });
    }
    let computedPlacement;
    if (placement !== void 0) {
      computedPlacement = placement;
    } else if (position !== void 0) {
      computedPlacement = __experimentalPopoverLegacyPositionToPlacement(position);
    }
    computedPlacement = computedPlacement || DEFAULT_PLACEMENT;
    const [isSettingsExpanded, setIsSettingsExpanded] = (0,external_wp_element_namespaceObject.useState)(false);
    const showSettings = !!renderSettings && isSettingsExpanded;
    const toggleSettingsVisibility = () => {
      setIsSettingsExpanded(!isSettingsExpanded);
    };
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.Popover,
      {
        ref,
        role: "dialog",
        "aria-modal": "true",
        "aria-label": (0,external_wp_i18n_namespaceObject.__)("Edit URL"),
        className: "block-editor-url-popover",
        focusOnMount,
        placement: computedPlacement,
        shift: true,
        variant: "toolbar",
        ...popoverProps,
        children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-url-popover__input-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-url-popover__row", children: [
            children,
            !!renderSettings && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.Button,
              {
                className: "block-editor-url-popover__settings-toggle",
                icon: chevron_down_default,
                label: (0,external_wp_i18n_namespaceObject.__)("Link settings"),
                onClick: toggleSettingsVisibility,
                "aria-expanded": isSettingsExpanded,
                size: "compact"
              }
            )
          ] }) }),
          showSettings && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-url-popover__settings", children: renderSettings() }),
          additionalControls && !showSettings && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-url-popover__additional-controls", children: additionalControls })
        ]
      }
    );
  }
);
URLPopover.LinkEditor = LinkEditor;
URLPopover.LinkViewer = LinkViewer;
var url_popover_default = URLPopover;


;// ./node_modules/@wordpress/block-editor/build-module/components/media-placeholder/index.js













const media_placeholder_noop = () => {
};
const InsertFromURLPopover = ({
  src,
  onChange,
  onSubmit,
  onClose,
  popoverAnchor
}) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(url_popover_default, { anchor: popoverAnchor, onClose, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  "form",
  {
    className: "block-editor-media-placeholder__url-input-form",
    onSubmit,
    children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.__experimentalInputControl,
      {
        __next40pxDefaultSize: true,
        label: (0,external_wp_i18n_namespaceObject.__)("URL"),
        type: "text",
        hideLabelFromVision: true,
        placeholder: (0,external_wp_i18n_namespaceObject.__)("Paste or type URL"),
        onChange,
        value: src,
        suffix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            size: "small",
            icon: keyboard_return_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Apply"),
            type: "submit"
          }
        ) })
      }
    )
  }
) });
const URLSelectionUI = ({ src, onChangeSrc, onSelectURL }) => {
  const [popoverAnchor, setPopoverAnchor] = (0,external_wp_element_namespaceObject.useState)(null);
  const [isURLInputVisible, setIsURLInputVisible] = (0,external_wp_element_namespaceObject.useState)(false);
  const openURLInput = () => {
    setIsURLInputVisible(true);
  };
  const closeURLInput = () => {
    setIsURLInputVisible(false);
    popoverAnchor?.focus();
  };
  const onSubmitSrc = (event) => {
    event.preventDefault();
    if (src && onSelectURL) {
      onSelectURL(src);
      closeURLInput();
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-media-placeholder__url-input-container", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        className: "block-editor-media-placeholder__button",
        onClick: openURLInput,
        isPressed: isURLInputVisible,
        variant: "secondary",
        "aria-haspopup": "dialog",
        ref: setPopoverAnchor,
        children: (0,external_wp_i18n_namespaceObject.__)("Insert from URL")
      }
    ),
    isURLInputVisible && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      InsertFromURLPopover,
      {
        src,
        onChange: onChangeSrc,
        onSubmit: onSubmitSrc,
        onClose: closeURLInput,
        popoverAnchor
      }
    )
  ] });
};
function MediaPlaceholder({
  value = {},
  allowedTypes,
  className,
  icon,
  labels = {},
  mediaPreview,
  notices,
  isAppender,
  accept,
  addToGallery,
  multiple = false,
  handleUpload = true,
  disableDropZone,
  disableMediaButtons,
  onError,
  onSelect,
  onCancel,
  onSelectURL,
  onToggleFeaturedImage,
  onDoubleClick,
  onFilesPreUpload = media_placeholder_noop,
  onHTMLDrop: deprecatedOnHTMLDrop,
  children,
  mediaLibraryButton,
  placeholder,
  style
}) {
  if (deprecatedOnHTMLDrop) {
    external_wp_deprecated_default()("wp.blockEditor.MediaPlaceholder onHTMLDrop prop", {
      since: "6.2",
      version: "6.4"
    });
  }
  const mediaUpload = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getSettings } = select(store);
    return getSettings().mediaUpload;
  }, []);
  const [src, setSrc] = (0,external_wp_element_namespaceObject.useState)("");
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setSrc(value?.src ?? "");
  }, [value?.src]);
  const onlyAllowsImages = () => {
    if (!allowedTypes || allowedTypes.length === 0) {
      return false;
    }
    return allowedTypes.every(
      (allowedType) => allowedType === "image" || allowedType.startsWith("image/")
    );
  };
  const onFilesUpload = (files) => {
    if (!handleUpload || typeof handleUpload === "function" && !handleUpload(files)) {
      return onSelect(files);
    }
    onFilesPreUpload(files);
    let setMedia;
    if (multiple) {
      if (addToGallery) {
        let lastMediaPassed = [];
        setMedia = (newMedia) => {
          const filteredMedia = (value ?? []).filter((item) => {
            if (item.id) {
              return !lastMediaPassed.some(
                // Be sure to convert to number for comparison.
                ({ id }) => Number(id) === Number(item.id)
              );
            }
            return !lastMediaPassed.some(
              ({ urlSlug }) => item.url.includes(urlSlug)
            );
          });
          onSelect(filteredMedia.concat(newMedia));
          lastMediaPassed = newMedia.map((media) => {
            const cutOffIndex = media.url.lastIndexOf(".");
            const urlSlug = media.url.slice(0, cutOffIndex);
            return { id: media.id, urlSlug };
          });
        };
      } else {
        setMedia = onSelect;
      }
    } else {
      setMedia = ([media]) => onSelect(media);
    }
    mediaUpload({
      allowedTypes,
      filesList: files,
      onFileChange: setMedia,
      onError,
      multiple
    });
  };
  async function handleBlocksDrop(event) {
    const { blocks } = parseDropEvent(event);
    if (!blocks?.length) {
      return;
    }
    const uploadedMediaList = await Promise.all(
      blocks.map((block) => {
        const blockType = block.name.split("/")[1];
        if (block.attributes.id) {
          block.attributes.type = blockType;
          return block.attributes;
        }
        return new Promise((resolve, reject) => {
          window.fetch(block.attributes.url).then((response) => response.blob()).then(
            (blob) => mediaUpload({
              filesList: [blob],
              additionalData: {
                title: block.attributes.title,
                alt_text: block.attributes.alt,
                caption: block.attributes.caption,
                type: blockType
              },
              onFileChange: ([media]) => {
                if (media.id) {
                  resolve(media);
                }
              },
              allowedTypes,
              onError: reject
            })
          ).catch(() => resolve(block.attributes.url));
        });
      })
    ).catch((err) => onError(err));
    if (!uploadedMediaList?.length) {
      return;
    }
    onSelect(multiple ? uploadedMediaList : uploadedMediaList[0]);
  }
  const onUpload = (event) => {
    onFilesUpload(event.target.files);
  };
  const defaultRenderPlaceholder = (content) => {
    let { instructions, title } = labels;
    if (!mediaUpload && !onSelectURL) {
      instructions = (0,external_wp_i18n_namespaceObject.__)(
        "To edit this block, you need permission to upload media."
      );
    }
    if (instructions === void 0 || title === void 0) {
      const typesAllowed = allowedTypes ?? [];
      const [firstAllowedType] = typesAllowed;
      const isOneType = 1 === typesAllowed.length;
      const isAudio = isOneType && "audio" === firstAllowedType;
      const isImage = isOneType && "image" === firstAllowedType;
      const isVideo = isOneType && "video" === firstAllowedType;
      if (instructions === void 0 && mediaUpload) {
        instructions = (0,external_wp_i18n_namespaceObject.__)(
          "Drag and drop an image or video, upload, or choose from your library."
        );
        if (isAudio) {
          instructions = (0,external_wp_i18n_namespaceObject.__)(
            "Drag and drop an audio file, upload, or choose from your library."
          );
        } else if (isImage) {
          instructions = (0,external_wp_i18n_namespaceObject.__)(
            "Drag and drop an image, upload, or choose from your library."
          );
        } else if (isVideo) {
          instructions = (0,external_wp_i18n_namespaceObject.__)(
            "Drag and drop a video, upload, or choose from your library."
          );
        }
      }
      if (title === void 0) {
        title = (0,external_wp_i18n_namespaceObject.__)("Media");
        if (isAudio) {
          title = (0,external_wp_i18n_namespaceObject.__)("Audio");
        } else if (isImage) {
          title = (0,external_wp_i18n_namespaceObject.__)("Image");
        } else if (isVideo) {
          title = (0,external_wp_i18n_namespaceObject.__)("Video");
        }
      }
    }
    const placeholderClassName = dist_clsx(
      "block-editor-media-placeholder",
      className,
      {
        "is-appender": isAppender
      }
    );
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
      external_wp_components_namespaceObject.Placeholder,
      {
        icon,
        label: title,
        instructions,
        className: placeholderClassName,
        notices,
        onDoubleClick,
        preview: mediaPreview,
        style,
        children: [
          content,
          children
        ]
      }
    );
  };
  const renderPlaceholder = placeholder ?? defaultRenderPlaceholder;
  const renderDropZone = () => {
    if (disableDropZone) {
      return null;
    }
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.DropZone,
      {
        onFilesDrop: onFilesUpload,
        onDrop: handleBlocksDrop,
        isEligible: (dataTransfer) => {
          const prefix = "wp-block:core/";
          const types = [];
          for (const type of dataTransfer.types) {
            if (type.startsWith(prefix)) {
              types.push(type.slice(prefix.length));
            }
          }
          return types.every(
            (type) => allowedTypes.includes(type)
          ) && (multiple ? true : types.length === 1);
        }
      }
    );
  };
  const renderCancelLink = () => {
    return onCancel && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        className: "block-editor-media-placeholder__cancel-button",
        title: (0,external_wp_i18n_namespaceObject.__)("Cancel"),
        variant: "link",
        onClick: onCancel,
        children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
      }
    );
  };
  const renderUrlSelectionUI = () => {
    return onSelectURL && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      URLSelectionUI,
      {
        src,
        onChangeSrc: setSrc,
        onSelectURL
      }
    );
  };
  const renderFeaturedImageToggle = () => {
    return onToggleFeaturedImage && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-media-placeholder__url-input-container", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        __next40pxDefaultSize: true,
        className: "block-editor-media-placeholder__button",
        onClick: onToggleFeaturedImage,
        variant: "secondary",
        children: (0,external_wp_i18n_namespaceObject.__)("Use featured image")
      }
    ) });
  };
  const renderMediaUploadChecked = () => {
    const defaultButton = ({ open }) => {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          __next40pxDefaultSize: true,
          variant: "secondary",
          onClick: () => {
            open();
          },
          children: (0,external_wp_i18n_namespaceObject.__)("Media Library")
        }
      );
    };
    const libraryButton = mediaLibraryButton ?? defaultButton;
    const uploadMediaLibraryButton = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      media_upload_default,
      {
        addToGallery,
        gallery: multiple && onlyAllowsImages(),
        multiple,
        onSelect,
        allowedTypes,
        mode: "browse",
        value: Array.isArray(value) ? value.map(({ id }) => id) : value.id,
        render: libraryButton
      }
    );
    if (mediaUpload && isAppender) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        renderDropZone(),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.FormFileUpload,
          {
            onChange: onUpload,
            accept,
            multiple: !!multiple,
            render: ({ openFileDialog }) => {
              const content = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
                /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                  external_wp_components_namespaceObject.Button,
                  {
                    __next40pxDefaultSize: true,
                    variant: "primary",
                    className: dist_clsx(
                      "block-editor-media-placeholder__button",
                      "block-editor-media-placeholder__upload-button"
                    ),
                    onClick: openFileDialog,
                    children: (0,external_wp_i18n_namespaceObject._x)("Upload", "verb")
                  }
                ),
                uploadMediaLibraryButton,
                renderUrlSelectionUI(),
                renderFeaturedImageToggle(),
                renderCancelLink()
              ] });
              return renderPlaceholder(content);
            }
          }
        )
      ] });
    }
    if (mediaUpload) {
      const content = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        renderDropZone(),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.FormFileUpload,
          {
            render: ({ openFileDialog }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
              external_wp_components_namespaceObject.Button,
              {
                __next40pxDefaultSize: true,
                onClick: openFileDialog,
                variant: "primary",
                className: dist_clsx(
                  "block-editor-media-placeholder__button",
                  "block-editor-media-placeholder__upload-button"
                ),
                children: (0,external_wp_i18n_namespaceObject._x)("Upload", "verb")
              }
            ),
            onChange: onUpload,
            accept,
            multiple: !!multiple
          }
        ),
        uploadMediaLibraryButton,
        renderUrlSelectionUI(),
        renderFeaturedImageToggle(),
        renderCancelLink()
      ] });
      return renderPlaceholder(content);
    }
    return renderPlaceholder(uploadMediaLibraryButton);
  };
  if (disableMediaButtons) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(check_default, { children: renderDropZone() });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    check_default,
    {
      fallback: renderPlaceholder(renderUrlSelectionUI()),
      children: renderMediaUploadChecked()
    }
  );
}
var media_placeholder_default = (0,external_wp_components_namespaceObject.withFilters)("editor.MediaPlaceholder")(MediaPlaceholder);


;// ./node_modules/@wordpress/block-editor/build-module/components/panel-color-settings/index.js


const PanelColorSettings = ({ colorSettings, ...props }) => {
  const settings = colorSettings.map((setting) => {
    if (!setting) {
      return setting;
    }
    const { value, onChange, ...otherSettings } = setting;
    return {
      ...otherSettings,
      colorValue: value,
      onColorChange: onChange
    };
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    panel_color_gradient_settings_default,
    {
      settings,
      gradients: [],
      disableCustomGradients: true,
      ...props
    }
  );
};
var panel_color_settings_default = PanelColorSettings;


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar/index.js






const format_toolbar_POPOVER_PROPS = {
  placement: "bottom-start"
};
const FormatToolbar = () => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    ["bold", "italic", "link", "unknown"].map((format) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Slot,
      {
        name: `RichText.ToolbarControls.${format}`
      },
      format
    )),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Slot, { name: "RichText.ToolbarControls", children: (fills) => {
      if (!fills.length) {
        return null;
      }
      const allProps = fills.map(([{ props }]) => props);
      const hasActive = allProps.some(
        ({ isActive }) => isActive
      );
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarItem, { children: (toggleProps) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.DropdownMenu,
        {
          icon: chevron_down_default,
          label: (0,external_wp_i18n_namespaceObject.__)("More"),
          toggleProps: {
            ...toggleProps,
            className: dist_clsx(
              toggleProps.className,
              { "is-pressed": hasActive }
            ),
            description: (0,external_wp_i18n_namespaceObject.__)(
              "Displays more block tools"
            )
          },
          controls: orderBy(
            fills.map(([{ props }]) => props),
            "title"
          ),
          popoverProps: format_toolbar_POPOVER_PROPS
        }
      ) });
    } })
  ] });
};
var format_toolbar_default = FormatToolbar;


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-toolbar-container.js






function InlineToolbar({ popoverAnchor }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Popover,
    {
      placement: "top",
      focusOnMount: false,
      anchor: popoverAnchor,
      className: "block-editor-rich-text__inline-format-toolbar",
      __unstableSlotName: "block-toolbar",
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        NavigableToolbar,
        {
          className: "block-editor-rich-text__inline-format-toolbar-group",
          "aria-label": (0,external_wp_i18n_namespaceObject.__)("Format tools"),
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarGroup, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(format_toolbar_default, {}) })
        }
      )
    }
  );
}
const FormatToolbarContainer = ({ inline, editableContentElement }) => {
  if (inline) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(InlineToolbar, { popoverAnchor: editableContentElement });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_controls_default, { group: "inline", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(format_toolbar_default, {}) });
};
var format_toolbar_container_default = FormatToolbarContainer;


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-mark-persistent.js



function useMarkPersistent({ html, value }) {
  const previousTextRef = (0,external_wp_element_namespaceObject.useRef)();
  const hasActiveFormats = !!value.activeFormats?.length;
  const { __unstableMarkLastChangeAsPersistent } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  (0,external_wp_element_namespaceObject.useLayoutEffect)(() => {
    if (!previousTextRef.current) {
      previousTextRef.current = value.text;
      return;
    }
    if (previousTextRef.current !== value.text) {
      const timeout = window.setTimeout(() => {
        __unstableMarkLastChangeAsPersistent();
      }, 1e3);
      previousTextRef.current = value.text;
      return () => {
        window.clearTimeout(timeout);
      };
    }
    __unstableMarkLastChangeAsPersistent();
  }, [html, hasActiveFormats]);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/use-format-types.js



function formatTypesSelector(select) {
  return select(external_wp_richText_namespaceObject.store).getFormatTypes();
}
const interactiveContentTags = /* @__PURE__ */ new Set([
  "a",
  "audio",
  "button",
  "details",
  "embed",
  "iframe",
  "input",
  "label",
  "select",
  "textarea",
  "video"
]);
function prefixSelectKeys(selected, prefix) {
  if (typeof selected !== "object") {
    return { [prefix]: selected };
  }
  return Object.fromEntries(
    Object.entries(selected).map(([key, value]) => [
      `${prefix}.${key}`,
      value
    ])
  );
}
function getPrefixedSelectKeys(selected, prefix) {
  if (selected[prefix]) {
    return selected[prefix];
  }
  return Object.keys(selected).filter((key) => key.startsWith(prefix + ".")).reduce((accumulator, key) => {
    accumulator[key.slice(prefix.length + 1)] = selected[key];
    return accumulator;
  }, {});
}
function useFormatTypes({
  clientId,
  identifier,
  withoutInteractiveFormatting,
  allowedFormats
}) {
  const allFormatTypes = (0,external_wp_data_namespaceObject.useSelect)(formatTypesSelector, []);
  const formatTypes = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return allFormatTypes.filter(({ name, interactive, tagName }) => {
      if (allowedFormats && !allowedFormats.includes(name)) {
        return false;
      }
      if (withoutInteractiveFormatting && (interactive || interactiveContentTags.has(tagName))) {
        return false;
      }
      return true;
    });
  }, [allFormatTypes, allowedFormats, withoutInteractiveFormatting]);
  const keyedSelected = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => formatTypes.reduce((accumulator, type) => {
      if (!type.__experimentalGetPropsForEditableTreePreparation) {
        return accumulator;
      }
      return {
        ...accumulator,
        ...prefixSelectKeys(
          type.__experimentalGetPropsForEditableTreePreparation(
            select,
            {
              richTextIdentifier: identifier,
              blockClientId: clientId
            }
          ),
          type.name
        )
      };
    }, {}),
    [formatTypes, clientId, identifier]
  );
  const dispatch = (0,external_wp_data_namespaceObject.useDispatch)();
  const prepareHandlers = [];
  const valueHandlers = [];
  const changeHandlers = [];
  const dependencies = [];
  for (const key in keyedSelected) {
    dependencies.push(keyedSelected[key]);
  }
  formatTypes.forEach((type) => {
    if (type.__experimentalCreatePrepareEditableTree) {
      const handler = type.__experimentalCreatePrepareEditableTree(
        getPrefixedSelectKeys(keyedSelected, type.name),
        {
          richTextIdentifier: identifier,
          blockClientId: clientId
        }
      );
      if (type.__experimentalCreateOnChangeEditableValue) {
        valueHandlers.push(handler);
      } else {
        prepareHandlers.push(handler);
      }
    }
    if (type.__experimentalCreateOnChangeEditableValue) {
      let dispatchers = {};
      if (type.__experimentalGetPropsForEditableTreeChangeHandler) {
        dispatchers = type.__experimentalGetPropsForEditableTreeChangeHandler(
          dispatch,
          {
            richTextIdentifier: identifier,
            blockClientId: clientId
          }
        );
      }
      const selected = getPrefixedSelectKeys(keyedSelected, type.name);
      changeHandlers.push(
        type.__experimentalCreateOnChangeEditableValue(
          {
            ...typeof selected === "object" ? selected : {},
            ...dispatchers
          },
          {
            richTextIdentifier: identifier,
            blockClientId: clientId
          }
        )
      );
    }
  });
  return {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  };
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/before-input-rules.js



const wrapSelectionSettings = ["`", '"', "'", "\u201C\u201D", "\u2018\u2019"];
var before_input_rules_default = (props) => (element) => {
  function onInput(event) {
    const { inputType, data } = event;
    const { value, onChange, registry } = props.current;
    if (inputType !== "insertText") {
      return;
    }
    if ((0,external_wp_richText_namespaceObject.isCollapsed)(value)) {
      return;
    }
    const pair = (0,external_wp_hooks_namespaceObject.applyFilters)(
      "blockEditor.wrapSelectionSettings",
      wrapSelectionSettings
    ).find(
      ([startChar2, endChar2]) => startChar2 === data || endChar2 === data
    );
    if (!pair) {
      return;
    }
    const [startChar, endChar = startChar] = pair;
    const start = value.start;
    const end = value.end + startChar.length;
    let newValue = (0,external_wp_richText_namespaceObject.insert)(value, startChar, start, start);
    newValue = (0,external_wp_richText_namespaceObject.insert)(newValue, endChar, end, end);
    const {
      __unstableMarkLastChangeAsPersistent,
      __unstableMarkAutomaticChange
    } = registry.dispatch(store);
    __unstableMarkLastChangeAsPersistent();
    onChange(newValue);
    __unstableMarkAutomaticChange();
    const init = {};
    for (const key in event) {
      init[key] = event[key];
    }
    init.data = endChar;
    const { ownerDocument } = element;
    const { defaultView } = ownerDocument;
    const newEvent = new defaultView.InputEvent("input", init);
    window.queueMicrotask(() => {
      event.target.dispatchEvent(newEvent);
    });
    event.preventDefault();
  }
  element.addEventListener("beforeinput", onInput);
  return () => {
    element.removeEventListener("beforeinput", onInput);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/prevent-event-discovery.js

function preventEventDiscovery(value) {
  const searchText = "tales of gutenberg";
  const addText = " \u{1F421}\u{1F422}\u{1F980}\u{1F424}\u{1F98B}\u{1F418}\u{1F427}\u{1F439}\u{1F981}\u{1F984}\u{1F98D}\u{1F43C}\u{1F43F}\u{1F383}\u{1F434}\u{1F41D}\u{1F406}\u{1F995}\u{1F994}\u{1F331}\u{1F347}\u03C0\u{1F34C}\u{1F409}\u{1F4A7}\u{1F968}\u{1F30C}\u{1F342}\u{1F360}\u{1F966}\u{1F95A}\u{1F95D}\u{1F39F}\u{1F965}\u{1F952}\u{1F6F5}\u{1F956}\u{1F352}\u{1F36F}\u{1F3BE}\u{1F3B2}\u{1F43A}\u{1F41A}\u{1F42E}\u231B\uFE0F";
  const { start, text } = value;
  if (start < searchText.length) {
    return value;
  }
  const charactersBefore = text.slice(start - searchText.length, start);
  if (charactersBefore.toLowerCase() !== searchText) {
    return value;
  }
  return (0,external_wp_richText_namespaceObject.insert)(value, addText);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/input-rules.js





function findSelection(blocks) {
  let i = blocks.length;
  while (i--) {
    const attributeKey = retrieveSelectedAttribute(
      blocks[i].attributes
    );
    if (attributeKey) {
      blocks[i].attributes[attributeKey] = blocks[i].attributes[attributeKey].toString().replace(START_OF_SELECTED_AREA, "");
      return [blocks[i].clientId, attributeKey, 0, 0];
    }
    const nestedSelection = findSelection(blocks[i].innerBlocks);
    if (nestedSelection) {
      return nestedSelection;
    }
  }
  return [];
}
var input_rules_default = (props) => (element) => {
  function inputRule() {
    const { getValue, onReplace, selectionChange, registry } = props.current;
    if (!onReplace) {
      return;
    }
    const value = getValue();
    const { start, text } = value;
    const characterBefore = text.slice(start - 1, start);
    if (characterBefore !== " ") {
      return;
    }
    const trimmedTextBefore = text.slice(0, start).trim();
    const prefixTransforms = (0,external_wp_blocks_namespaceObject.getBlockTransforms)("from").filter(
      ({ type }) => type === "prefix"
    );
    const transformation = (0,external_wp_blocks_namespaceObject.findTransform)(
      prefixTransforms,
      ({ prefix }) => {
        return trimmedTextBefore === prefix;
      }
    );
    if (!transformation) {
      return;
    }
    const content = (0,external_wp_richText_namespaceObject.toHTMLString)({
      value: (0,external_wp_richText_namespaceObject.insert)(value, START_OF_SELECTED_AREA, 0, start)
    });
    const block = transformation.transform(content);
    selectionChange(...findSelection([block]));
    onReplace([block]);
    registry.dispatch(store).__unstableMarkAutomaticChange();
    return true;
  }
  function onInput(event) {
    const { inputType, type } = event;
    const {
      getValue,
      onChange,
      __unstableAllowPrefixTransformations,
      formatTypes,
      registry
    } = props.current;
    if (inputType !== "insertText" && type !== "compositionend") {
      return;
    }
    if (__unstableAllowPrefixTransformations && inputRule()) {
      return;
    }
    const value = getValue();
    const transformed = formatTypes.reduce(
      (accumulator, { __unstableInputRule }) => {
        if (__unstableInputRule) {
          accumulator = __unstableInputRule(accumulator);
        }
        return accumulator;
      },
      preventEventDiscovery(value)
    );
    const {
      __unstableMarkLastChangeAsPersistent,
      __unstableMarkAutomaticChange
    } = registry.dispatch(store);
    if (transformed !== value) {
      __unstableMarkLastChangeAsPersistent();
      onChange({
        ...transformed,
        activeFormats: value.activeFormats
      });
      __unstableMarkAutomaticChange();
    }
  }
  element.addEventListener("input", onInput);
  element.addEventListener("compositionend", onInput);
  return () => {
    element.removeEventListener("input", onInput);
    element.removeEventListener("compositionend", onInput);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/insert-replacement-text.js

var insert_replacement_text_default = (props) => (element) => {
  function onInput(event) {
    if (event.inputType !== "insertReplacementText") {
      return;
    }
    const { registry } = props.current;
    registry.dispatch(store).__unstableMarkLastChangeAsPersistent();
  }
  element.addEventListener("beforeinput", onInput);
  return () => {
    element.removeEventListener("beforeinput", onInput);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/remove-browser-shortcuts.js

var remove_browser_shortcuts_default = () => (node) => {
  function onKeydown(event) {
    if (external_wp_keycodes_namespaceObject.isKeyboardEvent.primary(event, "z") || external_wp_keycodes_namespaceObject.isKeyboardEvent.primary(event, "y") || external_wp_keycodes_namespaceObject.isKeyboardEvent.primaryShift(event, "z")) {
      event.preventDefault();
    }
  }
  node.addEventListener("keydown", onKeydown);
  return () => {
    node.removeEventListener("keydown", onKeydown);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/shortcuts.js
var shortcuts_default = (props) => (element) => {
  const { keyboardShortcuts } = props.current;
  function onKeyDown(event) {
    for (const keyboardShortcut of keyboardShortcuts.current) {
      keyboardShortcut(event);
    }
  }
  element.addEventListener("keydown", onKeyDown);
  return () => {
    element.removeEventListener("keydown", onKeyDown);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/input-events.js
var input_events_default = (props) => (element) => {
  const { inputEvents } = props.current;
  function onInput(event) {
    for (const keyboardShortcut of inputEvents.current) {
      keyboardShortcut(event);
    }
  }
  element.addEventListener("input", onInput);
  return () => {
    element.removeEventListener("input", onInput);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/undo-automatic-change.js


var undo_automatic_change_default = (props) => (element) => {
  function onKeyDown(event) {
    const { keyCode } = event;
    if (event.defaultPrevented) {
      return;
    }
    if (keyCode !== external_wp_keycodes_namespaceObject.BACKSPACE && keyCode !== external_wp_keycodes_namespaceObject.ESCAPE) {
      return;
    }
    const { registry } = props.current;
    const { didAutomaticChange, getSettings } = registry.select(store);
    const { __experimentalUndo } = getSettings();
    if (!__experimentalUndo) {
      return;
    }
    if (!didAutomaticChange()) {
      return;
    }
    event.preventDefault();
    __experimentalUndo();
  }
  element.addEventListener("keydown", onKeyDown);
  return () => {
    element.removeEventListener("keydown", onKeyDown);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/utils.js



function addActiveFormats(value, activeFormats) {
  if (activeFormats?.length) {
    let index = value.formats.length;
    while (index--) {
      value.formats[index] = [
        ...activeFormats,
        ...value.formats[index] || []
      ];
    }
  }
}
function getMultilineTag(multiline) {
  if (multiline !== true && multiline !== "p" && multiline !== "li") {
    return;
  }
  return multiline === true ? "p" : multiline;
}
function getAllowedFormats({ allowedFormats, disableFormats }) {
  if (disableFormats) {
    return getAllowedFormats.EMPTY_ARRAY;
  }
  return allowedFormats;
}
getAllowedFormats.EMPTY_ARRAY = [];
function createLinkInParagraph(url, onReplace) {
  const link = /* @__PURE__ */ jsx("a", { href: url, children: url });
  onReplace(
    createBlock("core/paragraph", { content: renderToString(link) })
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/paste-handler.js





var paste_handler_default = (props) => (element) => {
  function _onPaste(event) {
    const {
      disableFormats,
      onChange,
      value,
      formatTypes,
      tagName,
      onReplace,
      __unstableEmbedURLOnPaste,
      preserveWhiteSpace,
      pastePlainText
    } = props.current;
    if (!element.contains(event.target)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const { plainText, html } = getPasteEventData(event);
    event.preventDefault();
    window.console.log("Received HTML:\n\n", html);
    window.console.log("Received plain text:\n\n", plainText);
    if (disableFormats) {
      onChange((0,external_wp_richText_namespaceObject.insert)(value, plainText));
      return;
    }
    const isInternal = event.clipboardData.getData("rich-text") === "true";
    function pasteInline(content2) {
      const transformed = formatTypes.reduce(
        (accumulator, { __unstablePasteRule }) => {
          if (__unstablePasteRule && accumulator === value) {
            accumulator = __unstablePasteRule(value, {
              html,
              plainText
            });
          }
          return accumulator;
        },
        value
      );
      if (transformed !== value) {
        onChange(transformed);
      } else {
        const valueToInsert = (0,external_wp_richText_namespaceObject.create)({ html: content2 });
        addActiveFormats(valueToInsert, value.activeFormats);
        onChange((0,external_wp_richText_namespaceObject.insert)(value, valueToInsert));
      }
    }
    if (isInternal) {
      pasteInline(html);
      return;
    }
    if (pastePlainText) {
      onChange((0,external_wp_richText_namespaceObject.insert)(value, (0,external_wp_richText_namespaceObject.create)({ text: plainText })));
      return;
    }
    let mode = "INLINE";
    const trimmedPlainText = plainText.trim();
    if (__unstableEmbedURLOnPaste && (0,external_wp_richText_namespaceObject.isEmpty)(value) && (0,external_wp_url_namespaceObject.isURL)(trimmedPlainText) && // For the link pasting feature, allow only http(s) protocols.
    /^https?:/.test(trimmedPlainText)) {
      mode = "BLOCKS";
    }
    const content = (0,external_wp_blocks_namespaceObject.pasteHandler)({
      HTML: html,
      plainText,
      mode,
      tagName,
      preserveWhiteSpace
    });
    if (typeof content === "string") {
      pasteInline(content);
    } else if (content.length > 0) {
      if (onReplace && (0,external_wp_richText_namespaceObject.isEmpty)(value)) {
        onReplace(content, content.length - 1, -1);
      }
    }
  }
  const { defaultView } = element.ownerDocument;
  defaultView.addEventListener("paste", _onPaste);
  return () => {
    defaultView.removeEventListener("paste", _onPaste);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/delete.js


var delete_default = (props) => (element) => {
  function onKeyDown(event) {
    const { keyCode } = event;
    if (event.defaultPrevented) {
      return;
    }
    const { value, onMerge, onRemove } = props.current;
    if (keyCode === external_wp_keycodes_namespaceObject.DELETE || keyCode === external_wp_keycodes_namespaceObject.BACKSPACE) {
      const { start, end, text } = value;
      const isReverse = keyCode === external_wp_keycodes_namespaceObject.BACKSPACE;
      const hasActiveFormats = value.activeFormats && !!value.activeFormats.length;
      if (!(0,external_wp_richText_namespaceObject.isCollapsed)(value) || hasActiveFormats || isReverse && start !== 0 || !isReverse && end !== text.length) {
        return;
      }
      if (onMerge) {
        onMerge(!isReverse);
      } else if (onRemove && (0,external_wp_richText_namespaceObject.isEmpty)(value) && isReverse) {
        onRemove(!isReverse);
      }
      event.preventDefault();
    }
  }
  element.addEventListener("keydown", onKeyDown);
  return () => {
    element.removeEventListener("keydown", onKeyDown);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/enter.js


var enter_default = (props) => (element) => {
  function onKeyDownDeprecated(event) {
    if (event.keyCode !== external_wp_keycodes_namespaceObject.ENTER) {
      return;
    }
    const { onReplace, onSplit } = props.current;
    if (onReplace && onSplit) {
      event.__deprecatedOnSplit = true;
    }
  }
  function onKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }
    if (event.target !== element) {
      return;
    }
    if (event.keyCode !== external_wp_keycodes_namespaceObject.ENTER) {
      return;
    }
    const {
      value,
      onChange,
      disableLineBreaks,
      onSplitAtEnd,
      onSplitAtDoubleLineEnd,
      registry
    } = props.current;
    event.preventDefault();
    const { text, start, end } = value;
    if (event.shiftKey) {
      if (!disableLineBreaks) {
        onChange((0,external_wp_richText_namespaceObject.insert)(value, "\n"));
      }
    } else if (onSplitAtEnd && start === end && end === text.length) {
      onSplitAtEnd();
    } else if (
      // For some blocks it's desirable to split at the end of the
      // block when there are two line breaks at the end of the
      // block, so triple Enter exits the block.
      onSplitAtDoubleLineEnd && start === end && end === text.length && text.slice(-2) === "\n\n"
    ) {
      registry.batch(() => {
        const _value = { ...value };
        _value.start = _value.end - 2;
        onChange((0,external_wp_richText_namespaceObject.remove)(_value));
        onSplitAtDoubleLineEnd();
      });
    } else if (!disableLineBreaks) {
      onChange((0,external_wp_richText_namespaceObject.insert)(value, "\n"));
    }
  }
  const { defaultView } = element.ownerDocument;
  defaultView.addEventListener("keydown", onKeyDown);
  element.addEventListener("keydown", onKeyDownDeprecated);
  return () => {
    defaultView.removeEventListener("keydown", onKeyDown);
    element.removeEventListener("keydown", onKeyDownDeprecated);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/firefox-compat.js

var firefox_compat_default = (props) => (element) => {
  function onFocus() {
    const { registry } = props.current;
    if (!registry.select(store).isMultiSelecting()) {
      return;
    }
    const parentEditable = element.parentElement.closest(
      '[contenteditable="true"]'
    );
    if (parentEditable) {
      parentEditable.focus();
    }
  }
  element.addEventListener("focus", onFocus);
  return () => {
    element.removeEventListener("focus", onFocus);
  };
};


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/event-listeners/index.js













const allEventListeners = [
  before_input_rules_default,
  input_rules_default,
  insert_replacement_text_default,
  remove_browser_shortcuts_default,
  shortcuts_default,
  input_events_default,
  undo_automatic_change_default,
  paste_handler_default,
  delete_default,
  enter_default,
  firefox_compat_default
];
function useEventListeners(props) {
  const propsRef = (0,external_wp_element_namespaceObject.useRef)(props);
  (0,external_wp_element_namespaceObject.useInsertionEffect)(() => {
    propsRef.current = props;
  });
  const refEffects = (0,external_wp_element_namespaceObject.useMemo)(
    () => allEventListeners.map((refEffect) => refEffect(propsRef)),
    [propsRef]
  );
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (element) => {
      if (!props.isSelected) {
        return;
      }
      const cleanups = refEffects.map((effect) => effect(element));
      return () => {
        cleanups.forEach((cleanup) => cleanup());
      };
    },
    [refEffects, props.isSelected]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/format-edit.js





const format_edit_DEFAULT_BLOCK_CONTEXT = {};
const usesContextKey = Symbol("usesContext");
function format_edit_Edit({ onChange, onFocus, value, forwardedRef, settings }) {
  const {
    name,
    edit: EditFunction,
    [usesContextKey]: usesContext
  } = settings;
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context_default);
  const context = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return usesContext ? Object.fromEntries(
      Object.entries(blockContext).filter(
        ([key]) => usesContext.includes(key)
      )
    ) : format_edit_DEFAULT_BLOCK_CONTEXT;
  }, [usesContext, blockContext]);
  if (!EditFunction) {
    return null;
  }
  const activeFormat = (0,external_wp_richText_namespaceObject.getActiveFormat)(value, name);
  const isActive = activeFormat !== void 0;
  const activeObject = (0,external_wp_richText_namespaceObject.getActiveObject)(value);
  const isObjectActive = activeObject !== void 0 && activeObject.type === name;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    EditFunction,
    {
      isActive,
      activeAttributes: isActive ? activeFormat.attributes || {} : {},
      isObjectActive,
      activeObjectAttributes: isObjectActive ? activeObject.attributes || {} : {},
      value,
      onChange,
      onFocus,
      contentRef: forwardedRef,
      context
    },
    name
  );
}
function FormatEdit({ formatTypes, ...props }) {
  return formatTypes.map((settings) => /* @__PURE__ */ (0,external_React_.createElement)(format_edit_Edit, { settings, ...props, key: settings.name }));
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/content.js






function valueToHTMLString(value, multiline) {
  if (rich_text_default.isEmpty(value)) {
    const multilineTag = getMultilineTag(multiline);
    return multilineTag ? `<${multilineTag}></${multilineTag}>` : "";
  }
  if (Array.isArray(value)) {
    external_wp_deprecated_default()("wp.blockEditor.RichText value prop as children type", {
      since: "6.1",
      version: "6.3",
      alternative: "value prop as string",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
    });
    return external_wp_blocks_namespaceObject.children.toHTML(value);
  }
  if (typeof value === "string") {
    return value;
  }
  return value.toHTMLString();
}
function Content({
  value,
  tagName: Tag,
  multiline,
  format,
  ...props
}) {
  value = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_element_namespaceObject.RawHTML, { children: valueToHTMLString(value, multiline) });
  return Tag ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Tag, { ...props, children: value }) : value;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/multiline.js










function RichTextMultiline({
  children,
  identifier,
  tagName: TagName = "div",
  value = "",
  onChange,
  multiline,
  ...props
}, forwardedRef) {
  external_wp_deprecated_default()("wp.blockEditor.RichText multiline prop", {
    since: "6.1",
    version: "6.3",
    alternative: "nested blocks (InnerBlocks)",
    link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/nested-blocks-inner-blocks/"
  });
  const { clientId } = useBlockEditContext();
  const { getSelectionStart, getSelectionEnd } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { selectionChange } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const multilineTagName = getMultilineTag(multiline);
  value = value || `<${multilineTagName}></${multilineTagName}>`;
  const padded = `</${multilineTagName}>${value}<${multilineTagName}>`;
  const values = padded.split(
    `</${multilineTagName}><${multilineTagName}>`
  );
  values.shift();
  values.pop();
  function _onChange(newValues) {
    onChange(
      `<${multilineTagName}>${newValues.join(
        `</${multilineTagName}><${multilineTagName}>`
      )}</${multilineTagName}>`
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(TagName, { ref: forwardedRef, children: values.map((_value, index) => {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      RichTextWrapper,
      {
        identifier: `${identifier}-${index}`,
        tagName: multilineTagName,
        value: _value,
        onChange: (newValue) => {
          const newValues = values.slice();
          newValues[index] = newValue;
          _onChange(newValues);
        },
        isSelected: void 0,
        onKeyDown: (event) => {
          if (event.keyCode !== external_wp_keycodes_namespaceObject.ENTER) {
            return;
          }
          event.preventDefault();
          const { offset: start } = getSelectionStart();
          const { offset: end } = getSelectionEnd();
          if (typeof start !== "number" || typeof end !== "number") {
            return;
          }
          const richTextValue = (0,external_wp_richText_namespaceObject.create)({ html: _value });
          richTextValue.start = start;
          richTextValue.end = end;
          const array = (0,external_wp_richText_namespaceObject.split)(richTextValue).map(
            (v) => (0,external_wp_richText_namespaceObject.toHTMLString)({ value: v })
          );
          const newValues = values.slice();
          newValues.splice(index, 1, ...array);
          _onChange(newValues);
          selectionChange(
            clientId,
            `${identifier}-${index + 1}`,
            0,
            0
          );
        },
        onMerge: (forward) => {
          const newValues = values.slice();
          let offset = 0;
          if (forward) {
            if (!newValues[index + 1]) {
              return;
            }
            newValues.splice(
              index,
              2,
              newValues[index] + newValues[index + 1]
            );
            offset = newValues[index].length - 1;
          } else {
            if (!newValues[index - 1]) {
              return;
            }
            newValues.splice(
              index - 1,
              2,
              newValues[index - 1] + newValues[index]
            );
            offset = newValues[index - 1].length - 1;
          }
          _onChange(newValues);
          selectionChange(
            clientId,
            `${identifier}-${index - (forward ? 0 : 1)}`,
            offset,
            offset
          );
        },
        ...props
      },
      index
    );
  }) });
}
var multiline_default = (0,external_wp_element_namespaceObject.forwardRef)(RichTextMultiline);


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/with-deprecations.js






function withDeprecations(Component) {
  return (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
    let value = props.value;
    let onChange = props.onChange;
    if (Array.isArray(value)) {
      external_wp_deprecated_default()("wp.blockEditor.RichText value prop as children type", {
        since: "6.1",
        version: "6.3",
        alternative: "value prop as string",
        link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
      });
      value = external_wp_blocks_namespaceObject.children.toHTML(props.value);
      onChange = (newValue) => props.onChange(
        external_wp_blocks_namespaceObject.children.fromDOM(
          (0,external_wp_richText_namespaceObject.__unstableCreateElement)(document, newValue).childNodes
        )
      );
    }
    const NewComponent = props.multiline ? multiline_default : Component;
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      NewComponent,
      {
        ...props,
        value,
        onChange,
        ref
      }
    );
  });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/index.js

























const keyboardShortcutContext = (0,external_wp_element_namespaceObject.createContext)();
keyboardShortcutContext.displayName = "keyboardShortcutContext";
const inputEventContext = (0,external_wp_element_namespaceObject.createContext)();
inputEventContext.displayName = "inputEventContext";
const instanceIdKey = Symbol("instanceId");
function removeNativeProps(props) {
  const {
    __unstableMobileNoFocusOnMount,
    deleteEnter,
    placeholderTextColor,
    textAlign,
    selectionColor,
    tagsToEliminate,
    disableEditingMenu,
    fontSize,
    fontFamily,
    fontWeight,
    fontStyle,
    minWidth,
    maxWidth,
    disableSuggestions,
    disableAutocorrection,
    ...restProps
  } = props;
  return restProps;
}
function RichTextWrapper({
  children,
  tagName = "div",
  value: adjustedValue = "",
  onChange: adjustedOnChange,
  isSelected: originalIsSelected,
  multiline,
  inlineToolbar,
  wrapperClassName,
  autocompleters,
  onReplace,
  placeholder,
  allowedFormats,
  withoutInteractiveFormatting,
  onRemove,
  onMerge,
  onSplit,
  __unstableOnSplitAtEnd: onSplitAtEnd,
  __unstableOnSplitAtDoubleLineEnd: onSplitAtDoubleLineEnd,
  identifier,
  preserveWhiteSpace,
  __unstablePastePlainText: pastePlainText,
  __unstableEmbedURLOnPaste,
  __unstableDisableFormats: disableFormats,
  disableLineBreaks,
  __unstableAllowPrefixTransformations,
  readOnly,
  ...props
}, forwardedRef) {
  props = removeNativeProps(props);
  if (onSplit) {
    external_wp_deprecated_default()("wp.blockEditor.RichText onSplit prop", {
      since: "6.4",
      alternative: 'block.json support key: "splitting"'
    });
  }
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(RichTextWrapper);
  const anchorRef = (0,external_wp_element_namespaceObject.useRef)();
  const context = useBlockEditContext();
  const { clientId, isSelected: isBlockSelected } = context;
  const blockBindings = context[blockBindingsKey];
  const blockContext = (0,external_wp_element_namespaceObject.useContext)(block_context_default);
  const { bindableAttributes } = (0,external_wp_element_namespaceObject.useContext)(PrivateBlockContext);
  const registry = (0,external_wp_data_namespaceObject.useRegistry)();
  const selector = (select) => {
    if (!isBlockSelected) {
      return { isSelected: false };
    }
    const { getSelectionStart: getSelectionStart2, getSelectionEnd: getSelectionEnd2 } = select(store);
    const selectionStart2 = getSelectionStart2();
    const selectionEnd2 = getSelectionEnd2();
    let isSelected2;
    if (originalIsSelected === void 0) {
      isSelected2 = selectionStart2.clientId === clientId && selectionEnd2.clientId === clientId && (identifier ? selectionStart2.attributeKey === identifier : selectionStart2[instanceIdKey] === instanceId);
    } else if (originalIsSelected) {
      isSelected2 = selectionStart2.clientId === clientId;
    }
    return {
      selectionStart: isSelected2 ? selectionStart2.offset : void 0,
      selectionEnd: isSelected2 ? selectionEnd2.offset : void 0,
      isSelected: isSelected2
    };
  };
  const { selectionStart, selectionEnd, isSelected } = (0,external_wp_data_namespaceObject.useSelect)(selector, [
    clientId,
    identifier,
    instanceId,
    originalIsSelected,
    isBlockSelected
  ]);
  const { disableBoundBlock, bindingsPlaceholder, bindingsLabel } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!blockBindings?.[identifier] || !bindableAttributes) {
        return {};
      }
      const relatedBinding = blockBindings[identifier];
      const blockBindingsSource = (0,external_wp_blocks_namespaceObject.getBlockBindingsSource)(
        relatedBinding.source
      );
      const blockBindingsContext = {};
      if (blockBindingsSource?.usesContext?.length) {
        for (const key of blockBindingsSource.usesContext) {
          blockBindingsContext[key] = blockContext[key];
        }
      }
      const _disableBoundBlock = !blockBindingsSource?.canUserEditValue?.({
        select,
        context: blockBindingsContext,
        args: relatedBinding.args
      });
      if (adjustedValue.length > 0) {
        return {
          disableBoundBlock: _disableBoundBlock,
          // Null values will make them fall back to the default behavior.
          bindingsPlaceholder: null,
          bindingsLabel: null
        };
      }
      const { getBlockAttributes } = select(store);
      const blockAttributes = getBlockAttributes(clientId);
      let clientSideFieldLabel = null;
      if (blockBindingsSource?.getFieldsList) {
        const fieldsItems = blockBindingsSource.getFieldsList({
          select,
          context: blockBindingsContext
        });
        clientSideFieldLabel = fieldsItems?.find(
          (item) => es6_default()(item.args, relatedBinding?.args)
        )?.label;
      }
      const bindingKey = clientSideFieldLabel ?? blockBindingsSource?.label;
      const _bindingsPlaceholder = _disableBoundBlock ? bindingKey : (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: connected field label or source label */
        (0,external_wp_i18n_namespaceObject.__)("Add %s"),
        bindingKey
      );
      const _bindingsLabel = _disableBoundBlock ? relatedBinding?.args?.key || blockBindingsSource?.label : (0,external_wp_i18n_namespaceObject.sprintf)(
        /* translators: %s: source label or key */
        (0,external_wp_i18n_namespaceObject.__)("Empty %s; start writing to edit its value"),
        relatedBinding?.args?.key || blockBindingsSource?.label
      );
      return {
        disableBoundBlock: _disableBoundBlock,
        bindingsPlaceholder: blockAttributes?.placeholder || _bindingsPlaceholder,
        bindingsLabel: _bindingsLabel
      };
    },
    [
      blockBindings,
      identifier,
      bindableAttributes,
      adjustedValue,
      clientId,
      blockContext
    ]
  );
  const isInsidePatternOverrides = !!blockContext?.["pattern/overrides"];
  const hasOverrideEnabled = blockBindings?.__default?.source === "core/pattern-overrides";
  const shouldDisableForPattern = isInsidePatternOverrides && !hasOverrideEnabled;
  const shouldDisableEditing = readOnly || disableBoundBlock || shouldDisableForPattern;
  const { getSelectionStart, getSelectionEnd, getBlockRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(store);
  const { selectionChange } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const adjustedAllowedFormats = getAllowedFormats({
    allowedFormats,
    disableFormats
  });
  const hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
  const onSelectionChange = (0,external_wp_element_namespaceObject.useCallback)(
    (start, end) => {
      const selection = {};
      const unset = start === void 0 && end === void 0;
      const baseSelection = {
        clientId,
        [identifier ? "attributeKey" : instanceIdKey]: identifier ? identifier : instanceId
      };
      if (typeof start === "number" || unset) {
        if (end === void 0 && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionEnd().clientId)) {
          return;
        }
        selection.start = {
          ...baseSelection,
          offset: start
        };
      }
      if (typeof end === "number" || unset) {
        if (start === void 0 && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionStart().clientId)) {
          return;
        }
        selection.end = {
          ...baseSelection,
          offset: end
        };
      }
      selectionChange(selection);
    },
    [
      clientId,
      getBlockRootClientId,
      getSelectionEnd,
      getSelectionStart,
      identifier,
      instanceId,
      selectionChange
    ]
  );
  const {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  } = useFormatTypes({
    clientId,
    identifier,
    withoutInteractiveFormatting,
    allowedFormats: adjustedAllowedFormats
  });
  function addEditorOnlyFormats(value2) {
    return valueHandlers.reduce(
      (accumulator, fn) => fn(accumulator, value2.text),
      value2.formats
    );
  }
  function removeEditorOnlyFormats(value2) {
    formatTypes.forEach((formatType) => {
      if (formatType.__experimentalCreatePrepareEditableTree) {
        value2 = (0,external_wp_richText_namespaceObject.removeFormat)(
          value2,
          formatType.name,
          0,
          value2.text.length
        );
      }
    });
    return value2.formats;
  }
  function addInvisibleFormats(value2) {
    return prepareHandlers.reduce(
      (accumulator, fn) => fn(accumulator, value2.text),
      value2.formats
    );
  }
  const {
    value,
    getValue,
    onChange,
    ref: richTextRef
  } = (0,external_wp_richText_namespaceObject.__unstableUseRichText)({
    value: adjustedValue,
    onChange(html, { __unstableFormats, __unstableText }) {
      adjustedOnChange(html);
      Object.values(changeHandlers).forEach((changeHandler) => {
        changeHandler(__unstableFormats, __unstableText);
      });
    },
    selectionStart,
    selectionEnd,
    onSelectionChange,
    placeholder: bindingsPlaceholder || placeholder,
    __unstableIsSelected: isSelected,
    __unstableDisableFormats: disableFormats,
    preserveWhiteSpace,
    __unstableDependencies: [...dependencies, tagName],
    __unstableAfterParse: addEditorOnlyFormats,
    __unstableBeforeSerialize: removeEditorOnlyFormats,
    __unstableAddInvisibleFormats: addInvisibleFormats
  });
  const autocompleteProps = useBlockEditorAutocompleteProps({
    onReplace,
    completers: autocompleters,
    record: value,
    onChange
  });
  useMarkPersistent({ html: adjustedValue, value });
  const keyboardShortcuts = (0,external_wp_element_namespaceObject.useRef)(/* @__PURE__ */ new Set());
  const inputEvents = (0,external_wp_element_namespaceObject.useRef)(/* @__PURE__ */ new Set());
  function onFocus() {
    anchorRef.current?.focus();
  }
  const TagName = tagName;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    isSelected && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(keyboardShortcutContext.Provider, { value: keyboardShortcuts, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inputEventContext.Provider, { value: inputEvents, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Popover.__unstableSlotNameProvider, { value: "__unstable-block-tools-after", children: [
      children && children({ value, onChange, onFocus }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        FormatEdit,
        {
          value,
          onChange,
          onFocus,
          formatTypes,
          forwardedRef: anchorRef
        }
      )
    ] }) }) }),
    isSelected && hasFormats && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      format_toolbar_container_default,
      {
        inline: inlineToolbar,
        editableContentElement: anchorRef.current
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      TagName,
      {
        role: "textbox",
        "aria-multiline": !disableLineBreaks,
        "aria-readonly": shouldDisableEditing,
        ...props,
        draggable: void 0,
        "aria-label": bindingsLabel || props["aria-label"] || placeholder,
        ...autocompleteProps,
        ref: (0,external_wp_compose_namespaceObject.useMergeRefs)([
          // Rich text ref must be first because its focus listener
          // must be set up before any other ref calls .focus() on
          // mount.
          richTextRef,
          forwardedRef,
          autocompleteProps.ref,
          props.ref,
          useEventListeners({
            registry,
            getValue,
            onChange,
            __unstableAllowPrefixTransformations,
            formatTypes,
            onReplace,
            selectionChange,
            isSelected,
            disableFormats,
            value,
            tagName,
            onSplit,
            __unstableEmbedURLOnPaste,
            pastePlainText,
            onMerge,
            onRemove,
            removeEditorOnlyFormats,
            disableLineBreaks,
            onSplitAtEnd,
            onSplitAtDoubleLineEnd,
            keyboardShortcuts,
            inputEvents
          }),
          anchorRef
        ]),
        contentEditable: !shouldDisableEditing,
        suppressContentEditableWarning: true,
        className: dist_clsx(
          "block-editor-rich-text__editable",
          props.className,
          "rich-text"
        ),
        tabIndex: props.tabIndex === 0 && !shouldDisableEditing ? null : props.tabIndex,
        "data-wp-block-attribute-key": identifier
      }
    )
  ] });
}
const PrivateRichText = withDeprecations(
  (0,external_wp_element_namespaceObject.forwardRef)(RichTextWrapper)
);
PrivateRichText.Content = Content;
PrivateRichText.isEmpty = (value) => {
  return !value || value.length === 0;
};
const PublicForwardedRichTextContainer = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  const context = useBlockEditContext();
  const isPreviewMode = context[isPreviewModeKey];
  if (isPreviewMode) {
    const {
      children,
      tagName: Tag = "div",
      value,
      onChange,
      isSelected,
      multiline,
      inlineToolbar,
      wrapperClassName,
      autocompleters,
      onReplace,
      placeholder,
      allowedFormats,
      withoutInteractiveFormatting,
      onRemove,
      onMerge,
      onSplit,
      __unstableOnSplitAtEnd,
      __unstableOnSplitAtDoubleLineEnd,
      identifier,
      preserveWhiteSpace,
      __unstablePastePlainText,
      __unstableEmbedURLOnPaste,
      __unstableDisableFormats,
      disableLineBreaks,
      __unstableAllowPrefixTransformations,
      readOnly,
      ...contentProps
    } = removeNativeProps(props);
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      Tag,
      {
        ref,
        ...contentProps,
        dangerouslySetInnerHTML: {
          __html: valueToHTMLString(value, multiline)
        }
      }
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PrivateRichText, { ref, ...props, readOnly: false });
});
PublicForwardedRichTextContainer.Content = Content;
PublicForwardedRichTextContainer.isEmpty = (value) => {
  return !value || value.length === 0;
};
var rich_text_default = PublicForwardedRichTextContainer;





;// ./node_modules/@wordpress/block-editor/build-module/components/editable-text/index.js



const EditableText = (0,external_wp_element_namespaceObject.forwardRef)((props, ref) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(rich_text_default, { ref, ...props, __unstableDisableFormats: true });
});
EditableText.Content = ({ value = "", tagName: Tag = "div", ...props }) => {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(Tag, { ...props, children: value });
};
var editable_text_default = EditableText;


;// ./node_modules/@wordpress/block-editor/build-module/components/plain-text/index.js





const PlainText = (0,external_wp_element_namespaceObject.forwardRef)(({ __experimentalVersion, ...props }, ref) => {
  if (__experimentalVersion === 2) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(editable_text_default, { ref, ...props });
  }
  const { className, onChange, ...remainingProps } = props;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    lib/* default */.A,
    {
      ref,
      className: dist_clsx("block-editor-plain-text", className),
      onChange: (event) => onChange(event.target.value),
      ...remainingProps
    }
  );
});
var plain_text_default = PlainText;


;// ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/label.js




function ResponsiveBlockControlLabel({
  property,
  viewport,
  desc
}) {
  const instanceId = (0,external_wp_compose_namespaceObject.useInstanceId)(ResponsiveBlockControlLabel);
  const accessibleLabel = desc || (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: 1: property name. 2: viewport name. */
    (0,external_wp_i18n_namespaceObject._x)(
      "Controls the %1$s property for %2$s viewports.",
      "Text labelling a interface as controlling a given layout property (eg: margin) for a given screen size."
    ),
    property,
    viewport.label
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { "aria-describedby": `rbc-desc-${instanceId}`, children: viewport.label }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.VisuallyHidden, { as: "span", id: `rbc-desc-${instanceId}`, children: accessibleLabel })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/responsive-block-control/index.js






function ResponsiveBlockControl(props) {
  const {
    title,
    property,
    toggleLabel,
    onIsResponsiveChange,
    renderDefaultControl,
    renderResponsiveControls,
    isResponsive = false,
    defaultLabel = {
      id: "all",
      label: (0,external_wp_i18n_namespaceObject._x)("All", "screen sizes")
    },
    viewports = [
      {
        id: "small",
        label: (0,external_wp_i18n_namespaceObject.__)("Small screens")
      },
      {
        id: "medium",
        label: (0,external_wp_i18n_namespaceObject.__)("Medium screens")
      },
      {
        id: "large",
        label: (0,external_wp_i18n_namespaceObject.__)("Large screens")
      }
    ]
  } = props;
  if (!title || !property || !renderDefaultControl) {
    return null;
  }
  const toggleControlLabel = toggleLabel || (0,external_wp_i18n_namespaceObject.sprintf)(
    /* translators: %s: Property value for the control (eg: margin, padding, etc.). */
    (0,external_wp_i18n_namespaceObject.__)("Use the same %s on all screen sizes."),
    property
  );
  const toggleHelpText = (0,external_wp_i18n_namespaceObject.__)(
    "Choose whether to use the same value for all screen sizes or a unique value for each screen size."
  );
  const defaultControl = renderDefaultControl(
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ResponsiveBlockControlLabel,
      {
        property,
        viewport: defaultLabel
      }
    ),
    defaultLabel
  );
  const defaultResponsiveControls = () => {
    return viewports.map((viewport) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_element_namespaceObject.Fragment, { children: renderDefaultControl(
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        ResponsiveBlockControlLabel,
        {
          property,
          viewport
        }
      ),
      viewport
    ) }, viewport.id));
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("fieldset", { className: "block-editor-responsive-block-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("legend", { className: "block-editor-responsive-block-control__title", children: title }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-responsive-block-control__inner", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.ToggleControl,
        {
          __nextHasNoMarginBottom: true,
          className: "block-editor-responsive-block-control__toggle",
          label: toggleControlLabel,
          checked: !isResponsive,
          onChange: onIsResponsiveChange,
          help: toggleHelpText
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
        "div",
        {
          className: dist_clsx(
            "block-editor-responsive-block-control__group",
            {
              "is-responsive": isResponsive
            }
          ),
          children: [
            !isResponsive && defaultControl,
            isResponsive && (renderResponsiveControls ? renderResponsiveControls(viewports) : defaultResponsiveControls())
          ]
        }
      )
    ] })
  ] });
}
var responsive_block_control_default = ResponsiveBlockControl;


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/shortcut.js



function RichTextShortcut({ character, type, onUse }) {
  const keyboardShortcuts = (0,external_wp_element_namespaceObject.useContext)(keyboardShortcutContext);
  const onUseRef = (0,external_wp_element_namespaceObject.useRef)();
  onUseRef.current = onUse;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    function callback(event) {
      if (external_wp_keycodes_namespaceObject.isKeyboardEvent[type](event, character)) {
        onUseRef.current();
        event.preventDefault();
      }
    }
    keyboardShortcuts.current.add(callback);
    return () => {
      keyboardShortcuts.current.delete(callback);
    };
  }, [character, type]);
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/toolbar-button.js



function RichTextToolbarButton({
  name,
  shortcutType,
  shortcutCharacter,
  ...props
}) {
  let shortcut;
  let fillName = "RichText.ToolbarControls";
  if (name) {
    fillName += `.${name}`;
  }
  if (shortcutType && shortcutCharacter) {
    shortcut = external_wp_keycodes_namespaceObject.displayShortcut[shortcutType](shortcutCharacter);
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Fill, { name: fillName, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ToolbarButton, { ...props, shortcut }) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/input-event.js


function __unstableRichTextInputEvent({ inputType, onInput }) {
  const callbacks = (0,external_wp_element_namespaceObject.useContext)(inputEventContext);
  const onInputRef = (0,external_wp_element_namespaceObject.useRef)();
  onInputRef.current = onInput;
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    function callback(event) {
      if (event.inputType === inputType) {
        onInputRef.current();
        event.preventDefault();
      }
    }
    callbacks.current.add(callback);
    return () => {
      callbacks.current.delete(callback);
    };
  }, [inputType]);
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/unit-control/index.js



function UnitControl({ units: unitsProp, ...props }) {
  const [availableUnits] = use_settings_useSettings("spacing.units");
  const units = (0,external_wp_components_namespaceObject.__experimentalUseCustomUnits)({
    availableUnits: availableUnits || ["%", "px", "em", "rem", "vw"],
    units: unitsProp
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalUnitControl, { units, ...props });
}


;// ./node_modules/@wordpress/icons/build-module/library/arrow-left.js


var arrow_left_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M20 11.2H6.8l3.7-3.7-1-1L3.9 12l5.6 5.5 1-1-3.7-3.7H20z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/url-input/button.js






function URLInputButton({ url, onChange }) {
  const [expanded, toggleExpanded] = (0,external_wp_element_namespaceObject.useReducer)(
    (isExpanded) => !isExpanded,
    false
  );
  const submitLink = (event) => {
    event.preventDefault();
    toggleExpanded();
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-url-input__button", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.Button,
      {
        size: "compact",
        icon: link_default,
        label: url ? (0,external_wp_i18n_namespaceObject.__)("Edit link") : (0,external_wp_i18n_namespaceObject.__)("Insert link"),
        onClick: toggleExpanded,
        className: "components-toolbar__control",
        isPressed: !!url
      }
    ),
    expanded && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      "form",
      {
        className: "block-editor-url-input__button-modal",
        onSubmit: submitLink,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-url-input__button-modal-line", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              __next40pxDefaultSize: true,
              className: "block-editor-url-input__back",
              icon: arrow_left_default,
              label: (0,external_wp_i18n_namespaceObject.__)("Close"),
              onClick: toggleExpanded
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            url_input_default,
            {
              value: url || "",
              onChange,
              suffix: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalInputControlSuffixWrapper, { variant: "control", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
                external_wp_components_namespaceObject.Button,
                {
                  size: "small",
                  icon: keyboard_return_default,
                  label: (0,external_wp_i18n_namespaceObject.__)("Submit"),
                  type: "submit"
                }
              ) })
            }
          )
        ] })
      }
    )
  ] });
}
var button_default = URLInputButton;


;// ./node_modules/@wordpress/icons/build-module/library/image.js


var image_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.Path, { d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM5 4.5h14c.3 0 .5.2.5.5v8.4l-3-2.9c-.3-.3-.8-.3-1 0L11.9 14 9 12c-.3-.2-.6-.2-.8 0l-3.6 2.6V5c-.1-.3.1-.5.4-.5zm14 15H5c-.3 0-.5-.2-.5-.5v-2.4l4.1-3 3 1.9c.3.2.7.2.9-.1L16 12l3.5 3.4V19c0 .3-.2.5-.5.5z" }) });


;// ./node_modules/@wordpress/block-editor/build-module/components/url-popover/image-url-input-ui.js








const LINK_DESTINATION_NONE = "none";
const LINK_DESTINATION_CUSTOM = "custom";
const LINK_DESTINATION_MEDIA = "media";
const LINK_DESTINATION_ATTACHMENT = "attachment";
const NEW_TAB_REL = ["noreferrer", "noopener"];
const ImageURLInputUI = ({
  linkDestination,
  onChangeUrl,
  url,
  mediaType = "image",
  mediaUrl,
  mediaLink,
  linkTarget,
  linkClass,
  rel,
  showLightboxSetting,
  lightboxEnabled,
  onSetLightbox,
  resetLightbox
}) => {
  const [isOpen, setIsOpen] = (0,external_wp_element_namespaceObject.useState)(false);
  const [popoverAnchor, setPopoverAnchor] = (0,external_wp_element_namespaceObject.useState)(null);
  const openLinkUI = () => {
    setIsOpen(true);
  };
  const [isEditingLink, setIsEditingLink] = (0,external_wp_element_namespaceObject.useState)(false);
  const [urlInput, setUrlInput] = (0,external_wp_element_namespaceObject.useState)(null);
  const autocompleteRef = (0,external_wp_element_namespaceObject.useRef)(null);
  const wrapperRef = (0,external_wp_element_namespaceObject.useRef)();
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (!wrapperRef.current) {
      return;
    }
    const nextFocusTarget = external_wp_dom_namespaceObject.focus.focusable.find(wrapperRef.current)[0] || wrapperRef.current;
    nextFocusTarget.focus();
  }, [isEditingLink, url, lightboxEnabled]);
  const startEditLink = () => {
    if (linkDestination === LINK_DESTINATION_MEDIA || linkDestination === LINK_DESTINATION_ATTACHMENT) {
      setUrlInput("");
    }
    setIsEditingLink(true);
  };
  const stopEditLink = () => {
    setIsEditingLink(false);
  };
  const closeLinkUI = () => {
    setUrlInput(null);
    stopEditLink();
    setIsOpen(false);
  };
  const getUpdatedLinkTargetSettings = (value) => {
    const newLinkTarget = value ? "_blank" : void 0;
    let updatedRel;
    if (newLinkTarget) {
      const rels = (rel ?? "").split(" ");
      NEW_TAB_REL.forEach((relVal) => {
        if (!rels.includes(relVal)) {
          rels.push(relVal);
        }
      });
      updatedRel = rels.join(" ");
    } else {
      const rels = (rel ?? "").split(" ").filter(
        (relVal) => NEW_TAB_REL.includes(relVal) === false
      );
      updatedRel = rels.length ? rels.join(" ") : void 0;
    }
    return {
      linkTarget: newLinkTarget,
      rel: updatedRel
    };
  };
  const onFocusOutside = () => {
    return (event) => {
      const autocompleteElement = autocompleteRef.current;
      if (autocompleteElement && autocompleteElement.contains(event.target)) {
        return;
      }
      setIsOpen(false);
      setUrlInput(null);
      stopEditLink();
    };
  };
  const onSubmitLinkChange = () => {
    return (event) => {
      if (urlInput) {
        const selectedDestination = getLinkDestinations().find(
          (destination) => destination.url === urlInput
        )?.linkDestination || LINK_DESTINATION_CUSTOM;
        onChangeUrl({
          href: (0,external_wp_url_namespaceObject.prependHTTP)(urlInput),
          linkDestination: selectedDestination,
          lightbox: { enabled: false }
        });
      }
      stopEditLink();
      setUrlInput(null);
      event.preventDefault();
    };
  };
  const onLinkRemove = () => {
    onChangeUrl({
      linkDestination: LINK_DESTINATION_NONE,
      href: ""
    });
  };
  const getLinkDestinations = () => {
    const linkDestinations = [
      {
        linkDestination: LINK_DESTINATION_MEDIA,
        title: (0,external_wp_i18n_namespaceObject.__)("Link to image file"),
        url: mediaType === "image" ? mediaUrl : void 0,
        icon: image_default
      }
    ];
    if (mediaType === "image" && mediaLink) {
      linkDestinations.push({
        linkDestination: LINK_DESTINATION_ATTACHMENT,
        title: (0,external_wp_i18n_namespaceObject.__)("Link to attachment page"),
        url: mediaType === "image" ? mediaLink : void 0,
        icon: page_default
      });
    }
    return linkDestinations;
  };
  const onSetHref = (value) => {
    const linkDestinations = getLinkDestinations();
    let linkDestinationInput;
    if (!value) {
      linkDestinationInput = LINK_DESTINATION_NONE;
    } else {
      linkDestinationInput = (linkDestinations.find((destination) => {
        return destination.url === value;
      }) || { linkDestination: LINK_DESTINATION_CUSTOM }).linkDestination;
    }
    onChangeUrl({
      linkDestination: linkDestinationInput,
      href: value
    });
  };
  const onSetNewTab = (value) => {
    const updatedLinkTarget = getUpdatedLinkTargetSettings(value);
    onChangeUrl(updatedLinkTarget);
  };
  const onSetLinkRel = (value) => {
    onChangeUrl({ rel: value });
  };
  const onSetLinkClass = (value) => {
    onChangeUrl({ linkClass: value });
  };
  const advancedOptions = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: "3", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToggleControl,
      {
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Open in new tab"),
        onChange: onSetNewTab,
        checked: linkTarget === "_blank"
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.TextControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Link relation"),
        value: rel ?? "",
        onChange: onSetLinkRel,
        help: (0,external_wp_element_namespaceObject.createInterpolateElement)(
          (0,external_wp_i18n_namespaceObject.__)(
            "The <a>Link Relation</a> attribute defines the relationship between a linked resource and the current document."
          ),
          {
            a: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ExternalLink, { href: "https://developer.mozilla.org/docs/Web/HTML/Attributes/rel" })
          }
        )
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.TextControl,
      {
        __next40pxDefaultSize: true,
        __nextHasNoMarginBottom: true,
        label: (0,external_wp_i18n_namespaceObject.__)("Link CSS class"),
        value: linkClass || "",
        onChange: onSetLinkClass
      }
    )
  ] });
  const linkEditorValue = urlInput !== null ? urlInput : url;
  const hideLightboxPanel = !lightboxEnabled || lightboxEnabled && !showLightboxSetting;
  const showLinkEditor = !linkEditorValue && hideLightboxPanel;
  const urlLabel = (getLinkDestinations().find(
    (destination) => destination.linkDestination === linkDestination
  ) || {}).title;
  const PopoverChildren = () => {
    if (lightboxEnabled && showLightboxSetting && !url && !isEditingLink) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-url-popover__expand-on-click", children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(icon_default, { icon: fullscreen_default }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "text", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: (0,external_wp_i18n_namespaceObject.__)("Enlarge on click") }),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { className: "description", children: (0,external_wp_i18n_namespaceObject.__)("Scales the image with a lightbox effect") })
        ] }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: link_off_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Disable enlarge on click"),
            onClick: () => {
              onSetLightbox?.(false);
            },
            size: "compact"
          }
        )
      ] });
    } else if (!url || isEditingLink) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        url_popover_default.LinkEditor,
        {
          className: "block-editor-format-toolbar__link-container-content",
          value: linkEditorValue,
          onChangeInputValue: setUrlInput,
          onSubmit: onSubmitLinkChange(),
          autocompleteRef
        }
      );
    } else if (url && !isEditingLink) {
      return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          url_popover_default.LinkViewer,
          {
            className: "block-editor-format-toolbar__link-container-content",
            url,
            onEditLinkClick: startEditLink,
            urlLabel
          }
        ),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.Button,
          {
            icon: link_off_default,
            label: (0,external_wp_i18n_namespaceObject.__)("Remove link"),
            onClick: () => {
              onLinkRemove();
              resetLightbox?.();
            },
            size: "compact"
          }
        )
      ] });
    }
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.ToolbarButton,
      {
        icon: link_default,
        className: "components-toolbar__control",
        label: (0,external_wp_i18n_namespaceObject.__)("Link"),
        "aria-expanded": isOpen,
        onClick: openLinkUI,
        ref: setPopoverAnchor,
        isActive: !!url || lightboxEnabled && showLightboxSetting
      }
    ),
    isOpen && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      url_popover_default,
      {
        ref: wrapperRef,
        anchor: popoverAnchor,
        onFocusOutside: onFocusOutside(),
        onClose: closeLinkUI,
        renderSettings: hideLightboxPanel ? () => advancedOptions : null,
        additionalControls: showLinkEditor && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.NavigableMenu, { children: [
          getLinkDestinations().map((link) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.MenuItem,
            {
              icon: link.icon,
              iconPosition: "left",
              onClick: () => {
                setUrlInput(null);
                onSetHref(link.url);
                stopEditLink();
              },
              children: link.title
            },
            link.linkDestination
          )),
          showLightboxSetting && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.MenuItem,
            {
              className: "block-editor-url-popover__expand-on-click",
              icon: fullscreen_default,
              info: (0,external_wp_i18n_namespaceObject.__)(
                "Scale the image with a lightbox effect."
              ),
              iconPosition: "left",
              onClick: () => {
                setUrlInput(null);
                onChangeUrl({
                  linkDestination: LINK_DESTINATION_NONE,
                  href: ""
                });
                onSetLightbox?.(true);
                stopEditLink();
              },
              children: (0,external_wp_i18n_namespaceObject.__)("Enlarge on click")
            },
            "expand-on-click"
          )
        ] }),
        offset: 13,
        children: PopoverChildren()
      }
    )
  ] });
};


;// ./node_modules/@wordpress/block-editor/build-module/components/preview-options/index.js

function PreviewOptions() {
  external_wp_deprecated_default()("wp.blockEditor.PreviewOptions", {
    version: "6.5"
  });
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/use-resize-canvas/index.js

function useResizeCanvas(deviceType) {
  const [actualWidth, updateActualWidth] = (0,external_wp_element_namespaceObject.useState)(window.innerWidth);
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (deviceType === "Desktop") {
      return;
    }
    const resizeListener = () => updateActualWidth(window.innerWidth);
    window.addEventListener("resize", resizeListener);
    return () => {
      window.removeEventListener("resize", resizeListener);
    };
  }, [deviceType]);
  const getCanvasWidth = (device) => {
    let deviceWidth;
    switch (device) {
      case "Tablet":
        deviceWidth = 780;
        break;
      case "Mobile":
        deviceWidth = 360;
        break;
      default:
        return null;
    }
    return deviceWidth < actualWidth ? deviceWidth : actualWidth;
  };
  const contentInlineStyles = (device) => {
    const height = device === "Mobile" ? "768px" : "1024px";
    const marginVertical = "40px";
    const marginHorizontal = "auto";
    switch (device) {
      case "Tablet":
      case "Mobile":
        return {
          width: getCanvasWidth(device),
          // Keeping margin styles separate to avoid warnings
          // when those props get overridden in the iframe component
          marginTop: marginVertical,
          marginBottom: marginVertical,
          marginLeft: marginHorizontal,
          marginRight: marginHorizontal,
          height,
          overflowY: "auto"
        };
      default:
        return {
          marginLeft: marginHorizontal,
          marginRight: marginHorizontal
        };
    }
  };
  return contentInlineStyles(deviceType);
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/edit-contents-button.js





function EditContentsButton({ clientId }) {
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const { attributes } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      return {
        attributes: select(store).getBlockAttributes(clientId)
      };
    },
    [clientId]
  );
  if (!attributes?.metadata?.patternName) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      className: "block-editor-block-inspector-edit-contents-button",
      __next40pxDefaultSize: true,
      variant: "secondary",
      onClick: () => {
        const { patternName, ...metadataWithoutPatternName } = attributes?.metadata ?? {};
        updateBlockAttributes(clientId, {
          ...attributes,
          metadata: metadataWithoutPatternName
        });
      },
      children: (0,external_wp_i18n_namespaceObject.__)("Edit contents")
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/skip-to-selected-block/index.js







function SkipToSelectedBlock() {
  const selectedBlockClientId = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getBlockSelectionStart(),
    []
  );
  const ref = (0,external_wp_element_namespaceObject.useRef)();
  useBlockElementRef(selectedBlockClientId, ref);
  const onClick = () => {
    ref.current?.focus();
  };
  return selectedBlockClientId ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      __next40pxDefaultSize: true,
      variant: "secondary",
      className: "block-editor-skip-to-selected-block",
      onClick,
      children: (0,external_wp_i18n_namespaceObject.__)("Skip to the selected block")
    }
  ) : null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/multi-selection-inspector/index.js







function MultiSelectionInspector() {
  const selectedBlockCount = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).getSelectedBlockCount(),
    []
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.__experimentalHStack,
    {
      justify: "flex-start",
      spacing: 2,
      className: "block-editor-multi-selection-inspector__card",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: copy_default, showColors: true }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-multi-selection-inspector__card-title", children: (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %d: number of blocks */
          (0,external_wp_i18n_namespaceObject._n)("%d Block", "%d Blocks", selectedBlockCount),
          selectedBlockCount
        ) })
      ]
    }
  );
}


;// ./node_modules/@wordpress/icons/build-module/library/cog.js


var cog_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    d: "M10.289 4.836A1 1 0 0111.275 4h1.306a1 1 0 01.987.836l.244 1.466c.787.26 1.503.679 2.108 1.218l1.393-.522a1 1 0 011.216.437l.653 1.13a1 1 0 01-.23 1.273l-1.148.944a6.025 6.025 0 010 2.435l1.149.946a1 1 0 01.23 1.272l-.653 1.13a1 1 0 01-1.216.437l-1.394-.522c-.605.54-1.32.958-2.108 1.218l-.244 1.466a1 1 0 01-.987.836h-1.306a1 1 0 01-.986-.836l-.244-1.466a5.995 5.995 0 01-2.108-1.218l-1.394.522a1 1 0 01-1.217-.436l-.653-1.131a1 1 0 01.23-1.272l1.149-.946a6.026 6.026 0 010-2.435l-1.148-.944a1 1 0 01-.23-1.272l.653-1.131a1 1 0 011.217-.437l1.393.522a5.994 5.994 0 012.108-1.218l.244-1.466zM14.929 12a3 3 0 11-6 0 3 3 0 016 0z",
    clipRule: "evenodd"
  }
) });


;// ./node_modules/@wordpress/icons/build-module/library/styles.js


var styles_default = /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_primitives_namespaceObject.SVG, { viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
  external_wp_primitives_namespaceObject.Path,
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M20 12a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 0 1-6.5 6.5v-13a6.5 6.5 0 0 1 6.5 6.5Z"
  }
) });


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/utils.js


const TAB_SETTINGS = {
  name: "settings",
  title: (0,external_wp_i18n_namespaceObject.__)("Settings"),
  value: "settings",
  icon: cog_default
};
const TAB_STYLES = {
  name: "styles",
  title: (0,external_wp_i18n_namespaceObject.__)("Styles"),
  value: "styles",
  icon: styles_default
};
const TAB_CONTENT = {
  name: "content",
  title: (0,external_wp_i18n_namespaceObject.__)("Content"),
  value: "content",
  icon: page_default
};
const TAB_LIST_VIEW = {
  name: "list",
  title: (0,external_wp_i18n_namespaceObject.__)("List View"),
  value: "list-view",
  icon: list_view_default
};


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/advanced-controls-panel.js





const AdvancedControls = () => {
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName);
  const privateFills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(
    PrivateInspectorControlsAllowedBlocks.name
  );
  const hasFills = Boolean(fills && fills.length);
  const hasPrivateFills = Boolean(privateFills && privateFills.length);
  if (!hasFills && !hasPrivateFills) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.PanelBody,
    {
      className: "block-editor-block-inspector__advanced",
      title: (0,external_wp_i18n_namespaceObject.__)("Advanced"),
      initialOpen: false,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "advanced" }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PrivateInspectorControlsAllowedBlocks.Slot, {})
      ]
    }
  );
};
var advanced_controls_panel_default = AdvancedControls;


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/position-controls-panel.js









const PositionControlsPanel = () => {
  const { selectedClientIds, selectedBlocks, hasPositionAttribute } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const { getBlocksByClientId, getSelectedBlockClientIds } = select(store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const _selectedBlocks = getBlocksByClientId(
      selectedBlockClientIds
    );
    return {
      selectedClientIds: selectedBlockClientIds,
      selectedBlocks: _selectedBlocks,
      hasPositionAttribute: _selectedBlocks?.some(
        ({ attributes }) => !!attributes?.style?.position?.type
      )
    };
  }, []);
  const { updateBlockAttributes } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  function resetPosition() {
    if (!selectedClientIds?.length || !selectedBlocks?.length) {
      return;
    }
    const attributesByClientId = Object.fromEntries(
      selectedBlocks?.map(({ clientId, attributes }) => [
        clientId,
        {
          style: utils_cleanEmptyObject({
            ...attributes?.style,
            position: {
              ...attributes?.style?.position,
              type: void 0,
              top: void 0,
              right: void 0,
              bottom: void 0,
              left: void 0
            }
          })
        }
      ])
    );
    updateBlockAttributes(selectedClientIds, attributesByClientId, true);
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      className: "block-editor-block-inspector__position",
      label: (0,external_wp_i18n_namespaceObject.__)("Position"),
      resetAll: resetPosition,
      dropdownMenuProps,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        {
          isShownByDefault: hasPositionAttribute,
          label: (0,external_wp_i18n_namespaceObject.__)("Position"),
          hasValue: () => hasPositionAttribute,
          onDeselect: resetPosition,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "position" })
        }
      )
    }
  );
};
const PositionControls = () => {
  const fills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(groups_groups_default.position.name);
  const hasFills = Boolean(fills && fills.length);
  if (!hasFills) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(PositionControlsPanel, {});
};
var position_controls_panel_default = PositionControls;


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/settings-tab.js




const SettingsTab = ({ showAdvancedControls = false }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, {}),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(position_controls_panel_default, {}),
  /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "bindings" }),
  showAdvancedControls && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(advanced_controls_panel_default, {}) })
] });
var settings_tab_default = SettingsTab;


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/styles-tab.js






const StylesTab = ({
  blockName,
  clientId,
  hasBlockStyles,
  isSectionBlock
}) => {
  const borderPanelLabel = useBorderPanelLabel({ blockName });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    hasBlockStyles && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.PanelBody, { title: (0,external_wp_i18n_namespaceObject.__)("Styles"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_styles_default, { clientId }) }) }),
    !isSectionBlock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inspector_controls_default.Slot,
        {
          group: "color",
          label: (0,external_wp_i18n_namespaceObject.__)("Color"),
          className: "color-block-support-panel__inner-wrapper"
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inspector_controls_default.Slot,
        {
          group: "background",
          label: (0,external_wp_i18n_namespaceObject.__)("Background image")
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "filter" }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inspector_controls_default.Slot,
        {
          group: "typography",
          label: (0,external_wp_i18n_namespaceObject.__)("Typography")
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inspector_controls_default.Slot,
        {
          group: "dimensions",
          label: (0,external_wp_i18n_namespaceObject.__)("Dimensions")
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        inspector_controls_default.Slot,
        {
          group: "border",
          label: borderPanelLabel
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "styles" })
    ] })
  ] });
};
var styles_tab_default = StylesTab;


;// ./node_modules/@wordpress/block-editor/build-module/components/block-quick-navigation/index.js







function BlockQuickNavigation({ clientIds, onSelect }) {
  if (!clientIds.length) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 1, children: clientIds.map((clientId) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockQuickNavigationItem,
    {
      onSelect,
      clientId
    },
    clientId
  )) });
}
function BlockQuickNavigationItem({ clientId, onSelect }) {
  const blockInformation = useBlockDisplayInformation(clientId);
  const blockTitle = useBlockDisplayTitle({
    clientId,
    context: "list-view"
  });
  const { isSelected } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { isBlockSelected, hasSelectedInnerBlock } = select(store);
      return {
        isSelected: isBlockSelected(clientId) || hasSelectedInnerBlock(
          clientId,
          /* deep: */
          true
        )
      };
    },
    [clientId]
  );
  const { selectBlock } = (0,external_wp_data_namespaceObject.useDispatch)(store);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.Button,
    {
      __next40pxDefaultSize: true,
      isPressed: isSelected,
      onClick: async () => {
        await selectBlock(clientId);
        if (onSelect) {
          onSelect(clientId);
        }
      },
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.Flex, { children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexItem, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_icon_default, { icon: blockInformation?.icon }) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.FlexBlock, { style: { textAlign: "left" }, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalTruncate, { children: blockTitle }) })
      ] })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/content-tab.js




const ContentTab = ({ contentClientIds }) => {
  if (!contentClientIds || contentClientIds.length === 0) {
    return null;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.PanelBody, { title: (0,external_wp_i18n_namespaceObject.__)("Content"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockQuickNavigation, { clientIds: contentClientIds }) });
};
var content_tab_default = ContentTab;


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/use-is-list-view-tab-disabled.js
const allowlist = ["core/navigation"];
const useIsListViewTabDisabled = (blockName) => {
  return !allowlist.includes(blockName);
};
var use_is_list_view_tab_disabled_default = useIsListViewTabDisabled;


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/index.js












const { Tabs: inspector_controls_tabs_Tabs } = unlock(external_wp_components_namespaceObject.privateApis);
function InspectorControlsTabs({
  blockName,
  clientId,
  hasBlockStyles,
  tabs,
  isSectionBlock,
  contentClientIds
}) {
  const showIconLabels = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    return select(external_wp_preferences_namespaceObject.store).get("core", "showIconLabels");
  }, []);
  const initialTabName = !use_is_list_view_tab_disabled_default(blockName) ? TAB_LIST_VIEW.name : void 0;
  const [selectedTabId, setSelectedTabId] = (0,external_wp_element_namespaceObject.useState)(
    initialTabName ?? tabs[0]?.name
  );
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    if (initialTabName) {
      return;
    }
    if (tabs?.length && selectedTabId) {
      const activeTab = tabs.find(
        (tab) => tab.name === selectedTabId
      );
      if (!activeTab) {
        setSelectedTabId(tabs[0].name);
      }
    }
  }, [tabs, selectedTabId, initialTabName]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-inspector__tabs", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    inspector_controls_tabs_Tabs,
    {
      defaultTabId: initialTabName,
      selectedTabId,
      onSelect: setSelectedTabId,
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.TabList, { children: tabs.map(
          (tab) => showIconLabels ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.Tab, { tabId: tab.name, children: tab.title }, tab.name) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Tooltip, { text: tab.title, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            inspector_controls_tabs_Tabs.Tab,
            {
              tabId: tab.name,
              "aria-label": tab.title,
              children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Icon, { icon: tab.icon })
            }
          ) }, tab.name)
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.TabPanel, { tabId: TAB_SETTINGS.name, focusable: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(settings_tab_default, { showAdvancedControls: !!blockName }) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.TabPanel, { tabId: TAB_STYLES.name, focusable: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          styles_tab_default,
          {
            blockName,
            clientId,
            hasBlockStyles,
            isSectionBlock
          }
        ) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.TabPanel, { tabId: TAB_CONTENT.name, focusable: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(content_tab_default, { contentClientIds }) }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_tabs_Tabs.TabPanel, { tabId: TAB_LIST_VIEW.name, focusable: false, children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "list" }) })
      ]
    },
    clientId
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-controls-tabs/use-inspector-controls-tabs.js







const use_inspector_controls_tabs_EMPTY_ARRAY = [];
function getShowTabs(blockName, tabSettings = {}) {
  if (tabSettings[blockName] !== void 0) {
    return tabSettings[blockName];
  }
  if (tabSettings.default !== void 0) {
    return tabSettings.default;
  }
  return true;
}
function useInspectorControlsTabs(blockName, contentClientIds, isSectionBlock, hasBlockStyles) {
  const tabs = [];
  const {
    bindings: bindingsGroup,
    border: borderGroup,
    color: colorGroup,
    default: defaultGroup,
    dimensions: dimensionsGroup,
    list: listGroup,
    position: positionGroup,
    styles: stylesGroup,
    typography: typographyGroup,
    effects: effectsGroup
  } = groups_groups_default;
  const listViewDisabled = use_is_list_view_tab_disabled_default(blockName);
  const listFills = (0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(listGroup.name);
  const hasListFills = !listViewDisabled && !!listFills && listFills.length;
  const styleFills = [
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(borderGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(colorGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(dimensionsGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(stylesGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(typographyGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(effectsGroup.name) || []
  ];
  const hasStyleFills = styleFills.length;
  const advancedFills = [
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(InspectorAdvancedControls.slotName) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(bindingsGroup.name) || []
  ];
  const settingsFills = [
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(defaultGroup.name) || [],
    ...(0,external_wp_components_namespaceObject.__experimentalUseSlotFills)(positionGroup.name) || [],
    ...hasListFills && hasStyleFills > 1 ? advancedFills : []
  ];
  const hasContentTab = !!(contentClientIds && contentClientIds.length > 0);
  if (hasListFills && !isSectionBlock) {
    tabs.push(TAB_LIST_VIEW);
  }
  if (hasContentTab) {
    tabs.push(TAB_CONTENT);
  }
  if (settingsFills.length && !isSectionBlock) {
    tabs.push(TAB_SETTINGS);
  }
  if (isSectionBlock ? hasBlockStyles : hasStyleFills) {
    tabs.push(TAB_STYLES);
  }
  const tabSettings = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    return select(store).getSettings().blockInspectorTabs;
  }, []);
  const showTabs = getShowTabs(blockName, tabSettings);
  return showTabs ? tabs : use_inspector_controls_tabs_EMPTY_ARRAY;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/useBlockInspectorAnimationSettings.js


function useBlockInspectorAnimationSettings(blockType) {
  return (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (blockType) {
        const globalBlockInspectorAnimationSettings = select(store).getSettings().blockInspectorAnimation;
        const animationParent = globalBlockInspectorAnimationSettings?.animationParent;
        const { getSelectedBlockClientId, getBlockParentsByBlockName } = select(store);
        const _selectedBlockClientId = getSelectedBlockClientId();
        const animationParentBlockClientId = getBlockParentsByBlockName(
          _selectedBlockClientId,
          animationParent,
          true
        )[0];
        if (!animationParentBlockClientId && blockType.name !== animationParent) {
          return null;
        }
        return globalBlockInspectorAnimationSettings?.[blockType.name];
      }
      return null;
    },
    [blockType]
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-inspector/index.js






















function BlockStylesPanel({ clientId }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.PanelBody, { title: (0,external_wp_i18n_namespaceObject.__)("Styles"), children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_styles_default, { clientId }) });
}
function StyleInspectorSlots({
  blockName,
  showAdvancedControls = true,
  showPositionControls = true,
  showListControls = false,
  showBindingsControls = true
}) {
  const borderPanelLabel = useBorderPanelLabel({ blockName });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, {}),
    showListControls && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "list" }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inspector_controls_default.Slot,
      {
        group: "color",
        label: (0,external_wp_i18n_namespaceObject.__)("Color"),
        className: "color-block-support-panel__inner-wrapper"
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inspector_controls_default.Slot,
      {
        group: "background",
        label: (0,external_wp_i18n_namespaceObject.__)("Background image")
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inspector_controls_default.Slot,
      {
        group: "typography",
        label: (0,external_wp_i18n_namespaceObject.__)("Typography")
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      inspector_controls_default.Slot,
      {
        group: "dimensions",
        label: (0,external_wp_i18n_namespaceObject.__)("Dimensions")
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "border", label: borderPanelLabel }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "styles" }),
    showPositionControls && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(position_controls_panel_default, {}),
    showBindingsControls && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inspector_controls_default.Slot, { group: "bindings" }),
    showAdvancedControls && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(advanced_controls_panel_default, {}) })
  ] });
}
function BlockInspector() {
  const {
    selectedBlockCount,
    selectedBlockName,
    selectedBlockClientId,
    blockType,
    isSectionBlock,
    isSectionBlockInSelection,
    hasBlockStyles
  } = (0,external_wp_data_namespaceObject.useSelect)((select) => {
    const {
      getSelectedBlockClientId,
      getSelectedBlockClientIds,
      getSelectedBlockCount,
      getBlockName,
      getParentSectionBlock,
      isSectionBlock: _isSectionBlock
    } = unlock(select(store));
    const { getBlockStyles } = select(external_wp_blocks_namespaceObject.store);
    const _selectedBlockClientId = getSelectedBlockClientId();
    const renderedBlockClientId = getParentSectionBlock(_selectedBlockClientId) || _selectedBlockClientId;
    const _selectedBlockName = renderedBlockClientId && getBlockName(renderedBlockClientId);
    const _blockType = _selectedBlockName && (0,external_wp_blocks_namespaceObject.getBlockType)(_selectedBlockName);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const _isSectionBlockInSelection = selectedBlockClientIds.some(
      (id) => _isSectionBlock(id)
    );
    const blockStyles = _selectedBlockName && getBlockStyles(_selectedBlockName);
    const _hasBlockStyles = blockStyles && blockStyles.length > 0;
    return {
      selectedBlockCount: getSelectedBlockCount(),
      selectedBlockClientId: renderedBlockClientId,
      selectedBlockName: _selectedBlockName,
      blockType: _blockType,
      isSectionBlockInSelection: _isSectionBlockInSelection,
      isSectionBlock: _isSectionBlock(renderedBlockClientId),
      hasBlockStyles: _hasBlockStyles
    };
  }, []);
  const contentClientIds = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!isSectionBlock || !selectedBlockClientId) {
        return [];
      }
      const {
        getClientIdsOfDescendants,
        getBlockName,
        getBlockEditingMode
      } = unlock(select(store));
      const descendants = getClientIdsOfDescendants(
        selectedBlockClientId
      );
      const navigationDescendants = /* @__PURE__ */ new Set();
      descendants.forEach((clientId) => {
        if (getBlockName(clientId) === "core/navigation") {
          const navChildren = getClientIdsOfDescendants(clientId);
          navChildren.forEach(
            (childId) => navigationDescendants.add(childId)
          );
        }
      });
      return descendants.filter((current) => {
        if (navigationDescendants.has(current)) {
          return false;
        }
        return getBlockName(current) !== "core/list-item" && getBlockEditingMode(current) === "contentOnly";
      });
    },
    [isSectionBlock, selectedBlockClientId]
  );
  const availableTabs = useInspectorControlsTabs(
    blockType?.name,
    contentClientIds,
    isSectionBlock,
    hasBlockStyles
  );
  const hasMultipleTabs = availableTabs?.length > 1;
  const blockInspectorAnimationSettings = useBlockInspectorAnimationSettings(blockType);
  const hasSelectedBlocks = selectedBlockCount > 1;
  if (hasSelectedBlocks && !isSectionBlockInSelection) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-inspector", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MultiSelectionInspector, {}),
      hasMultipleTabs ? /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(InspectorControlsTabs, { tabs: availableTabs }) : /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        StyleInspectorSlots,
        {
          blockName: selectedBlockName,
          showAdvancedControls: false,
          showPositionControls: false,
          showBindingsControls: false
        }
      )
    ] });
  }
  if (hasSelectedBlocks && isSectionBlockInSelection) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { className: "block-editor-block-inspector", children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(MultiSelectionInspector, {}) });
  }
  const isSelectedBlockUnregistered = selectedBlockName === (0,external_wp_blocks_namespaceObject.getUnregisteredTypeHandlerName)();
  const shouldShowWarning = !blockType || !selectedBlockClientId || isSelectedBlockUnregistered;
  if (shouldShowWarning) {
    return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("span", { className: "block-editor-block-inspector__no-blocks", children: (0,external_wp_i18n_namespaceObject.__)("No block selected.") });
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    BlockInspectorSingleBlockWrapper,
    {
      animate: blockInspectorAnimationSettings,
      wrapper: (children) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        AnimatedContainer,
        {
          blockInspectorAnimationSettings,
          selectedBlockClientId,
          children
        }
      ),
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        BlockInspectorSingleBlock,
        {
          clientId: selectedBlockClientId,
          blockName: blockType.name,
          isSectionBlock,
          availableTabs,
          contentClientIds,
          hasBlockStyles
        }
      )
    }
  );
}
const BlockInspectorSingleBlockWrapper = ({ animate, wrapper, children }) => {
  return animate ? wrapper(children) : children;
};
const AnimatedContainer = ({
  blockInspectorAnimationSettings,
  selectedBlockClientId,
  children
}) => {
  const animationOrigin = blockInspectorAnimationSettings && blockInspectorAnimationSettings.enterDirection === "leftToRight" ? -50 : 50;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__unstableMotion.div,
    {
      animate: {
        x: 0,
        opacity: 1,
        transition: {
          ease: "easeInOut",
          duration: 0.14
        }
      },
      initial: {
        x: animationOrigin,
        opacity: 0
      },
      children
    },
    selectedBlockClientId
  );
};
const BlockInspectorSingleBlock = ({
  clientId,
  blockName,
  isSectionBlock,
  availableTabs,
  contentClientIds,
  hasBlockStyles
}) => {
  const hasMultipleTabs = availableTabs?.length > 1;
  const blockInformation = useBlockDisplayInformation(clientId);
  const isBlockSynced = blockInformation.isSynced;
  const shouldShowTabs = !isBlockSynced && hasMultipleTabs;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { className: "block-editor-block-inspector", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      block_card_default,
      {
        ...blockInformation,
        className: isBlockSynced && "is-synced",
        allowParentNavigation: true,
        children: window?.__experimentalContentOnlyPatternInsertion && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(EditContentsButton, { clientId })
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(block_variation_transforms_default, { blockClientId: clientId }),
    shouldShowTabs && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      InspectorControlsTabs,
      {
        hasBlockStyles,
        clientId,
        blockName,
        tabs: availableTabs,
        isSectionBlock,
        contentClientIds
      }
    ),
    !shouldShowTabs && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
      hasBlockStyles && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(BlockStylesPanel, { clientId }),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(content_tab_default, { contentClientIds }),
      !isSectionBlock && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        StyleInspectorSlots,
        {
          blockName,
          showListControls: true
        }
      )
    ] }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(SkipToSelectedBlock, {}, "back")
  ] });
};
var block_inspector_default = BlockInspector;


;// ./node_modules/@wordpress/block-editor/build-module/components/copy-handler/index.js



const __unstableUseClipboardHandler = () => {
  external_wp_deprecated_default()("__unstableUseClipboardHandler", {
    alternative: "BlockCanvas or WritingFlow",
    since: "6.4",
    version: "6.7"
  });
  return useClipboardHandler();
};
function CopyHandler(props) {
  external_wp_deprecated_default()("CopyHandler", {
    alternative: "BlockCanvas or WritingFlow",
    since: "6.4",
    version: "6.7"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ...props, ref: useClipboardHandler() });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/inserter/library.js





const library_noop = () => {
};
function InserterLibrary({
  rootClientId,
  clientId,
  isAppender,
  showInserterHelpPanel,
  showMostUsedBlocks = false,
  __experimentalInsertionIndex,
  __experimentalInitialTab,
  __experimentalInitialCategory,
  __experimentalFilterValue,
  onPatternCategorySelection,
  onSelect = library_noop,
  shouldFocusBlock = false,
  onClose
}, ref) {
  const { destinationRootClientId } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      const { getBlockRootClientId } = select(store);
      const _rootClientId = rootClientId || getBlockRootClientId(clientId) || void 0;
      return {
        destinationRootClientId: _rootClientId
      };
    },
    [clientId, rootClientId]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateInserterMenu,
    {
      onSelect,
      rootClientId: destinationRootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      showMostUsedBlocks,
      __experimentalInsertionIndex,
      __experimentalFilterValue,
      onPatternCategorySelection,
      __experimentalInitialTab,
      __experimentalInitialCategory,
      shouldFocusBlock,
      ref,
      onClose
    }
  );
}
const PrivateInserterLibrary = (0,external_wp_element_namespaceObject.forwardRef)(InserterLibrary);
function PublicInserterLibrary(props, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivateInserterLibrary,
    {
      ...props,
      onPatternCategorySelection: void 0,
      ref
    }
  );
}
var library_default = (0,external_wp_element_namespaceObject.forwardRef)(PublicInserterLibrary);


;// ./node_modules/@wordpress/block-editor/build-module/components/selection-scroll-into-view/index.js

function MultiSelectScrollIntoView() {
  external_wp_deprecated_default()("wp.blockEditor.MultiSelectScrollIntoView", {
    hint: "This behaviour is now built-in.",
    since: "5.8"
  });
  return null;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/typewriter/index.js






const isIE = window.navigator.userAgent.indexOf("Trident") !== -1;
const arrowKeyCodes = /* @__PURE__ */ new Set([external_wp_keycodes_namespaceObject.UP, external_wp_keycodes_namespaceObject.DOWN, external_wp_keycodes_namespaceObject.LEFT, external_wp_keycodes_namespaceObject.RIGHT]);
const initialTriggerPercentage = 0.75;
function useTypewriter() {
  const hasSelectedBlock = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => select(store).hasSelectedBlock(),
    []
  );
  return (0,external_wp_compose_namespaceObject.useRefEffect)(
    (node) => {
      if (!hasSelectedBlock) {
        return;
      }
      const { ownerDocument } = node;
      const { defaultView } = ownerDocument;
      let scrollResizeRafId;
      let onKeyDownRafId;
      let caretRect;
      function onScrollResize() {
        if (scrollResizeRafId) {
          return;
        }
        scrollResizeRafId = defaultView.requestAnimationFrame(() => {
          computeCaretRectangle();
          scrollResizeRafId = null;
        });
      }
      function onKeyDown(event) {
        if (onKeyDownRafId) {
          defaultView.cancelAnimationFrame(onKeyDownRafId);
        }
        onKeyDownRafId = defaultView.requestAnimationFrame(() => {
          maintainCaretPosition(event);
          onKeyDownRafId = null;
        });
      }
      function maintainCaretPosition({ keyCode }) {
        if (!isSelectionEligibleForScroll()) {
          return;
        }
        const currentCaretRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);
        if (!currentCaretRect) {
          return;
        }
        if (!caretRect) {
          caretRect = currentCaretRect;
          return;
        }
        if (arrowKeyCodes.has(keyCode)) {
          caretRect = currentCaretRect;
          return;
        }
        const diff = currentCaretRect.top - caretRect.top;
        if (diff === 0) {
          return;
        }
        const scrollContainer = (0,external_wp_dom_namespaceObject.getScrollContainer)(node);
        if (!scrollContainer) {
          return;
        }
        const windowScroll = scrollContainer === ownerDocument.body || scrollContainer === ownerDocument.documentElement;
        const scrollY = windowScroll ? defaultView.scrollY : scrollContainer.scrollTop;
        const scrollContainerY = windowScroll ? 0 : scrollContainer.getBoundingClientRect().top;
        const relativeScrollPosition = windowScroll ? caretRect.top / defaultView.innerHeight : (caretRect.top - scrollContainerY) / (defaultView.innerHeight - scrollContainerY);
        if (scrollY === 0 && relativeScrollPosition < initialTriggerPercentage && isLastEditableNode()) {
          caretRect = currentCaretRect;
          return;
        }
        const scrollContainerHeight = windowScroll ? defaultView.innerHeight : scrollContainer.clientHeight;
        if (
          // The caret is under the lower fold.
          caretRect.top + caretRect.height > scrollContainerY + scrollContainerHeight || // The caret is above the upper fold.
          caretRect.top < scrollContainerY
        ) {
          caretRect = currentCaretRect;
          return;
        }
        if (windowScroll) {
          defaultView.scrollBy(0, diff);
        } else {
          scrollContainer.scrollTop += diff;
        }
      }
      function addSelectionChangeListener() {
        ownerDocument.addEventListener(
          "selectionchange",
          computeCaretRectOnSelectionChange
        );
      }
      function computeCaretRectOnSelectionChange() {
        ownerDocument.removeEventListener(
          "selectionchange",
          computeCaretRectOnSelectionChange
        );
        computeCaretRectangle();
      }
      function computeCaretRectangle() {
        if (isSelectionEligibleForScroll()) {
          caretRect = (0,external_wp_dom_namespaceObject.computeCaretRect)(defaultView);
        }
      }
      function isSelectionEligibleForScroll() {
        return node.contains(ownerDocument.activeElement) && ownerDocument.activeElement.isContentEditable;
      }
      function isLastEditableNode() {
        const editableNodes = node.querySelectorAll(
          '[contenteditable="true"]'
        );
        const lastEditableNode = editableNodes[editableNodes.length - 1];
        return lastEditableNode === ownerDocument.activeElement;
      }
      defaultView.addEventListener("scroll", onScrollResize, true);
      defaultView.addEventListener("resize", onScrollResize, true);
      node.addEventListener("keydown", onKeyDown);
      node.addEventListener("keyup", maintainCaretPosition);
      node.addEventListener("mousedown", addSelectionChangeListener);
      node.addEventListener("touchstart", addSelectionChangeListener);
      return () => {
        defaultView.removeEventListener(
          "scroll",
          onScrollResize,
          true
        );
        defaultView.removeEventListener(
          "resize",
          onScrollResize,
          true
        );
        node.removeEventListener("keydown", onKeyDown);
        node.removeEventListener("keyup", maintainCaretPosition);
        node.removeEventListener(
          "mousedown",
          addSelectionChangeListener
        );
        node.removeEventListener(
          "touchstart",
          addSelectionChangeListener
        );
        ownerDocument.removeEventListener(
          "selectionchange",
          computeCaretRectOnSelectionChange
        );
        defaultView.cancelAnimationFrame(scrollResizeRafId);
        defaultView.cancelAnimationFrame(onKeyDownRafId);
      };
    },
    [hasSelectedBlock]
  );
}
function Typewriter({ children }) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("div", { ref: useTypewriter(), className: "block-editor__typewriter", children });
}
const TypewriterOrIEBypass = isIE ? (props) => props.children : Typewriter;
var typewriter_default = TypewriterOrIEBypass;


;// ./node_modules/@wordpress/block-editor/build-module/components/recursion-provider/index.js




const RenderedRefsContext = (0,external_wp_element_namespaceObject.createContext)({});
RenderedRefsContext.displayName = "RenderedRefsContext";
function addToBlockType(renderedBlocks, blockName, uniqueId) {
  const result = {
    ...renderedBlocks,
    [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : /* @__PURE__ */ new Set()
  };
  result[blockName].add(uniqueId);
  return result;
}
function RecursionProvider({ children, uniqueId, blockName = "" }) {
  const previouslyRenderedBlocks = (0,external_wp_element_namespaceObject.useContext)(RenderedRefsContext);
  const { name } = useBlockEditContext();
  blockName = blockName || name;
  const newRenderedBlocks = (0,external_wp_element_namespaceObject.useMemo)(
    () => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId),
    [previouslyRenderedBlocks, blockName, uniqueId]
  );
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(RenderedRefsContext.Provider, { value: newRenderedBlocks, children });
}
function useHasRecursion(uniqueId, blockName = "") {
  const previouslyRenderedBlocks = (0,external_wp_element_namespaceObject.useContext)(RenderedRefsContext);
  const { name } = useBlockEditContext();
  blockName = blockName || name;
  return Boolean(previouslyRenderedBlocks[blockName]?.has(uniqueId));
}
const DeprecatedExperimentalRecursionProvider = (props) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalRecursionProvider", {
    since: "6.5",
    alternative: "wp.blockEditor.RecursionProvider"
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(RecursionProvider, { ...props });
};
const DeprecatedExperimentalUseHasRecursion = (...args) => {
  external_wp_deprecated_default()("wp.blockEditor.__experimentalUseHasRecursion", {
    since: "6.5",
    alternative: "wp.blockEditor.useHasRecursion"
  });
  return useHasRecursion(...args);
};


;// ./node_modules/@wordpress/block-editor/build-module/components/inspector-popover-header/index.js




function InspectorPopoverHeader({
  title,
  help,
  actions = [],
  onClose
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { className: "block-editor-inspector-popover-header", spacing: 4, children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { alignment: "center", children: [
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalHeading,
        {
          className: "block-editor-inspector-popover-header__heading",
          level: 2,
          size: 13,
          children: title
        }
      ),
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalSpacer, {}),
      actions.map(({ label, icon, onClick }) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          size: "small",
          className: "block-editor-inspector-popover-header__action",
          label,
          icon,
          variant: !icon && "tertiary",
          onClick,
          children: !icon && label
        },
        label
      )),
      onClose && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.Button,
        {
          size: "small",
          className: "block-editor-inspector-popover-header__action",
          label: (0,external_wp_i18n_namespaceObject.__)("Close"),
          icon: close_small_default,
          onClick: onClose
        }
      )
    ] }),
    help && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.__experimentalText, { children: help })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/publish-date-time-picker/index.js






function PublishDateTimePicker({
  onClose,
  onChange,
  showPopoverHeaderActions,
  isCompact,
  currentDate,
  title,
  ...additionalProps
}, ref) {
  const datePickerProps = {
    startOfWeek: (0,external_wp_date_namespaceObject.getSettings)().l10n.startOfWeek,
    onChange,
    currentDate: isCompact ? void 0 : currentDate,
    currentTime: isCompact ? currentDate : void 0,
    ...additionalProps
  };
  const DatePickerComponent = isCompact ? external_wp_components_namespaceObject.TimePicker : external_wp_components_namespaceObject.DateTimePicker;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)("div", { ref, className: "block-editor-publish-date-time-picker", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      InspectorPopoverHeader,
      {
        title: title || (0,external_wp_i18n_namespaceObject.__)("Publish"),
        actions: showPopoverHeaderActions ? [
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Now"),
            onClick: () => onChange?.(null)
          }
        ] : void 0,
        onClose
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(DatePickerComponent, { ...datePickerProps })
  ] });
}
const PrivatePublishDateTimePicker = (0,external_wp_element_namespaceObject.forwardRef)(PublishDateTimePicker);
function PublicPublishDateTimePicker(props, ref) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    PrivatePublishDateTimePicker,
    {
      ...props,
      showPopoverHeaderActions: true,
      isCompact: false,
      ref
    }
  );
}
var publish_date_time_picker_default = (0,external_wp_element_namespaceObject.forwardRef)(PublicPublishDateTimePicker);


;// ./node_modules/@wordpress/block-editor/build-module/components/tool-selector/index.js


function ToolSelector() {
  external_wp_deprecated_default()("wp.blockEditor.ToolSelector", {
    since: "6.9",
    hint: "The ToolSelector component no longer renders anything."
  });
  return null;
}
var tool_selector_default = (0,external_wp_element_namespaceObject.forwardRef)(ToolSelector);


;// ./node_modules/@wordpress/block-editor/build-module/components/index.js
















































































































;// ./node_modules/@wordpress/block-editor/build-module/elements/index.js
const elements_ELEMENT_CLASS_NAMES = {
  button: "wp-element-button",
  caption: "wp-element-caption"
};
const __experimentalGetElementClassName = (element) => {
  return elements_ELEMENT_CLASS_NAMES[element] ? elements_ELEMENT_CLASS_NAMES[element] : "";
};


;// ./node_modules/@wordpress/block-editor/build-module/utils/get-px-from-css-unit.js
var get_px_from_css_unit_default = () => "";


;// ./node_modules/@wordpress/block-editor/build-module/utils/index.js





;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/image-settings-panel.js




function useHasImageSettingsPanel(name, value, inheritedValue) {
  return name === "core/image" && inheritedValue?.lightbox?.allowEditing || !!value?.lightbox;
}
function ImageSettingsPanel({
  onChange,
  value,
  inheritedValue,
  panelId
}) {
  const dropdownMenuProps = useToolsPanelDropdownMenuProps();
  const resetLightbox = () => {
    onChange(void 0);
  };
  const onChangeLightbox = (newSetting) => {
    onChange({
      enabled: newSetting
    });
  };
  let lightboxChecked = false;
  if (inheritedValue?.lightbox?.enabled) {
    lightboxChecked = inheritedValue.lightbox.enabled;
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanel,
    {
      label: (0,external_wp_i18n_namespaceObject._x)("Settings", "Image settings"),
      resetAll: resetLightbox,
      panelId,
      dropdownMenuProps,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToolsPanelItem,
        {
          hasValue: () => !!value?.lightbox,
          label: (0,external_wp_i18n_namespaceObject.__)("Enlarge on click"),
          onDeselect: resetLightbox,
          isShownByDefault: true,
          panelId,
          children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.ToggleControl,
            {
              __nextHasNoMarginBottom: true,
              label: (0,external_wp_i18n_namespaceObject.__)("Enlarge on click"),
              checked: lightboxChecked,
              onChange: onChangeLightbox
            }
          )
        }
      )
    }
  ) });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/advanced-panel.js





function AdvancedPanel({
  value,
  onChange,
  inheritedValue = value
}) {
  const [cssError, setCSSError] = (0,external_wp_element_namespaceObject.useState)(null);
  const customCSS = inheritedValue?.css;
  function handleOnChange(newValue) {
    onChange({
      ...value,
      css: newValue
    });
    if (cssError) {
      const [transformed] = transform_styles_default(
        [{ css: newValue }],
        ".for-validation-only"
      );
      if (transformed) {
        setCSSError(null);
      }
    }
  }
  function handleOnBlur(event) {
    if (!event?.target?.value) {
      setCSSError(null);
      return;
    }
    const [transformed] = transform_styles_default(
      [{ css: event.target.value }],
      ".for-validation-only"
    );
    setCSSError(
      transformed === null ? (0,external_wp_i18n_namespaceObject.__)("There is an error with your CSS structure.") : null
    );
  }
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 3, children: [
    cssError && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Notice, { status: "error", onRemove: () => setCSSError(null), children: cssError }),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.TextareaControl,
      {
        label: (0,external_wp_i18n_namespaceObject.__)("Additional CSS"),
        __nextHasNoMarginBottom: true,
        value: customCSS,
        onChange: (newValue) => handleOnChange(newValue),
        onBlur: handleOnBlur,
        className: "block-editor-global-styles-advanced-panel__custom-css-input",
        spellCheck: false
      }
    )
  ] });
}


;// ./node_modules/memize/dist/index.js
/**
 * Memize options object.
 *
 * @typedef MemizeOptions
 *
 * @property {number} [maxSize] Maximum size of the cache.
 */

/**
 * Internal cache entry.
 *
 * @typedef MemizeCacheNode
 *
 * @property {?MemizeCacheNode|undefined} [prev] Previous node.
 * @property {?MemizeCacheNode|undefined} [next] Next node.
 * @property {Array<*>}                   args   Function arguments for cache
 *                                               entry.
 * @property {*}                          val    Function result.
 */

/**
 * Properties of the enhanced function for controlling cache.
 *
 * @typedef MemizeMemoizedFunction
 *
 * @property {()=>void} clear Clear the cache.
 */

/**
 * Accepts a function to be memoized, and returns a new memoized function, with
 * optional options.
 *
 * @template {(...args: any[]) => any} F
 *
 * @param {F}             fn        Function to memoize.
 * @param {MemizeOptions} [options] Options object.
 *
 * @return {((...args: Parameters<F>) => ReturnType<F>) & MemizeMemoizedFunction} Memoized function.
 */
function memize(fn, options) {
	var size = 0;

	/** @type {?MemizeCacheNode|undefined} */
	var head;

	/** @type {?MemizeCacheNode|undefined} */
	var tail;

	options = options || {};

	function memoized(/* ...args */) {
		var node = head,
			len = arguments.length,
			args,
			i;

		searchCache: while (node) {
			// Perform a shallow equality test to confirm that whether the node
			// under test is a candidate for the arguments passed. Two arrays
			// are shallowly equal if their length matches and each entry is
			// strictly equal between the two sets. Avoid abstracting to a
			// function which could incur an arguments leaking deoptimization.

			// Check whether node arguments match arguments length
			if (node.args.length !== arguments.length) {
				node = node.next;
				continue;
			}

			// Check whether node arguments match arguments values
			for (i = 0; i < len; i++) {
				if (node.args[i] !== arguments[i]) {
					node = node.next;
					continue searchCache;
				}
			}

			// At this point we can assume we've found a match

			// Surface matched node to head if not already
			if (node !== head) {
				// As tail, shift to previous. Must only shift if not also
				// head, since if both head and tail, there is no previous.
				if (node === tail) {
					tail = node.prev;
				}

				// Adjust siblings to point to each other. If node was tail,
				// this also handles new tail's empty `next` assignment.
				/** @type {MemizeCacheNode} */ (node.prev).next = node.next;
				if (node.next) {
					node.next.prev = node.prev;
				}

				node.next = head;
				node.prev = null;
				/** @type {MemizeCacheNode} */ (head).prev = node;
				head = node;
			}

			// Return immediately
			return node.val;
		}

		// No cached value found. Continue to insertion phase:

		// Create a copy of arguments (avoid leaking deoptimization)
		args = new Array(len);
		for (i = 0; i < len; i++) {
			args[i] = arguments[i];
		}

		node = {
			args: args,

			// Generate the result from original function
			val: fn.apply(null, args),
		};

		// Don't need to check whether node is already head, since it would
		// have been returned above already if it was

		// Shift existing head down list
		if (head) {
			head.prev = node;
			node.next = head;
		} else {
			// If no head, follows that there's no tail (at initial or reset)
			tail = node;
		}

		// Trim tail if we're reached max size and are pending cache insertion
		if (size === /** @type {MemizeOptions} */ (options).maxSize) {
			tail = /** @type {MemizeCacheNode} */ (tail).prev;
			/** @type {MemizeCacheNode} */ (tail).next = null;
		} else {
			size++;
		}

		head = node;

		return node.val;
	}

	memoized.clear = function () {
		head = null;
		tail = null;
		size = 0;
	};

	// Ignore reason: There's not a clear solution to create an intersection of
	// the function with additional properties, where the goal is to retain the
	// function signature of the incoming argument and add control properties
	// on the return value.

	// @ts-ignore
	return memoized;
}



;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/get-global-styles-changes.js



const globalStylesChangesCache = /* @__PURE__ */ new Map();
const get_global_styles_changes_EMPTY_ARRAY = [];
const translationMap = {
  caption: (0,external_wp_i18n_namespaceObject.__)("Caption"),
  link: (0,external_wp_i18n_namespaceObject.__)("Link"),
  button: (0,external_wp_i18n_namespaceObject.__)("Button"),
  heading: (0,external_wp_i18n_namespaceObject.__)("Heading"),
  h1: (0,external_wp_i18n_namespaceObject.__)("H1"),
  h2: (0,external_wp_i18n_namespaceObject.__)("H2"),
  h3: (0,external_wp_i18n_namespaceObject.__)("H3"),
  h4: (0,external_wp_i18n_namespaceObject.__)("H4"),
  h5: (0,external_wp_i18n_namespaceObject.__)("H5"),
  h6: (0,external_wp_i18n_namespaceObject.__)("H6"),
  "settings.color": (0,external_wp_i18n_namespaceObject.__)("Color"),
  "settings.typography": (0,external_wp_i18n_namespaceObject.__)("Typography"),
  "settings.shadow": (0,external_wp_i18n_namespaceObject.__)("Shadow"),
  "settings.layout": (0,external_wp_i18n_namespaceObject.__)("Layout"),
  "styles.color": (0,external_wp_i18n_namespaceObject.__)("Colors"),
  "styles.spacing": (0,external_wp_i18n_namespaceObject.__)("Spacing"),
  "styles.background": (0,external_wp_i18n_namespaceObject.__)("Background"),
  "styles.typography": (0,external_wp_i18n_namespaceObject.__)("Typography")
};
const getBlockNames = memize(
  () => (0,external_wp_blocks_namespaceObject.getBlockTypes)().reduce((accumulator, { name, title }) => {
    accumulator[name] = title;
    return accumulator;
  }, {})
);
const isObject = (obj) => obj !== null && typeof obj === "object";
function getTranslation(key) {
  if (translationMap[key]) {
    return translationMap[key];
  }
  const keyArray = key.split(".");
  if (keyArray?.[0] === "blocks") {
    const blockName = getBlockNames()?.[keyArray[1]];
    return blockName || keyArray[1];
  }
  if (keyArray?.[0] === "elements") {
    return translationMap[keyArray[1]] || keyArray[1];
  }
  return void 0;
}
function deepCompare(changedObject, originalObject, parentPath = "") {
  if (!isObject(changedObject) && !isObject(originalObject)) {
    return changedObject !== originalObject ? parentPath.split(".").slice(0, 2).join(".") : void 0;
  }
  changedObject = isObject(changedObject) ? changedObject : {};
  originalObject = isObject(originalObject) ? originalObject : {};
  const allKeys = /* @__PURE__ */ new Set([
    ...Object.keys(changedObject),
    ...Object.keys(originalObject)
  ]);
  let diffs = [];
  for (const key of allKeys) {
    const path = parentPath ? parentPath + "." + key : key;
    const changedPath = deepCompare(
      changedObject[key],
      originalObject[key],
      path
    );
    if (changedPath) {
      diffs = diffs.concat(changedPath);
    }
  }
  return diffs;
}
function getGlobalStylesChangelist(next, previous) {
  const cacheKey = JSON.stringify({ next, previous });
  if (globalStylesChangesCache.has(cacheKey)) {
    return globalStylesChangesCache.get(cacheKey);
  }
  const changedValueTree = deepCompare(
    {
      styles: {
        background: next?.styles?.background,
        color: next?.styles?.color,
        typography: next?.styles?.typography,
        spacing: next?.styles?.spacing
      },
      blocks: next?.styles?.blocks,
      elements: next?.styles?.elements,
      settings: next?.settings
    },
    {
      styles: {
        background: previous?.styles?.background,
        color: previous?.styles?.color,
        typography: previous?.styles?.typography,
        spacing: previous?.styles?.spacing
      },
      blocks: previous?.styles?.blocks,
      elements: previous?.styles?.elements,
      settings: previous?.settings
    }
  );
  if (!changedValueTree.length) {
    globalStylesChangesCache.set(cacheKey, get_global_styles_changes_EMPTY_ARRAY);
    return get_global_styles_changes_EMPTY_ARRAY;
  }
  const result = [...new Set(changedValueTree)].reduce((acc, curr) => {
    const translation = getTranslation(curr);
    if (translation) {
      acc.push([curr.split(".")[0], translation]);
    }
    return acc;
  }, []);
  globalStylesChangesCache.set(cacheKey, result);
  return result;
}
function getGlobalStylesChanges(next, previous, options = {}) {
  let changeList = getGlobalStylesChangelist(next, previous);
  const changesLength = changeList.length;
  const { maxResults } = options;
  if (changesLength) {
    if (!!maxResults && changesLength > maxResults) {
      changeList = changeList.slice(0, maxResults);
    }
    return Object.entries(
      changeList.reduce((acc, curr) => {
        const group = acc[curr[0]] || [];
        if (!group.includes(curr[1])) {
          acc[curr[0]] = [...group, curr[1]];
        }
        return acc;
      }, {})
    ).map(([key, changeValues]) => {
      const changeValuesLength = changeValues.length;
      const joinedChangesValue = changeValues.join(
        /* translators: Used between list items, there is a space after the comma. */
        (0,external_wp_i18n_namespaceObject.__)(", ")
        // eslint-disable-line @wordpress/i18n-no-flanking-whitespace
      );
      switch (key) {
        case "blocks": {
          return (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: a list of block names separated by a comma.
            (0,external_wp_i18n_namespaceObject._n)("%s block.", "%s blocks.", changeValuesLength),
            joinedChangesValue
          );
        }
        case "elements": {
          return (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: a list of element names separated by a comma.
            (0,external_wp_i18n_namespaceObject._n)("%s element.", "%s elements.", changeValuesLength),
            joinedChangesValue
          );
        }
        case "settings": {
          return (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: a list of theme.json setting labels separated by a comma.
            (0,external_wp_i18n_namespaceObject.__)("%s settings."),
            joinedChangesValue
          );
        }
        case "styles": {
          return (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: a list of theme.json top-level styles labels separated by a comma.
            (0,external_wp_i18n_namespaceObject.__)("%s styles."),
            joinedChangesValue
          );
        }
        default: {
          return (0,external_wp_i18n_namespaceObject.sprintf)(
            // translators: %s: a list of global styles changes separated by a comma.
            (0,external_wp_i18n_namespaceObject.__)("%s."),
            joinedChangesValue
          );
        }
      }
    });
  }
  return get_global_styles_changes_EMPTY_ARRAY;
}


;// ./node_modules/@wordpress/block-editor/build-module/components/global-styles/index.js
















;// ./node_modules/@wordpress/block-editor/build-module/components/rich-text/get-rich-text-values.js






function addValuesForElement(element, values, innerBlocks) {
  if (null === element || void 0 === element || false === element) {
    return;
  }
  if (Array.isArray(element)) {
    return addValuesForElements(element, values, innerBlocks);
  }
  switch (typeof element) {
    case "string":
    case "number":
      return;
  }
  const { type, props } = element;
  switch (type) {
    case external_wp_element_namespaceObject.StrictMode:
    case external_wp_element_namespaceObject.Fragment:
      return addValuesForElements(props.children, values, innerBlocks);
    case external_wp_element_namespaceObject.RawHTML:
      return;
    case inner_blocks_default.Content:
      return addValuesForBlocks(values, innerBlocks);
    case Content:
      values.push(props.value);
      return;
  }
  switch (typeof type) {
    case "string":
      if (typeof props.children !== "undefined") {
        return addValuesForElements(
          props.children,
          values,
          innerBlocks
        );
      }
      return;
    case "function":
      const el = type.prototype && typeof type.prototype.render === "function" ? new type(props).render() : type(props);
      return addValuesForElement(el, values, innerBlocks);
  }
}
function addValuesForElements(children, ...args) {
  children = Array.isArray(children) ? children : [children];
  for (let i = 0; i < children.length; i++) {
    addValuesForElement(children[i], ...args);
  }
}
function addValuesForBlocks(values, blocks) {
  for (let i = 0; i < blocks.length; i++) {
    const { name, attributes, innerBlocks } = blocks[i];
    const saveElement = (0,external_wp_blocks_namespaceObject.getSaveElement)(
      name,
      attributes,
      // Instead of letting save elements use `useInnerBlocksProps.save`,
      // force them to use InnerBlocks.Content instead so we can intercept
      // a single component.
      /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(inner_blocks_default.Content, {})
    );
    addValuesForElement(saveElement, values, innerBlocks);
  }
}
function getRichTextValues(blocks = []) {
  external_wp_blocks_namespaceObject.__unstableGetBlockProps.skipFilters = true;
  const values = [];
  addValuesForBlocks(values, blocks);
  external_wp_blocks_namespaceObject.__unstableGetBlockProps.skipFilters = false;
  return values.map(
    (value) => value instanceof external_wp_richText_namespaceObject.RichTextData ? value : external_wp_richText_namespaceObject.RichTextData.fromHTMLString(value)
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/resizable-box-popover/index.js



function ResizableBoxPopover({
  clientId,
  resizableBoxProps,
  ...props
}) {
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    cover_default,
    {
      clientId,
      __unstablePopoverSlot: "block-toolbar",
      ...props,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.ResizableBox, { ...resizableBoxProps })
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/block-removal-warning-modal/index.js







function BlockRemovalWarningModal({ rules }) {
  const { clientIds, selectPrevious, message } = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => unlock(select(store)).getRemovalPromptData()
  );
  const {
    clearBlockRemovalPrompt,
    setBlockRemovalRules,
    privateRemoveBlocks
  } = unlock((0,external_wp_data_namespaceObject.useDispatch)(store));
  (0,external_wp_element_namespaceObject.useEffect)(() => {
    setBlockRemovalRules(rules);
    return () => {
      setBlockRemovalRules();
    };
  }, [rules, setBlockRemovalRules]);
  if (!message) {
    return;
  }
  const onConfirmRemoval = () => {
    privateRemoveBlocks(
      clientIds,
      selectPrevious,
      /* force */
      true
    );
    clearBlockRemovalPrompt();
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(
    external_wp_components_namespaceObject.Modal,
    {
      title: (0,external_wp_i18n_namespaceObject.__)("Be careful!"),
      onRequestClose: clearBlockRemovalPrompt,
      size: "medium",
      children: [
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)("p", { children: message }),
        /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalHStack, { justify: "right", children: [
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              variant: "tertiary",
              onClick: clearBlockRemovalPrompt,
              __next40pxDefaultSize: true,
              children: (0,external_wp_i18n_namespaceObject.__)("Cancel")
            }
          ),
          /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.Button,
            {
              variant: "primary",
              onClick: onConfirmRemoval,
              __next40pxDefaultSize: true,
              children: (0,external_wp_i18n_namespaceObject.__)("Delete")
            }
          )
        ] })
      ]
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/scale-tool.js




const DEFAULT_SCALE_OPTIONS = [
  {
    value: "fill",
    label: (0,external_wp_i18n_namespaceObject._x)("Fill", "Scale option for dimensions control"),
    help: (0,external_wp_i18n_namespaceObject.__)("Fill the space by stretching the content.")
  },
  {
    value: "contain",
    label: (0,external_wp_i18n_namespaceObject._x)("Contain", "Scale option for dimensions control"),
    help: (0,external_wp_i18n_namespaceObject.__)("Fit the content to the space without clipping.")
  },
  {
    value: "cover",
    label: (0,external_wp_i18n_namespaceObject._x)("Cover", "Scale option for dimensions control"),
    help: (0,external_wp_i18n_namespaceObject.__)("Fill the space by clipping what doesn't fit.")
  },
  {
    value: "none",
    label: (0,external_wp_i18n_namespaceObject._x)("None", "Scale option for dimensions control"),
    help: (0,external_wp_i18n_namespaceObject.__)(
      "Do not adjust the sizing of the content. Content that is too large will be clipped, and content that is too small will have additional padding."
    )
  },
  {
    value: "scale-down",
    label: (0,external_wp_i18n_namespaceObject._x)("Scale down", "Scale option for dimensions control"),
    help: (0,external_wp_i18n_namespaceObject.__)(
      "Scale down the content to fit the space if it is too big. Content that is too small will have additional padding."
    )
  }
];
function ScaleTool({
  panelId,
  value,
  onChange,
  options = DEFAULT_SCALE_OPTIONS,
  defaultValue = DEFAULT_SCALE_OPTIONS[0].value,
  isShownByDefault = true
}) {
  const displayValue = value ?? "fill";
  const scaleHelp = (0,external_wp_element_namespaceObject.useMemo)(() => {
    return options.reduce((acc, option) => {
      acc[option.value] = option.help;
      return acc;
    }, {});
  }, [options]);
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      label: (0,external_wp_i18n_namespaceObject.__)("Scale"),
      isShownByDefault,
      hasValue: () => displayValue !== defaultValue,
      onDeselect: () => onChange(defaultValue),
      panelId,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.__experimentalToggleGroupControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Scale"),
          isBlock: true,
          help: scaleHelp[displayValue],
          value: displayValue,
          onChange,
          size: "__unstable-large",
          children: options.map((option) => /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
            external_wp_components_namespaceObject.__experimentalToggleGroupControlOption,
            {
              ...option
            },
            option.value
          ))
        }
      )
    }
  );
}


;// ./node_modules/@babel/runtime/helpers/esm/extends.js
function extends_extends() {
  return extends_extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, extends_extends.apply(null, arguments);
}

;// ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}



;// ./node_modules/@emotion/styled/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);



;// ./node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
/*

Based off glamor's StyleSheet, thanks Sunil 

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (false) { var isImportRule; }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (false) {}
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (false) {}
  };

  return StyleSheet;
}();



;// ./node_modules/stylis/src/Utility.js
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs

/**
 * @param {number}
 * @return {string}
 */
var Utility_from = String.fromCharCode

/**
 * @param {object}
 * @return {object}
 */
var Utility_assign = Object.assign

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return Utility_charat(value, 0) ^ 45 ? (((((((length << 2) ^ Utility_charat(value, 0)) << 2) ^ Utility_charat(value, 1)) << 2) ^ Utility_charat(value, 2)) << 2) ^ Utility_charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function Utility_match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function Utility_replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function Utility_charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function Utility_substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function Utility_strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function Utility_sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function Utility_append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function Utility_combine (array, callback) {
	return array.map(callback).join('')
}

;// ./node_modules/stylis/src/Tokenizer.js


var line = 1
var column = 1
var Tokenizer_length = 0
var position = 0
var Tokenizer_character = 0
var characters = ''

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function Tokenizer_copy (root, props) {
	return Utility_assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function Tokenizer_char () {
	return Tokenizer_character
}

/**
 * @return {number}
 */
function prev () {
	Tokenizer_character = position > 0 ? Utility_charat(characters, --position) : 0

	if (column--, Tokenizer_character === 10)
		column = 1, line--

	return Tokenizer_character
}

/**
 * @return {number}
 */
function next () {
	Tokenizer_character = position < Tokenizer_length ? Utility_charat(characters, position++) : 0

	if (column++, Tokenizer_character === 10)
		column = 1, line++

	return Tokenizer_character
}

/**
 * @return {number}
 */
function peek () {
	return Utility_charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return Utility_substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, Tokenizer_length = Utility_strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {string} value
 * @return {string[]}
 */
function Tokenizer_tokenize (value) {
	return dealloc(tokenizer(alloc(value)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (Tokenizer_character = peek())
		if (Tokenizer_character < 33)
			next()
		else
			break

	return token(type) > 2 || token(Tokenizer_character) > 3 ? '' : ' '
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer (children) {
	while (next())
		switch (token(Tokenizer_character)) {
			case 0: append(identifier(position - 1), children)
				break
			case 2: append(delimit(Tokenizer_character), children)
				break
			default: append(from(Tokenizer_character), children)
		}

	return children
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (Tokenizer_character < 48 || Tokenizer_character > 102 || (Tokenizer_character > 57 && Tokenizer_character < 65) || (Tokenizer_character > 70 && Tokenizer_character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (Tokenizer_character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(Tokenizer_character)
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type)
				break
			// \
			case 92:
				next()
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + Tokenizer_character === 47 + 10)
			break
		// /*
		else if (type + Tokenizer_character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + Utility_from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next()

	return slice(index, position)
}

;// ./node_modules/stylis/src/Enum.js
var Enum_MS = '-ms-'
var Enum_MOZ = '-moz-'
var Enum_WEBKIT = '-webkit-'

var COMMENT = 'comm'
var Enum_RULESET = 'rule'
var Enum_DECLARATION = 'decl'

var PAGE = '@page'
var MEDIA = '@media'
var IMPORT = '@import'
var CHARSET = '@charset'
var VIEWPORT = '@viewport'
var SUPPORTS = '@supports'
var DOCUMENT = '@document'
var NAMESPACE = '@namespace'
var Enum_KEYFRAMES = '@keyframes'
var FONT_FACE = '@font-face'
var COUNTER_STYLE = '@counter-style'
var FONT_FEATURE_VALUES = '@font-feature-values'

;// ./node_modules/stylis/src/Serializer.js



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_serialize (children, callback) {
	var output = ''
	var length = Utility_sizeof(children)

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || ''

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_stringify (element, index, children, callback) {
	switch (element.type) {
		case IMPORT: case Enum_DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case Enum_KEYFRAMES: return element.return = element.value + '{' + Serializer_serialize(element.children, callback) + '}'
		case Enum_RULESET: element.value = element.props.join(',')
	}

	return Utility_strlen(children = Serializer_serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

;// ./node_modules/stylis/src/Middleware.js






/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = Utility_sizeof(collection)

	return function (element, index, children, callback) {
		var output = ''

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || ''

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element)
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (element.length > -1)
		if (!element.return)
			switch (element.type) {
				case DECLARATION: element.return = prefix(element.value, element.length, children)
					return
				case KEYFRAMES:
					return serialize([copy(element, {value: replace(element.value, '@', '@' + WEBKIT)})], callback)
				case RULESET:
					if (element.length)
						return combine(element.props, function (value) {
							switch (match(value, /(::plac\w+|:read-\w+)/)) {
								// :read-(only|write)
								case ':read-only': case ':read-write':
									return serialize([copy(element, {props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]})], callback)
								// :placeholder
								case '::placeholder':
									return serialize([
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]})
									], callback)
							}

							return ''
						})
			}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 */
function namespace (element) {
	switch (element.type) {
		case RULESET:
			element.props = element.props.map(function (value) {
				return combine(tokenize(value), function (value, index, children) {
					switch (charat(value, 0)) {
						// \f
						case 12:
							return substr(value, 1, strlen(value))
						// \0 ( + > ~
						case 0: case 40: case 43: case 62: case 126:
							return value
						// :
						case 58:
							if (children[++index] === 'global')
								children[index] = '', children[++index] = '\f' + substr(children[index], index = 1, -1)
						// \s
						case 32:
							return index === 1 ? '' : value
						default:
							switch (index) {
								case 0: element = value
									return sizeof(children) > 1 ? '' : value
								case index = sizeof(children) - 1: case 2:
									return index === 2 ? value + element + element : value + element
								default:
									return value
							}
					}
				})
			})
	}
}

;// ./node_modules/stylis/src/Parser.js




/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(Parser_parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function Parser_parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0
	var offset = 0
	var length = pseudo
	var atrule = 0
	var property = 0
	var previous = 0
	var variable = 1
	var scanning = 1
	var ampersand = 1
	var character = 0
	var type = ''
	var props = rules
	var children = rulesets
	var reference = rule
	var characters = type

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && Utility_charat(characters, length - 1) == 58) {
					if (indexof(characters += Utility_replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character)
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous)
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7)
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						Utility_append(comment(commenter(next(), caret()), root, parent), declarations)
						break
					default:
						characters += '/'
				}
				break
			// {
			case 123 * variable:
				points[index++] = Utility_strlen(characters) * ampersand
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0
					// ;
					case 59 + offset:
						if (property > 0 && (Utility_strlen(characters) - length))
							Utility_append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(Utility_replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)
						break
					// @ ;
					case 59: characters += ';'
					// { rule/at-rule
					default:
						Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)

						if (character === 123)
							if (offset === 0)
								Parser_parse(characters, root, reference, reference, props, rulesets, length, points, children)
							else
								switch (atrule === 99 && Utility_charat(characters, 3) === 110 ? 100 : atrule) {
									// d m s
									case 100: case 109: case 115:
										Parser_parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)
										break
									default:
										Parser_parse(characters, reference, reference, reference, [''], children, 0, points, children)
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo
				break
			// :
			case 58:
				length = 1 + Utility_strlen(characters), property = previous
			default:
				if (variable < 1)
					if (character == 123)
						--variable
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += Utility_from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1)
						break
					// ,
					case 44:
						points[index++] = (Utility_strlen(characters) - 1) * ampersand, ampersand = 1
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next())

						atrule = peek(), offset = length = Utility_strlen(type = characters += identifier(caret())), character++
						break
					// -
					case 45:
						if (previous === 45 && Utility_strlen(characters) == 2)
							variable = 0
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1
	var rule = offset === 0 ? rules : ['']
	var size = Utility_sizeof(rule)

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = Utility_substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : Utility_replace(y, /&\f/g, rule[x])))
				props[k++] = z

	return node(value, root, parent, offset === 0 ? Enum_RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, Utility_from(Tokenizer_char()), Utility_substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, Enum_DECLARATION, Utility_substr(value, 0, length), Utility_substr(value, length + 1, -1), length)
}

;// ./node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js





var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += Utility_from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? children[0].children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function emotion_cache_browser_esm_prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return Enum_WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Enum_WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Enum_WEBKIT + value + Enum_MOZ + value + Enum_MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return Enum_WEBKIT + value + Enum_MS + value + value;
    // order

    case 6165:
      return Enum_WEBKIT + value + Enum_MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return Enum_WEBKIT + value + Utility_replace(value, /(\w+).+(:[^]+)/, Enum_WEBKIT + 'box-$1$2' + Enum_MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return Enum_WEBKIT + value + Enum_MS + 'flex-item-' + Utility_replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return Enum_WEBKIT + value + Enum_MS + 'flex-line-pack' + Utility_replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return Enum_WEBKIT + 'box-' + Utility_replace(value, '-grow', '') + Enum_WEBKIT + value + Enum_MS + Utility_replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return Enum_WEBKIT + Utility_replace(value, /([^-])(transform)/g, '$1' + Enum_WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return Utility_replace(Utility_replace(Utility_replace(value, /(zoom-|grab)/, Enum_WEBKIT + '$1'), /(image-set)/, Enum_WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return Utility_replace(value, /(image-set\([^]*)/, Enum_WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return Utility_replace(Utility_replace(value, /(.+:)(flex-)?(.*)/, Enum_WEBKIT + 'box-pack:$3' + Enum_MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + Enum_WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Utility_replace(value, /(.+)-inline(.+)/, Enum_WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (Utility_strlen(value) - 1 - length > 6) switch (Utility_charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (Utility_charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return Utility_replace(value, /(.+:)(.+)-([^]+)/, '$1' + Enum_WEBKIT + '$2-$3' + '$1' + Enum_MOZ + (Utility_charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? emotion_cache_browser_esm_prefix(Utility_replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (Utility_charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (Utility_charat(value, Utility_strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return Utility_replace(value, ':', ':' + Enum_WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return Utility_replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + Enum_WEBKIT + (Utility_charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + Enum_WEBKIT + '$2$3' + '$1' + Enum_MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (Utility_charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return Enum_WEBKIT + value + Enum_MS + Utility_replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return Enum_WEBKIT + value + Enum_MS + value + value;
  }

  return value;
}

var emotion_cache_browser_esm_prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case Enum_DECLARATION:
      element["return"] = emotion_cache_browser_esm_prefix(element.value, element.length);
      break;

    case Enum_KEYFRAMES:
      return Serializer_serialize([Tokenizer_copy(element, {
        value: Utility_replace(element.value, '@', '@' + Enum_WEBKIT)
      })], callback);

    case Enum_RULESET:
      if (element.length) return Utility_combine(element.props, function (value) {
        switch (Utility_match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(read-\w+)/, ':' + Enum_MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return Serializer_serialize([Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_WEBKIT + 'input-$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, ':' + Enum_MOZ + '$1')]
            }), Tokenizer_copy(element, {
              props: [Utility_replace(value, /:(plac\w+)/, Enum_MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [emotion_cache_browser_esm_prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (false) {}

  if ( key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (false) {}

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (false) {}

  {
    var currentSheet;
    var finalizingPlugins = [Serializer_stringify,  false ? 0 : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return Serializer_serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (false) {}

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

/* harmony default export */ const emotion_cache_browser_esm = (createCache);

;// ./node_modules/@emotion/hash/dist/emotion-hash.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ const emotion_hash_esm = (murmur2);

;// ./node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ const emotion_unitless_esm = (unitlessKeys);

;// ./node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js




var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (emotion_unitless_esm[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (false) { var hyphenatedCache, hyphenPattern, msPattern, oldProcessStyleValue, contentValues, contentValuePattern; }

var noComponentSelectorMessage = (/* unused pure expression or super */ null && ('Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.'));

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (false) {}

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (false) {}

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (false) {}

        break;
      }

    case 'string':
      if (false) { var replaced, matched; }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {}

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (false) {}

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (false) {} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var emotion_serialize_browser_esm_serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {}

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (false) {}

      styles += strings[i];
    }
  }

  var sourceMap;

  if (false) {} // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = emotion_hash_esm(styles) + identifierName;

  if (false) {}

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};



;// ./node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js



var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = external_React_['useInsertion' + 'Effect'] ? external_React_['useInsertion' + 'Effect'] : false;
var emotion_use_insertion_effect_with_fallbacks_browser_esm_useInsertionEffectAlwaysWithSyncFallback =  useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = (/* unused pure expression or super */ null && (useInsertionEffect || useLayoutEffect));



;// ./node_modules/@emotion/react/dist/emotion-element-6a883da9.browser.esm.js









var emotion_element_6a883da9_browser_esm_hasOwnProperty = {}.hasOwnProperty;

var EmotionCacheContext = /* #__PURE__ */(0,external_React_.createContext)( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */emotion_cache_browser_esm({
  key: 'css'
}) : null);

if (false) {}

var CacheProvider = EmotionCacheContext.Provider;
var __unsafe_useEmotionCache = function useEmotionCache() {
  return useContext(EmotionCacheContext);
};

var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/(0,external_React_.forwardRef)(function (props, ref) {
    // the cache will never be null in the browser
    var cache = (0,external_React_.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext = /* #__PURE__ */(0,external_React_.createContext)({});

if (false) {}

var useTheme = function useTheme() {
  return useContext(ThemeContext);
};

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(outerTheme);

    if (false) {}

    return mergedTheme;
  }

  if (false) {}

  return _extends({}, outerTheme, theme);
};

var createCacheWithTheme = /* #__PURE__ */(/* unused pure expression or super */ null && (weakMemoize(function (outerTheme) {
  return weakMemoize(function (theme) {
    return getTheme(outerTheme, theme);
  });
})));
var ThemeProvider = function ThemeProvider(props) {
  var theme = useContext(ThemeContext);

  if (props.theme !== theme) {
    theme = createCacheWithTheme(theme)(props.theme);
  }

  return /*#__PURE__*/createElement(ThemeContext.Provider, {
    value: theme
  }, props.children);
};
function withTheme(Component) {
  var componentName = Component.displayName || Component.name || 'Component';

  var render = function render(props, ref) {
    var theme = useContext(ThemeContext);
    return /*#__PURE__*/createElement(Component, _extends({
      theme: theme,
      ref: ref
    }, props));
  }; // $FlowFixMe


  var WithTheme = /*#__PURE__*/forwardRef(render);
  WithTheme.displayName = "WithTheme(" + componentName + ")";
  return hoistNonReactStatics(WithTheme, Component);
}

var getLastPart = function getLastPart(functionName) {
  // The match may be something like 'Object.createEmotionProps' or
  // 'Loader.prototype.render'
  var parts = functionName.split('.');
  return parts[parts.length - 1];
};

var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine(line) {
  // V8
  var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
  if (match) return getLastPart(match[1]); // Safari / Firefox

  match = /^([A-Za-z0-9$.]+)@/.exec(line);
  if (match) return getLastPart(match[1]);
  return undefined;
};

var internalReactFunctionNames = /* #__PURE__ */new Set(['renderWithHooks', 'processChild', 'finishClassComponent', 'renderToString']); // These identifiers come from error stacks, so they have to be valid JS
// identifiers, thus we only need to replace what is a valid character for JS,
// but not for CSS.

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var getLabelFromStackTrace = function getLabelFromStackTrace(stackTrace) {
  if (!stackTrace) return undefined;
  var lines = stackTrace.split('\n');

  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]); // The first line of V8 stack traces is just "Error"

    if (!functionName) continue; // If we reach one of these, we have gone too far and should quit

    if (internalReactFunctionNames.has(functionName)) break; // The component name is the first function in the stack that starts with an
    // uppercase letter

    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }

  return undefined;
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {
  if (false) {}

  var newProps = {};

  for (var key in props) {
    if (emotion_element_6a883da9_browser_esm_hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when
  // the label hasn't already been computed

  if (false) { var label; }

  return newProps;
};

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var Emotion = /* #__PURE__ */(/* unused pure expression or super */ null && (withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, useContext(ThemeContext));

  if (false) { var labelFromStack; }

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (emotion_element_6a883da9_browser_esm_hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( true || 0)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement(Insertion, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/createElement(WrappedComponent, newProps));
})));

if (false) {}



;// ./node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = "object" !== 'undefined';
function emotion_utils_browser_esm_getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var emotion_utils_browser_esm_registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var emotion_utils_browser_esm_insertStyles = function insertStyles(cache, serialized, isStringTag) {
  emotion_utils_browser_esm_registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};



;// ./node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js








var testOmitPropsOnStringTag = isPropValid;

var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};

var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;

  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }

  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }

  return shouldForwardProp;
};

var emotion_styled_base_browser_esm_ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";

var emotion_styled_base_browser_esm_Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  emotion_utils_browser_esm_registerStyles(cache, serialized, isStringTag);
  var rules = emotion_use_insertion_effect_with_fallbacks_browser_esm_useInsertionEffectAlwaysWithSyncFallback(function () {
    return emotion_utils_browser_esm_insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var createStyled = function createStyled(tag, options) {
  if (false) {}

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }

  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if (false) {}

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {
        if (false) {}

        styles.push(args[i], args[0][i]);
      }
    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


    var Styled = withEmotionCache(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;

      if (props.theme == null) {
        mergedProps = {};

        for (var key in props) {
          mergedProps[key] = props[key];
        }

        mergedProps.theme = (0,external_React_.useContext)(ThemeContext);
      }

      if (typeof props.className === 'string') {
        className = emotion_utils_browser_esm_getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = emotion_serialize_browser_esm_serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};

      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;

        if ( // $FlowFixMe
        finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }

      newProps.className = className;
      newProps.ref = ref;
      return /*#__PURE__*/(0,external_React_.createElement)(external_React_.Fragment, null, /*#__PURE__*/(0,external_React_.createElement)(emotion_styled_base_browser_esm_Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/(0,external_React_.createElement)(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && "production" !== 'production') {} // $FlowFixMe: coerce undefined to string


        return "." + targetClassName;
      }
    });

    Styled.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, extends_extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };

    return Styled;
  };
};

/* harmony default export */ const emotion_styled_base_browser_esm = (createStyled);

;// ./node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js









var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

var newStyled = emotion_styled_base_browser_esm.bind();
tags.forEach(function (tagName) {
  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
  newStyled[tagName] = newStyled(tagName);
});

/* harmony default export */ const emotion_styled_browser_esm = (newStyled);

;// ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/width-height-tool.js




const SingleColumnToolsPanelItem = emotion_styled_browser_esm((0,external_wp_components_namespaceObject.__experimentalToolsPanelItem))`
	grid-column: span 1;
`;
function WidthHeightTool({
  panelId,
  value = {},
  onChange = () => {
  },
  units,
  isShownByDefault = true
}) {
  const width = value.width === "auto" ? "" : value.width ?? "";
  const height = value.height === "auto" ? "" : value.height ?? "";
  const onDimensionChange = (dimension) => (nextDimension) => {
    const nextValue = { ...value };
    if (!nextDimension) {
      delete nextValue[dimension];
    } else {
      nextValue[dimension] = nextDimension;
    }
    onChange(nextValue);
  };
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SingleColumnToolsPanelItem,
      {
        label: (0,external_wp_i18n_namespaceObject.__)("Width"),
        isShownByDefault,
        hasValue: () => width !== "",
        onDeselect: onDimensionChange("width"),
        panelId,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalUnitControl,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Width"),
            placeholder: (0,external_wp_i18n_namespaceObject.__)("Auto"),
            labelPosition: "top",
            units,
            min: 0,
            value: width,
            onChange: onDimensionChange("width"),
            size: "__unstable-large"
          }
        )
      }
    ),
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      SingleColumnToolsPanelItem,
      {
        label: (0,external_wp_i18n_namespaceObject.__)("Height"),
        isShownByDefault,
        hasValue: () => height !== "",
        onDeselect: onDimensionChange("height"),
        panelId,
        children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
          external_wp_components_namespaceObject.__experimentalUnitControl,
          {
            label: (0,external_wp_i18n_namespaceObject.__)("Height"),
            placeholder: (0,external_wp_i18n_namespaceObject.__)("Auto"),
            labelPosition: "top",
            units,
            min: 0,
            value: height,
            onChange: onDimensionChange("height"),
            size: "__unstable-large"
          }
        )
      }
    )
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/components/dimensions-tool/index.js





function DimensionsTool({
  panelId,
  value = {},
  onChange = () => {
  },
  aspectRatioOptions,
  // Default options handled by AspectRatioTool.
  defaultAspectRatio = "auto",
  // Match CSS default value for aspect-ratio.
  scaleOptions,
  // Default options handled by ScaleTool.
  defaultScale = "fill",
  // Match CSS default value for object-fit.
  unitsOptions,
  // Default options handled by UnitControl.
  tools = ["aspectRatio", "widthHeight", "scale"]
}) {
  const width = value.width === void 0 || value.width === "auto" ? null : value.width;
  const height = value.height === void 0 || value.height === "auto" ? null : value.height;
  const aspectRatio = value.aspectRatio === void 0 || value.aspectRatio === "auto" ? null : value.aspectRatio;
  const scale = value.scale === void 0 || value.scale === "fill" ? null : value.scale;
  const [lastScale, setLastScale] = (0,external_wp_element_namespaceObject.useState)(scale);
  const [lastAspectRatio, setLastAspectRatio] = (0,external_wp_element_namespaceObject.useState)(aspectRatio);
  const aspectRatioValue = width && height ? "custom" : lastAspectRatio;
  const showScaleControl = aspectRatio || width && height;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_ReactJSXRuntime_namespaceObject.Fragment, { children: [
    tools.includes("aspectRatio") && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      AspectRatioTool,
      {
        panelId,
        options: aspectRatioOptions,
        defaultValue: defaultAspectRatio,
        value: aspectRatioValue,
        onChange: (nextAspectRatio) => {
          const nextValue = { ...value };
          nextAspectRatio = nextAspectRatio === "auto" ? null : nextAspectRatio;
          setLastAspectRatio(nextAspectRatio);
          if (!nextAspectRatio) {
            delete nextValue.aspectRatio;
          } else {
            nextValue.aspectRatio = nextAspectRatio;
          }
          if (!nextAspectRatio) {
            delete nextValue.scale;
          } else if (lastScale) {
            nextValue.scale = lastScale;
          } else {
            nextValue.scale = defaultScale;
            setLastScale(defaultScale);
          }
          if ("custom" !== nextAspectRatio && width && height) {
            delete nextValue.height;
          }
          onChange(nextValue);
        }
      }
    ),
    tools.includes("widthHeight") && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      WidthHeightTool,
      {
        panelId,
        units: unitsOptions,
        value: { width, height },
        onChange: ({ width: nextWidth, height: nextHeight }) => {
          const nextValue = { ...value };
          nextWidth = nextWidth === "auto" ? null : nextWidth;
          nextHeight = nextHeight === "auto" ? null : nextHeight;
          if (!nextWidth) {
            delete nextValue.width;
          } else {
            nextValue.width = nextWidth;
          }
          if (!nextHeight) {
            delete nextValue.height;
          } else {
            nextValue.height = nextHeight;
          }
          if (nextWidth && nextHeight) {
            delete nextValue.aspectRatio;
          } else if (lastAspectRatio) {
            nextValue.aspectRatio = lastAspectRatio;
          } else {
          }
          if (!lastAspectRatio && !!nextWidth !== !!nextHeight) {
            delete nextValue.scale;
          } else if (lastScale) {
            nextValue.scale = lastScale;
          } else {
            nextValue.scale = defaultScale;
            setLastScale(defaultScale);
          }
          onChange(nextValue);
        }
      }
    ),
    tools.includes("scale") && showScaleControl && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      ScaleTool,
      {
        panelId,
        options: scaleOptions,
        defaultValue: defaultScale,
        value: lastScale,
        onChange: (nextScale) => {
          const nextValue = { ...value };
          nextScale = nextScale === "fill" ? null : nextScale;
          setLastScale(nextScale);
          if (!nextScale) {
            delete nextValue.scale;
          } else {
            nextValue.scale = nextScale;
          }
          onChange(nextValue);
        }
      }
    )
  ] });
}
var dimensions_tool_default = DimensionsTool;


;// ./node_modules/@wordpress/block-editor/build-module/components/resolution-tool/index.js



const DEFAULT_SIZE_OPTIONS = [
  {
    label: (0,external_wp_i18n_namespaceObject._x)("Thumbnail", "Image size option for resolution control"),
    value: "thumbnail"
  },
  {
    label: (0,external_wp_i18n_namespaceObject._x)("Medium", "Image size option for resolution control"),
    value: "medium"
  },
  {
    label: (0,external_wp_i18n_namespaceObject._x)("Large", "Image size option for resolution control"),
    value: "large"
  },
  {
    label: (0,external_wp_i18n_namespaceObject._x)("Full Size", "Image size option for resolution control"),
    value: "full"
  }
];
function ResolutionTool({
  panelId,
  value,
  onChange,
  options = DEFAULT_SIZE_OPTIONS,
  defaultValue = DEFAULT_SIZE_OPTIONS[0].value,
  isShownByDefault = true,
  resetAllFilter
}) {
  const displayValue = value ?? defaultValue;
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
    external_wp_components_namespaceObject.__experimentalToolsPanelItem,
    {
      hasValue: () => displayValue !== defaultValue,
      label: (0,external_wp_i18n_namespaceObject.__)("Resolution"),
      onDeselect: () => onChange(defaultValue),
      isShownByDefault,
      panelId,
      resetAllFilter,
      children: /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
        external_wp_components_namespaceObject.SelectControl,
        {
          __nextHasNoMarginBottom: true,
          label: (0,external_wp_i18n_namespaceObject.__)("Resolution"),
          value: displayValue,
          options,
          onChange,
          help: (0,external_wp_i18n_namespaceObject.__)("Select the size of the source image."),
          size: "__unstable-large"
        }
      )
    }
  );
}


;// ./node_modules/@wordpress/block-editor/build-module/components/html-element-control/messages.js

const htmlElementMessages = {
  a: (0,external_wp_i18n_namespaceObject.__)(
    "The <a> element should be used for links that navigate to a different page or to a different section within the same page."
  ),
  article: (0,external_wp_i18n_namespaceObject.__)(
    "The <article> element should represent a self-contained, syndicatable portion of the document."
  ),
  aside: (0,external_wp_i18n_namespaceObject.__)(
    "The <aside> element should represent a portion of a document whose content is only indirectly related to the document's main content."
  ),
  button: (0,external_wp_i18n_namespaceObject.__)(
    "The <button> element should be used for interactive controls that perform an action on the current page, such as opening a modal or toggling content visibility."
  ),
  div: (0,external_wp_i18n_namespaceObject.__)(
    "The <div> element should only be used if the block is a design element with no semantic meaning."
  ),
  footer: (0,external_wp_i18n_namespaceObject.__)(
    "The <footer> element should represent a footer for its nearest sectioning element (e.g.: <section>, <article>, <main> etc.)."
  ),
  header: (0,external_wp_i18n_namespaceObject.__)(
    "The <header> element should represent introductory content, typically a group of introductory or navigational aids."
  ),
  main: (0,external_wp_i18n_namespaceObject.__)(
    "The <main> element should be used for the primary content of your document only."
  ),
  nav: (0,external_wp_i18n_namespaceObject.__)(
    "The <nav> element should be used to identify groups of links that are intended to be used for website or page content navigation."
  ),
  section: (0,external_wp_i18n_namespaceObject.__)(
    "The <section> element should represent a standalone portion of the document that can't be better represented by another element."
  )
};


;// ./node_modules/@wordpress/block-editor/build-module/components/html-element-control/index.js






function HTMLElementControl({
  tagName,
  onChange,
  clientId,
  options = [
    { label: (0,external_wp_i18n_namespaceObject.__)("Default (<div>)"), value: "div" },
    { label: "<header>", value: "header" },
    { label: "<main>", value: "main" },
    { label: "<section>", value: "section" },
    { label: "<article>", value: "article" },
    { label: "<aside>", value: "aside" },
    { label: "<footer>", value: "footer" }
  ]
}) {
  const checkForMainTag = !!clientId && options.some((option) => option.value === "main");
  const hasMainElementElsewhere = (0,external_wp_data_namespaceObject.useSelect)(
    (select) => {
      if (!checkForMainTag) {
        return false;
      }
      const { getClientIdsWithDescendants, getBlockAttributes } = select(store);
      return getClientIdsWithDescendants().some((id) => {
        if (id === clientId) {
          return false;
        }
        return getBlockAttributes(id)?.tagName === "main";
      });
    },
    [clientId, checkForMainTag]
  );
  const modifiedOptions = options.map((option) => {
    if (option.value === "main" && hasMainElementElsewhere && tagName !== "main") {
      return {
        ...option,
        disabled: true,
        label: (0,external_wp_i18n_namespaceObject.sprintf)(
          /* translators: %s: HTML element name */
          (0,external_wp_i18n_namespaceObject.__)("%s (Already in use)"),
          option.label
        )
      };
    }
    return option;
  });
  return /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsxs)(external_wp_components_namespaceObject.__experimentalVStack, { spacing: 2, className: "block-editor-html-element-control", children: [
    /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(
      external_wp_components_namespaceObject.SelectControl,
      {
        __nextHasNoMarginBottom: true,
        __next40pxDefaultSize: true,
        label: (0,external_wp_i18n_namespaceObject.__)("HTML element"),
        options: modifiedOptions,
        value: tagName,
        onChange,
        help: htmlElementMessages[tagName]
      }
    ),
    tagName === "main" && hasMainElementElsewhere && /* @__PURE__ */ (0,external_ReactJSXRuntime_namespaceObject.jsx)(external_wp_components_namespaceObject.Notice, { status: "warning", isDismissible: false, children: (0,external_wp_i18n_namespaceObject.__)(
      "Multiple <main> elements detected. The duplicate may be in your content or template. This is not valid HTML and may cause accessibility issues. Please change this HTML element."
    ) })
  ] });
}


;// ./node_modules/@wordpress/block-editor/build-module/private-apis.js



































const privateApis = {};
lock(privateApis, {
  ...global_styles_namespaceObject,
  ExperimentalBlockCanvas: ExperimentalBlockCanvas,
  ExperimentalBlockEditorProvider: ExperimentalBlockEditorProvider,
  getDuotoneFilter: getDuotoneFilter,
  getRichTextValues: getRichTextValues,
  PrivateQuickInserter: QuickInserter,
  extractWords: extractWords,
  getNormalizedSearchTerms: getNormalizedSearchTerms,
  normalizeString: normalizeString,
  PrivateListView: PrivateListView,
  ResizableBoxPopover: ResizableBoxPopover,
  useHasBlockToolbar: useHasBlockToolbar,
  cleanEmptyObject: utils_cleanEmptyObject,
  BlockQuickNavigation: BlockQuickNavigation,
  LayoutStyle: LayoutStyle,
  BlockManager: BlockManager,
  BlockRemovalWarningModal: BlockRemovalWarningModal,
  useLayoutClasses: useLayoutClasses,
  useLayoutStyles: useLayoutStyles,
  DimensionsTool: dimensions_tool_default,
  ResolutionTool: ResolutionTool,
  TabbedSidebar: tabbed_sidebar_default,
  TextAlignmentControl: TextAlignmentControl,
  usesContextKey: usesContextKey,
  useFlashEditableBlocks: useFlashEditableBlocks,
  HTMLElementControl: HTMLElementControl,
  useZoomOut: useZoomOut,
  globalStylesDataKey: globalStylesDataKey,
  globalStylesLinksDataKey: globalStylesLinksDataKey,
  selectBlockPatternsKey: selectBlockPatternsKey,
  requiresWrapperOnCopy: requiresWrapperOnCopy,
  PrivateRichText: PrivateRichText,
  PrivateInserterLibrary: PrivateInserterLibrary,
  reusableBlocksSelectKey: reusableBlocksSelectKey,
  PrivateBlockPopover: PrivateBlockPopover,
  PrivatePublishDateTimePicker: PrivatePublishDateTimePicker,
  useSpacingSizes: useSpacingSizes,
  useBlockDisplayTitle: useBlockDisplayTitle,
  __unstableBlockStyleVariationOverridesWithConfig: __unstableBlockStyleVariationOverridesWithConfig,
  setBackgroundStyleDefaults: setBackgroundStyleDefaults,
  sectionRootClientIdKey: sectionRootClientIdKey,
  CommentIconSlotFill: block_comment_icon_slot_default,
  CommentIconToolbarSlotFill: block_comment_icon_toolbar_slot_default,
  mediaEditKey: mediaEditKey,
  useBlockElement: useBlockElement,
  useBlockElementRef: useBlockElementRef
});


;// ./node_modules/@wordpress/block-editor/build-module/index.js










})();

(window.wp = window.wp || {}).blockEditor = __webpack_exports__;
/******/ })()
;