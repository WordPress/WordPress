{"version":3,"sources":["webpack://wp.[name]/webpack/bootstrap","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/objectSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/apply-format.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/char-at.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/concat.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/create-element.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/create.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/get-active-format.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/get-format-type.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/get-selection-end.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/get-selection-start.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/get-text-content.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/index.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/insert-line-separator.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/insert-object.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/insert.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/is-collapsed.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/is-empty.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/is-format-equal.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/join.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/normalise-formats.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/register-format-type.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/remove-format.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/remove.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/replace.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/slice.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/special-characters.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/split.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/store/actions.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/store/index.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/store/reducer.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/store/selectors.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/to-dom.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/to-html-string.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/to-tree.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/toggle-format.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/rich-text/src/unregister-format-type.js","webpack://wp.[name]/./node_modules/memize/index.js","webpack://wp.[name]/./node_modules/rememo/es/rememo.js","webpack://wp.[name]/external {\"this\":[\"wp\",\"compose\"]}","webpack://wp.[name]/external {\"this\":[\"wp\",\"data\"]}","webpack://wp.[name]/external {\"this\":[\"wp\",\"element\"]}","webpack://wp.[name]/external {\"this\":[\"wp\",\"escapeHtml\"]}","webpack://wp.[name]/external {\"this\":[\"wp\",\"hooks\"]}","webpack://wp.[name]/external \"lodash\""],"names":["applyFormat","format","formats","text","start","end","startIndex","endIndex","newFormats","slice","startFormat","find","type","applyFormats","previousFormat","hasType","formatPlaceholder","index","undefined","normaliseFormats","newFormatsAtIndex","filter","push","charAt","concat","values","reduce","accumlator","createElement","html","implementation","createHTMLDocument","body","innerHTML","window","Node","TEXT_NODE","ELEMENT_NODE","createEmptyValue","simpleFindKey","object","value","key","toFormat","attributes","formatType","class","select","getFormatTypeForClassName","replace","className","trim","getFormatTypeForBareElement","name","registeredAttributes","unregisteredAttributes","create","element","range","multilineTag","multilineWrapperTags","removeNode","unwrapNode","filterString","removeAttribute","length","Array","document","createFromElement","createFromMultilineElement","accumulateSelection","accumulator","node","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","nodeType","childNodes","filterRange","nodeValue","currentWrapperTags","hasChildNodes","filterStringComplete","string","nodeName","toLowerCase","lastFormats","lastFormat","newFormat","getAttributes","isFormatEqual","indexOf","isEmpty","OBJECT_REPLACEMENT_CHARACTER","unshift","i","formatIndex","children","LINE_SEPARATOR","hasAttributes","getActiveFormat","getFormatType","getSelectionEnd","getSelectionStart","getTextContent","insertLineSeparator","beforeText","previousLineSeparatorIndex","lastIndexOf","previousLineSeparatorFormats","valueToInsert","insert","insertObject","formatToInsert","isCollapsed","isEmptyLine","format1","format2","attributes1","attributes2","keys1","Object","keys","keys2","join","separator","forEach","formatsAtIndex","lastFormatsAtIndex","EMPTY_ARRAY","registerFormatType","settings","console","error","test","tagName","formatTypeForBareElement","formatTypeForClassName","title","keywords","dispatch","addFormatTypes","getFunctionStackMemoized","memize","previousStack","newFunction","__experimentalGetPropsForEditableTreePreparation","addFilter","OriginalComponent","Component","__experimentalCreatePrepareEditableTree","__experimentalCreateFormatToValue","__experimentalCreateValueToFormat","props","additionalProps","prepareEditableTree","richTextIdentifier","identifier","blockClientId","clientId","__experimentalCreateOnChangeEditableValue","dispatchProps","propKey","propValue","keyPrefix","startsWith","realKey","onChangeEditableValue","hocs","withSelect","sel","__experimentalGetPropsForEditableTreeChangeHandler","withDispatch","disp","mapKeys","compose","removeFormat","filterFormats","remove","pattern","replacement","match","rest","offset","newText","fill","ZERO_WIDTH_NO_BREAK_SPACE","split","splitAtSelection","arguments","nextStart","map","substring","before","after","formatTypes","castArray","removeFormatTypes","names","registerStore","reducer","selectors","actions","state","action","keyBy","omit","combineReducers","getFormatTypes","createSelector","bareElementTagName","elementClassName","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","createEmpty","append","child","ownerDocument","createTextNode","setAttribute","appendChild","appendText","appendData","getLastChild","lastChild","getParent","isText","getText","removeChild","padEmptyLines","createLinePadding","doc","insertBefore","prepareFormats","fn","toDom","startPath","endPath","tree","toTree","onStartIndex","pointer","onEndIndex","isEditableTree","selection","apply","current","applyValue","applySelection","future","firstChild","currentChild","futureNodeType","replaceChild","windowSelection","getSelection","createRange","collapsed","insertData","setStart","setEnd","removeAllRanges","addRange","toHTMLString","createChildrenHTML","parent","splice","createElementHTML","attributeString","isValidAttributeName","escapeAttribute","escapeHTML","fromFormat","elementAttributes","formatsLength","multilineFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","setFormatPlaceholder","character","characterFormats","newNode","toggleFormat","unregisterFormatType","oldFormat","removeFilter"],"mappings":"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EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,KAA+B,GAAG,EAMtC;;AAEF;AACA;;;;;;;;;;;;;ACpHA;AAAa;;AAEb;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACjRD,aAAa,wCAAwC,EAAE,I;;;;;;;;;;;ACAvD,aAAa,qCAAqC,EAAE,I;;;;;;;;;;;ACApD,aAAa,wCAAwC,EAAE,I;;;;;;;;;;;ACAvD,aAAa,2CAA2C,EAAE,I;;;;;;;;;;;ACA1D,aAAa,sCAAsC,EAAE,I;;;;;;;;;;;ACArD,aAAa,iCAAiC,EAAE,I","file":"rich-text.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/rich-text/build-module/index.js\");\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\t{ formats, text, start, end },\n\tformat,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// The selection is collpased.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], { type: format.type } );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\twhile ( find( newFormats[ startIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, startIndex, format );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, endIndex, format );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t// Otherwise, insert a placeholder with the format so new input appears\n\t\t// with the format applied.\n\t\t} else {\n\t\t\tconst previousFormat = newFormats[ startIndex - 1 ] || [];\n\t\t\tconst hasType = find( previousFormat, { type: format.type } );\n\n\t\t\treturn {\n\t\t\t\tformats,\n\t\t\t\ttext,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tformatPlaceholder: {\n\t\t\t\t\tindex: startIndex,\n\t\t\t\t\tformat: hasType ? undefined : format,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tapplyFormats( newFormats, index, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction applyFormats( formats, index, format ) {\n\tif ( formats[ index ] ) {\n\t\tconst newFormatsAtIndex = formats[ index ].filter( ( { type } ) => type !== format.type );\n\t\tnewFormatsAtIndex.push( format );\n\t\tformats[ index ] = newFormatsAtIndex;\n\t} else {\n\t\tformats[ index ] = [ format ];\n\t}\n}\n","/**\n * Gets the character at the specified index, or returns `undefined` if no\n * character was found.\n *\n * @param {Object} value Value to get the character from.\n * @param {string} index Index to use.\n *\n * @return {?string} A one character long string, or undefined.\n */\nexport function charAt( { text }, index ) {\n\treturn text[ index ];\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...[object]} values An array of all values to combine.\n *\n * @return {Object} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + text,\n\t\tformats: accumlator.formats.concat( formats ),\n\t} ) ) );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\tconst { body } = implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\treturn body;\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\n\nimport { isEmpty } from './is-empty';\nimport { isFormatEqual } from './is-format-equal';\nimport { createElement } from './create-element';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n} from './special-characters';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\nfunction createEmptyValue() {\n\treturn { formats: [], text: '' };\n}\n\nfunction simpleFindKey( object, value ) {\n\tfor ( const key in object ) {\n\t\tif ( object[ key ] === value ) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\nfunction toFormat( { type, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForClassName( attributes.class );\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `.replace( ` ${ formatType.className } `, ' ' ).trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForBareElement( type );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type, attributes } : { type };\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\n\tfor ( const name in attributes ) {\n\t\tconst key = simpleFindKey( formatType.attributes, name );\n\n\t\tif ( key ) {\n\t\t\tregisteredAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * @param {?Object}   $1                      Optional named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?string}   $1.text                 Text to create value from.\n * @param {?string}   $1.html                 HTML to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n *\n * @return {Object} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\ttext: text,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tremoveNode,\n\t\tunwrapNode,\n\t\tfilterString,\n\t\tremoveAttribute,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {?Object} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}    $1                      Named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Remove any line breaks in text nodes. They are not content, but used to\n\t// format the HTML. Line breaks in HTML are stored as BR elements.\n\t// See https://www.w3.org/TR/html5/syntax.html#newlines.\n\tconst filterStringComplete = ( string ) => {\n\t\tstring = string.replace( /[\\r\\n]/g, '' );\n\n\t\tif ( filterString ) {\n\t\t\tstring = filterString( string );\n\t\t}\n\n\t\treturn string;\n\t};\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst type = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\tconst text = filterStringComplete( node.nodeValue );\n\t\t\trange = filterRange( node, range, filterStringComplete );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\taccumulator.text += text;\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\t( removeNode && removeNode( node ) ) ||\n\t\t\t( unwrapNode && unwrapNode( node ) && ! node.hasChildNodes() )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( type === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\taccumulator.text += '\\n';\n\t\t\taccumulator.formats.length += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lastFormats = accumulator.formats[ accumulator.formats.length - 1 ];\n\t\tconst lastFormat = lastFormats && lastFormats[ lastFormats.length - 1 ];\n\t\tlet format;\n\t\tlet value;\n\n\t\tif ( ! unwrapNode || ! unwrapNode( node ) ) {\n\t\t\tconst newFormat = toFormat( {\n\t\t\t\ttype,\n\t\t\t\tattributes: getAttributes( {\n\t\t\t\t\telement: node,\n\t\t\t\t\tremoveAttribute,\n\t\t\t\t} ),\n\t\t\t} );\n\n\t\t\tif ( newFormat ) {\n\t\t\t\t// Reuse the last format if it's equal.\n\t\t\t\tif ( isFormatEqual( newFormat, lastFormat ) ) {\n\t\t\t\t\tformat = lastFormat;\n\t\t\t\t} else {\n\t\t\t\t\tformat = newFormat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( multilineWrapperTags && multilineWrapperTags.indexOf( type ) !== -1 ) {\n\t\t\tvalue = createFromMultilineElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tremoveNode,\n\t\t\t\tunwrapNode,\n\t\t\t\tfilterString,\n\t\t\t\tremoveAttribute,\n\t\t\t\tcurrentWrapperTags: [ ...currentWrapperTags, format ],\n\t\t\t} );\n\t\t\tformat = undefined;\n\t\t} else {\n\t\t\tvalue = createFromElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tremoveNode,\n\t\t\t\tunwrapNode,\n\t\t\t\tfilterString,\n\t\t\t\tremoveAttribute,\n\t\t\t} );\n\t\t}\n\n\t\tconst text = value.text;\n\t\tconst start = accumulator.text.length;\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Don't apply the element as formatting if it has no content.\n\t\tif ( isEmpty( value ) && format && ! format.attributes ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { formats } = accumulator;\n\n\t\tif ( format && format.attributes && text.length === 0 ) {\n\t\t\tformat.object = true;\n\t\t\taccumulator.text += OBJECT_REPLACEMENT_CHARACTER;\n\n\t\t\tif ( formats[ start ] ) {\n\t\t\t\tformats[ start ].unshift( format );\n\t\t\t} else {\n\t\t\t\tformats[ start ] = [ format ];\n\t\t\t}\n\t\t} else {\n\t\t\taccumulator.text += text;\n\t\t\taccumulator.formats.length += text.length;\n\n\t\t\tlet i = value.formats.length;\n\n\t\t\t// Optimise for speed.\n\t\t\twhile ( i-- ) {\n\t\t\t\tconst formatIndex = start + i;\n\n\t\t\t\tif ( format ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( format );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = [ format ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( value.formats[ i ] ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( ...value.formats[ i ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = value.formats[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}    $1                      Named argements.\n * @param {?Element}  $1.element              Element to create value from.\n * @param {?Range}    $1.range                Range to create value from.\n * @param {?string}   $1.multilineTag         Multiline tag if the structure is\n *                                            multiline.\n * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\n *                                            nesting is possible.\n * @param {?Function} $1.removeNode           Function to declare whether the\n *                                            given node should be removed.\n * @param {?Function} $1.unwrapNode           Function to declare whether the\n *                                            given node should be unwrapped.\n * @param {?Function} $1.filterString         Function to filter the given\n *                                            string.\n * @param {?Function} $1.removeAttribute      Wether to remove an attribute\n *                                            based on the name.\n * @param {boolean}   $1.currentWrapperTags   Whether to prepend a line\n *                                            separator.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n\tcurrentWrapperTags = [],\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tcurrentWrapperTags,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\t// If a line consists of one single line break (invisible), consider the\n\t\t// line empty, wether this is the browser's doing or not.\n\t\tif ( value.text === '\\n' ) {\n\t\t\tconst start = value.start;\n\t\t\tconst end = value.end;\n\n\t\t\tvalue = createEmptyValue();\n\n\t\t\tif ( start !== undefined ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end !== undefined ) {\n\t\t\t\tvalue.end = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Multiline value text should be separated by a double line break.\n\t\tif ( index !== 0 || currentWrapperTags.length > 0 ) {\n\t\t\tconst formats = currentWrapperTags.length > 0 ? [ currentWrapperTags ] : [ , ];\n\t\t\taccumulator.formats = accumulator.formats.concat( formats );\n\t\t\taccumulator.text += LINE_SEPARATOR;\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\taccumulator.formats = accumulator.formats.concat( value.formats );\n\t\taccumulator.text += value.text;\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}    $1                 Named argements.\n * @param {Element}   $1.element         Element to get attributes from.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {?Object} Attribute object or `undefined` if the element has no\n *                   attributes.\n */\nfunction getAttributes( {\n\telement,\n\tremoveAttribute,\n} ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( removeAttribute && removeAttribute( name ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ name ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {Object} value      Value to inspect.\n * @param {string} formatType Format type to look for.\n *\n * @return {?Object} Active format object of the specified type, or undefined.\n */\nexport function getActiveFormat( { formats, start }, formatType ) {\n\tif ( start === undefined ) {\n\t\treturn;\n\t}\n\n\treturn find( formats[ start ], { type: formatType } );\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {?Object} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( 'core/rich-text' ).getFormatType( name );\n}\n","/**\n * Gets the end index of the current selection, or returns `undefined` if no\n * selection exists. The selection ends right before the character at this\n * index.\n *\n * @param {Object} value Value to get the selection from.\n *\n * @return {?number} Index where the selection ends.\n */\nexport function getSelectionEnd( { end } ) {\n\treturn end;\n}\n","/**\n * Gets the start index of the current selection, or returns `undefined` if no\n * selection exists. The selection starts right before the character at this\n * index.\n *\n * @param {Object} value Value to get the selection from.\n *\n * @return {?number} Index where the selection starts.\n */\nexport function getSelectionStart( { start } ) {\n\treturn start;\n}\n","/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {Object} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text;\n}\n","import './store';\n\nexport { applyFormat } from './apply-format';\nexport { charAt } from './char-at';\nexport { concat } from './concat';\nexport { create } from './create';\nexport { getActiveFormat } from './get-active-format';\nexport { getSelectionEnd } from './get-selection-end';\nexport { getSelectionStart } from './get-selection-start';\nexport { getTextContent } from './get-text-content';\nexport { isCollapsed } from './is-collapsed';\nexport { isEmpty, isEmptyLine } from './is-empty';\nexport { join } from './join';\nexport { registerFormatType } from './register-format-type';\nexport { removeFormat } from './remove-format';\nexport { remove } from './remove';\nexport { replace } from './replace';\nexport { insert } from './insert';\nexport { insertLineSeparator } from './insert-line-separator';\nexport { insertObject } from './insert-object';\nexport { slice } from './slice';\nexport { split } from './split';\nexport { apply, toDom as unstableToDom } from './to-dom';\nexport { toHTMLString } from './to-html-string';\nexport { toggleFormat } from './toggle-format';\nexport { LINE_SEPARATOR } from './special-characters';\nexport { unregisterFormatType } from './unregister-format-type';\n","/**\n * Internal dependencies\n */\n\nimport { getTextContent } from './get-text-content';\nimport { insert } from './insert';\nimport { LINE_SEPARATOR } from './special-characters';\n\n/**\n * Insert a line break character into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value         Value to modify.\n * @param {number} startIndex    Start index.\n * @param {number} endIndex      End index.\n *\n * @return {Object} A new value with the value inserted.\n */\nexport function insertLineSeparator(\n\tvalue,\n\tstartIndex = value.start,\n\tendIndex = value.end,\n) {\n\tconst beforeText = getTextContent( value ).slice( 0, startIndex );\n\tconst previousLineSeparatorIndex = beforeText.lastIndexOf( LINE_SEPARATOR );\n\tconst previousLineSeparatorFormats = value.formats[ previousLineSeparatorIndex ];\n\tlet formats = [ , ];\n\n\tif ( previousLineSeparatorFormats ) {\n\t\tformats = [ previousLineSeparatorFormats ];\n\t}\n\n\tconst valueToInsert = {\n\t\tformats,\n\t\ttext: LINE_SEPARATOR,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\n\nconst OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value          Value to modify.\n * @param {Object} formatToInsert Format to insert as object.\n * @param {number} startIndex     Start index.\n * @param {number} endIndex       End index.\n *\n * @return {Object} A new value with the object inserted.\n */\nexport function insertObject(\n\tvalue,\n\tformatToInsert,\n\tstartIndex,\n\tendIndex\n) {\n\tconst valueToInsert = {\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\tformats: [ [ {\n\t\t\t...formatToInsert,\n\t\t\tobject: true,\n\t\t} ] ],\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {Object} value         Value to modify.\n * @param {string} valueToInsert Value to insert.\n * @param {number} startIndex    Start index.\n * @param {number} endIndex      End index.\n *\n * @return {Object} A new value with the value inserted.\n */\nexport function insert(\n\t{ formats, text, start, end },\n\tvalueToInsert,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats.slice( 0, startIndex ).concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\ttext: text.slice( 0, startIndex ) + valueToInsert.text + text.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param {Object} value The rich text value to check.\n *\n * @return {?boolean} True if the selection is collapsed, false if not,\n *                    undefined if there is no selection.\n */\nexport function isCollapsed( { start, end } ) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","import { LINE_SEPARATOR } from './special-characters';\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {Object} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n\n/**\n * Check if the current collapsed selection is on an empty line in case of a\n * multiline value.\n *\n * @param  {Object} value Value te check.\n *\n * @return {boolean} True if the line is empty, false if not.\n */\nexport function isEmptyLine( { text, start, end } ) {\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\tif ( text.length === 0 ) {\n\t\treturn true;\n\t}\n\n\tif ( start === 0 && text.slice( 0, 1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\tif ( start === text.length && text.slice( -1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\treturn text.slice( start - 1, end + 1 ) === `${ LINE_SEPARATOR }${ LINE_SEPARATOR }`;\n}\n","/**\n * Optimised equality check for format objects.\n *\n * @param {?Object} format1 Format to compare.\n * @param {?Object} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array}         values    An array of values to join.\n * @param {string|Object} separator Separator string or value.\n *\n * @return {Object} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + separator.text + text,\n\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t} ) ) );\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Normalises formats: ensures subsequent equal formats have the same reference.\n *\n * @param  {Object} value Value to normalise formats of.\n *\n * @return {Object} New value with normalised formats.\n */\nexport function normaliseFormats( { formats, text, start, end } ) {\n\tconst newFormats = formats.slice( 0 );\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst lastFormatsAtIndex = newFormats[ index - 1 ];\n\n\t\tif ( lastFormatsAtIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice( 0 );\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst lastFormat = lastFormatsAtIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, lastFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = lastFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn { formats: newFormats, text, start, end };\n}\n","/**\n * External dependencies\n */\nimport { mapKeys } from 'lodash';\nimport memize from 'memize';\n\n/**\n * WordPress dependencies\n */\nimport { select, dispatch, withSelect, withDispatch } from '@wordpress/data';\nimport { addFilter } from '@wordpress/hooks';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Shared reference to an empty array for cases where it is important to avoid\n * returning a new array reference on every invocation, as in a connected or\n * other pure component which performs `shouldComponentUpdate` check on props.\n * This should be used as a last resort, since the normalized data should be\n * maintained by the reducer result in state.\n *\n * @type {Array}\n */\nconst EMPTY_ARRAY = [];\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string} name     Format name.\n * @param {Object} settings Format settings.\n *\n * @return {?WPFormat} The format, if it has been successfully registered;\n *                     otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error(\n\t\t\t'Format names must be strings.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( 'core/rich-text' ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif (\n\t\ttypeof settings.tagName !== 'string' ||\n\t\tsettings.tagName === ''\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format tag names must be a string.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' || settings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select( 'core/rich-text' )\n\t\t\t.getFormatTypeForBareElement( settings.tagName );\n\n\t\tif ( formatTypeForBareElement ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select( 'core/rich-text' )\n\t\t\t.getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error(\n\t\t\t'Format titles must be strings.'\n\t\t);\n\t\treturn;\n\t}\n\n\tdispatch( 'core/rich-text' ).addFormatTypes( settings );\n\n\tconst getFunctionStackMemoized = memize( ( previousStack = EMPTY_ARRAY, newFunction ) => {\n\t\treturn [\n\t\t\t...previousStack,\n\t\t\tnewFunction,\n\t\t];\n\t} );\n\n\tif (\n\t\tsettings.__experimentalGetPropsForEditableTreePreparation\n\t) {\n\t\taddFilter( 'experimentalRichText', name, ( OriginalComponent ) => {\n\t\t\tlet Component = OriginalComponent;\n\t\t\tif (\n\t\t\t\tsettings.__experimentalCreatePrepareEditableTree ||\n\t\t\t\tsettings.__experimentalCreateFormatToValue ||\n\t\t\t\tsettings.__experimentalCreateValueToFormat\n\t\t\t) {\n\t\t\t\tComponent = ( props ) => {\n\t\t\t\t\tconst additionalProps = {};\n\n\t\t\t\t\tif ( settings.__experimentalCreatePrepareEditableTree ) {\n\t\t\t\t\t\tadditionalProps.prepareEditableTree = getFunctionStackMemoized(\n\t\t\t\t\t\t\tprops.prepareEditableTree,\n\t\t\t\t\t\t\tsettings.__experimentalCreatePrepareEditableTree( props[ `format_${ name }` ], {\n\t\t\t\t\t\t\t\trichTextIdentifier: props.identifier,\n\t\t\t\t\t\t\t\tblockClientId: props.clientId,\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( settings.__experimentalCreateOnChangeEditableValue ) {\n\t\t\t\t\t\tconst dispatchProps = Object.keys( props ).reduce( ( accumulator, propKey ) => {\n\t\t\t\t\t\t\tconst propValue = props[ propKey ];\n\t\t\t\t\t\t\tconst keyPrefix = `format_${ name }_dispatch_`;\n\t\t\t\t\t\t\tif ( propKey.startsWith( keyPrefix ) ) {\n\t\t\t\t\t\t\t\tconst realKey = propKey.replace( keyPrefix, '' );\n\n\t\t\t\t\t\t\t\taccumulator[ realKey ] = propValue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t\t}, {} );\n\n\t\t\t\t\t\tadditionalProps.onChangeEditableValue = getFunctionStackMemoized(\n\t\t\t\t\t\t\tprops.onChangeEditableValue,\n\t\t\t\t\t\t\tsettings.__experimentalCreateOnChangeEditableValue( {\n\t\t\t\t\t\t\t\t...props[ `format_${ name }` ],\n\t\t\t\t\t\t\t\t...dispatchProps,\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\trichTextIdentifier: props.identifier,\n\t\t\t\t\t\t\t\tblockClientId: props.clientId,\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn <OriginalComponent\n\t\t\t\t\t\t{ ...props }\n\t\t\t\t\t\t{ ...additionalProps }\n\t\t\t\t\t/>;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst hocs = [\n\t\t\t\twithSelect( ( sel, { clientId, identifier } ) => ( {\n\t\t\t\t\t[ `format_${ name }` ]: settings.__experimentalGetPropsForEditableTreePreparation(\n\t\t\t\t\t\tsel,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t\t\t}\n\t\t\t\t\t),\n\t\t\t\t} ) ),\n\t\t\t];\n\n\t\t\tif ( settings.__experimentalGetPropsForEditableTreeChangeHandler ) {\n\t\t\t\thocs.push( withDispatch( ( disp, { clientId, identifier } ) => {\n\t\t\t\t\tconst dispatchProps = settings.__experimentalGetPropsForEditableTreeChangeHandler(\n\t\t\t\t\t\tdisp,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\treturn mapKeys( dispatchProps, ( value, key ) => {\n\t\t\t\t\t\treturn `format_${ name }_dispatch_${ key }`;\n\t\t\t\t\t} );\n\t\t\t\t} ) );\n\t\t\t}\n\n\t\t\treturn compose( hocs )( Component );\n\t\t} );\n\t}\n\n\treturn settings;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {string} formatType Format type to remove.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function removeFormat(\n\t{ formats, text, start, end },\n\tformatType,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tendIndex++;\n\n\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\tendIndex++;\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter( ( { type } ) => type !== formatType );\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {Object}         value        The value to modify.\n * @param {RegExp|string}  pattern      A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {Object} A new value with replacements applied.\n */\nexport function replace( { formats, text, start, end }, pattern, replacement ) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats.slice( 0, offset ).concat( newFormats, formats.slice( offset + match.length ) );\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, text, start, end } );\n}\n","/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {Object} value       Value to modify.\n * @param {number} startIndex  Start index.\n * @param {number} endIndex    End index.\n *\n * @return {Object} A new extracted value.\n */\nexport function slice(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { formats, text };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","export const LINE_SEPARATOR = '\\u2028';\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\nexport const ZERO_WIDTH_NO_BREAK_SPACE = '\\uFEFF';\n","/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {Object}        value   Value to modify.\n * @param {number|string} string  Start index, or string at which to split.\n * @param {number}        end     End index.\n *\n * @return {Array} An array of new values.\n */\nexport function split( { formats, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n","/**\n * External dependencies\n */\nimport { castArray } from 'lodash';\n\n/**\n * Returns an action object used in signalling that format types have been\n * added.\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: castArray( formatTypes ),\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: castArray( names ),\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { registerStore } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nregisterStore( 'core/rich-text', { reducer, selectors, actions } );\n","/**\n * External dependencies\n */\nimport { keyBy, omit } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...keyBy( action.formatTypes, 'name' ),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn omit( state, action.names );\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n","/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { find } from 'lodash';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [\n\t\tstate.formatTypes,\n\t]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name Format type name.\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\treturn find( getFormatTypes( state ), ( { tagName } ) => {\n\t\treturn bareElementTagName === tagName;\n\t} );\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn find( getFormatTypes( state ), ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction createEmpty() {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\treturn body;\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nfunction padEmptyLines( { element, createLinePadding, multilineWrapperTags } ) {\n\tconst length = element.childNodes.length;\n\tconst doc = element.ownerDocument;\n\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst child = element.childNodes[ index ];\n\n\t\tif ( child.nodeType === TEXT_NODE ) {\n\t\t\tif ( length === 1 && ! child.nodeValue ) {\n\t\t\t\t// Pad if the only child is an empty text node.\n\t\t\t\telement.appendChild( createLinePadding( doc ) );\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tmultilineWrapperTags &&\n\t\t\t\t! child.previousSibling &&\n\t\t\t\tmultilineWrapperTags.indexOf( child.nodeName.toLowerCase() ) !== -1\n\t\t\t) {\n\t\t\t\t// Pad the line if there is no content before a nested wrapper.\n\t\t\t\telement.insertBefore( createLinePadding( doc ), child );\n\t\t\t}\n\n\t\t\tpadEmptyLines( { element: child, createLinePadding, multilineWrapperTags } );\n\t\t}\n\t}\n}\n\nfunction prepareFormats( prepareEditableTree = [], value ) {\n\treturn prepareEditableTree.reduce( ( accumlator, fn ) => {\n\t\treturn fn( accumlator, value.text );\n\t}, value.formats );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( {\n\t\tvalue: {\n\t\t\t...value,\n\t\t\tformats: prepareFormats( prepareEditableTree, value ),\n\t\t},\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree: true,\n\t} );\n\n\tif ( createLinePadding ) {\n\t\tpadEmptyLines( { element: tree, createLinePadding, multilineWrapperTags } );\n\t}\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcreateLinePadding,\n\tprepareEditableTree,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateLinePadding,\n\t\tprepareEditableTree,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\n\twhile ( future.firstChild ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\t\tconst futureNodeType = future.firstChild.nodeType;\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( future.firstChild );\n\t\t} else if (\n\t\t\tfutureNodeType !== currentChild.nodeType ||\n\t\t\tfutureNodeType !== TEXT_NODE ||\n\t\t\tfuture.firstChild.nodeValue !== currentChild.nodeValue\n\t\t) {\n\t\t\tcurrent.replaceChild( future.firstChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( future.firstChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\twindowSelection.removeAllRanges();\n\twindowSelection.addRange( range );\n}\n","/**\n * Internal dependencies\n */\n\nimport {\n\tescapeHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Create an HTML string from a Rich Text value. If a `multilineTag` is\n * provided, text separated by a line separator will be wrapped in it.\n *\n * @param {Object} $1                      Named argements.\n * @param {Object} $1.value                Rich text value.\n * @param {string} $1.multilineTag         Multiline tag.\n * @param {Array}  $1.multilineWrapperTags Tags where lines can be found if\n *                                         nesting is possible.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, multilineTag, multilineWrapperTags } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute( attributes[ key ] ) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML( children ) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children.map( ( child ) => {\n\t\treturn child.text === undefined ? createElementHTML( child ) : escapeHTML( child.text );\n\t} ).join( '' );\n}\n","/**\n * Internal dependencies\n */\n\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZERO_WIDTH_NO_BREAK_SPACE,\n} from './special-characters';\n\nfunction fromFormat( { type, attributes, unregisteredAttributes, object } ) {\n\tconst formatType = getFormatType( type );\n\n\tif ( ! formatType ) {\n\t\treturn { type, attributes, object };\n\t}\n\n\tconst elementAttributes = { ...unregisteredAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes[ name ];\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: elementAttributes,\n\t};\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tmultilineWrapperTags = [],\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n} ) {\n\tconst { formats, text, start, end, formatPlaceholder } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfunction setFormatPlaceholder( pointer, index ) {\n\t\tif ( isEditableTree && formatPlaceholder && formatPlaceholder.index === index ) {\n\t\t\tconst parent = getParent( pointer );\n\n\t\t\tif ( formatPlaceholder.format === undefined ) {\n\t\t\t\tpointer = getParent( parent );\n\t\t\t} else {\n\t\t\t\tpointer = append( parent, fromFormat( formatPlaceholder.format ) );\n\t\t\t}\n\n\t\t\tpointer = append( pointer, ZERO_WIDTH_NO_BREAK_SPACE );\n\t\t}\n\n\t\treturn pointer;\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = ( characterFormats || [] ).reduce( ( accumulator, format ) => {\n\t\t\t\t\tif ( character === LINE_SEPARATOR && multilineWrapperTags.indexOf( format.type ) !== -1 ) {\n\t\t\t\t\t\taccumulator.push( format );\n\t\t\t\t\t\taccumulator.push( multilineFormat );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, [ multilineFormat ] );\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [ ...lastSeparatorFormats, ...( characterFormats || [] ) ];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\tformat === lastCharacterFormats[ formatIndex ] &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append( parent, fromFormat( format ) );\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( format.object ? parent : newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpointer = setFormatPlaceholder( pointer, 0 );\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tif ( character === '\\n' ) {\n\t\t\t\tpointer = append( getParent( pointer ), { type: 'br', object: true } );\n\t\t\t\t// Ensure pointer is text node.\n\t\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t\t} else if ( ! isText( pointer ) ) {\n\t\t\t\tpointer = append( getParent( pointer ), character );\n\t\t\t} else {\n\t\t\t\tappendText( pointer, character );\n\t\t\t}\n\t\t}\n\n\t\tpointer = setFormatPlaceholder( pointer, i + 1 );\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply or remove.\n *\n * @return {Object} A new value with the format applied or removed.\n */\nexport function toggleFormat(\n\tvalue,\n\tformat\n) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\treturn removeFormat( value, format.type );\n\t}\n\n\treturn applyFormat( value, format );\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\nimport { removeFilter } from '@wordpress/hooks';\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {?WPFormat} The previous format value, if it has been successfully\n *                     unregistered; otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( 'core/rich-text' ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error(\n\t\t\t`Format ${ name } is not registered.`\n\t\t);\n\t\treturn;\n\t}\n\n\tif (\n\t\toldFormat.__experimentalCreatePrepareEditableTree &&\n\t\toldFormat.__experimentalGetPropsForEditableTreePreparation\n\t) {\n\t\tremoveFilter( 'experimentalRichText', name );\n\t}\n\n\tdispatch( 'core/rich-text' ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n","module.exports = function memize( fn, options ) {\n\tvar size = 0,\n\t\tmaxSize, head, tail;\n\n\tif ( options && options.maxSize ) {\n\t\tmaxSize = options.maxSize;\n\t}\n\n\tfunction memoized( /* ...args */ ) {\n\t\tvar node = head,\n\t\t\tlen = arguments.length,\n\t\t\targs, i;\n\n\t\tsearchCache: while ( node ) {\n\t\t\t// Perform a shallow equality test to confirm that whether the node\n\t\t\t// under test is a candidate for the arguments passed. Two arrays\n\t\t\t// are shallowly equal if their length matches and each entry is\n\t\t\t// strictly equal between the two sets. Avoid abstracting to a\n\t\t\t// function which could incur an arguments leaking deoptimization.\n\n\t\t\t// Check whether node arguments match arguments length\n\t\t\tif ( node.args.length !== arguments.length ) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check whether node arguments match arguments values\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( node.args[ i ] !== arguments[ i ] ) {\n\t\t\t\t\tnode = node.next;\n\t\t\t\t\tcontinue searchCache;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif ( node !== head ) {\n\t\t\t\t// As tail, shift to previous. Must only shift if not also\n\t\t\t\t// head, since if both head and tail, there is no previous.\n\t\t\t\tif ( node === tail ) {\n\t\t\t\t\ttail = node.prev;\n\t\t\t\t}\n\n\t\t\t\t// Adjust siblings to point to each other. If node was tail,\n\t\t\t\t// this also handles new tail's empty `next` assignment.\n\t\t\t\tnode.prev.next = node.next;\n\t\t\t\tif ( node.next ) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = head;\n\t\t\t\tnode.prev = null;\n\t\t\t\thead.prev = node;\n\t\t\t\thead = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\t// Create a copy of arguments (avoid leaking deoptimization)\n\t\targs = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tnode = {\n\t\t\targs: args,\n\n\t\t\t// Generate the result from original function\n\t\t\tval: fn.apply( null, args )\n\t\t};\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif ( head ) {\n\t\t\thead.prev = node;\n\t\t\tnode.next = head;\n\t\t} else {\n\t\t\t// If no head, follows that there's no tail (at initial or reset)\n\t\t\ttail = node;\n\t\t}\n\n\t\t// Trim tail if we're reached max size and are pending cache insertion\n\t\tif ( size === maxSize ) {\n\t\t\ttail = tail.prev;\n\t\t\ttail.next = null;\n\t\t} else {\n\t\t\tsize++;\n\t\t}\n\n\t\thead = node;\n\n\t\treturn node.val;\n\t}\n\n\tmemoized.clear = function() {\n\t\thead = null;\n\t\ttail = null;\n\t\tsize = 0;\n\t};\n\n\tif ( process.env.NODE_ENV === 'test' ) {\n\t\t// Cache is not exposed in the public API, but used in tests to ensure\n\t\t// expected list progression\n\t\tmemoized.getCache = function() {\n\t\t\treturn [ head, tail, size ];\n\t\t};\n\t}\n\n\treturn memoized;\n};\n","'use strict';\n\nvar LEAF_KEY, hasWeakMap;\n\n/**\n * Arbitrary value used as key for referencing cache object in WeakMap tree.\n *\n * @type {Object}\n */\nLEAF_KEY = {};\n\n/**\n * Whether environment supports WeakMap.\n *\n * @type {boolean}\n */\nhasWeakMap = typeof WeakMap !== 'undefined';\n\n/**\n * Returns the first argument as the sole entry in an array.\n *\n * @param {*} value Value to return.\n *\n * @return {Array} Value returned as entry in array.\n */\nfunction arrayOf( value ) {\n\treturn [ value ];\n}\n\n/**\n * Returns true if the value passed is object-like, or false otherwise. A value\n * is object-like if it can support property assignment, e.g. object or array.\n *\n * @param {*} value Value to test.\n *\n * @return {boolean} Whether value is object-like.\n */\nfunction isObjectLike( value ) {\n\treturn !! value && 'object' === typeof value;\n}\n\n/**\n * Creates and returns a new cache object.\n *\n * @return {Object} Cache object.\n */\nfunction createCache() {\n\tvar cache = {\n\t\tclear: function() {\n\t\t\tcache.head = null;\n\t\t},\n\t};\n\n\treturn cache;\n}\n\n/**\n * Returns true if entries within the two arrays are strictly equal by\n * reference from a starting index.\n *\n * @param {Array}  a         First array.\n * @param {Array}  b         Second array.\n * @param {number} fromIndex Index from which to start comparison.\n *\n * @return {boolean} Whether arrays are shallowly equal.\n */\nfunction isShallowEqual( a, b, fromIndex ) {\n\tvar i;\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( i = fromIndex; i < a.length; i++ ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns a memoized selector function. The getDependants function argument is\n * called before the memoized selector and is expected to return an immutable\n * reference or array of references on which the selector depends for computing\n * its own return value. The memoize cache is preserved only as long as those\n * dependant references remain the same. If getDependants returns a different\n * reference(s), the cache is cleared and the selector value regenerated.\n *\n * @param {Function} selector      Selector function.\n * @param {Function} getDependants Dependant getter returning an immutable\n *                                 reference or array of reference used in\n *                                 cache bust consideration.\n *\n * @return {Function} Memoized selector.\n */\nexport default function( selector, getDependants ) {\n\tvar rootCache, getCache;\n\n\t// Use object source as dependant if getter not provided\n\tif ( ! getDependants ) {\n\t\tgetDependants = arrayOf;\n\t}\n\n\t/**\n\t * Returns the root cache. If WeakMap is supported, this is assigned to the\n\t * root WeakMap cache set, otherwise it is a shared instance of the default\n\t * cache object.\n\t *\n\t * @return {(WeakMap|Object)} Root cache object.\n\t */\n\tfunction getRootCache() {\n\t\treturn rootCache;\n\t}\n\n\t/**\n\t * Returns the cache for a given dependants array. When possible, a WeakMap\n\t * will be used to create a unique cache for each set of dependants. This\n\t * is feasible due to the nature of WeakMap in allowing garbage collection\n\t * to occur on entries where the key object is no longer referenced. Since\n\t * WeakMap requires the key to be an object, this is only possible when the\n\t * dependant is object-like. The root cache is created as a hierarchy where\n\t * each top-level key is the first entry in a dependants set, the value a\n\t * WeakMap where each key is the next dependant, and so on. This continues\n\t * so long as the dependants are object-like. If no dependants are object-\n\t * like, then the cache is shared across all invocations.\n\t *\n\t * @see isObjectLike\n\t *\n\t * @param {Array} dependants Selector dependants.\n\t *\n\t * @return {Object} Cache object.\n\t */\n\tfunction getWeakMapCache( dependants ) {\n\t\tvar caches = rootCache,\n\t\t\tisUniqueByDependants = true,\n\t\t\ti, dependant, map, cache;\n\n\t\tfor ( i = 0; i < dependants.length; i++ ) {\n\t\t\tdependant = dependants[ i ];\n\n\t\t\t// Can only compose WeakMap from object-like key.\n\t\t\tif ( ! isObjectLike( dependant ) ) {\n\t\t\t\tisUniqueByDependants = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Does current segment of cache already have a WeakMap?\n\t\t\tif ( caches.has( dependant ) ) {\n\t\t\t\t// Traverse into nested WeakMap.\n\t\t\t\tcaches = caches.get( dependant );\n\t\t\t} else {\n\t\t\t\t// Create, set, and traverse into a new one.\n\t\t\t\tmap = new WeakMap();\n\t\t\t\tcaches.set( dependant, map );\n\t\t\t\tcaches = map;\n\t\t\t}\n\t\t}\n\n\t\t// We use an arbitrary (but consistent) object as key for the last item\n\t\t// in the WeakMap to serve as our running cache.\n\t\tif ( ! caches.has( LEAF_KEY ) ) {\n\t\t\tcache = createCache();\n\t\t\tcache.isUniqueByDependants = isUniqueByDependants;\n\t\t\tcaches.set( LEAF_KEY, cache );\n\t\t}\n\n\t\treturn caches.get( LEAF_KEY );\n\t}\n\n\t// Assign cache handler by availability of WeakMap\n\tgetCache = hasWeakMap ? getWeakMapCache : getRootCache;\n\n\t/**\n\t * Resets root memoization cache.\n\t */\n\tfunction clear() {\n\t\trootCache = hasWeakMap ? new WeakMap() : createCache();\n\t}\n\n\t// eslint-disable-next-line jsdoc/check-param-names\n\t/**\n\t * The augmented selector call, considering first whether dependants have\n\t * changed before passing it to underlying memoize function.\n\t *\n\t * @param {Object} source    Source object for derivation.\n\t * @param {...*}   extraArgs Additional arguments to pass to selector.\n\t *\n\t * @return {*} Selector result.\n\t */\n\tfunction callSelector( /* source, ...extraArgs */ ) {\n\t\tvar len = arguments.length,\n\t\t\tcache, node, i, args, dependants;\n\n\t\t// Create copy of arguments (avoid leaking deoptimization).\n\t\targs = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tdependants = getDependants.apply( null, args );\n\t\tcache = getCache( dependants );\n\n\t\t// If not guaranteed uniqueness by dependants (primitive type or lack\n\t\t// of WeakMap support), shallow compare against last dependants and, if\n\t\t// references have changed, destroy cache to recalculate result.\n\t\tif ( ! cache.isUniqueByDependants ) {\n\t\t\tif ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\n\t\t\tcache.lastDependants = dependants;\n\t\t}\n\n\t\tnode = cache.head;\n\t\twhile ( node ) {\n\t\t\t// Check whether node arguments match arguments\n\t\t\tif ( ! isShallowEqual( node.args, args, 1 ) ) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif ( node !== cache.head ) {\n\t\t\t\t// Adjust siblings to point to each other.\n\t\t\t\tnode.prev.next = node.next;\n\t\t\t\tif ( node.next ) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = cache.head;\n\t\t\t\tnode.prev = null;\n\t\t\t\tcache.head.prev = node;\n\t\t\t\tcache.head = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\tnode = {\n\t\t\t// Generate the result from original function\n\t\t\tval: selector.apply( null, args ),\n\t\t};\n\n\t\t// Avoid including the source object in the cache.\n\t\targs[ 0 ] = null;\n\t\tnode.args = args;\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif ( cache.head ) {\n\t\t\tcache.head.prev = node;\n\t\t\tnode.next = cache.head;\n\t\t}\n\n\t\tcache.head = node;\n\n\t\treturn node.val;\n\t}\n\n\tcallSelector.getDependants = getDependants;\n\tcallSelector.clear = clear;\n\tclear();\n\n\treturn callSelector;\n}\n","(function() { module.exports = this[\"wp\"][\"compose\"]; }());","(function() { module.exports = this[\"wp\"][\"data\"]; }());","(function() { module.exports = this[\"wp\"][\"element\"]; }());","(function() { module.exports = this[\"wp\"][\"escapeHtml\"]; }());","(function() { module.exports = this[\"wp\"][\"hooks\"]; }());","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}