{"version":3,"sources":["webpack://wp.[name]/webpack/bootstrap","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/dom/src/dom.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/dom/src/focusable.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/dom/src/index.js","webpack://wp.[name]//Users/gziolo/PhpstormProjects/gutenberg/packages/dom/src/tabbable.js","webpack://wp.[name]/external \"lodash\""],"names":["window","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isHorizontalEdge","container","isReverse","includes","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","range","getRangeAt","cloneRange","isCollapsed","collapse","node","startContainer","extentOffset","nodeValue","childNodes","offset","order","parentNode","isVerticalEdge","rangeCount","rangeRect","getRectangleFromRange","buffer","height","editableRect","getBoundingClientRect","top","bottom","collapsed","rect","getClientRects","padNode","document","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","createRange","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","x","y","caretPositionFromPoint","point","setStart","offsetNode","hiddenCaretRangeFromPoint","style","zIndex","placeCaretAtVerticalEdge","mayUseScroll","left","contains","scrollIntoView","nodeType","parentRect","side","padding","parseInt","getPropertyValue","actualY","isTextField","element","nodeName","contentEditable","documentHasSelection","activeElement","isEntirelySelected","endContainer","startOffset","endOffset","getScrollContainer","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","firstChild","replaceTag","createElement","appendChild","replaceChild","SELECTOR","join","isVisible","offsetWidth","offsetHeight","isValidFocusableArea","map","closest","img","querySelector","name","find","context","elements","querySelectorAll","filter","focusable","tabbable","getTabIndex","tabIndex","getAttribute","isTabbableIndex","mapElementToObjectTabbable","index","mapObjectTabbableToElement","object","compareObjectTabbables","a","b","aTabIndex","bTabIndex","findFocusable","sort"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAe;AACf;AACA,iDAAiD,gBAAgB;AACjE;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACRA;AAAA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAA;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACJ;AACI;AACrC;AACf,SAAS,kEAAiB,SAAS,gEAAe,SAAS,kEAAiB;AAC5E,C;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAEA;;;;cAI6BA,M;IAArBC,gB,WAAAA,gB;mBAMJD,MAAM,CAACE,I;IAJVC,S,gBAAAA,S;IACAC,Y,gBAAAA,Y;IACAC,2B,gBAAAA,2B;IACAC,2B,gBAAAA,2B;AAGD;;;;;;;;;;;AAUA,SAASC,kBAAT,CAA6BC,SAA7B,EAAyC;AAAA,MAEvCC,UAFuC,GAMpCD,SANoC,CAEvCC,UAFuC;AAAA,MAGvCC,SAHuC,GAMpCF,SANoC,CAGvCE,SAHuC;AAAA,MAIvCC,YAJuC,GAMpCH,SANoC,CAIvCG,YAJuC;AAAA,MAKvCC,WALuC,GAMpCJ,SANoC,CAKvCI,WALuC;AAQxC,MAAMC,QAAQ,GAAGJ,UAAU,CAACK,uBAAX,CAAoCJ,SAApC,CAAjB,CARwC,CAUxC;AACA;;AACA;AACA;AACA;;AACA,MAAKG,QAAQ,GAAGR,2BAAhB,EAA8C;AAC7C,WAAO,KAAP;AACA;;AAED,MAAKQ,QAAQ,GAAGP,2BAAhB,EAA8C;AAC7C,WAAO,IAAP;AACA;AACD;AAEA;AACA;;;AACA,MAAKO,QAAQ,KAAK,CAAlB,EAAsB;AACrB,WAAOF,YAAY,IAAIC,WAAvB;AACA,GA5BuC,CA8BxC;;;AACA,SAAO,IAAP;AACA;AAED;;;;;;;;;;AAQO,SAASG,gBAAT,CAA2BC,SAA3B,EAAsCC,SAAtC,EAAkD;AACxD,MAAKC,uDAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BF,SAAS,CAACG,OAArC,CAAb,EAA8D;AAC7D,QAAKH,SAAS,CAACI,cAAV,KAA6BJ,SAAS,CAACK,YAA5C,EAA2D;AAC1D,aAAO,KAAP;AACA;;AAED,QAAKJ,SAAL,EAAiB;AAChB,aAAOD,SAAS,CAACI,cAAV,KAA6B,CAApC;AACA;;AAED,WAAOJ,SAAS,CAACM,KAAV,CAAgBC,MAAhB,KAA2BP,SAAS,CAACI,cAA5C;AACA;;AAED,MAAK,CAAEJ,SAAS,CAACQ,iBAAjB,EAAqC;AACpC,WAAO,IAAP;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB,CAjBwD,CAmBxD;;AACA,MAAMC,KAAK,GAAGlB,SAAS,CAACmB,UAAV,CAAsB,CAAtB,EAA0BC,UAA1B,EAAd,CApBwD,CAsBxD;;AACA,MAAK,CAAEpB,SAAS,CAACqB,WAAjB,EAA+B;AAC9BH,SAAK,CAACI,QAAN,CAAgB,CAAEvB,kBAAkB,CAAEC,SAAF,CAApC;AACA;;AAED,MAAIuB,IAAI,GAAGL,KAAK,CAACM,cAAjB;AAEA,MAAIC,YAAJ;;AACA,MAAKhB,SAAL,EAAiB;AAChB;AACAgB,gBAAY,GAAG,CAAf;AACA,GAHD,MAGO,IAAKF,IAAI,CAACG,SAAV,EAAsB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,gBAAY,GAAGF,IAAI,CAACG,SAAL,CAAeX,MAA9B;AACA,GAXM,MAWA;AACN;AACA;AACA;AACA;AACA;AACAU,gBAAY,GAAGF,IAAI,CAACI,UAAL,CAAgBZ,MAA/B;AACA,GAnDuD,CAqDxD;;;AACA,MAAMV,QAAQ,GAAGI,SAAS,GAAG,OAAH,GAAa,KAAvC;AACA,MAAMmB,MAAM,GAAGV,KAAK,WAAMb,QAAN,YAApB;;AACA,MAAKuB,MAAM,KAAKH,YAAhB,EAA+B;AAC9B,WAAO,KAAP;AACA,GA1DuD,CA4DxD;AACA;AACA;;;AACA,MAAMI,KAAK,GAAGpB,SAAS,GAAG,OAAH,GAAa,MAApC;;AACA,SAAQc,IAAI,KAAKf,SAAjB,EAA6B;AAC5B,QAAMsB,UAAU,GAAGP,IAAI,CAACO,UAAxB;;AACA,QAAKA,UAAU,WAAMD,KAAN,WAAV,KAAoCN,IAAzC,EAAgD;AAC/C,aAAO,KAAP;AACA;;AAEDA,QAAI,GAAGO,UAAP;AACA,GAvEuD,CAyExD;;;AACA,SAAO,IAAP;AACA;AAED;;;;;;;;;AAQO,SAASC,cAAT,CAAyBvB,SAAzB,EAAoCC,SAApC,EAAgD;AACtD,MAAKC,uDAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BF,SAAS,CAACG,OAArC,CAAb,EAA8D;AAC7D,WAAOJ,gBAAgB,CAAEC,SAAF,EAAaC,SAAb,CAAvB;AACA;;AAED,MAAK,CAAED,SAAS,CAACQ,iBAAjB,EAAqC;AACpC,WAAO,IAAP;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAMC,KAAK,GAAGlB,SAAS,CAACgC,UAAV,GAAuBhC,SAAS,CAACmB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;;AACA,MAAK,CAAED,KAAP,EAAe;AACd,WAAO,KAAP;AACA;;AAED,MAAMe,SAAS,GAAGC,qBAAqB,CAAEhB,KAAF,CAAvC;;AAEA,MAAK,CAAEe,SAAP,EAAmB;AAClB,WAAO,KAAP;AACA;;AAED,MAAME,MAAM,GAAGF,SAAS,CAACG,MAAV,GAAmB,CAAlC;AACA,MAAMC,YAAY,GAAG7B,SAAS,CAAC8B,qBAAV,EAArB,CAtBsD,CAwBtD;;AACA,MAAK7B,SAAS,IAAIwB,SAAS,CAACM,GAAV,GAAgBJ,MAAhB,GAAyBE,YAAY,CAACE,GAAxD,EAA8D;AAC7D,WAAO,KAAP;AACA,GA3BqD,CA6BtD;;;AACA,MAAK,CAAE9B,SAAF,IAAewB,SAAS,CAACO,MAAV,GAAmBL,MAAnB,GAA4BE,YAAY,CAACG,MAA7D,EAAsE;AACrE,WAAO,KAAP;AACA;;AAED,SAAO,IAAP;AACA;AAED;;;;;;;;AAOO,SAASN,qBAAT,CAAgChB,KAAhC,EAAwC;AAC9C;AACA;AACA;AACA,MAAK,CAAEA,KAAK,CAACuB,SAAb,EAAyB;AACxB,WAAOvB,KAAK,CAACoB,qBAAN,EAAP;AACA;;AAED,MAAII,IAAI,GAAGxB,KAAK,CAACyB,cAAN,GAAwB,CAAxB,CAAX,CAR8C,CAU9C;AACA;AACA;AACA;AACA;;AACA,MAAK,CAAED,IAAP,EAAc;AACb,QAAME,OAAO,GAAGC,QAAQ,CAACC,cAAT,CAAyB,QAAzB,CAAhB;AACA5B,SAAK,CAAC6B,UAAN,CAAkBH,OAAlB;AACAF,QAAI,GAAGxB,KAAK,CAACyB,cAAN,GAAwB,CAAxB,CAAP;AACAC,WAAO,CAACd,UAAR,CAAmBkB,WAAnB,CAAgCJ,OAAhC;AACA;;AAED,SAAOF,IAAP;AACA;AAED;;;;;;;;AAOO,SAASO,gBAAT,CAA2BzC,SAA3B,EAAuC;AAC7C,MAAK,CAAEA,SAAS,CAACQ,iBAAjB,EAAqC;AACpC;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAMC,KAAK,GAAGlB,SAAS,CAACgC,UAAV,GAAuBhC,SAAS,CAACmB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;;AAEA,MAAK,CAAED,KAAP,EAAe;AACd;AACA;;AAED,SAAOgB,qBAAqB,CAAEhB,KAAF,CAA5B;AACA;AAED;;;;;;;AAMO,SAASgC,0BAAT,CAAqC1C,SAArC,EAAgDC,SAAhD,EAA4D;AAClE,MAAK,CAAED,SAAP,EAAmB;AAClB;AACA;;AAED,MAAKE,uDAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BF,SAAS,CAACG,OAArC,CAAb,EAA8D;AAC7DH,aAAS,CAAC2C,KAAV;;AACA,QAAK1C,SAAL,EAAiB;AAChBD,eAAS,CAACI,cAAV,GAA2BJ,SAAS,CAACM,KAAV,CAAgBC,MAA3C;AACAP,eAAS,CAACK,YAAV,GAAyBL,SAAS,CAACM,KAAV,CAAgBC,MAAzC;AACA,KAHD,MAGO;AACNP,eAAS,CAACI,cAAV,GAA2B,CAA3B;AACAJ,eAAS,CAACK,YAAV,GAAyB,CAAzB;AACA;;AACD;AACA;;AAEDL,WAAS,CAAC2C,KAAV;;AAEA,MAAK,CAAE3C,SAAS,CAACQ,iBAAjB,EAAqC;AACpC;AACA,GArBiE,CAuBlE;AACA;AACA;;;AACA,MAAMoC,WAAW,GAAG5C,SAAS,CAAEC,SAAS,GAAG,WAAH,GAAiB,YAA5B,CAA7B,CA1BkE,CA4BlE;AACA;;AACA,MAAK,CAAE2C,WAAP,EAAqB;AACpB;AACA;;AAED,MAAMpD,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAMC,KAAK,GAAG2B,QAAQ,CAACQ,WAAT,EAAd;AAEAnC,OAAK,CAACoC,kBAAN,CAA0BF,WAA1B;AACAlC,OAAK,CAACI,QAAN,CAAgB,CAAEb,SAAlB;AAEAT,WAAS,CAACuD,eAAV;AACAvD,WAAS,CAACwD,QAAV,CAAoBtC,KAApB;AACA;AAED;;;;;;;;;;;;;AAYA,SAASuC,mBAAT,CAA8BC,GAA9B,EAAmCC,CAAnC,EAAsCC,CAAtC,EAA0C;AACzC,MAAKF,GAAG,CAACD,mBAAT,EAA+B;AAC9B,WAAOC,GAAG,CAACD,mBAAJ,CAAyBE,CAAzB,EAA4BC,CAA5B,CAAP;AACA;;AAED,MAAK,CAAEF,GAAG,CAACG,sBAAX,EAAoC;AACnC,WAAO,IAAP;AACA;;AAED,MAAMC,KAAK,GAAGJ,GAAG,CAACG,sBAAJ,CAA4BF,CAA5B,EAA+BC,CAA/B,CAAd,CATyC,CAWzC;AACA;;AACA,MAAK,CAAEE,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAED,MAAM5C,KAAK,GAAGwC,GAAG,CAACL,WAAJ,EAAd;AAEAnC,OAAK,CAAC6C,QAAN,CAAgBD,KAAK,CAACE,UAAtB,EAAkCF,KAAK,CAAClC,MAAxC;AACAV,OAAK,CAACI,QAAN,CAAgB,IAAhB;AAEA,SAAOJ,KAAP;AACA;AAED;;;;;;;;;;;;;;AAYA,SAAS+C,yBAAT,CAAoCP,GAApC,EAAyCC,CAAzC,EAA4CC,CAA5C,EAA+CpD,SAA/C,EAA2D;AAC1DA,WAAS,CAAC0D,KAAV,CAAgBC,MAAhB,GAAyB,OAAzB;AAEA,MAAMjD,KAAK,GAAGuC,mBAAmB,CAAEC,GAAF,EAAOC,CAAP,EAAUC,CAAV,CAAjC;AAEApD,WAAS,CAAC0D,KAAV,CAAgBC,MAAhB,GAAyB,IAAzB;AAEA,SAAOjD,KAAP;AACA;AAED;;;;;;;;;;AAQO,SAASkD,wBAAT,CAAmC5D,SAAnC,EAA8CC,SAA9C,EAAyDiC,IAAzD,EAAqF;AAAA,MAAtB2B,YAAsB,uEAAP,IAAO;;AAC3F,MAAK,CAAE7D,SAAP,EAAmB;AAClB;AACA;;AAED,MAAK,CAAEkC,IAAF,IAAU,CAAElC,SAAS,CAACQ,iBAA3B,EAA+C;AAC9CkC,8BAA0B,CAAE1C,SAAF,EAAaC,SAAb,CAA1B;AACA;AACA,GAR0F,CAU3F;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM0B,MAAM,GAAGO,IAAI,CAACN,MAAL,GAAc,CAA7B;AACA,MAAMC,YAAY,GAAG7B,SAAS,CAAC8B,qBAAV,EAArB;AACA,MAAMqB,CAAC,GAAGjB,IAAI,CAAC4B,IAAf;AACA,MAAMV,CAAC,GAAGnD,SAAS,GAAK4B,YAAY,CAACG,MAAb,GAAsBL,MAA3B,GAAwCE,YAAY,CAACE,GAAb,GAAmBJ,MAA9E;AACA,MAAMnC,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AAEA,MAAIC,KAAK,GAAG+C,yBAAyB,CAAEpB,QAAF,EAAYc,CAAZ,EAAeC,CAAf,EAAkBpD,SAAlB,CAArC;;AAEA,MAAK,CAAEU,KAAF,IAAW,CAAEV,SAAS,CAAC+D,QAAV,CAAoBrD,KAAK,CAACM,cAA1B,CAAlB,EAA+D;AAC9D,QAAK6C,YAAY,KACd,CAAEnD,KAAF,IAAW,CAAEA,KAAK,CAACM,cAArB,IACC,CAAEN,KAAK,CAACM,cAAN,CAAqB+C,QAArB,CAA+B/D,SAA/B,CAFa,CAAjB,EAEmD;AAClD;AACA;AACAA,eAAS,CAACgE,cAAV,CAA0B/D,SAA1B;AACA2D,8BAAwB,CAAE5D,SAAF,EAAaC,SAAb,EAAwBiC,IAAxB,EAA8B,KAA9B,CAAxB;AACA;AACA;;AAEDQ,8BAA0B,CAAE1C,SAAF,EAAaC,SAAb,CAA1B;AACA;AACA,GArC0F,CAuC3F;AACA;;;AACA,MAAKS,KAAK,CAACM,cAAN,CAAqBiD,QAArB,KAAkC9E,SAAvC,EAAmD;AAClD,QAAMmC,UAAU,GAAGZ,KAAK,CAACM,cAAN,CAAqBM,UAAxC;AACA,QAAM4C,UAAU,GAAG5C,UAAU,CAACQ,qBAAX,EAAnB;AACA,QAAMqC,IAAI,GAAGlE,SAAS,GAAG,QAAH,GAAc,KAApC;AACA,QAAMmE,OAAO,GAAGC,QAAQ,CAAEpF,gBAAgB,CAAEqC,UAAF,CAAhB,CAA+BgD,gBAA/B,mBAA6DH,IAA7D,EAAF,EAA0E,EAA1E,CAAR,IAA0F,CAA1G;AACA,QAAMI,OAAO,GAAGtE,SAAS,GAAKiE,UAAU,CAAClC,MAAX,GAAoBoC,OAApB,GAA8BzC,MAAnC,GAAgDuC,UAAU,CAACnC,GAAX,GAAiBqC,OAAjB,GAA2BzC,MAApG;;AAEA,QAAKyB,CAAC,KAAKmB,OAAX,EAAqB;AACpB7D,WAAK,GAAG+C,yBAAyB,CAAEpB,QAAF,EAAYc,CAAZ,EAAeoB,OAAf,EAAwBvE,SAAxB,CAAjC;AACA;AACD;;AAEDR,WAAS,CAACuD,eAAV;AACAvD,WAAS,CAACwD,QAAV,CAAoBtC,KAApB;AACAV,WAAS,CAAC2C,KAAV,GAvD2F,CAwD3F;AACA;;AACAnD,WAAS,CAACuD,eAAV;AACAvD,WAAS,CAACwD,QAAV,CAAoBtC,KAApB;AACA;AAED;;;;;;;;;;;AAUO,SAAS8D,WAAT,CAAsBC,OAAtB,EAAgC;AAAA,MAC9BC,QAD8B,GACgBD,OADhB,CAC9BC,QAD8B;AAAA,MACpBtE,cADoB,GACgBqE,OADhB,CACpBrE,cADoB;AAAA,MACJuE,eADI,GACgBF,OADhB,CACJE,eADI;AAGtC,SACGD,QAAQ,KAAK,OAAb,IAAwBtE,cAAc,KAAK,IAA7C,IACEsE,QAAQ,KAAK,UADf,IAEAC,eAAe,KAAK,MAHrB;AAKA;AAED;;;;;;;AAMO,SAASC,oBAAT,GAAgC;AACtC,MAAKJ,WAAW,CAAEnC,QAAQ,CAACwC,aAAX,CAAhB,EAA6C;AAC5C,WAAO,IAAP;AACA;;AAED,MAAMrF,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAMC,KAAK,GAAGlB,SAAS,CAACgC,UAAV,GAAuBhC,SAAS,CAACmB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;AAEA,SAAOD,KAAK,IAAI,CAAEA,KAAK,CAACuB,SAAxB;AACA;AAED;;;;;;;;;AAQO,SAAS6C,kBAAT,CAA6BL,OAA7B,EAAuC;AAC7C,MAAKvE,uDAAQ,CAAE,CAAE,OAAF,EAAW,UAAX,CAAF,EAA2BuE,OAAO,CAACC,QAAnC,CAAb,EAA6D;AAC5D,WAAOD,OAAO,CAACrE,cAAR,KAA2B,CAA3B,IAAgCqE,OAAO,CAACnE,KAAR,CAAcC,MAAd,KAAyBkE,OAAO,CAACpE,YAAxE;AACA;;AAED,MAAK,CAAEoE,OAAO,CAACjE,iBAAf,EAAmC;AAClC,WAAO,IAAP;AACA;;AAED,MAAMhB,SAAS,GAAGR,MAAM,CAACyB,YAAP,EAAlB;AACA,MAAMC,KAAK,GAAGlB,SAAS,CAACgC,UAAV,GAAuBhC,SAAS,CAACmB,UAAV,CAAsB,CAAtB,CAAvB,GAAmD,IAAjE;;AAEA,MAAK,CAAED,KAAP,EAAe;AACd,WAAO,IAAP;AACA;;AAd4C,MAgBrCM,cAhBqC,GAgBoBN,KAhBpB,CAgBrCM,cAhBqC;AAAA,MAgBrB+D,YAhBqB,GAgBoBrE,KAhBpB,CAgBrBqE,YAhBqB;AAAA,MAgBPC,WAhBO,GAgBoBtE,KAhBpB,CAgBPsE,WAhBO;AAAA,MAgBMC,SAhBN,GAgBoBvE,KAhBpB,CAgBMuE,SAhBN;AAkB7C,SACCjE,cAAc,KAAKyD,OAAnB,IACAM,YAAY,KAAKN,OADjB,IAEAO,WAAW,KAAK,CAFhB,IAGAC,SAAS,KAAKR,OAAO,CAACtD,UAAR,CAAmBZ,MAJlC;AAMA;AAED;;;;;;;;AAOO,SAAS2E,kBAAT,CAA6BnE,IAA7B,EAAoC;AAC1C,MAAK,CAAEA,IAAP,EAAc;AACb;AACA,GAHyC,CAK1C;;;AACA,MAAKA,IAAI,CAACoE,YAAL,GAAoBpE,IAAI,CAACqE,YAA9B,EAA6C;AAC5C;AAD4C,gCAEtBpG,MAAM,CAACC,gBAAP,CAAyB8B,IAAzB,CAFsB;AAAA,QAEpCsE,SAFoC,yBAEpCA,SAFoC;;AAG5C,QAAK,gBAAgBC,IAAhB,CAAsBD,SAAtB,CAAL,EAAyC;AACxC,aAAOtE,IAAP;AACA;AACD,GAZyC,CAc1C;;;AACA,SAAOmE,kBAAkB,CAAEnE,IAAI,CAACO,UAAP,CAAzB;AACA;AAED;;;;;;;;;;;;AAWO,SAASiE,eAAT,CAA0BxE,IAA1B,EAAiC;AACvC;AACA;AACA,MAAIyE,cAAJ;;AACA,SAAUA,cAAc,GAAGzE,IAAI,CAACO,UAAhC,EAA+C;AAC9C,QAAKkE,cAAc,CAACvB,QAAf,KAA4B7E,YAAjC,EAAgD;AAC/C;AACA;AACD;;AAED,MAAK,CAAEoG,cAAP,EAAwB;AACvB,WAAO,IAAP;AACA,GAZsC,CAcvC;AACA;;;AACA,MAAKvG,gBAAgB,CAAEuG,cAAF,CAAhB,CAAmC3F,QAAnC,KAAgD,QAArD,EAAgE;AAC/D,WAAO2F,cAAP;AACA;;AAED,SAAOA,cAAc,CAACC,YAAtB;AACA;AAED;;;;;;;;AAOO,SAASC,OAAT,CAAkBC,aAAlB,EAAiCC,OAAjC,EAA2C;AACjDC,aAAW,CAAED,OAAF,EAAWD,aAAa,CAACrE,UAAzB,CAAX;AACAwE,QAAM,CAAEH,aAAF,CAAN;AACA;AAED;;;;;;;AAMO,SAASG,MAAT,CAAiB/E,IAAjB,EAAwB;AAC9BA,MAAI,CAACO,UAAL,CAAgBkB,WAAhB,CAA6BzB,IAA7B;AACA;AAED;;;;;;;;;AAQO,SAAS8E,WAAT,CAAsBD,OAAtB,EAA+BG,aAA/B,EAA+C;AACrDA,eAAa,CAACzE,UAAd,CAAyB0E,YAAzB,CAAuCJ,OAAvC,EAAgDG,aAAa,CAACE,WAA9D;AACA;AAED;;;;;;;;AAOO,SAASC,MAAT,CAAiBnF,IAAjB,EAAwB;AAC9B,MAAMoF,MAAM,GAAGpF,IAAI,CAACO,UAApB;;AAEA,SAAQP,IAAI,CAACqF,UAAb,EAA0B;AACzBD,UAAM,CAACH,YAAP,CAAqBjF,IAAI,CAACqF,UAA1B,EAAsCrF,IAAtC;AACA;;AAEDoF,QAAM,CAAC3D,WAAP,CAAoBzB,IAApB;AACA;AAED;;;;;;;;;;AASO,SAASsF,UAAT,CAAqBtF,IAArB,EAA2BZ,OAA3B,EAAoC+C,GAApC,EAA0C;AAChD,MAAM0C,OAAO,GAAG1C,GAAG,CAACoD,aAAJ,CAAmBnG,OAAnB,CAAhB;;AAEA,SAAQY,IAAI,CAACqF,UAAb,EAA0B;AACzBR,WAAO,CAACW,WAAR,CAAqBxF,IAAI,CAACqF,UAA1B;AACA;;AAEDrF,MAAI,CAACO,UAAL,CAAgBkF,YAAhB,CAA8BZ,OAA9B,EAAuC7E,IAAvC;AAEA,SAAO6E,OAAP;AACA;;;;;;;;;;;;;;;;;;AChnBD;;;;;;;;;;;;;;;;;;AAmBA,IAAMa,QAAQ,GAAG,CAChB,YADgB,EAEhB,SAFgB,EAGhB,wBAHgB,EAIhB,4CAJgB,EAKhB,wBALgB,EAMhB,0BANgB,EAOhB,QAPgB,EAQhB,QARgB,EAShB,OATgB,EAUhB,YAVgB,EAWhB,gDAXgB,EAYfC,IAZe,CAYT,GAZS,CAAjB;AAcA;;;;;;;;;AAQA,SAASC,SAAT,CAAoBlC,OAApB,EAA8B;AAC7B,SACCA,OAAO,CAACmC,WAAR,GAAsB,CAAtB,IACAnC,OAAO,CAACoC,YAAR,GAAuB,CADvB,IAEApC,OAAO,CAACtC,cAAR,GAAyB5B,MAAzB,GAAkC,CAHnC;AAKA;AAED;;;;;;;;;;;AASA,SAASuG,oBAAT,CAA+BrC,OAA/B,EAAyC;AACxC,MAAMsC,GAAG,GAAGtC,OAAO,CAACuC,OAAR,CAAiB,WAAjB,CAAZ;;AACA,MAAK,CAAED,GAAP,EAAa;AACZ,WAAO,KAAP;AACA;;AAED,MAAME,GAAG,GAAG5E,QAAQ,CAAC6E,aAAT,CAAwB,kBAAkBH,GAAG,CAACI,IAAtB,GAA6B,IAArD,CAAZ;AACA,SAAO,CAAC,CAAEF,GAAH,IAAUN,SAAS,CAAEM,GAAF,CAA1B;AACA;AAED;;;;;;;;;AAOO,SAASG,IAAT,CAAeC,OAAf,EAAyB;AAC/B,MAAMC,QAAQ,GAAGD,OAAO,CAACE,gBAAR,CAA0Bd,QAA1B,CAAjB;AAEA,SAAO,6FAAKa,QAAL,EAAgBE,MAAhB,CAAwB,UAAE/C,OAAF,EAAe;AAC7C,QAAK,CAAEkC,SAAS,CAAElC,OAAF,CAAhB,EAA8B;AAC7B,aAAO,KAAP;AACA;;AAH4C,QAKrCC,QALqC,GAKxBD,OALwB,CAKrCC,QALqC;;AAM7C,QAAK,WAAWA,QAAhB,EAA2B;AAC1B,aAAOoC,oBAAoB,CAAErC,OAAF,CAA3B;AACA;;AAED,WAAO,IAAP;AACA,GAXM,CAAP;AAYA;;;;;;;;;;;;;AC1FD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AAEO,IAAM9B,KAAK,GAAG;AAAE8E,WAAS,EAATA,uCAAF;AAAaC,UAAQ,EAARA,sCAAQA;AAArB,CAAd;AAEP;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAEA;;;;;;;;;;;;;AAYA,SAASC,WAAT,CAAsBlD,OAAtB,EAAgC;AAC/B,MAAMmD,QAAQ,GAAGnD,OAAO,CAACoD,YAAR,CAAsB,UAAtB,CAAjB;AACA,SAAOD,QAAQ,KAAK,IAAb,GAAoB,CAApB,GAAwBvD,QAAQ,CAAEuD,QAAF,EAAY,EAAZ,CAAvC;AACA;AAED;;;;;;;;;AAOO,SAASE,eAAT,CAA0BrD,OAA1B,EAAoC;AAC1C,SAAOkD,WAAW,CAAElD,OAAF,CAAX,KAA2B,CAAC,CAAnC;AACA;AAED;;;;;;;;;;;;AAWA,SAASsD,0BAAT,CAAqCtD,OAArC,EAA8CuD,KAA9C,EAAsD;AACrD,SAAO;AAAEvD,WAAO,EAAPA,OAAF;AAAWuD,SAAK,EAALA;AAAX,GAAP;AACA;AAED;;;;;;;;;;AAQA,SAASC,0BAAT,CAAqCC,MAArC,EAA8C;AAC7C,SAAOA,MAAM,CAACzD,OAAd;AACA;AAED;;;;;;;;;;;;AAUA,SAAS0D,sBAAT,CAAiCC,CAAjC,EAAoCC,CAApC,EAAwC;AACvC,MAAMC,SAAS,GAAGX,WAAW,CAAES,CAAC,CAAC3D,OAAJ,CAA7B;AACA,MAAM8D,SAAS,GAAGZ,WAAW,CAAEU,CAAC,CAAC5D,OAAJ,CAA7B;;AAEA,MAAK6D,SAAS,KAAKC,SAAnB,EAA+B;AAC9B,WAAOH,CAAC,CAACJ,KAAF,GAAUK,CAAC,CAACL,KAAnB;AACA;;AAED,SAAOM,SAAS,GAAGC,SAAnB;AACA;;AAEM,SAASnB,IAAT,CAAeC,OAAf,EAAyB;AAC/B,SAAOmB,uDAAa,CAAEnB,OAAF,CAAb,CACLG,MADK,CACGM,eADH,EAELf,GAFK,CAEAgB,0BAFA,EAGLU,IAHK,CAGCN,sBAHD,EAILpB,GAJK,CAIAkB,0BAJA,CAAP;AAKA;;;;;;;;;;;;ACvFD,aAAa,iCAAiC,EAAE,I","file":"dom.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/dom/build-module/index.js\");\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","/**\n * External dependencies\n */\nimport { includes } from 'lodash';\n\n/**\n * Browser dependencies\n */\n\nconst { getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst {\n\t\tanchorNode,\n\t\tfocusNode,\n\t\tanchorOffset,\n\t\tfocusOffset,\n\t} = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\t// Create copy of range for setting selection to find effective offset.\n\tconst range = selection.getRangeAt( 0 ).cloneRange();\n\n\t// Collapse in direction of selection.\n\tif ( ! selection.isCollapsed ) {\n\t\trange.collapse( ! isSelectionForward( selection ) );\n\t}\n\n\tlet node = range.startContainer;\n\n\tlet extentOffset;\n\tif ( isReverse ) {\n\t\t// When in reverse, range node should be first.\n\t\textentOffset = 0;\n\t} else if ( node.nodeValue ) {\n\t\t// Otherwise, vary by node type. A text node has no children. Its range\n\t\t// offset reflects its position in nodeValue.\n\t\t//\n\t\t// \"If the startContainer is a Node of type Text, Comment, or\n\t\t// CDATASection, then the offset is the number of characters from the\n\t\t// start of the startContainer to the boundary point of the Range.\"\n\t\t//\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue\n\t\textentOffset = node.nodeValue.length;\n\t} else {\n\t\t// \"For other Node types, the startOffset is the number of child nodes\n\t\t// between the start of the startContainer and the boundary point of\n\t\t// the Range.\"\n\t\t//\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Range/startOffset\n\t\textentOffset = node.childNodes.length;\n\t}\n\n\t// Offset of range should be at expected extent.\n\tconst position = isReverse ? 'start' : 'end';\n\tconst offset = range[ `${ position }Offset` ];\n\tif ( offset !== extentOffset ) {\n\t\treturn false;\n\t}\n\n\t// If confirmed to be at extent, traverse up through DOM, verifying that\n\t// the node is at first or last child for reverse or forward respectively.\n\t// Continue until container is reached.\n\tconst order = isReverse ? 'first' : 'last';\n\twhile ( node !== container ) {\n\t\tconst parentNode = node.parentNode;\n\t\tif ( parentNode[ `${ order }Child` ] !== node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tnode = parentNode;\n\t}\n\n\t// If reached, range is assumed to be at edge.\n\treturn true;\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\treturn isHorizontalEdge( container, isReverse );\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\tif ( ! range ) {\n\t\treturn false;\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst buffer = rangeRect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\n\t// Too low.\n\tif ( isReverse && rangeRect.top - buffer > editableRect.top ) {\n\t\treturn false;\n\t}\n\n\t// Too high.\n\tif ( ! isReverse && rangeRect.bottom + buffer < editableRect.bottom ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Element} container Editable container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( container ) {\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = null;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge( container, isReverse, rect, mayUseScroll = true ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse ? ( editableRect.bottom - buffer ) : ( editableRect.top + buffer );\n\tconst selection = window.getSelection();\n\n\tlet range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif ( mayUseScroll && (\n\t\t\t( ! range || ! range.startContainer ) ||\n\t\t\t\t! range.startContainer.contains( container ) ) ) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Check if the closest text node is actually further away.\n\t// If so, attempt to get the range again with the y position adjusted to get the right offset.\n\tif ( range.startContainer.nodeType === TEXT_NODE ) {\n\t\tconst parentNode = range.startContainer.parentNode;\n\t\tconst parentRect = parentNode.getBoundingClientRect();\n\t\tconst side = isReverse ? 'bottom' : 'top';\n\t\tconst padding = parseInt( getComputedStyle( parentNode ).getPropertyValue( `padding-${ side }` ), 10 ) || 0;\n\t\tconst actualY = isReverse ? ( parentRect.bottom - padding - buffer ) : ( parentRect.top + padding + buffer );\n\n\t\tif ( y !== actualY ) {\n\t\t\trange = hiddenCaretRangeFromPoint( document, x, actualY, container );\n\t\t}\n\t}\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\tconst { nodeName, selectionStart, contentEditable } = element;\n\n\treturn (\n\t\t( nodeName === 'INPUT' && selectionStart !== null ) ||\n\t\t( nodeName === 'TEXTAREA' ) ||\n\t\tcontentEditable === 'true'\n\t);\n}\n\n/**\n * Check wether the current document has a selection.\n * This checks both for focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\tif ( isTextField( document.activeElement ) ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn element.selectionStart === 0 && element.value.length === element.selectionEnd;\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\treturn (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n * @param {Document} doc     The document of the node.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName, doc ) {\n\tconst newNode = doc.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n","/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\nconst SELECTOR = [\n\t'[tabindex]',\n\t'a[href]',\n\t'button:not([disabled])',\n\t'input:not([type=\"hidden\"]):not([disabled])',\n\t'select:not([disabled])',\n\t'textarea:not([disabled])',\n\t'iframe',\n\t'object',\n\t'embed',\n\t'area[href]',\n\t'[contenteditable]:not([contenteditable=false])',\n].join( ',' );\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {Element} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {Element} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\tconst img = document.querySelector( 'img[usemap=\"#' + map.name + '\"]' );\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context Element in which to search.\n *\n * @return {Element[]} Focusable elements.\n */\nexport function find( context ) {\n\tconst elements = context.querySelectorAll( SELECTOR );\n\n\treturn [ ...elements ].filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea( element );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n","/**\n * Internal dependencies\n */\nimport * as focusable from './focusable';\nimport * as tabbable from './tabbable';\n\nexport const focus = { focusable, tabbable };\n\nexport * from './dom';\n","/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {?number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {Element} element Element.\n * @param {number}  index   Array index of element.\n *\n * @return {Object} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {Object} object Mapped object with index.\n *\n * @return {Element} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {Object} a First object to compare.\n * @param {Object} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\nexport function find( context ) {\n\treturn findFocusable( context )\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement );\n}\n","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}