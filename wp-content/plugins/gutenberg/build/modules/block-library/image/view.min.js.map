{
  "version": 3,
  "sources": ["../../../../packages/block-library/src/image/view.js", "../../../../packages/block-library/src/image/constants.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport {\n\tstore,\n\tgetContext,\n\tgetElement,\n\twithSyncEvent,\n\twithScope,\n} from '@wordpress/interactivity';\n\n/**\n * Internal dependencies\n */\nimport { IMAGE_PRELOAD_DELAY } from './constants';\n\n/**\n * Tracks whether user is touching screen; used to differentiate behavior for\n * touch and mouse input.\n *\n * @type {boolean}\n */\nlet isTouching = false;\n\n/**\n * Tracks the last time the screen was touched; used to differentiate behavior\n * for touch and mouse input.\n *\n * @type {number}\n */\nlet lastTouchTime = 0;\n\n/**\n * Returns the appropriate src URL for an image.\n *\n * @param {string} uploadedSrc - Full size image src.\n * @return {string} The source URL.\n */\nfunction getImageSrc( { uploadedSrc } ) {\n\treturn (\n\t\tuploadedSrc ||\n\t\t'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n\t);\n}\n\n/**\n * Returns the appropriate srcset for an image.\n *\n * @param {string} lightboxSrcset - Image srcset.\n * @return {string} The srcset value.\n */\nfunction getImageSrcset( { lightboxSrcset } ) {\n\treturn lightboxSrcset || '';\n}\n\nconst { state, actions, callbacks } = store(\n\t'core/image',\n\t{\n\t\tstate: {\n\t\t\tcurrentImageId: null,\n\t\t\tpreloadTimers: new Map(),\n\t\t\tpreloadedImageIds: new Set(),\n\t\t\tget currentImage() {\n\t\t\t\treturn state.metadata[ state.currentImageId ];\n\t\t\t},\n\t\t\tget overlayOpened() {\n\t\t\t\treturn state.currentImageId !== null;\n\t\t\t},\n\t\t\tget roleAttribute() {\n\t\t\t\treturn state.overlayOpened ? 'dialog' : null;\n\t\t\t},\n\t\t\tget ariaModal() {\n\t\t\t\treturn state.overlayOpened ? 'true' : null;\n\t\t\t},\n\t\t\tget enlargedSrc() {\n\t\t\t\treturn getImageSrc( state.currentImage );\n\t\t\t},\n\t\t\tget enlargedSrcset() {\n\t\t\t\treturn getImageSrcset( state.currentImage );\n\t\t\t},\n\t\t\tget figureStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.currentImage.figureStyles?.replace(\n\t\t\t\t\t\t/margin[^;]*;?/g,\n\t\t\t\t\t\t''\n\t\t\t\t\t) };`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget imgStyles() {\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayOpened &&\n\t\t\t\t\t`${ state.currentImage.imgStyles?.replace(\n\t\t\t\t\t\t/;$/,\n\t\t\t\t\t\t''\n\t\t\t\t\t) }; object-fit:cover;`\n\t\t\t\t);\n\t\t\t},\n\t\t\tget imageButtonRight() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\treturn state.metadata[ imageId ].imageButtonRight;\n\t\t\t},\n\t\t\tget imageButtonTop() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\treturn state.metadata[ imageId ].imageButtonTop;\n\t\t\t},\n\t\t\tget isContentHidden() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\tstate.overlayEnabled && state.currentImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t\tget isContentVisible() {\n\t\t\t\tconst ctx = getContext();\n\t\t\t\treturn (\n\t\t\t\t\t! state.overlayEnabled &&\n\t\t\t\t\tstate.currentImageId === ctx.imageId\n\t\t\t\t);\n\t\t\t},\n\t\t},\n\t\tactions: {\n\t\t\tshowLightbox() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\t// Bails out if the image has not loaded yet.\n\t\t\t\tif ( ! state.metadata[ imageId ].imageRef?.complete ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores the positions of the scroll to fix it until the overlay is\n\t\t\t\t// closed.\n\t\t\t\tstate.scrollTopReset = document.documentElement.scrollTop;\n\t\t\t\tstate.scrollLeftReset = document.documentElement.scrollLeft;\n\n\t\t\t\t// Sets the current expanded image in the state and enables the overlay.\n\t\t\t\tstate.overlayEnabled = true;\n\t\t\t\tstate.currentImageId = imageId;\n\n\t\t\t\t// Computes the styles of the overlay for the animation.\n\t\t\t\tcallbacks.setOverlayStyles();\n\t\t\t},\n\t\t\thideLightbox() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tstate.overlayEnabled = false;\n\n\t\t\t\t\t// Waits until the close animation has completed before allowing a\n\t\t\t\t\t// user to scroll again. The duration of this animation is defined in\n\t\t\t\t\t// the `styles.scss` file, but in any case we should wait a few\n\t\t\t\t\t// milliseconds longer than the duration, otherwise a user may scroll\n\t\t\t\t\t// too soon and cause the animation to look sloppy.\n\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\t// Delays before changing the focus. Otherwise the focus ring will\n\t\t\t\t\t\t// appear on Firefox before the image has finished animating, which\n\t\t\t\t\t\t// looks broken.\n\t\t\t\t\t\tstate.currentImage.buttonRef.focus( {\n\t\t\t\t\t\t\tpreventScroll: true,\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Resets the current image id to mark the overlay as closed.\n\t\t\t\t\t\tstate.currentImageId = null;\n\t\t\t\t\t}, 450 );\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleKeydown: withSyncEvent( ( event ) => {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t// Focuses the close button when the user presses the tab key.\n\t\t\t\t\tif ( event.key === 'Tab' ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tconst { ref } = getElement();\n\t\t\t\t\t\tref.querySelector( 'button' ).focus();\n\t\t\t\t\t}\n\t\t\t\t\t// Closes the lightbox when the user presses the escape key.\n\t\t\t\t\tif ( event.key === 'Escape' ) {\n\t\t\t\t\t\tactions.hideLightbox();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchMove: withSyncEvent( ( event ) => {\n\t\t\t\t// On mobile devices, prevents triggering the scroll event because\n\t\t\t\t// otherwise the page jumps around when it resets the scroll position.\n\t\t\t\t// This also means that closing the lightbox requires that a user\n\t\t\t\t// perform a simple tap. This may be changed in the future if there is a\n\t\t\t\t// better alternative to override or reset the scroll position during\n\t\t\t\t// swipe actions.\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} ),\n\t\t\thandleTouchStart() {\n\t\t\t\tisTouching = true;\n\t\t\t},\n\t\t\thandleTouchEnd() {\n\t\t\t\t// Waits a few milliseconds before resetting to ensure that pinch to\n\t\t\t\t// zoom works consistently on mobile devices when the lightbox is open.\n\t\t\t\tlastTouchTime = Date.now();\n\t\t\t\tisTouching = false;\n\t\t\t},\n\t\t\thandleScroll() {\n\t\t\t\t// Prevents scrolling behaviors that trigger content shift while the\n\t\t\t\t// lightbox is open. It would be better to accomplish through CSS alone,\n\t\t\t\t// but using overflow: hidden is currently the only way to do so and\n\t\t\t\t// that causes a layout to shift and prevents the zoom animation from\n\t\t\t\t// working in some cases because it's not possible to account for the\n\t\t\t\t// layout shift when doing the animation calculations. Instead, it uses\n\t\t\t\t// JavaScript to prevent and reset the scrolling behavior.\n\t\t\t\tif ( state.overlayOpened ) {\n\t\t\t\t\t// Avoids overriding the scroll behavior on mobile devices because\n\t\t\t\t\t// doing so breaks the pinch to zoom functionality, and users should\n\t\t\t\t\t// be able to zoom in further on the high-res image.\n\t\t\t\t\tif ( ! isTouching && Date.now() - lastTouchTime > 450 ) {\n\t\t\t\t\t\t// It doesn't rely on `event.preventDefault()` to prevent scrolling\n\t\t\t\t\t\t// because the scroll event can't be canceled, so it resets the\n\t\t\t\t\t\t// position instead.\n\t\t\t\t\t\twindow.scrollTo(\n\t\t\t\t\t\t\tstate.scrollLeftReset,\n\t\t\t\t\t\t\tstate.scrollTopReset\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpreloadImage() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\t// Bails if it has already been preloaded. This could help\n\t\t\t\t// prevent unnecessary preloading of the same image multiple times,\n\t\t\t\t// leading to duplicate link elements in the document head.\n\t\t\t\tif ( state.preloadedImageIds.has( imageId ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Link element to preload the image.\n\t\t\t\tconst imageMetadata = state.metadata[ imageId ];\n\t\t\t\tconst imageLink = document.createElement( 'link' );\n\t\t\t\timageLink.rel = 'preload';\n\t\t\t\timageLink.as = 'image';\n\t\t\t\timageLink.href = getImageSrc( imageMetadata );\n\n\t\t\t\t// Apply srcset if available for responsive preloading\n\t\t\t\tconst srcset = getImageSrcset( imageMetadata );\n\t\t\t\tif ( srcset ) {\n\t\t\t\t\timageLink.setAttribute( 'imagesrcset', srcset );\n\t\t\t\t\timageLink.setAttribute( 'imagesizes', '100vw' );\n\t\t\t\t}\n\n\t\t\t\tdocument.head.appendChild( imageLink );\n\t\t\t\tstate.preloadedImageIds.add( imageId );\n\t\t\t},\n\t\t\tpreloadImageWithDelay() {\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\tactions.cancelPreload();\n\n\t\t\t\t// Set a new timer to preload the image after a short delay.\n\t\t\t\tconst timerId = setTimeout(\n\t\t\t\t\twithScope( () => {\n\t\t\t\t\t\tactions.preloadImage();\n\t\t\t\t\t\tstate.preloadTimers.delete( imageId );\n\t\t\t\t\t} ),\n\t\t\t\t\tIMAGE_PRELOAD_DELAY\n\t\t\t\t);\n\t\t\t\tstate.preloadTimers.set( imageId, timerId );\n\t\t\t},\n\t\t\tcancelPreload() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tif ( state.preloadTimers.has( imageId ) ) {\n\t\t\t\t\tclearTimeout( state.preloadTimers.get( imageId ) );\n\t\t\t\t\tstate.preloadTimers.delete( imageId );\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tcallbacks: {\n\t\t\tsetOverlayStyles() {\n\t\t\t\tif ( ! state.overlayEnabled ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth: originalWidth,\n\t\t\t\t\toffsetHeight: originalHeight,\n\t\t\t\t} = state.currentImage.imageRef;\n\t\t\t\tlet { x: screenPosX, y: screenPosY } =\n\t\t\t\t\tstate.currentImage.imageRef.getBoundingClientRect();\n\n\t\t\t\t// Natural ratio of the image clicked to open the lightbox.\n\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t// Original ratio of the image clicked to open the lightbox.\n\t\t\t\tlet originalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// If it has object-fit: contain, recalculates the original sizes\n\t\t\t\t// and the screen position without the blank spaces.\n\t\t\t\tif ( state.currentImage.scaleAttr === 'contain' ) {\n\t\t\t\t\tif ( naturalRatio > originalRatio ) {\n\t\t\t\t\t\tconst heightWithoutSpace = originalWidth / naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the top space.\n\t\t\t\t\t\tscreenPosY +=\n\t\t\t\t\t\t\t( originalHeight - heightWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalHeight = heightWithoutSpace;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst widthWithoutSpace = originalHeight * naturalRatio;\n\t\t\t\t\t\t// Recalculates screen position without the left space.\n\t\t\t\t\t\tscreenPosX += ( originalWidth - widthWithoutSpace ) / 2;\n\t\t\t\t\t\toriginalWidth = widthWithoutSpace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalRatio = originalWidth / originalHeight;\n\n\t\t\t\t// Typically, it uses the image's full-sized dimensions. If those\n\t\t\t\t// dimensions have not been set (i.e. an external image with only one\n\t\t\t\t// size), the image's dimensions in the lightbox are the same\n\t\t\t\t// as those of the image in the content.\n\t\t\t\tlet imgMaxWidth = parseFloat(\n\t\t\t\t\tstate.currentImage.targetWidth !== 'none'\n\t\t\t\t\t\t? state.currentImage.targetWidth\n\t\t\t\t\t\t: naturalWidth\n\t\t\t\t);\n\t\t\t\tlet imgMaxHeight = parseFloat(\n\t\t\t\t\tstate.currentImage.targetHeight !== 'none'\n\t\t\t\t\t\t? state.currentImage.targetHeight\n\t\t\t\t\t\t: naturalHeight\n\t\t\t\t);\n\n\t\t\t\t// Ratio of the biggest image stored in the database.\n\t\t\t\tlet imgRatio = imgMaxWidth / imgMaxHeight;\n\t\t\t\tlet containerMaxWidth = imgMaxWidth;\n\t\t\t\tlet containerMaxHeight = imgMaxHeight;\n\t\t\t\tlet containerWidth = imgMaxWidth;\n\t\t\t\tlet containerHeight = imgMaxHeight;\n\n\t\t\t\t// Checks if the target image has a different ratio than the original\n\t\t\t\t// one (thumbnail). Recalculates the width and height.\n\t\t\t\tif ( naturalRatio.toFixed( 2 ) !== imgRatio.toFixed( 2 ) ) {\n\t\t\t\t\tif ( naturalRatio > imgRatio ) {\n\t\t\t\t\t\t// If the width is reached before the height, it keeps the maxWidth\n\t\t\t\t\t\t// and recalculates the height unless the difference between the\n\t\t\t\t\t\t// maxHeight and the reducedHeight is higher than the maxWidth,\n\t\t\t\t\t\t// where it keeps the reducedHeight and recalculate the width.\n\t\t\t\t\t\tconst reducedHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\tif ( imgMaxHeight - reducedHeight > imgMaxWidth ) {\n\t\t\t\t\t\t\timgMaxHeight = reducedHeight;\n\t\t\t\t\t\t\timgMaxWidth = reducedHeight * naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxHeight = imgMaxWidth / naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the height is reached before the width, it keeps the maxHeight\n\t\t\t\t\t\t// and recalculate the width unlesss the difference between the\n\t\t\t\t\t\t// maxWidth and the reducedWidth is higher than the maxHeight, where\n\t\t\t\t\t\t// it keeps the reducedWidth and recalculate the height.\n\t\t\t\t\t\tconst reducedWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\tif ( imgMaxWidth - reducedWidth > imgMaxHeight ) {\n\t\t\t\t\t\t\timgMaxWidth = reducedWidth;\n\t\t\t\t\t\t\timgMaxHeight = reducedWidth / naturalRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\timgMaxWidth = imgMaxHeight * naturalRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainerWidth = imgMaxWidth;\n\t\t\t\t\tcontainerHeight = imgMaxHeight;\n\t\t\t\t\timgRatio = imgMaxWidth / imgMaxHeight;\n\n\t\t\t\t\t// Calculates the max size of the container.\n\t\t\t\t\tif ( originalRatio > imgRatio ) {\n\t\t\t\t\t\tcontainerMaxWidth = imgMaxWidth;\n\t\t\t\t\t\tcontainerMaxHeight = containerMaxWidth / originalRatio;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainerMaxHeight = imgMaxHeight;\n\t\t\t\t\t\tcontainerMaxWidth = containerMaxHeight * originalRatio;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the image has been pixelated on purpose, it keeps that size.\n\t\t\t\tif (\n\t\t\t\t\toriginalWidth > containerWidth ||\n\t\t\t\t\toriginalHeight > containerHeight\n\t\t\t\t) {\n\t\t\t\t\tcontainerWidth = originalWidth;\n\t\t\t\t\tcontainerHeight = originalHeight;\n\t\t\t\t}\n\n\t\t\t\t// Calculates the final lightbox image size and the scale factor.\n\t\t\t\t// MaxWidth is either the window container (accounting for padding) or\n\t\t\t\t// the image resolution.\n\t\t\t\tlet horizontalPadding = 0;\n\t\t\t\tif ( window.innerWidth > 480 ) {\n\t\t\t\t\thorizontalPadding = 80;\n\t\t\t\t} else if ( window.innerWidth > 1920 ) {\n\t\t\t\t\thorizontalPadding = 160;\n\t\t\t\t}\n\t\t\t\tconst verticalPadding = 80;\n\n\t\t\t\tconst targetMaxWidth = Math.min(\n\t\t\t\t\twindow.innerWidth - horizontalPadding,\n\t\t\t\t\tcontainerWidth\n\t\t\t\t);\n\t\t\t\tconst targetMaxHeight = Math.min(\n\t\t\t\t\twindow.innerHeight - verticalPadding,\n\t\t\t\t\tcontainerHeight\n\t\t\t\t);\n\t\t\t\tconst targetContainerRatio = targetMaxWidth / targetMaxHeight;\n\n\t\t\t\tif ( originalRatio > targetContainerRatio ) {\n\t\t\t\t\t// If targetMaxWidth is reached before targetMaxHeight.\n\t\t\t\t\tcontainerWidth = targetMaxWidth;\n\t\t\t\t\tcontainerHeight = containerWidth / originalRatio;\n\t\t\t\t} else {\n\t\t\t\t\t// If targetMaxHeight is reached before targetMaxWidth.\n\t\t\t\t\tcontainerHeight = targetMaxHeight;\n\t\t\t\t\tcontainerWidth = containerHeight * originalRatio;\n\t\t\t\t}\n\n\t\t\t\tconst containerScale = originalWidth / containerWidth;\n\t\t\t\tconst lightboxImgWidth =\n\t\t\t\t\timgMaxWidth * ( containerWidth / containerMaxWidth );\n\t\t\t\tconst lightboxImgHeight =\n\t\t\t\t\timgMaxHeight * ( containerHeight / containerMaxHeight );\n\n\t\t\t\t// As of this writing, using the calculations above will render the\n\t\t\t\t// lightbox with a small, erroneous whitespace on the left side of the\n\t\t\t\t// image in iOS Safari, perhaps due to an inconsistency in how browsers\n\t\t\t\t// handle absolute positioning and CSS transformation. In any case,\n\t\t\t\t// adding 1 pixel to the container width and height solves the problem,\n\t\t\t\t// though this can be removed if the issue is fixed in the future.\n\t\t\t\tstate.overlayStyles = `\n\t\t\t\t\t--wp--lightbox-initial-top-position: ${ screenPosY }px;\n\t\t\t\t\t--wp--lightbox-initial-left-position: ${ screenPosX }px;\n\t\t\t\t\t--wp--lightbox-container-width: ${ containerWidth + 1 }px;\n\t\t\t\t\t--wp--lightbox-container-height: ${ containerHeight + 1 }px;\n\t\t\t\t\t--wp--lightbox-image-width: ${ lightboxImgWidth }px;\n\t\t\t\t\t--wp--lightbox-image-height: ${ lightboxImgHeight }px;\n\t\t\t\t\t--wp--lightbox-scale: ${ containerScale };\n\t\t\t\t\t--wp--lightbox-scrollbar-width: ${\n\t\t\t\t\t\twindow.innerWidth - document.documentElement.clientWidth\n\t\t\t\t\t}px;\n\t\t\t\t`;\n\t\t\t},\n\t\t\tsetButtonStyles() {\n\t\t\t\tconst { ref } = getElement();\n\n\t\t\t\t// This guard prevents errors in images with the `srcset`\n\t\t\t\t// attribute, which can dispatch `load` events even after DOM\n\t\t\t\t// removal. Preact doesn't automatically clean up `load` event\n\t\t\t\t// listeners on unmounted `img` elements (see\n\t\t\t\t// https://github.com/preactjs/preact/issues/3141).\n\t\t\t\tif ( ! ref ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { imageId } = getContext();\n\n\t\t\t\tstate.metadata[ imageId ].imageRef = ref;\n\t\t\t\tstate.metadata[ imageId ].currentSrc = ref.currentSrc;\n\n\t\t\t\tconst {\n\t\t\t\t\tnaturalWidth,\n\t\t\t\t\tnaturalHeight,\n\t\t\t\t\toffsetWidth,\n\t\t\t\t\toffsetHeight,\n\t\t\t\t} = ref;\n\n\t\t\t\t// If the image isn't loaded yet, it can't calculate where the button\n\t\t\t\t// should be.\n\t\t\t\tif ( naturalWidth === 0 || naturalHeight === 0 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst figure = ref.parentElement;\n\t\t\t\tconst figureWidth = ref.parentElement.clientWidth;\n\n\t\t\t\t// It needs special handling for the height because a caption will cause\n\t\t\t\t// the figure to be taller than the image, which means it needs to\n\t\t\t\t// account for that when calculating the placement of the button in the\n\t\t\t\t// top right corner of the image.\n\t\t\t\tlet figureHeight = ref.parentElement.clientHeight;\n\t\t\t\tconst caption = figure.querySelector( 'figcaption' );\n\t\t\t\tif ( caption ) {\n\t\t\t\t\tconst captionComputedStyle =\n\t\t\t\t\t\twindow.getComputedStyle( caption );\n\t\t\t\t\tif (\n\t\t\t\t\t\t! [ 'absolute', 'fixed' ].includes(\n\t\t\t\t\t\t\tcaptionComputedStyle.position\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfigureHeight =\n\t\t\t\t\t\t\tfigureHeight -\n\t\t\t\t\t\t\tcaption.offsetHeight -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginTop ) -\n\t\t\t\t\t\t\tparseFloat( captionComputedStyle.marginBottom );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst buttonOffsetTop = figureHeight - offsetHeight;\n\t\t\t\tconst buttonOffsetRight = figureWidth - offsetWidth;\n\n\t\t\t\tlet imageButtonTop = buttonOffsetTop + 16;\n\t\t\t\tlet imageButtonRight = buttonOffsetRight + 16;\n\n\t\t\t\t// In the case of an image with object-fit: contain, the size of the\n\t\t\t\t// <img> element can be larger than the image itself, so it needs to\n\t\t\t\t// calculate where to place the button.\n\t\t\t\tif ( state.metadata[ imageId ].scaleAttr === 'contain' ) {\n\t\t\t\t\t// Natural ratio of the image.\n\t\t\t\t\tconst naturalRatio = naturalWidth / naturalHeight;\n\t\t\t\t\t// Offset ratio of the image.\n\t\t\t\t\tconst offsetRatio = offsetWidth / offsetHeight;\n\n\t\t\t\t\tif ( naturalRatio >= offsetRatio ) {\n\t\t\t\t\t\t// If it reaches the width first, it keeps the width and compute the\n\t\t\t\t\t\t// height.\n\t\t\t\t\t\tconst referenceHeight = offsetWidth / naturalRatio;\n\t\t\t\t\t\timageButtonTop =\n\t\t\t\t\t\t\t( offsetHeight - referenceHeight ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetTop +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t\timageButtonRight = buttonOffsetRight + 16;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If it reaches the height first, it keeps the height and compute\n\t\t\t\t\t\t// the width.\n\t\t\t\t\t\tconst referenceWidth = offsetHeight * naturalRatio;\n\t\t\t\t\t\timageButtonTop = buttonOffsetTop + 16;\n\t\t\t\t\t\timageButtonRight =\n\t\t\t\t\t\t\t( offsetWidth - referenceWidth ) / 2 +\n\t\t\t\t\t\t\tbuttonOffsetRight +\n\t\t\t\t\t\t\t16;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.metadata[ imageId ].imageButtonTop = imageButtonTop;\n\t\t\t\tstate.metadata[ imageId ].imageButtonRight = imageButtonRight;\n\t\t\t},\n\t\t\tsetOverlayFocus() {\n\t\t\t\tif ( state.overlayEnabled ) {\n\t\t\t\t\t// Moves the focus to the dialog when it opens.\n\t\t\t\t\tconst { ref } = getElement();\n\t\t\t\t\tref.focus();\n\t\t\t\t}\n\t\t\t},\n\t\t\tinitTriggerButton() {\n\t\t\t\tconst { imageId } = getContext();\n\t\t\t\tconst { ref } = getElement();\n\t\t\t\tstate.metadata[ imageId ].buttonRef = ref;\n\t\t\t},\n\t\t},\n\t},\n\t{ lock: true }\n);\n", "export const MIN_SIZE = 20;\nexport const LINK_DESTINATION_NONE = 'none';\nexport const LINK_DESTINATION_MEDIA = 'media';\nexport const LINK_DESTINATION_ATTACHMENT = 'attachment';\nexport const LINK_DESTINATION_CUSTOM = 'custom';\nexport const NEW_TAB_REL = [ 'noreferrer', 'noopener' ];\nexport const ALLOWED_MEDIA_TYPES = [ 'image' ];\nexport const MEDIA_ID_NO_FEATURED_IMAGE_SET = 0;\nexport const SIZED_LAYOUTS = [ 'flex', 'grid' ];\nexport const DEFAULT_MEDIA_SIZE_SLUG = 'full';\n\n/**\n * Delay in milliseconds before preloading an image after hovering.\n * This prevents unnecessary preloading during quick scrolling or mouse movements.\n */\nexport const IMAGE_PRELOAD_DELAY = 200;\n"],
  "mappings": "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",
  "names": ["store", "getContext", "getElement", "withSyncEvent", "withScope", "IMAGE_PRELOAD_DELAY", "isTouching", "lastTouchTime", "getImageSrc", "uploadedSrc", "getImageSrcset", "lightboxSrcset", "state", "actions", "callbacks", "store", "imageId", "getContext", "ctx", "withSyncEvent", "event", "ref", "getElement", "imageMetadata", "imageLink", "srcset", "timerId", "withScope", "IMAGE_PRELOAD_DELAY", "naturalWidth", "naturalHeight", "originalWidth", "originalHeight", "screenPosX", "screenPosY", "naturalRatio", "originalRatio", "heightWithoutSpace", "widthWithoutSpace", "imgMaxWidth", "imgMaxHeight", "imgRatio", "containerMaxWidth", "containerMaxHeight", "containerWidth", "containerHeight", "reducedHeight", "reducedWidth", "horizontalPadding", "verticalPadding", "targetMaxWidth", "targetMaxHeight", "targetContainerRatio", "containerScale", "lightboxImgWidth", "lightboxImgHeight", "offsetWidth", "offsetHeight", "figure", "figureWidth", "figureHeight", "caption", "captionComputedStyle", "buttonOffsetTop", "buttonOffsetRight", "imageButtonTop", "imageButtonRight", "offsetRatio", "referenceHeight", "referenceWidth"]
}
