{
  "version": 3,
  "sources": ["../../../packages/is-shallow-equal/src/objects.ts", "../../../packages/is-shallow-equal/src/arrays.ts", "../../../packages/is-shallow-equal/src/index.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport type { ComparableObject } from '.';\n\n/**\n * Returns true if the two objects are shallow equal, or false otherwise.\n *\n * @param a First object to compare.\n * @param b Second object to compare.\n *\n * @return Whether the two objects are shallow equal.\n */\nexport default function isShallowEqualObjects(\n\ta: ComparableObject,\n\tb: ComparableObject\n): boolean {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tconst aKeys = Object.keys( a );\n\tconst bKeys = Object.keys( b );\n\n\tif ( aKeys.length !== bKeys.length ) {\n\t\treturn false;\n\t}\n\n\tlet i = 0;\n\n\twhile ( i < aKeys.length ) {\n\t\tconst key = aKeys[ i ];\n\t\tconst aValue = a[ key ];\n\n\t\tif (\n\t\t\t// In iterating only the keys of the first object after verifying\n\t\t\t// equal lengths, account for the case that an explicit `undefined`\n\t\t\t// value in the first is implicitly undefined in the second.\n\t\t\t//\n\t\t\t// Example: isShallowEqualObjects( { a: undefined }, { b: 5 } )\n\t\t\t( aValue === undefined && ! b.hasOwnProperty( key ) ) ||\n\t\t\taValue !== b[ key ]\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn true;\n}\n", "/**\n * Returns true if the two arrays are shallow equal, or false otherwise.\n *\n * @param a First array to compare.\n * @param b Second array to compare.\n *\n * @return Whether the two arrays are shallow equal.\n */\nexport default function isShallowEqualArrays(\n\ta: unknown[],\n\tb: unknown[]\n): boolean {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( let i = 0, len = a.length; i < len; i++ ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "/**\n * Internal dependencies\n */\nimport isShallowEqualObjects from './objects';\nimport isShallowEqualArrays from './arrays';\n\nexport { default as isShallowEqualObjects } from './objects';\nexport { default as isShallowEqualArrays } from './arrays';\n\nexport type ComparableObject = Record< string, any >;\n\n/**\n * Returns true if the two arrays or objects are shallow equal, or false\n * otherwise. Also handles primitive values, just in case.\n *\n * @param a First object or array to compare.\n * @param b Second object or array to compare.\n *\n * @return Whether the two values are shallow equal.\n */\nexport default function isShallowEqual( a: unknown, b: unknown ): boolean {\n\tif ( a && b ) {\n\t\tif ( a.constructor === Object && b.constructor === Object ) {\n\t\t\treturn isShallowEqualObjects( a, b );\n\t\t} else if ( Array.isArray( a ) && Array.isArray( b ) ) {\n\t\t\treturn isShallowEqualArrays( a, b );\n\t\t}\n\t}\n\n\treturn a === b;\n}\n"],
  "mappings": "oiBAae,SAARA,EACNC,EACAC,EACU,CACV,GAAKD,IAAMC,EACV,MAAO,GAGR,IAAMC,EAAQ,OAAO,KAAMF,CAAE,EACvBG,EAAQ,OAAO,KAAMF,CAAE,EAE7B,GAAKC,EAAM,SAAWC,EAAM,OAC3B,MAAO,GAGR,IAAIC,EAAI,EAER,KAAQA,EAAIF,EAAM,QAAS,CAC1B,IAAMG,EAAMH,EAAOE,CAAE,EACfE,EAASN,EAAGK,CAAI,EAEtB,GAMGC,IAAW,QAAa,CAAEL,EAAE,eAAgBI,CAAI,GAClDC,IAAWL,EAAGI,CAAI,EAElB,MAAO,GAGRD,GACD,CAEA,MAAO,EACR,CC1Ce,SAARG,EACNC,EACAC,EACU,CACV,GAAKD,IAAMC,EACV,MAAO,GAGR,GAAKD,EAAE,SAAWC,EAAE,OACnB,MAAO,GAGR,QAAUC,EAAI,EAAGC,EAAMH,EAAE,OAAQE,EAAIC,EAAKD,IACzC,GAAKF,EAAGE,CAAE,IAAMD,EAAGC,CAAE,EACpB,MAAO,GAIT,MAAO,EACR,CCPe,SAARE,EAAiCC,EAAYC,EAAsB,CACzE,GAAKD,GAAKC,EAAI,CACb,GAAKD,EAAE,cAAgB,QAAUC,EAAE,cAAgB,OAClD,OAAOC,EAAuBF,EAAGC,CAAE,EACpC,GAAY,MAAM,QAASD,CAAE,GAAK,MAAM,QAASC,CAAE,EAClD,OAAOE,EAAsBH,EAAGC,CAAE,CAEpC,CAEA,OAAOD,IAAMC,CACd",
  "names": ["isShallowEqualObjects", "a", "b", "aKeys", "bKeys", "i", "key", "aValue", "isShallowEqualArrays", "a", "b", "i", "len", "isShallowEqual", "a", "b", "isShallowEqualObjects", "isShallowEqualArrays"]
}
