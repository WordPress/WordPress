{
  "version": 3,
  "sources": ["package-external:@wordpress/is-shallow-equal", "../../../packages/undo-manager/src/index.ts"],
  "sourcesContent": ["module.exports = window.wp.isShallowEqual;", "/**\n * WordPress dependencies\n */\nimport isShallowEqual from '@wordpress/is-shallow-equal';\n\n/**\n * Internal dependencies\n */\nimport type {\n\tHistoryChange as _HistoryChange,\n\tHistoryChanges as _HistoryChanges,\n\tHistoryRecord as _HistoryRecord,\n\tUndoManager as _UndoManager,\n} from './types';\n\n/**\n * Represents a single change in history.\n */\nexport type HistoryChange< T = unknown > = _HistoryChange< T >;\n\n/**\n * Represents changes for a single item.\n */\nexport type HistoryChanges< T = unknown > = _HistoryChanges< T >;\n\n/**\n * Represents a record of history changes.\n */\nexport type HistoryRecord< T = unknown > = _HistoryRecord< T >;\n\n/**\n * The undo manager interface.\n */\nexport type UndoManager< T = unknown > = _UndoManager< T >;\n\n/**\n * Merge changes for a single item into a record of changes.\n *\n * @param changes1 Previous changes\n * @param changes2 Next changes\n *\n * @return Merged changes\n */\nfunction mergeHistoryChanges< T >(\n\tchanges1: Record< string, HistoryChange< T > >,\n\tchanges2: Record< string, HistoryChange< T > >\n): Record< string, HistoryChange< T > > {\n\tconst newChanges: Record< string, HistoryChange< T > > = { ...changes1 };\n\tObject.entries( changes2 ).forEach( ( [ key, value ] ) => {\n\t\tif ( newChanges[ key ] ) {\n\t\t\tnewChanges[ key ] = { ...newChanges[ key ], to: value.to };\n\t\t} else {\n\t\t\tnewChanges[ key ] = value;\n\t\t}\n\t} );\n\n\treturn newChanges;\n}\n\n/**\n * Adds history changes for a single item into a record of changes.\n *\n * @param record  The record to merge into.\n * @param changes The changes to merge.\n */\nconst addHistoryChangesIntoRecord = < T >(\n\trecord: HistoryRecord< T >,\n\tchanges: HistoryChanges< T >\n): HistoryRecord< T > => {\n\tconst existingChangesIndex = record?.findIndex(\n\t\t( { id: recordIdentifier } ) => {\n\t\t\treturn typeof recordIdentifier === 'string'\n\t\t\t\t? recordIdentifier === changes.id\n\t\t\t\t: isShallowEqual( recordIdentifier, changes.id );\n\t\t}\n\t);\n\tconst nextRecord = [ ...record ];\n\n\tif ( existingChangesIndex !== -1 ) {\n\t\t// If the edit is already in the stack leave the initial \"from\" value.\n\t\tnextRecord[ existingChangesIndex ] = {\n\t\t\tid: changes.id,\n\t\t\tchanges: mergeHistoryChanges(\n\t\t\t\tnextRecord[ existingChangesIndex ].changes,\n\t\t\t\tchanges.changes\n\t\t\t),\n\t\t};\n\t} else {\n\t\tnextRecord.push( changes );\n\t}\n\treturn nextRecord;\n};\n\n/**\n * Creates an undo manager.\n *\n * @return Undo manager.\n */\nexport function createUndoManager< T = unknown >(): UndoManager< T > {\n\tlet history: HistoryRecord< T >[] = [];\n\tlet stagedRecord: HistoryRecord< T > = [];\n\tlet offset = 0;\n\n\tconst dropPendingRedos = (): void => {\n\t\thistory = history.slice( 0, offset || undefined );\n\t\toffset = 0;\n\t};\n\n\tconst appendStagedRecordToLatestHistoryRecord = (): void => {\n\t\tconst index = history.length === 0 ? 0 : history.length - 1;\n\t\tlet latestRecord = history[ index ] ?? [];\n\t\tstagedRecord.forEach( ( changes ) => {\n\t\t\tlatestRecord = addHistoryChangesIntoRecord( latestRecord, changes );\n\t\t} );\n\t\tstagedRecord = [];\n\t\thistory[ index ] = latestRecord;\n\t};\n\n\t/**\n\t * Checks whether a record is empty.\n\t * A record is considered empty if it the changes keep the same values.\n\t * Also updates to function values are ignored.\n\t *\n\t * @param record The record to check.\n\t * @return Whether the record is empty.\n\t */\n\tconst isRecordEmpty = ( record: HistoryRecord< T > ): boolean => {\n\t\tconst filteredRecord = record.filter( ( { changes } ) => {\n\t\t\treturn Object.values( changes ).some(\n\t\t\t\t( { from, to } ) =>\n\t\t\t\t\ttypeof from !== 'function' &&\n\t\t\t\t\ttypeof to !== 'function' &&\n\t\t\t\t\t! isShallowEqual( from, to )\n\t\t\t);\n\t\t} );\n\t\treturn ! filteredRecord.length;\n\t};\n\n\treturn {\n\t\taddRecord( record?: HistoryRecord< T >, isStaged = false ): void {\n\t\t\tconst isEmpty = ! record || isRecordEmpty( record );\n\t\t\tif ( isStaged ) {\n\t\t\t\tif ( isEmpty ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\trecord.forEach( ( changes ) => {\n\t\t\t\t\tstagedRecord = addHistoryChangesIntoRecord(\n\t\t\t\t\t\tstagedRecord,\n\t\t\t\t\t\tchanges\n\t\t\t\t\t);\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tdropPendingRedos();\n\t\t\t\tif ( stagedRecord.length ) {\n\t\t\t\t\tappendStagedRecordToLatestHistoryRecord();\n\t\t\t\t}\n\t\t\t\tif ( isEmpty ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thistory.push( record );\n\t\t\t}\n\t\t},\n\n\t\tundo(): HistoryRecord< T > | undefined {\n\t\t\tif ( stagedRecord.length ) {\n\t\t\t\tdropPendingRedos();\n\t\t\t\tappendStagedRecordToLatestHistoryRecord();\n\t\t\t}\n\t\t\tconst undoRecord = history[ history.length - 1 + offset ];\n\t\t\tif ( ! undoRecord ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toffset -= 1;\n\t\t\treturn undoRecord;\n\t\t},\n\n\t\tredo(): HistoryRecord< T > | undefined {\n\t\t\tconst redoRecord = history[ history.length + offset ];\n\t\t\tif ( ! redoRecord ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toffset += 1;\n\t\t\treturn redoRecord;\n\t\t},\n\n\t\thasUndo(): boolean {\n\t\t\treturn !! history[ history.length - 1 + offset ];\n\t\t},\n\n\t\thasRedo(): boolean {\n\t\t\treturn !! history[ history.length + offset ];\n\t\t},\n\t};\n}\n"],
  "mappings": "upBAAA,IAAAA,EAAAC,EAAA,CAAAC,EAAAC,IAAA,CAAAA,EAAO,QAAU,OAAO,GAAG,yDCG3B,IAAAC,EAA2B,OAwC3B,SAASC,EACRC,EACAC,EACuC,CACvC,IAAMC,EAAmD,CAAE,GAAGF,CAAS,EACvE,cAAO,QAASC,CAAS,EAAE,QAAS,CAAE,CAAEE,EAAKC,CAAM,IAAO,CACpDF,EAAYC,CAAI,EACpBD,EAAYC,CAAI,EAAI,CAAE,GAAGD,EAAYC,CAAI,EAAG,GAAIC,EAAM,EAAG,EAEzDF,EAAYC,CAAI,EAAIC,CAEtB,CAAE,EAEKF,CACR,CAQA,IAAMG,EAA8B,CACnCC,EACAC,IACwB,CACxB,IAAMC,EAAuBF,GAAQ,UACpC,CAAE,CAAE,GAAIG,CAAiB,IACjB,OAAOA,GAAqB,SAChCA,IAAqBF,EAAQ,MAC7B,EAAAG,SAAgBD,EAAkBF,EAAQ,EAAG,CAElD,EACMI,EAAa,CAAE,GAAGL,CAAO,EAE/B,OAAKE,IAAyB,GAE7BG,EAAYH,CAAqB,EAAI,CACpC,GAAID,EAAQ,GACZ,QAASR,EACRY,EAAYH,CAAqB,EAAE,QACnCD,EAAQ,OACT,CACD,EAEAI,EAAW,KAAMJ,CAAQ,EAEnBI,CACR,EAOO,SAASC,GAAqD,CACpE,IAAIC,EAAgC,CAAC,EACjCC,EAAmC,CAAC,EACpCC,EAAS,EAEPC,EAAmB,IAAY,CACpCH,EAAUA,EAAQ,MAAO,EAAGE,GAAU,MAAU,EAChDA,EAAS,CACV,EAEME,EAA0C,IAAY,CAC3D,IAAMC,EAAQL,EAAQ,SAAW,EAAI,EAAIA,EAAQ,OAAS,EACtDM,EAAeN,EAASK,CAAM,GAAK,CAAC,EACxCJ,EAAa,QAAWP,GAAa,CACpCY,EAAed,EAA6Bc,EAAcZ,CAAQ,CACnE,CAAE,EACFO,EAAe,CAAC,EAChBD,EAASK,CAAM,EAAIC,CACpB,EAUMC,EAAkBd,GAShB,CARgBA,EAAO,OAAQ,CAAE,CAAE,QAAAC,CAAQ,IAC1C,OAAO,OAAQA,CAAQ,EAAE,KAC/B,CAAE,CAAE,KAAAc,EAAM,GAAAC,CAAG,IACZ,OAAOD,GAAS,YAChB,OAAOC,GAAO,YACd,IAAE,EAAAZ,SAAgBW,EAAMC,CAAG,CAC7B,CACC,EACsB,OAGzB,MAAO,CACN,UAAWhB,EAA6BiB,EAAW,GAAc,CAChE,IAAMC,EAAU,CAAElB,GAAUc,EAAed,CAAO,EAClD,GAAKiB,EAAW,CACf,GAAKC,EACJ,OAEDlB,EAAO,QAAWC,GAAa,CAC9BO,EAAeT,EACdS,EACAP,CACD,CACD,CAAE,CACH,KAAO,CAKN,GAJAS,EAAiB,EACZF,EAAa,QACjBG,EAAwC,EAEpCO,EACJ,OAEDX,EAAQ,KAAMP,CAAO,CACtB,CACD,EAEA,MAAuC,CACjCQ,EAAa,SACjBE,EAAiB,EACjBC,EAAwC,GAEzC,IAAMQ,EAAaZ,EAASA,EAAQ,OAAS,EAAIE,CAAO,EACxD,GAAOU,EAGP,OAAAV,GAAU,EACHU,CACR,EAEA,MAAuC,CACtC,IAAMC,EAAab,EAASA,EAAQ,OAASE,CAAO,EACpD,GAAOW,EAGP,OAAAX,GAAU,EACHW,CACR,EAEA,SAAmB,CAClB,MAAO,CAAC,CAAEb,EAASA,EAAQ,OAAS,EAAIE,CAAO,CAChD,EAEA,SAAmB,CAClB,MAAO,CAAC,CAAEF,EAASA,EAAQ,OAASE,CAAO,CAC5C,CACD,CACD",
  "names": ["require_is_shallow_equal", "__commonJSMin", "exports", "module", "import_is_shallow_equal", "mergeHistoryChanges", "changes1", "changes2", "newChanges", "key", "value", "addHistoryChangesIntoRecord", "record", "changes", "existingChangesIndex", "recordIdentifier", "isShallowEqual", "nextRecord", "createUndoManager", "history", "stagedRecord", "offset", "dropPendingRedos", "appendStagedRecordToLatestHistoryRecord", "index", "latestRecord", "isRecordEmpty", "from", "to", "isStaged", "isEmpty", "undoRecord", "redoRecord"]
}
