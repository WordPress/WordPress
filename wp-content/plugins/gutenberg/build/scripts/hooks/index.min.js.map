{
  "version": 3,
  "sources": ["../../../packages/hooks/src/validateNamespace.ts", "../../../packages/hooks/src/validateHookName.ts", "../../../packages/hooks/src/createAddHook.ts", "../../../packages/hooks/src/createRemoveHook.ts", "../../../packages/hooks/src/createHasHook.ts", "../../../packages/hooks/src/createRunHook.ts", "../../../packages/hooks/src/createCurrentHook.ts", "../../../packages/hooks/src/createDoingHook.ts", "../../../packages/hooks/src/createDidHook.ts", "../../../packages/hooks/src/createHooks.ts", "../../../packages/hooks/src/index.ts"],
  "sourcesContent": ["/**\n * Validate a namespace string.\n *\n * @param namespace The namespace to validate - should take the form\n *                  `vendor/plugin/function`.\n *\n * @return Whether the namespace is valid.\n */\nfunction validateNamespace( namespace: string ): boolean {\n\tif ( 'string' !== typeof namespace || '' === namespace ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The namespace must be a non-empty string.' );\n\t\treturn false;\n\t}\n\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.\\-\\/]*$/.test( namespace ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(\n\t\t\t'The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport default validateNamespace;\n", "/**\n * Validate a hookName string.\n *\n * @param hookName The hook name to validate. Should be a non empty string containing\n *                 only numbers, letters, dashes, periods and underscores. Also,\n *                 the hook name cannot begin with `__`.\n *\n * @return Whether the hook name is valid.\n */\nfunction validateHookName( hookName: string ): boolean {\n\tif ( 'string' !== typeof hookName || '' === hookName ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The hook name must be a non-empty string.' );\n\t\treturn false;\n\t}\n\n\tif ( /^__/.test( hookName ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The hook name cannot begin with `__`.' );\n\t\treturn false;\n\t}\n\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.-]*$/.test( hookName ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(\n\t\t\t'The hook name can only contain numbers, letters, dashes, periods and underscores.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport default validateHookName;\n", "/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace';\nimport validateHookName from './validateHookName';\nimport type { Callback, Hooks, StoreKey } from '.';\nimport type { Handler, HookInfo } from './types';\n\n/**\n *\n * Adds the hook to the appropriate hooks container.\n */\nexport type AddHook = (\n\t/**\n\t * Name of hook to add\n\t */\n\thookName: string,\n\t/**\n\t * The unique namespace identifying the callback in the form.\n\t */\n\tnamespace: string,\n\t/**\n\t * Function to call when the hook is run.\n\t */\n\tcallback: Callback,\n\t/**\n\t * Priority of this hook\n\t */\n\tpriority?: number\n) => void;\n\n/**\n * Returns a function which, when invoked, will add a hook.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that adds a new hook.\n */\nfunction createAddHook( hooks: Hooks, storeKey: StoreKey ): AddHook {\n\treturn function addHook( hookName, namespace, callback, priority = 10 ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! validateNamespace( namespace ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( 'function' !== typeof callback ) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error( 'The hook callback must be a function.' );\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate numeric priority\n\t\tif ( 'number' !== typeof priority ) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\n\t\t\t\t'If specified, the hook priority must be a number.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler: Handler = { callback, priority, namespace };\n\n\t\tif ( hooksStore[ hookName ] ) {\n\t\t\t// Find the correct insert index of the new hook.\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\n\n\t\t\tlet i: number;\n\t\t\tfor ( i = handlers.length; i > 0; i-- ) {\n\t\t\t\tif ( priority >= handlers[ i - 1 ].priority ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( i === handlers.length ) {\n\t\t\t\t// If append, operate via direct assignment.\n\t\t\t\thandlers[ i ] = handler;\n\t\t\t} else {\n\t\t\t\t// Otherwise, insert before index via splice.\n\t\t\t\thandlers.splice( i, 0, handler );\n\t\t\t}\n\n\t\t\t// We may also be currently executing this hook.  If the callback\n\t\t\t// we're adding would come after the current callback, there's no\n\t\t\t// problem; otherwise we need to increase the execution index of\n\t\t\t// any other runs by 1 to account for the added element.\n\t\t\thooksStore.__current.forEach( ( hookInfo: HookInfo ) => {\n\t\t\t\tif (\n\t\t\t\t\thookInfo.name === hookName &&\n\t\t\t\t\thookInfo.currentIndex >= i\n\t\t\t\t) {\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t} );\n\t\t} else {\n\t\t\t// This is the first hook of its type.\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\thandlers: [ handler ],\n\t\t\t\truns: 0,\n\t\t\t};\n\t\t}\n\n\t\tif ( hookName !== 'hookAdded' ) {\n\t\t\thooks.doAction(\n\t\t\t\t'hookAdded',\n\t\t\t\thookName,\n\t\t\t\tnamespace,\n\t\t\t\tcallback,\n\t\t\t\tpriority\n\t\t\t);\n\t\t}\n\t};\n}\n\nexport default createAddHook;\n", "/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace';\nimport validateHookName from './validateHookName';\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\n * and namespace.\n */\nexport type RemoveHook = (\n\t/**\n\t * The name of the hook to modify.\n\t */\n\thookName: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace: string\n) => number | undefined;\n\n/**\n * Returns a function which, when invoked, will remove a specified hook or all\n * hooks by the given name.\n *\n * @param hooks             Hooks instance.\n * @param storeKey\n * @param [removeAll=false] Whether to remove all callbacks for a hookName,\n *                          without regard to namespace. Used to create\n *                          `removeAll*` functions.\n *\n * @return Function that removes hooks.\n */\nfunction createRemoveHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey,\n\tremoveAll: boolean = false\n): RemoveHook {\n\treturn function removeHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! removeAll && ! validateNamespace( namespace ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Bail if no hooks exist by this name.\n\t\tif ( ! hooksStore[ hookName ] ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet handlersRemoved = 0;\n\n\t\tif ( removeAll ) {\n\t\t\thandlersRemoved = hooksStore[ hookName ].handlers.length;\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\truns: hooksStore[ hookName ].runs,\n\t\t\t\thandlers: [],\n\t\t\t};\n\t\t} else {\n\t\t\t// Try to find the specified callback to remove.\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\n\t\t\tfor ( let i = handlers.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( handlers[ i ].namespace === namespace ) {\n\t\t\t\t\thandlers.splice( i, 1 );\n\t\t\t\t\thandlersRemoved++;\n\t\t\t\t\t// This callback may also be part of a hook that is\n\t\t\t\t\t// currently executing.  If the callback we're removing\n\t\t\t\t\t// comes after the current callback, there's no problem;\n\t\t\t\t\t// otherwise we need to decrease the execution index of any\n\t\t\t\t\t// other runs by 1 to account for the removed element.\n\t\t\t\t\thooksStore.__current.forEach( ( hookInfo ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thookInfo.name === hookName &&\n\t\t\t\t\t\t\thookInfo.currentIndex >= i\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\thookInfo.currentIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( hookName !== 'hookRemoved' ) {\n\t\t\thooks.doAction( 'hookRemoved', hookName, namespace );\n\t\t}\n\n\t\treturn handlersRemoved;\n\t};\n}\n\nexport default createRemoveHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n/**\n *\n * Returns whether any handlers are attached for the given hookName and optional namespace.\n */\nexport type HasHook = (\n\t/**\n\t * The name of the hook to check for.\n\t */\n\thookname: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace?: string\n) => boolean;\n\n/**\n * Returns a function which, when invoked, will return whether any handlers are\n * attached to a particular hook.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that returns whether any handlers are\n *                   attached to a particular hook and optional namespace.\n */\nfunction createHasHook( hooks: Hooks, storeKey: StoreKey ): HasHook {\n\treturn function hasHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\t// Use the namespace if provided.\n\t\tif ( 'undefined' !== typeof namespace ) {\n\t\t\treturn (\n\t\t\t\thookName in hooksStore &&\n\t\t\t\thooksStore[ hookName ].handlers.some(\n\t\t\t\t\t( hook ) => hook.namespace === namespace\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn hookName in hooksStore;\n\t};\n}\n\nexport default createHasHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\nexport type RunHook = (\n\thookName: string,\n\t...args: unknown[]\n) => undefined | unknown;\n\n/**\n * Returns a function which, when invoked, will execute all callbacks\n * registered to a hook of the specified type, optionally returning the final\n * value of the call chain.\n *\n * @param hooks          Hooks instance.\n * @param storeKey\n * @param returnFirstArg Whether each hook callback is expected to return its first argument.\n * @param async          Whether the hook callback should be run asynchronously\n *\n * @return Function that runs hook callbacks.\n */\nfunction createRunHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey,\n\treturnFirstArg: boolean,\n\tasync: boolean\n): RunHook {\n\treturn function runHook( hookName, ...args ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! hooksStore[ hookName ] ) {\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\thandlers: [],\n\t\t\t\truns: 0,\n\t\t\t};\n\t\t}\n\n\t\thooksStore[ hookName ].runs++;\n\n\t\tconst handlers = hooksStore[ hookName ].handlers;\n\n\t\t// The following code is stripped from production builds.\n\t\tif ( 'production' !== process.env.NODE_ENV ) {\n\t\t\t// Handle any 'all' hooks registered.\n\t\t\tif ( 'hookAdded' !== hookName && hooksStore.all ) {\n\t\t\t\thandlers.push( ...hooksStore.all.handlers );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! handlers || ! handlers.length ) {\n\t\t\treturn returnFirstArg ? args[ 0 ] : undefined;\n\t\t}\n\n\t\tconst hookInfo = {\n\t\t\tname: hookName,\n\t\t\tcurrentIndex: 0,\n\t\t};\n\n\t\tasync function asyncRunner() {\n\t\t\ttry {\n\t\t\t\thooksStore.__current.add( hookInfo );\n\t\t\t\tlet result = returnFirstArg ? args[ 0 ] : undefined;\n\t\t\t\twhile ( hookInfo.currentIndex < handlers.length ) {\n\t\t\t\t\tconst handler = handlers[ hookInfo.currentIndex ];\n\t\t\t\t\tresult = await handler.callback.apply( null, args );\n\t\t\t\t\tif ( returnFirstArg ) {\n\t\t\t\t\t\targs[ 0 ] = result;\n\t\t\t\t\t}\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t\treturn returnFirstArg ? result : undefined;\n\t\t\t} finally {\n\t\t\t\thooksStore.__current.delete( hookInfo );\n\t\t\t}\n\t\t}\n\n\t\tfunction syncRunner() {\n\t\t\ttry {\n\t\t\t\thooksStore.__current.add( hookInfo );\n\t\t\t\tlet result = returnFirstArg ? args[ 0 ] : undefined;\n\t\t\t\twhile ( hookInfo.currentIndex < handlers.length ) {\n\t\t\t\t\tconst handler = handlers[ hookInfo.currentIndex ];\n\t\t\t\t\tresult = handler.callback.apply( null, args );\n\t\t\t\t\tif ( returnFirstArg ) {\n\t\t\t\t\t\targs[ 0 ] = result;\n\t\t\t\t\t}\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t\treturn returnFirstArg ? result : undefined;\n\t\t\t} finally {\n\t\t\t\thooksStore.__current.delete( hookInfo );\n\t\t\t}\n\t\t}\n\n\t\treturn ( async ? asyncRunner : syncRunner )();\n\t};\n}\n\nexport default createRunHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Returns a function which, when invoked, will return the name of the\n * currently running hook, or `null` if no hook of the given type is currently\n * running.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return Function that returns the current hook name or null.\n */\nfunction createCurrentHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey\n): () => string | null {\n\treturn function currentHook() {\n\t\tconst hooksStore = hooks[ storeKey ];\n\t\tconst currentArray = Array.from( hooksStore.__current );\n\t\treturn currentArray.at( -1 )?.name ?? null;\n\t};\n}\n\nexport default createCurrentHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Returns whether a hook is currently being executed.\n *\n */\nexport type DoingHook = (\n\t/**\n\t * The name of the hook to check for.\n\t * If omitted, will check for any hook being executed.\n\t */ hookName?: string\n) => boolean;\n\n/**\n * Returns a function which, when invoked, will return whether a hook is\n * currently being executed.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return Function that returns whether a hook is currently\n *                     being executed.\n */\nfunction createDoingHook( hooks: Hooks, storeKey: StoreKey ): DoingHook {\n\treturn function doingHook( hookName ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\t// If the hookName was not passed, check for any current hook.\n\t\tif ( 'undefined' === typeof hookName ) {\n\t\t\treturn hooksStore.__current.size > 0;\n\t\t}\n\n\t\t// Find if the `hookName` hook is in `__current`.\n\t\treturn Array.from( hooksStore.__current ).some(\n\t\t\t( hook ) => hook.name === hookName\n\t\t);\n\t};\n}\n\nexport default createDoingHook;\n", "/**\n * Internal dependencies\n */\nimport validateHookName from './validateHookName';\nimport type { Hooks, StoreKey } from './types';\n\n/**\n *\n * Returns the number of times an action has been fired.\n *\n */\nexport type DidHook = (\n\t/**\n\t * The hook name to check.\n\t */\n\thookName: string\n) => number | undefined;\n\n/**\n * Returns a function which, when invoked, will return the number of times a\n * hook has been called.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that returns a hook's call count.\n */\nfunction createDidHook( hooks: Hooks, storeKey: StoreKey ): DidHook {\n\treturn function didHook( hookName ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn hooksStore[ hookName ] && hooksStore[ hookName ].runs\n\t\t\t? hooksStore[ hookName ].runs\n\t\t\t: 0;\n\t};\n}\n\nexport default createDidHook;\n", "/**\n * Internal dependencies\n */\nimport createAddHook from './createAddHook';\nimport createRemoveHook from './createRemoveHook';\nimport createHasHook from './createHasHook';\nimport createRunHook from './createRunHook';\nimport createCurrentHook from './createCurrentHook';\nimport createDoingHook from './createDoingHook';\nimport createDidHook from './createDidHook';\nimport type { Store } from './types';\n\n/**\n * Internal class for constructing hooks. Use `createHooks()` function\n *\n * Note, it is necessary to expose this class to make its type public.\n *\n * @private\n */\nexport class _Hooks {\n\tpublic actions: Store;\n\tpublic filters: Store;\n\n\tpublic addAction: ReturnType< typeof createAddHook >;\n\tpublic addFilter: ReturnType< typeof createAddHook >;\n\tpublic removeAction: ReturnType< typeof createRemoveHook >;\n\tpublic removeFilter: ReturnType< typeof createRemoveHook >;\n\tpublic hasAction: ReturnType< typeof createHasHook >;\n\tpublic hasFilter: ReturnType< typeof createHasHook >;\n\tpublic removeAllActions: ReturnType< typeof createRemoveHook >;\n\tpublic removeAllFilters: ReturnType< typeof createRemoveHook >;\n\tpublic doAction: ReturnType< typeof createRunHook >;\n\tpublic doActionAsync: ReturnType< typeof createRunHook >;\n\tpublic applyFilters: ReturnType< typeof createRunHook >;\n\tpublic applyFiltersAsync: ReturnType< typeof createRunHook >;\n\tpublic currentAction: ReturnType< typeof createCurrentHook >;\n\tpublic currentFilter: ReturnType< typeof createCurrentHook >;\n\tpublic doingAction: ReturnType< typeof createDoingHook >;\n\tpublic doingFilter: ReturnType< typeof createDoingHook >;\n\tpublic didAction: ReturnType< typeof createDidHook >;\n\tpublic didFilter: ReturnType< typeof createDidHook >;\n\n\tconstructor() {\n\t\tthis.actions = Object.create( null );\n\t\tthis.actions.__current = new Set();\n\n\t\tthis.filters = Object.create( null );\n\t\tthis.filters.__current = new Set();\n\n\t\tthis.addAction = createAddHook( this, 'actions' );\n\t\tthis.addFilter = createAddHook( this, 'filters' );\n\t\tthis.removeAction = createRemoveHook( this, 'actions' );\n\t\tthis.removeFilter = createRemoveHook( this, 'filters' );\n\t\tthis.hasAction = createHasHook( this, 'actions' );\n\t\tthis.hasFilter = createHasHook( this, 'filters' );\n\t\tthis.removeAllActions = createRemoveHook( this, 'actions', true );\n\t\tthis.removeAllFilters = createRemoveHook( this, 'filters', true );\n\t\tthis.doAction = createRunHook( this, 'actions', false, false );\n\t\tthis.doActionAsync = createRunHook( this, 'actions', false, true );\n\t\tthis.applyFilters = createRunHook( this, 'filters', true, false );\n\t\tthis.applyFiltersAsync = createRunHook( this, 'filters', true, true );\n\t\tthis.currentAction = createCurrentHook( this, 'actions' );\n\t\tthis.currentFilter = createCurrentHook( this, 'filters' );\n\t\tthis.doingAction = createDoingHook( this, 'actions' );\n\t\tthis.doingFilter = createDoingHook( this, 'filters' );\n\t\tthis.didAction = createDidHook( this, 'actions' );\n\t\tthis.didFilter = createDidHook( this, 'filters' );\n\t}\n}\n\nexport type Hooks = _Hooks;\n\n/**\n * Returns an instance of the hooks object.\n *\n * @return A Hooks instance.\n */\nfunction createHooks(): Hooks {\n\treturn new _Hooks();\n}\n\nexport default createHooks;\n", "/**\n * Internal dependencies\n */\nimport createHooks from './createHooks';\n\nexport * from './types';\n\nexport const defaultHooks = createHooks();\n\nconst {\n\taddAction,\n\taddFilter,\n\tremoveAction,\n\tremoveFilter,\n\thasAction,\n\thasFilter,\n\tremoveAllActions,\n\tremoveAllFilters,\n\tdoAction,\n\tdoActionAsync,\n\tapplyFilters,\n\tapplyFiltersAsync,\n\tcurrentAction,\n\tcurrentFilter,\n\tdoingAction,\n\tdoingFilter,\n\tdidAction,\n\tdidFilter,\n\tactions,\n\tfilters,\n} = defaultHooks;\n\nexport {\n\tcreateHooks,\n\taddAction,\n\taddFilter,\n\tremoveAction,\n\tremoveFilter,\n\thasAction,\n\thasFilter,\n\tremoveAllActions,\n\tremoveAllFilters,\n\tdoAction,\n\tdoActionAsync,\n\tapplyFilters,\n\tapplyFiltersAsync,\n\tcurrentAction,\n\tcurrentFilter,\n\tdoingAction,\n\tdoingFilter,\n\tdidAction,\n\tdidFilter,\n\tactions,\n\tfilters,\n};\n"],
  "mappings": "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",
  "names": ["validateNamespace", "namespace", "validateNamespace_default", "validateHookName", "hookName", "validateHookName_default", "createAddHook", "hooks", "storeKey", "hookName", "namespace", "callback", "priority", "hooksStore", "validateHookName_default", "validateNamespace_default", "handler", "handlers", "i", "hookInfo", "createAddHook_default", "createRemoveHook", "hooks", "storeKey", "removeAll", "hookName", "namespace", "hooksStore", "validateHookName_default", "validateNamespace_default", "handlersRemoved", "handlers", "i", "hookInfo", "createRemoveHook_default", "createHasHook", "hooks", "storeKey", "hookName", "namespace", "hooksStore", "hook", "createHasHook_default", "createRunHook", "hooks", "storeKey", "returnFirstArg", "async", "hookName", "args", "hooksStore", "handlers", "hookInfo", "asyncRunner", "result", "syncRunner", "createRunHook_default", "createCurrentHook", "hooks", "storeKey", "hooksStore", "createCurrentHook_default", "createDoingHook", "hooks", "storeKey", "hookName", "hooksStore", "hook", "createDoingHook_default", "createDidHook", "hooks", "storeKey", "hookName", "hooksStore", "validateHookName_default", "createDidHook_default", "_Hooks", "createAddHook_default", "createRemoveHook_default", "createHasHook_default", "createRunHook_default", "createCurrentHook_default", "createDoingHook_default", "createDidHook_default", "createHooks", "createHooks_default", "defaultHooks", "createHooks_default", "addAction", "addFilter", "removeAction", "removeFilter", "hasAction", "hasFilter", "removeAllActions", "removeAllFilters", "doAction", "doActionAsync", "applyFilters", "applyFiltersAsync", "currentAction", "currentFilter", "doingAction", "doingFilter", "didAction", "didFilter", "actions", "filters"]
}
