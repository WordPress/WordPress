{
  "version": 3,
  "sources": ["package-external:@wordpress/data", "package-external:@wordpress/escape-html", "package-external:@wordpress/a11y", "package-external:@wordpress/i18n", "package-external:@wordpress/element", "package-external:@wordpress/deprecated", "package-external:@wordpress/compose", "package-external:@wordpress/keycodes", "../../../packages/rich-text/src/store/index.js", "../../../packages/rich-text/src/store/reducer.js", "../../../packages/rich-text/src/store/selectors.js", "../../../packages/rich-text/src/store/actions.js", "../../../packages/rich-text/src/is-format-equal.js", "../../../packages/rich-text/src/normalise-formats.js", "../../../packages/rich-text/src/apply-format.js", "../../../packages/rich-text/src/create.js", "../../../packages/rich-text/src/create-element.js", "../../../packages/rich-text/src/special-characters.js", "../../../packages/rich-text/src/to-html-string.js", "../../../packages/rich-text/src/get-active-formats.js", "../../../packages/rich-text/src/get-format-type.js", "../../../packages/rich-text/src/to-tree.js", "../../../packages/rich-text/src/get-text-content.js", "../../../packages/rich-text/src/concat.js", "../../../packages/rich-text/src/get-active-format.js", "../../../packages/rich-text/src/get-active-object.js", "../../../packages/rich-text/src/is-collapsed.ts", "../../../packages/rich-text/src/is-empty.js", "../../../packages/rich-text/src/join.js", "../../../packages/rich-text/src/register-format-type.js", "../../../packages/rich-text/src/remove-format.js", "../../../packages/rich-text/src/insert.js", "../../../packages/rich-text/src/remove.js", "../../../packages/rich-text/src/replace.js", "../../../packages/rich-text/src/insert-object.js", "../../../packages/rich-text/src/slice.js", "../../../packages/rich-text/src/split.js", "../../../packages/rich-text/src/is-range-equal.js", "../../../packages/rich-text/src/to-dom.js", "../../../packages/rich-text/src/toggle-format.js", "../../../packages/rich-text/src/unregister-format-type.js", "../../../packages/rich-text/src/component/use-anchor-ref.js", "../../../packages/rich-text/src/component/use-anchor.js", "../../../packages/rich-text/src/component/index.js", "../../../packages/rich-text/src/component/use-default-style.js", "../../../node_modules/colord/index.mjs", "../../../packages/rich-text/src/component/use-boundary-style.js", "../../../packages/rich-text/src/component/event-listeners/index.js", "../../../packages/rich-text/src/component/event-listeners/copy-handler.js", "../../../packages/rich-text/src/component/event-listeners/select-object.js", "../../../packages/rich-text/src/component/event-listeners/format-boundaries.js", "../../../packages/rich-text/src/component/event-listeners/delete.js", "../../../packages/rich-text/src/update-formats.js", "../../../packages/rich-text/src/component/event-listeners/input-and-selection.js", "../../../packages/rich-text/src/component/event-listeners/selection-change-compat.js", "../../../packages/rich-text/src/component/event-listeners/prevent-focus-capture.js"],
  "sourcesContent": ["module.exports = window.wp.data;", "module.exports = window.wp.escapeHtml;", "module.exports = window.wp.a11y;", "module.exports = window.wp.i18n;", "module.exports = window.wp.element;", "module.exports = window.wp.deprecated;", "module.exports = window.wp.compose;", "module.exports = window.wp.keycodes;", "/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nconst STORE_NAME = 'core/rich-text';\n\n/**\n * Store definition for the rich-text namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\nregister( store );\n", "/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t// Key format types by their name.\n\t\t\t\t...action.formatTypes.reduce(\n\t\t\t\t\t( newFormatTypes, type ) => ( {\n\t\t\t\t\t\t...newFormatTypes,\n\t\t\t\t\t\t[ type.name ]: type,\n\t\t\t\t\t} ),\n\t\t\t\t\t{}\n\t\t\t\t),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn Object.fromEntries(\n\t\t\t\tObject.entries( state ).filter(\n\t\t\t\t\t( [ key ] ) => ! action.names.includes( key )\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n", "/**\n * WordPress dependencies\n */\nimport { createSelector } from '@wordpress/data';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypes } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const availableFormats = getFormatTypes();\n *\n *    return availableFormats ? (\n *        <ul>\n *            { availableFormats?.map( ( format ) => (\n *                <li>{ format.name }</li>\n *           ) ) }\n *        </ul>\n *    ) : (\n *        __( 'No Formats available' )\n *    );\n * };\n * ```\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatType } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const boldFormat = getFormatType( 'core/bold' );\n *\n *    return boldFormat ? (\n *        <ul>\n *            { Object.entries( boldFormat )?.map( ( [ key, value ] ) => (\n *                <li>\n *                    { key } : { value }\n *                </li>\n *           ) ) }\n *       </ul>\n *    ) : (\n *        __( 'Not Found' )\n *    ;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForBareElement } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForBareElement( 'strong' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * }\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\tconst formatTypes = getFormatTypes( state );\n\treturn (\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && bareElementTagName === tagName;\n\t\t} ) ||\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && '*' === tagName;\n\t\t} )\n\t);\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForClassName } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForClassName( 'has-inline-color' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn getFormatTypes( state ).find( ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n", "/**\n * Returns an action object used in signalling that format types have been\n * added.\n * Ignored from documentation as registerFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: Array.isArray( formatTypes )\n\t\t\t? formatTypes\n\t\t\t: [ formatTypes ],\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * Ignored from documentation as unregisterFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: Array.isArray( names ) ? names : [ names ],\n\t};\n}\n", "/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === format.type\n\t\t);\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...( activeFormats?.filter(\n\t\t\t\t( { type } ) => type !== format.type\n\t\t\t) || [] ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n", "/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\nimport { toHTMLString } from './to-html-string';\nimport { getTextContent } from './get-text-content';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { tagName, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( tagName );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type: tagName, attributes } : { type: tagName };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { formatType, type: formatType.name, tagName };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\tif ( formatType.contentEditable === false ) {\n\t\tdelete unregisteredAttributes.contenteditable;\n\t}\n\n\treturn {\n\t\tformatType,\n\t\ttype: formatType.name,\n\t\ttagName,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * The RichTextData class is used to instantiate a wrapper around rich text\n * values, with methods that can be used to transform or manipulate the data.\n *\n * - Create an empty instance: `new RichTextData()`.\n * - Create one from an HTML string: `RichTextData.fromHTMLString(\n *   '<em>hello</em>' )`.\n * - Create one from a wrapper HTMLElement: `RichTextData.fromHTMLElement(\n *   document.querySelector( 'p' ) )`.\n * - Create one from plain text: `RichTextData.fromPlainText( '1\\n2' )`.\n * - Create one from a rich text value: `new RichTextData( { text: '...',\n *   formats: [ ... ] } )`.\n *\n * @todo Add methods to manipulate the data, such as applyFormat, slice etc.\n */\nexport class RichTextData {\n\t#value;\n\n\tstatic empty() {\n\t\treturn new RichTextData();\n\t}\n\tstatic fromPlainText( text ) {\n\t\treturn new RichTextData( create( { text } ) );\n\t}\n\tstatic fromHTMLString( html ) {\n\t\treturn new RichTextData( create( { html } ) );\n\t}\n\t/**\n\t * Create a RichTextData instance from an HTML element.\n\t *\n\t * @param {HTMLElement}                    htmlElement The HTML element to create the instance from.\n\t * @param {{preserveWhiteSpace?: boolean}} options     Options.\n\t * @return {RichTextData} The RichTextData instance.\n\t */\n\tstatic fromHTMLElement( htmlElement, options = {} ) {\n\t\tconst { preserveWhiteSpace = false } = options;\n\t\tconst element = preserveWhiteSpace\n\t\t\t? htmlElement\n\t\t\t: collapseWhiteSpace( htmlElement );\n\t\tconst richTextData = new RichTextData( create( { element } ) );\n\t\tObject.defineProperty( richTextData, 'originalHTML', {\n\t\t\tvalue: htmlElement.innerHTML,\n\t\t} );\n\t\treturn richTextData;\n\t}\n\tconstructor( init = createEmptyValue() ) {\n\t\tthis.#value = init;\n\t}\n\ttoPlainText() {\n\t\treturn getTextContent( this.#value );\n\t}\n\t// We could expose `toHTMLElement` at some point as well, but we'd only use\n\t// it internally.\n\t/**\n\t * Convert the rich text value to an HTML string.\n\t *\n\t * @param {{preserveWhiteSpace?: boolean}} options Options.\n\t * @return {string} The HTML string.\n\t */\n\ttoHTMLString( { preserveWhiteSpace } = {} ) {\n\t\treturn (\n\t\t\tthis.originalHTML ||\n\t\t\ttoHTMLString( { value: this.#value, preserveWhiteSpace } )\n\t\t);\n\t}\n\tvalueOf() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoString() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoJSON() {\n\t\treturn this.toHTMLString();\n\t}\n\tget length() {\n\t\treturn this.text.length;\n\t}\n\tget formats() {\n\t\treturn this.#value.formats;\n\t}\n\tget replacements() {\n\t\treturn this.#value.replacements;\n\t}\n\tget text() {\n\t\treturn this.#value.text;\n\t}\n}\n\nfor ( const name of Object.getOwnPropertyNames( String.prototype ) ) {\n\tif ( RichTextData.prototype.hasOwnProperty( name ) ) {\n\t\tcontinue;\n\t}\n\n\tObject.defineProperty( RichTextData.prototype, name, {\n\t\tvalue( ...args ) {\n\t\t\t// Should we convert back to RichTextData?\n\t\t\treturn this.toHTMLString()[ name ]( ...args );\n\t\t},\n\t} );\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. The optional\n * functions can be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {boolean} [$1.__unstableIsEditableTree]\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\t__unstableIsEditableTree: isEditableTree,\n} = {} ) {\n\tif ( html instanceof RichTextData ) {\n\t\treturn {\n\t\t\ttext: html.text,\n\t\t\tformats: html.formats,\n\t\t\treplacements: html.replacements,\n\t\t};\n\t}\n\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\treturn createFromElement( {\n\t\telement,\n\t\trange,\n\t\tisEditableTree,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * We need to strip it from the content because we use white-space: pre-wrap for\n * displaying editable rich text. Without using white-space: pre-wrap, the\n * browser will litter the content with non breaking spaces, among other issues.\n * See packages/rich-text/src/component/use-default-style.js.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse#collapsing_of_white_space\n *\n * @param {HTMLElement} element\n * @param {boolean}     isRoot\n *\n * @return {HTMLElement} New element with collapsed whitespace.\n */\nfunction collapseWhiteSpace( element, isRoot = true ) {\n\tconst clone = element.cloneNode( true );\n\tclone.normalize();\n\tArray.from( clone.childNodes ).forEach( ( node, i, nodes ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet newNodeValue = node.nodeValue;\n\n\t\t\tif ( /[\\n\\t\\r\\f]/.test( newNodeValue ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( /[\\n\\t\\r\\f]+/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( newNodeValue.indexOf( '  ' ) !== -1 ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( / {2,}/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( i === 0 && newNodeValue.startsWith( ' ' ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 1 );\n\t\t\t} else if (\n\t\t\t\tisRoot &&\n\t\t\t\ti === nodes.length - 1 &&\n\t\t\t\tnewNodeValue.endsWith( ' ' )\n\t\t\t) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 0, -1 );\n\t\t\t}\n\n\t\t\tnode.nodeValue = newNodeValue;\n\t\t} else if ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tnode.replaceWith( collapseWhiteSpace( node, false ) );\n\t\t}\n\t} );\n\treturn clone;\n}\n\n/**\n * We need to normalise line breaks to `\\n` so they are consistent across\n * platforms and serialised properly. Not removing \\r would cause it to\n * linger and result in double line breaks when whitespace is preserved.\n */\nconst CARRIAGE_RETURN = '\\r';\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces\n * added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR\n\t// reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp(\n\t\t\t`[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }${ CARRIAGE_RETURN }]`,\n\t\t\t'gu'\n\t\t),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                  Named arguments.\n * @param {Element} [$1.element]        Element to create value from.\n * @param {Range}   [$1.range]          Range to create value from.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( { element, range, isEditableTree } ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst tagName = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tconst text = removeReservedCharacters( node.nodeValue );\n\t\t\trange = filterRange( node, range, removeReservedCharacters );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tnode.nodeType === node.COMMENT_NODE ||\n\t\t\t( node.nodeType === node.ELEMENT_NODE &&\n\t\t\t\tnode.tagName === 'SPAN' &&\n\t\t\t\tnode.hasAttribute( 'data-rich-text-comment' ) )\n\t\t) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: '#comment',\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\t\tnode.nodeType === node.COMMENT_NODE\n\t\t\t\t\t\t\t\t\t? node.nodeValue\n\t\t\t\t\t\t\t\t\t: node.getAttribute(\n\t\t\t\t\t\t\t\t\t\t\t'data-rich-text-comment'\n\t\t\t\t\t\t\t\t\t  ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\ttagName === 'br' &&\n\t\t\t! node.getAttribute( 'data-rich-text-line-break' )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tagName,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttagName,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\t// When a format type is declared as not editable, replace it with an\n\t\t// object replacement character and preserve the inner HTML.\n\t\tif ( format?.formatType?.contentEditable === false ) {\n\t\t\tdelete format.formatType;\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...format,\n\t\t\t\t\t\tinnerHTML: node.innerHTML,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( format ) {\n\t\t\tdelete format.formatType;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Ignore any placeholders, but keep their content since the browser\n\t\t// might insert text inside them when the editable element is flex.\n\t\tif (\n\t\t\t! format ||\n\t\t\tnode.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\tnode.getAttribute( 'data-rich-text-bogus' )\n\t\t) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named arguments.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n", "/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\t// Because `createHTMLDocument` is an expensive operation, and with this\n\t// function being internal to `rich-text` (full control in avoiding a risk\n\t// of asynchronous operations on the shared reference), a single document\n\t// is reused and reset for each call to the function.\n\tif ( ! createElement.body ) {\n\t\tcreateElement.body = implementation.createHTMLDocument( '' ).body;\n\t}\n\n\tcreateElement.body.innerHTML = html;\n\n\treturn createElement.body;\n}\n", "/**\n * Object replacement character, used as a placeholder for objects.\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nexport const ZWNBSP = '\\ufeff';\n", "/**\n * WordPress dependencies\n */\n\nimport {\n\tescapeEditableHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value.\n *\n * @param {Object}        $1                      Named arguments.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {boolean}       [$1.preserveWhiteSpace] Preserves newlines if true.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, preserveWhiteSpace } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tpreserveWhiteSpace,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tif ( type === '#comment' ) {\n\t\t// We can't restore the original comment delimiters, because once parsed\n\t\t// into DOM nodes, we don't have the information. But in the future we\n\t\t// could allow comment handlers to specify custom delimiters, for\n\t\t// example `</{comment-content}>` for Bits, where `comment-content`\n\t\t// would be `/{bit-name}` or `__{translatable-string}` (TBD).\n\t\treturn `<!--${ attributes[ 'data-rich-text-comment' ] }-->`;\n\t}\n\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute(\n\t\t\tattributes[ key ]\n\t\t) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML(\n\t\tchildren\n\t) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children\n\t\t.map( ( child ) => {\n\t\t\tif ( child.html !== undefined ) {\n\t\t\t\treturn child.html;\n\t\t\t}\n\n\t\t\treturn child.text === undefined\n\t\t\t\t? createElementHTML( child )\n\t\t\t\t: escapeEditableHTML( child.text );\n\t\t} )\n\t\t.join( '' );\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormatList} RichTextFormatList */\n\n/**\n * Internal dependencies\n */\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats( value, EMPTY_ACTIVE_FORMATS = [] ) {\n\tconst { formats, start, end, activeFormats } = value;\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\t// If there's no formats at the start index, there are not active formats.\n\tif ( ! formats[ start ] ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tconst selectedFormats = formats.slice( start, end );\n\n\t// Clone the formats so we're not mutating the live value.\n\tconst _activeFormats = [ ...selectedFormats[ 0 ] ];\n\tlet i = selectedFormats.length;\n\n\t// For performance reasons, start from the end where it's much quicker to\n\t// realise that there are no active formats.\n\twhile ( i-- ) {\n\t\tconst formatsAtIndex = selectedFormats[ i ];\n\n\t\t// If we run into any index without formats, we're sure that there's no\n\t\t// active formats.\n\t\tif ( ! formatsAtIndex ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\n\t\tlet ii = _activeFormats.length;\n\n\t\t// Loop over the active formats and remove any that are not present at\n\t\t// the current index.\n\t\twhile ( ii-- ) {\n\t\t\tconst format = _activeFormats[ ii ];\n\n\t\t\tif (\n\t\t\t\t! formatsAtIndex.find( ( _format ) =>\n\t\t\t\t\tisFormatEqual( format, _format )\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t_activeFormats.splice( ii, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// If there are no active formats, we can stop.\n\t\tif ( _activeFormats.length === 0 ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\t}\n\n\treturn _activeFormats || EMPTY_ACTIVE_FORMATS;\n}\n", "/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( richTextStore ).getFormatType( name );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( isEditableTree && type === '#comment' ) {\n\t\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\tattributes[ 'data-rich-text-comment' ],\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t\tappend(\n\t\t\t\t\tappend( pointer, { type: 'span' } ),\n\t\t\t\t\tattributes[ 'data-rich-text-comment' ].trim()\n\t\t\t\t);\n\t\t\t} else if ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\tif ( innerHTML || isEditableTree ) {\n\t\t\t\t\tpointer = getParent( pointer );\n\t\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\t\tif ( isEditableTree ) {\n\t\t\t\t\t\tconst attrs = {\n\t\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t\t'data-rich-text-bogus': true,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif ( start === i && end === i + 1 ) {\n\t\t\t\t\t\t\tattrs[ 'data-rich-text-format-boundary' ] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = append( pointer, {\n\t\t\t\t\t\t\ttype: 'span',\n\t\t\t\t\t\t\tattributes: attrs,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\t// Some browsers like Safari and Firefox have issues placing\n\t\t\t\t\t\t// the caret after a non-editable element when it's at the\n\t\t\t\t\t\t// end of the field, so help them a little by providing a\n\t\t\t\t\t\t// text element. Similar to `insertPadding` above.\n\t\t\t\t\t\tif ( isEditableTree && i + 1 === text.length ) {\n\t\t\t\t\t\t\tappend( getParent( pointer ), ZWNBSP );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpointer = append(\n\t\t\t\t\t\tpointer,\n\t\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\t} )\n\t\t\t\t\t);\n\t\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\t// We CANNOT use CSS to add a placeholder with pseudo elements on\n\t\t\t// the main block wrappers because that could clash with theme CSS.\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n", "/**\n * Internal dependencies\n */\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text.replace( OBJECT_REPLACEMENT_CHARACTER, '' );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nexport function mergePair( a, b ) {\n\ta.formats = a.formats.concat( b.formats );\n\ta.replacements = a.replacements.concat( b.replacements );\n\ta.text += b.text;\n\n\treturn a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( mergePair, create() ) );\n}\n", "/**\n * Internal dependencies\n */\nimport { getActiveFormats } from './get-active-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nexport function getActiveFormat( value, formatType ) {\n\treturn getActiveFormats( value ).find(\n\t\t( { type } ) => type === formatType\n\t);\n}\n", "/**\n * Internal dependencies\n */\n\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nexport function getActiveObject( { start, end, replacements, text } ) {\n\tif ( start + 1 !== end || text[ start ] !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\treturn;\n\t}\n\n\treturn replacements[ start ];\n}\n", "/**\n * Internal dependencies\n */\nimport type { RichTextValue } from './types';\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param props       The rich text value to check.\n * @param props.start\n * @param props.end\n * @return True if the selection is collapsed, false if not, undefined if there is no selection.\n */\nexport function isCollapsed( {\n\tstart,\n\tend,\n}: RichTextValue ): boolean | undefined {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats(\n\t\tvalues.reduce( ( accumulator, { formats, replacements, text } ) => ( {\n\t\t\tformats: accumulator.formats.concat( separator.formats, formats ),\n\t\t\treplacements: accumulator.replacements.concat(\n\t\t\t\tseparator.replacements,\n\t\t\t\treplacements\n\t\t\t),\n\t\t\ttext: accumulator.text + separator.text + text,\n\t\t} ) )\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}        name        A string identifying the format. Must be\n *                                       unique across all registered formats.\n * @property {string}        tagName     The HTML tag this format will wrap the\n *                                       selection with.\n * @property {boolean}       interactive Whether format makes content interactive or not.\n * @property {boolean}       object      Whether the format represents an object (e.g., `img`, `br`),\n *                                       an object cannot contain other format types.\n * @property {string | null} [className] A class to match the format.\n * @property {string}        title       Name of the format.\n * @property {Function}      edit        Should return a component for the user to\n *                                       interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name     Format name.\n * @param {WPFormat} settings Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error( 'Format names must be strings.' );\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( richTextStore ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.tagName !== 'string' || settings.tagName === '' ) {\n\t\twindow.console.error( 'Format tag names must be a string.' );\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' ||\n\t\t\tsettings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9_-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, underscores, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForBareElement( settings.tagName );\n\n\t\tif (\n\t\t\tformatTypeForBareElement &&\n\t\t\tformatTypeForBareElement.name !== 'core/unknown'\n\t\t) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' +\n\t\t\t\tsettings.name +\n\t\t\t\t'\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error( 'Format titles must be strings.' );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).addFormatTypes( settings );\n\n\treturn settings;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === formatType\n\t\t);\n\n\t\tif ( format ) {\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats:\n\t\t\tactiveFormats?.filter( ( { type } ) => type !== formatType ) || [],\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n", "/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insert(\n\tvalue,\n\tvalueToInsert,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\treplacements: replacements\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat(\n\t\t\t\tvalueToInsert.replacements,\n\t\t\t\treplacements.slice( endIndex )\n\t\t\t),\n\t\ttext:\n\t\t\ttext.slice( 0, startIndex ) +\n\t\t\tvalueToInsert.text +\n\t\t\ttext.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nexport function insertObject( value, formatToInsert, startIndex, endIndex ) {\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements: [ formatToInsert ],\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nexport function slice( value, startIndex = value.start, endIndex = value.end ) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { ...value };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\treplacements: replacements.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n", "/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [ before, after ];\n}\n", "/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range|null} a First range object to test.\n * @param {Range|null} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nexport function isRangeEqual( a, b ) {\n\treturn (\n\t\ta === b ||\n\t\t( a &&\n\t\t\tb &&\n\t\t\ta.startContainer === b.startContainer &&\n\t\t\ta.startOffset === b.startOffset &&\n\t\t\ta.endContainer === b.endContainer &&\n\t\t\ta.endOffset === b.endOffset )\n\t);\n}\n", "/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\nimport { isRangeEqual } from './is-range-equal';\n\n/**\n * MathML namespace URI.\n *\n * @see https://www.w3.org/1998/Math/MathML/\n */\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( child.html !== undefined ) {\n\t\treturn ( element.innerHTML += child.html );\n\t}\n\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tif ( type === '#comment' ) {\n\t\t\tchild = element.ownerDocument.createComment(\n\t\t\t\tattributes[ 'data-rich-text-comment' ]\n\t\t\t);\n\t\t} else {\n\t\t\t// Handle namespace-aware element creation\n\t\t\tconst parentNamespace = element.namespaceURI;\n\n\t\t\tif ( type === 'math' ) {\n\t\t\t\t// Root math element always uses MathML namespace\n\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\ttype\n\t\t\t\t);\n\t\t\t} else if ( parentNamespace === MATHML_NAMESPACE ) {\n\t\t\t\tif ( element.tagName === 'MTEXT' ) {\n\t\t\t\t\t// mtext switches back to HTML namespace for phrasing content\n\t\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t\t} else {\n\t\t\t\t\t// All other elements in MathML context use MathML namespace\n\t\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\t\ttype\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Default HTML element creation\n\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t}\n\n\t\t\tfor ( const key in attributes ) {\n\t\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n", "/**\n * WordPress dependencies\n */\n\nimport { speak } from '@wordpress/a11y';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nexport function toggleFormat( value, format ) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\t// For screen readers, will announce if formatting control is disabled.\n\t\tif ( format.title ) {\n\t\t\t// translators: %s: title of the formatting control\n\t\t\tspeak( sprintf( __( '%s removed.' ), format.title ), 'assertive' );\n\t\t}\n\t\treturn removeFormat( value, format.type );\n\t}\n\t// For screen readers, will announce if formatting control is enabled.\n\tif ( format.title ) {\n\t\t// translators: %s: title of the formatting control\n\t\tspeak( sprintf( __( '%s applied.' ), format.title ), 'assertive' );\n\t}\n\treturn applyFormat( value, format );\n}\n", "/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').WPFormat} WPFormat */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {WPFormat|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( richTextStore ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error( `Format ${ name } is not registered.` );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useMemo } from '@wordpress/element';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\n\n/**\n * @template T\n * @typedef {import('@wordpress/element').RefObject<T>} RefObject<T>\n */\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or the selection range if no format is active.\n * The returned value is meant to be used for positioning UI, e.g. by passing it\n * to the `Popover` component.\n *\n * @param {Object}                 $1          Named parameters.\n * @param {RefObject<HTMLElement>} $1.ref      React ref of the element\n *                                             containing  the editable content.\n * @param {RichTextValue}          $1.value    Value to check for selection.\n * @param {WPFormat}               $1.settings The format type's settings.\n *\n * @return {Element|Range} The active element or selection range.\n */\nexport function useAnchorRef( { ref, value, settings = {} } ) {\n\tdeprecated( '`useAnchorRef` hook', {\n\t\tsince: '6.1',\n\t\talternative: '`useAnchor` hook',\n\t} );\n\n\tconst { tagName, className, name } = settings;\n\tconst activeFormat = name ? getActiveFormat( value, name ) : undefined;\n\n\treturn useMemo( () => {\n\t\tif ( ! ref.current ) {\n\t\t\treturn;\n\t\t}\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\n\t\tif ( ! selection.rangeCount ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = selection.getRangeAt( 0 );\n\n\t\tif ( ! activeFormat ) {\n\t\t\treturn range;\n\t\t}\n\n\t\tlet element = range.startContainer;\n\n\t\t// If the caret is right before the element, select the next element.\n\t\telement = element.nextElementSibling || element;\n\n\t\twhile ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\t\telement = element.parentNode;\n\t\t}\n\n\t\treturn element.closest(\n\t\t\ttagName + ( className ? '.' + className : '' )\n\t\t);\n\t}, [ activeFormat, value.start, value.end, tagName, className ] );\n}\n", "/**\n * WordPress dependencies\n */\nimport { usePrevious } from '@wordpress/compose';\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// Even if the active format is defined, the actually DOM range's start\n\t// container may be outside of the format's DOM element:\n\t// `a\u2038<strong>b</strong>` (DOM) while visually it's `a<strong>\u2038b</strong>`.\n\t// So at a given selection index, start with the deepest format DOM element.\n\tif (\n\t\telement.nodeType === element.TEXT_NODE &&\n\t\trange.startOffset === element.length &&\n\t\telement.nextSibling\n\t) {\n\t\telement = element.nextSibling;\n\n\t\twhile ( element.firstChild ) {\n\t\t\telement = element.firstChild;\n\t\t}\n\t}\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) {\n\t\treturn;\n\t}\n\tif ( element === editableContentElement ) {\n\t\treturn;\n\t}\n\tif ( ! editableContentElement.contains( element ) ) {\n\t\treturn;\n\t}\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) {\n\t\treturn;\n\t}\n\tif ( ! selection.rangeCount ) {\n\t\treturn;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) {\n\t\treturn;\n\t}\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) {\n\t\treturn formatElement;\n\t}\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className, isActive } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\tconst wasActive = usePrevious( isActive );\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tif (\n\t\t\teditableContentElement === ownerDocument.activeElement ||\n\t\t\t// When a link is created, we need to attach the popover to the newly created anchor.\n\t\t\t( ! wasActive && isActive ) ||\n\t\t\t// Sometimes we're _removing_ an active anchor, such as the inline color popover.\n\t\t\t// When we add the color, it switches from a virtual anchor to a `<mark>` element.\n\t\t\t// When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\n\t\t\t( wasActive && ! isActive )\n\t\t) {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn () => {\n\t\t\tdetach();\n\n\t\t\teditableContentElement.removeEventListener( 'focusin', attach );\n\t\t\teditableContentElement.removeEventListener( 'focusout', detach );\n\t\t};\n\t}, [ editableContentElement, tagName, className, isActive, wasActive ] );\n\n\treturn anchor;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useRef, useLayoutEffect, useReducer } from '@wordpress/element';\nimport { useMergeRefs, useRefEffect } from '@wordpress/compose';\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { create, RichTextData } from '../create';\nimport { apply } from '../to-dom';\nimport { toHTMLString } from '../to-html-string';\nimport { useDefaultStyle } from './use-default-style';\nimport { useBoundaryStyle } from './use-boundary-style';\nimport { useEventListeners } from './event-listeners';\n\nexport function useRichText( {\n\tvalue = '',\n\tselectionStart,\n\tselectionEnd,\n\tplaceholder,\n\tonSelectionChange,\n\tpreserveWhiteSpace,\n\tonChange,\n\t__unstableDisableFormats: disableFormats,\n\t__unstableIsSelected: isSelected,\n\t__unstableDependencies = [],\n\t__unstableAfterParse,\n\t__unstableBeforeSerialize,\n\t__unstableAddInvisibleFormats,\n} ) {\n\tconst registry = useRegistry();\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst ref = useRef();\n\n\tfunction createRecord() {\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\t\tconst range =\n\t\t\tselection.rangeCount > 0 ? selection.getRangeAt( 0 ) : null;\n\n\t\treturn create( {\n\t\t\telement: ref.current,\n\t\t\trange,\n\t\t\t__unstableIsEditableTree: true,\n\t\t} );\n\t}\n\n\tfunction applyRecord( newRecord, { domOnly } = {} ) {\n\t\tapply( {\n\t\t\tvalue: newRecord,\n\t\t\tcurrent: ref.current,\n\t\t\tprepareEditableTree: __unstableAddInvisibleFormats,\n\t\t\t__unstableDomOnly: domOnly,\n\t\t\tplaceholder,\n\t\t} );\n\t}\n\n\t// Internal values are updated synchronously, unlike props and state.\n\tconst _valueRef = useRef( value );\n\tconst recordRef = useRef();\n\n\tfunction setRecordFromProps() {\n\t\t_valueRef.current = value;\n\t\trecordRef.current = value;\n\t\tif ( ! ( value instanceof RichTextData ) ) {\n\t\t\trecordRef.current = value\n\t\t\t\t? RichTextData.fromHTMLString( value, { preserveWhiteSpace } )\n\t\t\t\t: RichTextData.empty();\n\t\t}\n\t\t// To do: make rich text internally work with RichTextData.\n\t\trecordRef.current = {\n\t\t\ttext: recordRef.current.text,\n\t\t\tformats: recordRef.current.formats,\n\t\t\treplacements: recordRef.current.replacements,\n\t\t};\n\t\tif ( disableFormats ) {\n\t\t\trecordRef.current.formats = Array( value.length );\n\t\t\trecordRef.current.replacements = Array( value.length );\n\t\t}\n\t\tif ( __unstableAfterParse ) {\n\t\t\trecordRef.current.formats = __unstableAfterParse(\n\t\t\t\trecordRef.current\n\t\t\t);\n\t\t}\n\t\trecordRef.current.start = selectionStart;\n\t\trecordRef.current.end = selectionEnd;\n\t}\n\n\tconst hadSelectionUpdateRef = useRef( false );\n\n\tif ( ! recordRef.current ) {\n\t\thadSelectionUpdateRef.current = isSelected;\n\t\tsetRecordFromProps();\n\t} else if (\n\t\tselectionStart !== recordRef.current.start ||\n\t\tselectionEnd !== recordRef.current.end\n\t) {\n\t\thadSelectionUpdateRef.current = isSelected;\n\t\trecordRef.current = {\n\t\t\t...recordRef.current,\n\t\t\tstart: selectionStart,\n\t\t\tend: selectionEnd,\n\t\t\tactiveFormats: undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Sync the value to global state. The node tree and selection will also be\n\t * updated if differences are found.\n\t *\n\t * @param {Object} newRecord The record to sync and apply.\n\t */\n\tfunction handleChange( newRecord ) {\n\t\trecordRef.current = newRecord;\n\t\tapplyRecord( newRecord );\n\n\t\tif ( disableFormats ) {\n\t\t\t_valueRef.current = newRecord.text;\n\t\t} else {\n\t\t\tconst newFormats = __unstableBeforeSerialize\n\t\t\t\t? __unstableBeforeSerialize( newRecord )\n\t\t\t\t: newRecord.formats;\n\t\t\tnewRecord = { ...newRecord, formats: newFormats };\n\t\t\tif ( typeof value === 'string' ) {\n\t\t\t\t_valueRef.current = toHTMLString( {\n\t\t\t\t\tvalue: newRecord,\n\t\t\t\t\tpreserveWhiteSpace,\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t_valueRef.current = new RichTextData( newRecord );\n\t\t\t}\n\t\t}\n\n\t\tconst { start, end, formats, text } = recordRef.current;\n\n\t\t// Selection must be updated first, so it is recorded in history when\n\t\t// the content change happens.\n\t\t// We batch both calls to only attempt to rerender once.\n\t\tregistry.batch( () => {\n\t\t\tonSelectionChange( start, end );\n\t\t\tonChange( _valueRef.current, {\n\t\t\t\t__unstableFormats: formats,\n\t\t\t\t__unstableText: text,\n\t\t\t} );\n\t\t} );\n\t\tforceRender();\n\t}\n\n\tfunction applyFromProps() {\n\t\t// Get previous value before updating\n\t\tconst previousValue = _valueRef.current;\n\n\t\tsetRecordFromProps();\n\n\t\t// Check if content length changed (text was added/removed, not just formatted)\n\t\tconst contentLengthChanged =\n\t\t\tpreviousValue &&\n\t\t\ttypeof previousValue === 'string' &&\n\t\t\ttypeof value === 'string' &&\n\t\t\tpreviousValue.length !== value.length;\n\n\t\t// Check if focus is on this element\n\t\tconst hasFocus = ref.current?.contains(\n\t\t\tref.current.ownerDocument.activeElement\n\t\t);\n\n\t\t// Skip re-applying the selection state when content changed from external source\n\t\t// (e.g., typing in sidebar input changes canvas text)\n\t\tconst skipSelection = contentLengthChanged && ! hasFocus;\n\n\t\tapplyRecord( recordRef.current, { domOnly: skipSelection } );\n\t}\n\n\tconst didMountRef = useRef( false );\n\n\t// Value updates must happen synchronously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( didMountRef.current && value !== _valueRef.current ) {\n\t\t\tapplyFromProps();\n\t\t\tforceRender();\n\t\t}\n\t}, [ value ] );\n\n\t// Value updates must happen synchronously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( ! hadSelectionUpdateRef.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ref.current.ownerDocument.activeElement !== ref.current ) {\n\t\t\tref.current.focus();\n\t\t}\n\n\t\tapplyRecord( recordRef.current );\n\t\thadSelectionUpdateRef.current = false;\n\t}, [ hadSelectionUpdateRef.current ] );\n\n\tconst mergedRefs = useMergeRefs( [\n\t\tref,\n\t\tuseDefaultStyle(),\n\t\tuseBoundaryStyle( { record: recordRef } ),\n\t\tuseEventListeners( {\n\t\t\trecord: recordRef,\n\t\t\thandleChange,\n\t\t\tapplyRecord,\n\t\t\tcreateRecord,\n\t\t\tisSelected,\n\t\t\tonSelectionChange,\n\t\t\tforceRender,\n\t\t} ),\n\t\tuseRefEffect( () => {\n\t\t\tapplyFromProps();\n\t\t\tdidMountRef.current = true;\n\t\t}, [ placeholder, ...__unstableDependencies ] ),\n\t] );\n\n\treturn {\n\t\tvalue: recordRef.current,\n\t\t// A function to get the most recent value so event handlers in\n\t\t// useRichText implementations have access to it. For example when\n\t\t// listening to input events, we internally update the state, but this\n\t\t// state is not yet available to the input event handler because React\n\t\t// may re-render asynchronously.\n\t\tgetValue: () => recordRef.current,\n\t\tonChange: handleChange,\n\t\tref: mergedRefs,\n\t};\n}\n\nexport default function __experimentalRichText() {}\n", "/**\n * WordPress dependencies\n */\nimport { useCallback } from '@wordpress/element';\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * A minimum width of 1px will prevent the rich text container from collapsing\n * to 0 width and hiding the caret. This is useful for inline containers.\n */\nconst minWidth = '1px';\n\nexport function useDefaultStyle() {\n\treturn useCallback( ( element ) => {\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\t\telement.style.whiteSpace = whiteSpace;\n\t\telement.style.minWidth = minWidth;\n\t}, [] );\n}\n", "var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n", "/**\n * External dependencies\n */\nimport { colord } from 'colord';\n\n/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nexport function useBoundaryStyle( { record } ) {\n\tconst ref = useRef();\n\tconst { activeFormats = [], replacements, start } = record.current;\n\tconst activeReplacement = replacements[ start ];\n\tuseEffect( () => {\n\t\t// There's no need to recalculate the boundary styles if no formats are\n\t\t// active, because no boundary styles will be visible.\n\t\tif (\n\t\t\t( ! activeFormats || ! activeFormats.length ) &&\n\t\t\t! activeReplacement\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundarySelector = '*[data-rich-text-format-boundary]';\n\t\tconst element = ref.current.querySelector( boundarySelector );\n\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst computedStyle = defaultView.getComputedStyle( element );\n\t\tconst newColor = colord( computedStyle.color )\n\t\t\t.alpha( 0.2 )\n\t\t\t.toRgbString();\n\t\tconst selector = `.rich-text:focus ${ boundarySelector }`;\n\t\tconst rule = `background-color: ${ newColor }`;\n\t\tconst style = `${ selector } {${ rule }}`;\n\t\tconst globalStyleId = 'rich-text-boundary-style';\n\n\t\tlet globalStyle = ownerDocument.getElementById( globalStyleId );\n\n\t\tif ( ! globalStyle ) {\n\t\t\tglobalStyle = ownerDocument.createElement( 'style' );\n\t\t\tglobalStyle.id = globalStyleId;\n\t\t\townerDocument.head.appendChild( globalStyle );\n\t\t}\n\n\t\tif ( globalStyle.innerHTML !== style ) {\n\t\t\tglobalStyle.innerHTML = style;\n\t\t}\n\t}, [ activeFormats, activeReplacement ] );\n\treturn ref;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useMemo, useRef, useInsertionEffect } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport copyHandler from './copy-handler';\nimport selectObject from './select-object';\nimport formatBoundaries from './format-boundaries';\nimport deleteHandler from './delete';\nimport inputAndSelection from './input-and-selection';\nimport selectionChangeCompat from './selection-change-compat';\nimport { preventFocusCapture } from './prevent-focus-capture';\n\nconst allEventListeners = [\n\tcopyHandler,\n\tselectObject,\n\tformatBoundaries,\n\tdeleteHandler,\n\tinputAndSelection,\n\tselectionChangeCompat,\n\tpreventFocusCapture,\n];\n\nexport function useEventListeners( props ) {\n\tconst propsRef = useRef( props );\n\tuseInsertionEffect( () => {\n\t\tpropsRef.current = props;\n\t} );\n\tconst refEffects = useMemo(\n\t\t() => allEventListeners.map( ( refEffect ) => refEffect( propsRef ) ),\n\t\t[ propsRef ]\n\t);\n\n\treturn useRefEffect(\n\t\t( element ) => {\n\t\t\tconst cleanups = refEffects.map( ( effect ) => effect( element ) );\n\t\t\treturn () => {\n\t\t\t\tcleanups.forEach( ( cleanup ) => cleanup() );\n\t\t\t};\n\t\t},\n\t\t[ refEffects ]\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport { toHTMLString } from '../../to-html-string';\nimport { isCollapsed } from '../../is-collapsed';\nimport { slice } from '../../slice';\nimport { getTextContent } from '../../get-text-content';\n\nexport default ( props ) => ( element ) => {\n\tfunction onCopy( event ) {\n\t\tconst { record } = props.current;\n\t\tconst { ownerDocument } = element;\n\t\tif (\n\t\t\tisCollapsed( record.current ) ||\n\t\t\t! element.contains( ownerDocument.activeElement )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedRecord = slice( record.current );\n\t\tconst plainText = getTextContent( selectedRecord );\n\t\tconst html = toHTMLString( { value: selectedRecord } );\n\t\tevent.clipboardData.setData( 'text/plain', plainText );\n\t\tevent.clipboardData.setData( 'text/html', html );\n\t\tevent.clipboardData.setData( 'rich-text', 'true' );\n\t\tevent.preventDefault();\n\n\t\tif ( event.type === 'cut' ) {\n\t\t\townerDocument.execCommand( 'delete' );\n\t\t}\n\t}\n\n\tconst { defaultView } = element.ownerDocument;\n\n\tdefaultView.addEventListener( 'copy', onCopy );\n\tdefaultView.addEventListener( 'cut', onCopy );\n\treturn () => {\n\t\tdefaultView.removeEventListener( 'copy', onCopy );\n\t\tdefaultView.removeEventListener( 'cut', onCopy );\n\t};\n};\n", "export default () => ( element ) => {\n\tfunction onClick( event ) {\n\t\tconst { target } = event;\n\n\t\t// If the child element has no text content, it must be an object.\n\t\tif (\n\t\t\ttarget === element ||\n\t\t\t( target.textContent && target.isContentEditable )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = target;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst selection = defaultView.getSelection();\n\n\t\t// If it's already selected, do nothing and let default behavior happen.\n\t\t// This means it's \"click-through\".\n\t\tif ( selection.containsNode( target ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = ownerDocument.createRange();\n\t\t// If the target is within a non editable element, select the non\n\t\t// editable element.\n\t\tconst nodeToSelect = target.isContentEditable\n\t\t\t? target\n\t\t\t: target.closest( '[contenteditable]' );\n\n\t\trange.selectNode( nodeToSelect );\n\t\tselection.removeAllRanges();\n\t\tselection.addRange( range );\n\n\t\tevent.preventDefault();\n\t}\n\n\tfunction onFocusIn( event ) {\n\t\t// When there is incoming focus from a link, select the object.\n\t\tif (\n\t\t\tevent.relatedTarget &&\n\t\t\t! element.contains( event.relatedTarget ) &&\n\t\t\tevent.relatedTarget.tagName === 'A'\n\t\t) {\n\t\t\tonClick( event );\n\t\t}\n\t}\n\n\telement.addEventListener( 'click', onClick );\n\telement.addEventListener( 'focusin', onFocusIn );\n\treturn () => {\n\t\telement.removeEventListener( 'click', onClick );\n\t\telement.removeEventListener( 'focusin', onFocusIn );\n\t};\n};\n", "/**\n * WordPress dependencies\n */\nimport { LEFT, RIGHT } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { isCollapsed } from '../../is-collapsed';\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nexport default ( props ) => ( element ) => {\n\tfunction onKeyDown( event ) {\n\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\tif (\n\t\t\t// Only override left and right keys without modifiers pressed.\n\t\t\tshiftKey ||\n\t\t\taltKey ||\n\t\t\tmetaKey ||\n\t\t\tctrlKey ||\n\t\t\t( keyCode !== LEFT && keyCode !== RIGHT )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { record, applyRecord, forceRender } = props.current;\n\t\tconst {\n\t\t\ttext,\n\t\t\tformats,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tactiveFormats: currentActiveFormats = [],\n\t\t} = record.current;\n\t\tconst collapsed = isCollapsed( record.current );\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\t// To do: ideally, we should look at visual position instead.\n\t\tconst { direction } = defaultView.getComputedStyle( element );\n\t\tconst reverseKey = direction === 'rtl' ? RIGHT : LEFT;\n\t\tconst isReverse = event.keyCode === reverseKey;\n\n\t\t// If the selection is collapsed and at the very start, do nothing if\n\t\t// navigating backward.\n\t\t// If the selection is collapsed and at the very end, do nothing if\n\t\t// navigating forward.\n\t\tif ( collapsed && currentActiveFormats.length === 0 ) {\n\t\t\tif ( start === 0 && isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( end === text.length && ! isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the selection is not collapsed, let the browser handle collapsing\n\t\t// the selection for now. Later we could expand this logic to set\n\t\t// boundary positions if needed.\n\t\tif ( ! collapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst destination = isReverse ? formatsBefore : formatsAfter;\n\t\tconst isIncreasing = currentActiveFormats.every(\n\t\t\t( format, index ) => format === destination[ index ]\n\t\t);\n\n\t\tlet newActiveFormatsLength = currentActiveFormats.length;\n\n\t\tif ( ! isIncreasing ) {\n\t\t\tnewActiveFormatsLength--;\n\t\t} else if ( newActiveFormatsLength < destination.length ) {\n\t\t\tnewActiveFormatsLength++;\n\t\t}\n\n\t\tif ( newActiveFormatsLength === currentActiveFormats.length ) {\n\t\t\trecord.current._newActiveFormats = destination;\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tconst origin = isReverse ? formatsAfter : formatsBefore;\n\t\tconst source = isIncreasing ? destination : origin;\n\t\tconst newActiveFormats = source.slice( 0, newActiveFormatsLength );\n\t\tconst newValue = {\n\t\t\t...record.current,\n\t\t\tactiveFormats: newActiveFormats,\n\t\t};\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue );\n\t\tforceRender();\n\t}\n\n\telement.addEventListener( 'keydown', onKeyDown );\n\treturn () => {\n\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t};\n};\n", "/**\n * WordPress dependencies\n */\nimport { BACKSPACE, DELETE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { remove } from '../../remove';\n\nexport default ( props ) => ( element ) => {\n\tfunction onKeyDown( event ) {\n\t\tconst { keyCode } = event;\n\t\tconst { createRecord, handleChange } = props.current;\n\n\t\tif ( event.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( keyCode !== DELETE && keyCode !== BACKSPACE ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, end, text } = currentValue;\n\n\t\t// Always handle full content deletion ourselves.\n\t\tif ( start === 0 && end !== 0 && end === text.length ) {\n\t\t\thandleChange( remove( currentValue ) );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\telement.addEventListener( 'keydown', onKeyDown );\n\treturn () => {\n\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t};\n};\n", "/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param {Object}        $1         Named paramentes.\n * @param {RichTextValue} $1.value   Value te update.\n * @param {number}        $1.start   Index to update from.\n * @param {number}        $1.end     Index to update until.\n * @param {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nexport function updateFormats( { value, start, end, formats } ) {\n\t// Start and end may be switched in case of delete.\n\tconst min = Math.min( start, end );\n\tconst max = Math.max( start, end );\n\tconst formatsBefore = value.formats[ min - 1 ] || [];\n\tconst formatsAfter = value.formats[ max ] || [];\n\n\t// First, fix the references. If any format right before or after are\n\t// equal, the replacement format should use the same reference.\n\tvalue.activeFormats = formats.map( ( format, index ) => {\n\t\tif ( formatsBefore[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsBefore[ index ] ) ) {\n\t\t\t\treturn formatsBefore[ index ];\n\t\t\t}\n\t\t} else if ( formatsAfter[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsAfter[ index ] ) ) {\n\t\t\t\treturn formatsAfter[ index ];\n\t\t\t}\n\t\t}\n\n\t\treturn format;\n\t} );\n\n\twhile ( --end >= start ) {\n\t\tif ( value.activeFormats.length > 0 ) {\n\t\t\tvalue.formats[ end ] = value.activeFormats;\n\t\t} else {\n\t\t\tdelete value.formats[ end ];\n\t\t}\n\t}\n\n\treturn value;\n}\n", "/**\n * Internal dependencies\n */\nimport { getActiveFormats } from '../../get-active-formats';\nimport { updateFormats } from '../../update-formats';\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set( [\n\t'insertParagraph',\n\t'insertOrderedList',\n\t'insertUnorderedList',\n\t'insertHorizontalRule',\n\t'insertLink',\n] );\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nconst PLACEHOLDER_ATTR_NAME = 'data-rich-text-placeholder';\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection( defaultView ) {\n\tconst selection = defaultView.getSelection();\n\tconst { anchorNode, anchorOffset } = selection;\n\n\tif ( anchorNode.nodeType !== anchorNode.ELEMENT_NODE ) {\n\t\treturn;\n\t}\n\n\tconst targetNode = anchorNode.childNodes[ anchorOffset ];\n\n\tif (\n\t\t! targetNode ||\n\t\ttargetNode.nodeType !== targetNode.ELEMENT_NODE ||\n\t\t! targetNode.hasAttribute( PLACEHOLDER_ATTR_NAME )\n\t) {\n\t\treturn;\n\t}\n\n\tselection.collapseToStart();\n}\n\nexport default ( props ) => ( element ) => {\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\n\tlet isComposing = false;\n\n\tfunction onInput( event ) {\n\t\t// Do not trigger a change if characters are being composed. Browsers\n\t\t// will usually emit a final `input` event when the characters are\n\t\t// composed. As of December 2019, Safari doesn't support\n\t\t// nativeEvent.isComposing.\n\t\tif ( isComposing ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet inputType;\n\n\t\tif ( event ) {\n\t\t\tinputType = event.inputType;\n\t\t}\n\n\t\tconst { record, applyRecord, createRecord, handleChange } =\n\t\t\tprops.current;\n\n\t\t// The browser formatted something or tried to insert HTML. Overwrite\n\t\t// it. It will be handled later by the format library if needed.\n\t\tif (\n\t\t\tinputType &&\n\t\t\t( inputType.indexOf( 'format' ) === 0 ||\n\t\t\t\tINSERTION_INPUT_TYPES_TO_IGNORE.has( inputType ) )\n\t\t) {\n\t\t\tapplyRecord( record.current );\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, activeFormats: oldActiveFormats = [] } = record.current;\n\n\t\t// Update the formats between the last and new caret position.\n\t\tconst change = updateFormats( {\n\t\t\tvalue: currentValue,\n\t\t\tstart,\n\t\t\tend: currentValue.start,\n\t\t\tformats: oldActiveFormats,\n\t\t} );\n\n\t\thandleChange( change );\n\t}\n\n\t/**\n\t * Syncs the selection to local state. A callback for the `selectionchange`\n\t * event.\n\t */\n\tfunction handleSelectionChange() {\n\t\tconst { record, applyRecord, createRecord, onSelectionChange } =\n\t\t\tprops.current;\n\n\t\t// Check if the implementor disabled editing. `contentEditable` does\n\t\t// disable input, but not text selection, so we must ignore selection\n\t\t// changes.\n\t\tif ( element.contentEditable !== 'true' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure the active element is the rich text element.\n\t\tif ( ownerDocument.activeElement !== element ) {\n\t\t\t// If it is not, we can stop listening for selection changes. We\n\t\t\t// resume listening when the element is focused.\n\t\t\townerDocument.removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// In case of a keyboard event, ignore selection changes during\n\t\t// composition.\n\t\tif ( isComposing ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { start, end, text } = createRecord();\n\t\tconst oldRecord = record.current;\n\n\t\t// Fallback mechanism for IE11, which doesn't support the input event.\n\t\t// Any input results in a selection change.\n\t\tif ( text !== oldRecord.text ) {\n\t\t\tonInput();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( start === oldRecord.start && end === oldRecord.end ) {\n\t\t\t// Sometimes the browser may set the selection on the placeholder\n\t\t\t// element, in which case the caret is not visible. We need to set\n\t\t\t// the caret before the placeholder if that's the case.\n\t\t\tif ( oldRecord.text.length === 0 && start === 0 ) {\n\t\t\t\tfixPlaceholderSelection( defaultView );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst newValue = {\n\t\t\t...oldRecord,\n\t\t\tstart,\n\t\t\tend,\n\t\t\t// _newActiveFormats may be set on arrow key navigation to control\n\t\t\t// the right boundary position. If undefined, getActiveFormats will\n\t\t\t// give the active formats according to the browser.\n\t\t\tactiveFormats: oldRecord._newActiveFormats,\n\t\t\t_newActiveFormats: undefined,\n\t\t};\n\n\t\tconst newActiveFormats = getActiveFormats(\n\t\t\tnewValue,\n\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t);\n\n\t\t// Update the value with the new active formats.\n\t\tnewValue.activeFormats = newActiveFormats;\n\n\t\t// It is important that the internal value is updated first,\n\t\t// otherwise the value will be wrong on render!\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue, { domOnly: true } );\n\t\tonSelectionChange( start, end );\n\t}\n\n\tfunction onCompositionStart() {\n\t\tisComposing = true;\n\t\t// Do not update the selection when characters are being composed as\n\t\t// this rerenders the component and might destroy internal browser\n\t\t// editing state.\n\t\townerDocument.removeEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t\t// Remove the placeholder. Since the rich text value doesn't update\n\t\t// during composition, the placeholder doesn't get removed. There's no\n\t\t// need to re-add it, when the value is updated on compositionend it\n\t\t// will be re-added when the value is empty.\n\t\telement.querySelector( `[${ PLACEHOLDER_ATTR_NAME }]` )?.remove();\n\t}\n\n\tfunction onCompositionEnd() {\n\t\tisComposing = false;\n\t\t// Ensure the value is up-to-date for browsers that don't emit a final\n\t\t// input event after composition.\n\t\tonInput( { inputType: 'insertText' } );\n\t\t// Tracking selection changes can be resumed.\n\t\townerDocument.addEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\tfunction onFocus() {\n\t\tconst { record, isSelected, onSelectionChange, applyRecord } =\n\t\t\tprops.current;\n\n\t\t// When the whole editor is editable, let writing flow handle\n\t\t// selection.\n\t\tif ( element.parentElement.closest( '[contenteditable=\"true\"]' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! isSelected ) {\n\t\t\t// We know for certain that on focus, the old selection is invalid.\n\t\t\t// It will be recalculated on the next mouseup, keyup, or touchend\n\t\t\t// event.\n\t\t\tconst index = undefined;\n\n\t\t\trecord.current = {\n\t\t\t\t...record.current,\n\t\t\t\tstart: index,\n\t\t\t\tend: index,\n\t\t\t\tactiveFormats: EMPTY_ACTIVE_FORMATS,\n\t\t\t};\n\t\t} else {\n\t\t\tapplyRecord( record.current, { domOnly: true } );\n\t\t}\n\n\t\tonSelectionChange( record.current.start, record.current.end );\n\n\t\t// There is no selection change event when the element is focused, so\n\t\t// we need to manually trigger it. The selection is also not available\n\t\t// yet in this call stack.\n\t\twindow.queueMicrotask( handleSelectionChange );\n\n\t\townerDocument.addEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\telement.addEventListener( 'input', onInput );\n\telement.addEventListener( 'compositionstart', onCompositionStart );\n\telement.addEventListener( 'compositionend', onCompositionEnd );\n\telement.addEventListener( 'focus', onFocus );\n\n\treturn () => {\n\t\telement.removeEventListener( 'input', onInput );\n\t\telement.removeEventListener( 'compositionstart', onCompositionStart );\n\t\telement.removeEventListener( 'compositionend', onCompositionEnd );\n\t\telement.removeEventListener( 'focus', onFocus );\n\t};\n};\n", "/**\n * Internal dependencies\n */\nimport { isRangeEqual } from '../../is-range-equal';\n\n/**\n * Sometimes some browsers are not firing a `selectionchange` event when\n * changing the selection by mouse or keyboard. This hook makes sure that, if we\n * detect no `selectionchange` or `input` event between the up and down events,\n * we fire a `selectionchange` event.\n */\nexport default () => ( element ) => {\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView?.getSelection();\n\n\tlet range;\n\n\tfunction getRange() {\n\t\treturn selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\t}\n\n\tfunction onDown( event ) {\n\t\tconst type = event.type === 'keydown' ? 'keyup' : 'pointerup';\n\n\t\tfunction onCancel() {\n\t\t\townerDocument.removeEventListener( type, onUp );\n\t\t\townerDocument.removeEventListener( 'selectionchange', onCancel );\n\t\t\townerDocument.removeEventListener( 'input', onCancel );\n\t\t}\n\n\t\tfunction onUp() {\n\t\t\tonCancel();\n\t\t\tif ( isRangeEqual( range, getRange() ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\townerDocument.dispatchEvent( new Event( 'selectionchange' ) );\n\t\t}\n\n\t\townerDocument.addEventListener( type, onUp );\n\t\townerDocument.addEventListener( 'selectionchange', onCancel );\n\t\townerDocument.addEventListener( 'input', onCancel );\n\n\t\trange = getRange();\n\t}\n\n\telement.addEventListener( 'pointerdown', onDown );\n\telement.addEventListener( 'keydown', onDown );\n\treturn () => {\n\t\telement.removeEventListener( 'pointerdown', onDown );\n\t\telement.removeEventListener( 'keydown', onDown );\n\t};\n};\n", "/**\n * Prevents focus from being captured by the element when clicking _outside_\n * around the element. This may happen when the parent element is flex.\n * @see https://github.com/WordPress/gutenberg/pull/65857\n * @see https://github.com/WordPress/gutenberg/pull/66402\n */\nexport function preventFocusCapture() {\n\treturn ( element ) => {\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\n\t\tlet value = null;\n\n\t\tfunction onPointerDown( event ) {\n\t\t\t// Abort if the event is default prevented, we will not get a pointer up event.\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( event.target === element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( ! event.target.contains( element ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue = element.getAttribute( 'contenteditable' );\n\t\t\telement.setAttribute( 'contenteditable', 'false' );\n\t\t\tdefaultView.getSelection().removeAllRanges();\n\t\t}\n\n\t\tfunction onPointerUp() {\n\t\t\tif ( value !== null ) {\n\t\t\t\telement.setAttribute( 'contenteditable', value );\n\t\t\t\tvalue = null;\n\t\t\t}\n\t\t}\n\n\t\tdefaultView.addEventListener( 'pointerdown', onPointerDown );\n\t\tdefaultView.addEventListener( 'pointerup', onPointerUp );\n\t\treturn () => {\n\t\t\tdefaultView.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tdefaultView.removeEventListener( 'pointerup', onPointerUp );\n\t\t};\n\t};\n}\n"],
  "mappings": "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",
  "names": ["require_data", "__commonJSMin", "exports", "module", "require_escape_html", "__commonJSMin", "exports", "module", "require_a11y", "__commonJSMin", "exports", "module", "require_i18n", "__commonJSMin", "exports", "module", "require_element", "__commonJSMin", "exports", "module", "require_deprecated", "__commonJSMin", "exports", "module", "require_compose", "__commonJSMin", "exports", "module", "require_keycodes", "__commonJSMin", "exports", "module", "import_data", "import_data", "formatTypes", "state", "action", "newFormatTypes", "type", "key", "reducer_default", "import_data", "getFormatTypes", "state", "getFormatType", "name", "getFormatTypeForBareElement", "bareElementTagName", "formatTypes", "className", "tagName", "getFormatTypeForClassName", "elementClassName", "addFormatTypes", "formatTypes", "removeFormatTypes", "names", "STORE_NAME", "store", "reducer_default", "selectors_exports", "actions_exports", "isFormatEqual", "format1", "format2", "attributes1", "attributes2", "keys1", "keys2", "length", "i", "name", "normaliseFormats", "value", "newFormats", "formatsAtIndex", "index", "formatsAtPreviousIndex", "newFormatsAtIndex", "format", "formatIndex", "previousFormat", "isFormatEqual", "replace", "array", "index", "value", "applyFormat", "format", "startIndex", "endIndex", "formats", "activeFormats", "newFormats", "startFormat", "type", "position", "length", "normaliseFormats", "import_data", "createElement", "implementation", "html", "OBJECT_REPLACEMENT_CHARACTER", "ZWNBSP", "import_escape_html", "getActiveFormats", "value", "EMPTY_ACTIVE_FORMATS", "formats", "start", "end", "activeFormats", "formatsBefore", "formatsAfter", "selectedFormats", "_activeFormats", "i", "formatsAtIndex", "ii", "format", "_format", "isFormatEqual", "import_data", "getFormatType", "name", "store", "restoreOnAttributes", "attributes", "isEditableTree", "newAttributes", "key", "newKey", "fromFormat", "type", "tagName", "unregisteredAttributes", "object", "boundaryClass", "formatType", "getFormatType", "elementAttributes", "name", "isEqualUntil", "a", "b", "index", "toTree", "value", "preserveWhiteSpace", "createEmpty", "append", "getLastChild", "getParent", "isText", "getText", "remove", "appendText", "onStartIndex", "onEndIndex", "placeholder", "formats", "replacements", "text", "start", "end", "formatsLength", "tree", "activeFormats", "getActiveFormats", "deepestActiveFormat", "lastCharacterFormats", "lastCharacter", "i", "character", "shouldInsertPadding", "characterFormats", "pointer", "format", "formatIndex", "parent", "newNode", "OBJECT_REPLACEMENT_CHARACTER", "replacement", "innerHTML", "attrs", "ZWNBSP", "toHTMLString", "value", "preserveWhiteSpace", "tree", "toTree", "createEmpty", "append", "getLastChild", "getParent", "isText", "getText", "remove", "appendText", "createChildrenHTML", "children", "parent", "object", "text", "index", "createElementHTML", "type", "attributes", "attributeString", "key", "child", "getTextContent", "text", "OBJECT_REPLACEMENT_CHARACTER", "createEmptyValue", "toFormat", "tagName", "attributes", "formatType", "store", "registeredAttributes", "unregisteredAttributes", "_attributes", "key", "name", "RichTextData", "_RichTextData", "#value", "text", "create", "html", "htmlElement", "options", "preserveWhiteSpace", "element", "collapseWhiteSpace", "richTextData", "init", "getTextContent", "toHTMLString", "args", "range", "isEditableTree", "createElement", "createFromElement", "accumulateSelection", "accumulator", "node", "value", "parentNode", "startContainer", "startOffset", "endContainer", "endOffset", "currentLength", "filterRange", "filter", "isRoot", "clone", "i", "nodes", "newNodeValue", "CARRIAGE_RETURN", "removeReservedCharacters", "string", "ZWNBSP", "OBJECT_REPLACEMENT_CHARACTER", "length", "index", "mergePair", "format", "getAttributes", "mergeFormats", "formats", "newFormats", "safeName", "mergePair", "a", "b", "concat", "values", "normaliseFormats", "create", "getActiveFormat", "value", "formatType", "getActiveFormats", "type", "getActiveObject", "start", "end", "replacements", "text", "OBJECT_REPLACEMENT_CHARACTER", "isCollapsed", "start", "end", "isEmpty", "text", "join", "values", "separator", "create", "normaliseFormats", "accumulator", "formats", "replacements", "text", "import_data", "registerFormatType", "name", "settings", "store", "formatTypeForBareElement", "formatTypeForClassName", "removeFormat", "value", "formatType", "startIndex", "endIndex", "formats", "activeFormats", "newFormats", "format", "type", "newFormat", "filterFormats", "i", "normaliseFormats", "index", "insert", "value", "valueToInsert", "startIndex", "endIndex", "formats", "replacements", "text", "create", "index", "normaliseFormats", "remove", "value", "startIndex", "endIndex", "insert", "create", "replace", "formats", "replacements", "text", "start", "end", "pattern", "replacement", "match", "rest", "offset", "newText", "newFormats", "newReplacements", "normaliseFormats", "insertObject", "value", "formatToInsert", "startIndex", "endIndex", "insert", "OBJECT_REPLACEMENT_CHARACTER", "slice", "value", "startIndex", "endIndex", "formats", "replacements", "text", "split", "formats", "replacements", "text", "start", "end", "string", "splitAtSelection", "nextStart", "substring", "startIndex", "value", "endIndex", "before", "after", "isRangeEqual", "a", "b", "MATHML_NAMESPACE", "createPathToNode", "node", "rootNode", "path", "parentNode", "i", "getNodeByPath", "append", "element", "child", "type", "attributes", "parentNamespace", "key", "appendText", "text", "getLastChild", "lastChild", "getParent", "isText", "getText", "nodeValue", "remove", "toDom", "value", "prepareEditableTree", "isEditableTree", "placeholder", "doc", "startPath", "endPath", "toTree", "createElement", "body", "pointer", "apply", "current", "__unstableDomOnly", "selection", "applyValue", "applySelection", "future", "futureChild", "currentChild", "currentAttributes", "futureAttributes", "ii", "name", "startContainer", "startOffset", "endContainer", "endOffset", "ownerDocument", "defaultView", "range", "activeElement", "isRangeEqual", "import_a11y", "import_i18n", "toggleFormat", "value", "format", "getActiveFormat", "removeFormat", "applyFormat", "import_data", "unregisterFormatType", "name", "oldFormat", "store", "import_element", "import_deprecated", "useAnchorRef", "ref", "value", "settings", "deprecated", "tagName", "className", "name", "activeFormat", "getActiveFormat", "defaultView", "selection", "range", "element", "import_compose", "import_element", "getFormatElement", "range", "editableContentElement", "tagName", "className", "element", "selector", "createVirtualAnchorElement", "getAnchor", "ownerDocument", "defaultView", "selection", "formatElement", "useAnchor", "settings", "isActive", "anchor", "setAnchor", "wasActive", "callback", "attach", "detach", "import_element", "import_compose", "import_data", "import_element", "whiteSpace", "minWidth", "useDefaultStyle", "element", "r", "t", "n", "e", "u", "a", "o", "i", "s", "h", "b", "g", "d", "f", "c", "l", "p", "v", "m", "y", "N", "x", "M", "r", "n", "c", "e", "H", "$", "j", "x", "o", "t", "u", "a", "s", "d", "h", "w", "import_element", "useBoundaryStyle", "record", "ref", "activeFormats", "replacements", "start", "activeReplacement", "boundarySelector", "element", "ownerDocument", "defaultView", "computedStyle", "newColor", "w", "selector", "rule", "style", "globalStyleId", "globalStyle", "import_element", "import_compose", "copy_handler_default", "props", "element", "onCopy", "event", "record", "ownerDocument", "isCollapsed", "selectedRecord", "slice", "plainText", "getTextContent", "html", "toHTMLString", "defaultView", "select_object_default", "element", "onClick", "event", "target", "ownerDocument", "defaultView", "selection", "range", "nodeToSelect", "onFocusIn", "import_keycodes", "EMPTY_ACTIVE_FORMATS", "format_boundaries_default", "props", "element", "onKeyDown", "event", "keyCode", "shiftKey", "altKey", "metaKey", "ctrlKey", "record", "applyRecord", "forceRender", "text", "formats", "start", "end", "currentActiveFormats", "collapsed", "isCollapsed", "ownerDocument", "defaultView", "direction", "reverseKey", "isReverse", "formatsBefore", "formatsAfter", "destination", "isIncreasing", "format", "index", "newActiveFormatsLength", "newActiveFormats", "newValue", "import_keycodes", "delete_default", "props", "element", "onKeyDown", "event", "keyCode", "createRecord", "handleChange", "currentValue", "start", "end", "text", "remove", "updateFormats", "value", "start", "end", "formats", "min", "max", "formatsBefore", "formatsAfter", "format", "index", "isFormatEqual", "INSERTION_INPUT_TYPES_TO_IGNORE", "EMPTY_ACTIVE_FORMATS", "PLACEHOLDER_ATTR_NAME", "fixPlaceholderSelection", "defaultView", "selection", "anchorNode", "anchorOffset", "targetNode", "input_and_selection_default", "props", "element", "ownerDocument", "isComposing", "onInput", "event", "inputType", "record", "applyRecord", "createRecord", "handleChange", "currentValue", "start", "oldActiveFormats", "change", "updateFormats", "handleSelectionChange", "onSelectionChange", "end", "text", "oldRecord", "newValue", "newActiveFormats", "getActiveFormats", "onCompositionStart", "onCompositionEnd", "onFocus", "isSelected", "selection_change_compat_default", "element", "ownerDocument", "defaultView", "selection", "range", "getRange", "onDown", "event", "type", "onCancel", "onUp", "isRangeEqual", "preventFocusCapture", "element", "ownerDocument", "defaultView", "value", "onPointerDown", "event", "onPointerUp", "allEventListeners", "copy_handler_default", "select_object_default", "format_boundaries_default", "delete_default", "input_and_selection_default", "selection_change_compat_default", "preventFocusCapture", "useEventListeners", "props", "propsRef", "refEffects", "refEffect", "element", "cleanups", "effect", "cleanup", "useRichText", "value", "selectionStart", "selectionEnd", "placeholder", "onSelectionChange", "preserveWhiteSpace", "onChange", "disableFormats", "isSelected", "__unstableDependencies", "__unstableAfterParse", "__unstableBeforeSerialize", "__unstableAddInvisibleFormats", "registry", "forceRender", "ref", "createRecord", "defaultView", "selection", "range", "create", "applyRecord", "newRecord", "domOnly", "apply", "_valueRef", "recordRef", "setRecordFromProps", "RichTextData", "hadSelectionUpdateRef", "handleChange", "newFormats", "toHTMLString", "start", "end", "formats", "text", "applyFromProps", "previousValue", "contentLengthChanged", "hasFocus", "skipSelection", "didMountRef", "mergedRefs", "useDefaultStyle", "useBoundaryStyle", "useEventListeners", "__experimentalRichText"]
}
