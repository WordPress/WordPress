{
  "version": 3,
  "sources": ["package-external:@wordpress/data", "package-external:@wordpress/escape-html", "package-external:@wordpress/a11y", "package-external:@wordpress/i18n", "package-external:@wordpress/element", "package-external:@wordpress/deprecated", "package-external:@wordpress/compose", "package-external:@wordpress/keycodes", "../../../packages/rich-text/src/store/index.js", "../../../packages/rich-text/src/store/reducer.js", "../../../packages/rich-text/src/store/selectors.js", "../../../packages/rich-text/src/store/actions.js", "../../../packages/rich-text/src/is-format-equal.js", "../../../packages/rich-text/src/normalise-formats.js", "../../../packages/rich-text/src/apply-format.js", "../../../packages/rich-text/src/create.js", "../../../packages/rich-text/src/create-element.js", "../../../packages/rich-text/src/special-characters.js", "../../../packages/rich-text/src/to-html-string.js", "../../../packages/rich-text/src/get-active-formats.js", "../../../packages/rich-text/src/get-format-type.js", "../../../packages/rich-text/src/to-tree.js", "../../../packages/rich-text/src/get-text-content.js", "../../../packages/rich-text/src/concat.js", "../../../packages/rich-text/src/get-active-format.js", "../../../packages/rich-text/src/get-active-object.js", "../../../packages/rich-text/src/is-collapsed.ts", "../../../packages/rich-text/src/is-empty.js", "../../../packages/rich-text/src/join.js", "../../../packages/rich-text/src/register-format-type.js", "../../../packages/rich-text/src/remove-format.js", "../../../packages/rich-text/src/insert.js", "../../../packages/rich-text/src/remove.js", "../../../packages/rich-text/src/replace.js", "../../../packages/rich-text/src/insert-object.js", "../../../packages/rich-text/src/slice.js", "../../../packages/rich-text/src/split.js", "../../../packages/rich-text/src/is-range-equal.js", "../../../packages/rich-text/src/to-dom.js", "../../../packages/rich-text/src/toggle-format.js", "../../../packages/rich-text/src/unregister-format-type.js", "../../../packages/rich-text/src/component/use-anchor-ref.js", "../../../packages/rich-text/src/component/use-anchor.js", "../../../packages/rich-text/src/component/index.js", "../../../packages/rich-text/src/component/use-default-style.js", "../../../node_modules/colord/index.mjs", "../../../packages/rich-text/src/component/use-boundary-style.js", "../../../packages/rich-text/src/component/event-listeners/index.js", "../../../packages/rich-text/src/component/event-listeners/copy-handler.js", "../../../packages/rich-text/src/component/event-listeners/select-object.js", "../../../packages/rich-text/src/component/event-listeners/format-boundaries.js", "../../../packages/rich-text/src/component/event-listeners/delete.js", "../../../packages/rich-text/src/update-formats.js", "../../../packages/rich-text/src/component/event-listeners/input-and-selection.js", "../../../packages/rich-text/src/component/event-listeners/selection-change-compat.js", "../../../packages/rich-text/src/component/event-listeners/prevent-focus-capture.js"],
  "sourcesContent": ["module.exports = window.wp.data;", "module.exports = window.wp.escapeHtml;", "module.exports = window.wp.a11y;", "module.exports = window.wp.i18n;", "module.exports = window.wp.element;", "module.exports = window.wp.deprecated;", "module.exports = window.wp.compose;", "module.exports = window.wp.keycodes;", "/**\n * WordPress dependencies\n */\nimport { createReduxStore, register } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nconst STORE_NAME = 'core/rich-text';\n\n/**\n * Store definition for the rich-text namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nexport const store = createReduxStore( STORE_NAME, {\n\treducer,\n\tselectors,\n\tactions,\n} );\n\nregister( store );\n", "/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t// Key format types by their name.\n\t\t\t\t...action.formatTypes.reduce(\n\t\t\t\t\t( newFormatTypes, type ) => ( {\n\t\t\t\t\t\t...newFormatTypes,\n\t\t\t\t\t\t[ type.name ]: type,\n\t\t\t\t\t} ),\n\t\t\t\t\t{}\n\t\t\t\t),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn Object.fromEntries(\n\t\t\t\tObject.entries( state ).filter(\n\t\t\t\t\t( [ key ] ) => ! action.names.includes( key )\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n", "/**\n * WordPress dependencies\n */\nimport { createSelector } from '@wordpress/data';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypes } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const availableFormats = getFormatTypes();\n *\n *    return availableFormats ? (\n *        <ul>\n *            { availableFormats?.map( ( format ) => (\n *                <li>{ format.name }</li>\n *           ) ) }\n *        </ul>\n *    ) : (\n *        __( 'No Formats available' )\n *    );\n * };\n * ```\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatType } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const boldFormat = getFormatType( 'core/bold' );\n *\n *    return boldFormat ? (\n *        <ul>\n *            { Object.entries( boldFormat )?.map( ( [ key, value ] ) => (\n *                <li>\n *                    { key } : { value }\n *                </li>\n *           ) ) }\n *       </ul>\n *    ) : (\n *        __( 'Not Found' )\n *    ;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForBareElement } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForBareElement( 'strong' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * }\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\tconst formatTypes = getFormatTypes( state );\n\treturn (\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && bareElementTagName === tagName;\n\t\t} ) ||\n\t\tformatTypes.find( ( { className, tagName } ) => {\n\t\t\treturn className === null && '*' === tagName;\n\t\t} )\n\t);\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForClassName } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForClassName( 'has-inline-color' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn getFormatTypes( state ).find( ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n", "/**\n * Returns an action object used in signalling that format types have been\n * added.\n * Ignored from documentation as registerFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: Array.isArray( formatTypes )\n\t\t\t? formatTypes\n\t\t\t: [ formatTypes ],\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * Ignored from documentation as unregisterFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: Array.isArray( names ) ? names : [ names ],\n\t};\n}\n", "/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === format.type\n\t\t);\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...( activeFormats?.filter(\n\t\t\t\t( { type } ) => type !== format.type\n\t\t\t) || [] ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n", "/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\nimport { toHTMLString } from './to-html-string';\nimport { getTextContent } from './get-text-content';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { tagName, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( tagName );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type: tagName, attributes } : { type: tagName };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { formatType, type: formatType.name, tagName };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\tif ( formatType.contentEditable === false ) {\n\t\tdelete unregisteredAttributes.contenteditable;\n\t}\n\n\treturn {\n\t\tformatType,\n\t\ttype: formatType.name,\n\t\ttagName,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * The RichTextData class is used to instantiate a wrapper around rich text\n * values, with methods that can be used to transform or manipulate the data.\n *\n * - Create an empty instance: `new RichTextData()`.\n * - Create one from an HTML string: `RichTextData.fromHTMLString(\n *   '<em>hello</em>' )`.\n * - Create one from a wrapper HTMLElement: `RichTextData.fromHTMLElement(\n *   document.querySelector( 'p' ) )`.\n * - Create one from plain text: `RichTextData.fromPlainText( '1\\n2' )`.\n * - Create one from a rich text value: `new RichTextData( { text: '...',\n *   formats: [ ... ] } )`.\n *\n * @todo Add methods to manipulate the data, such as applyFormat, slice etc.\n */\nexport class RichTextData {\n\t#value;\n\n\tstatic empty() {\n\t\treturn new RichTextData();\n\t}\n\tstatic fromPlainText( text ) {\n\t\treturn new RichTextData( create( { text } ) );\n\t}\n\tstatic fromHTMLString( html ) {\n\t\treturn new RichTextData( create( { html } ) );\n\t}\n\t/**\n\t * Create a RichTextData instance from an HTML element.\n\t *\n\t * @param {HTMLElement}                    htmlElement The HTML element to create the instance from.\n\t * @param {{preserveWhiteSpace?: boolean}} options     Options.\n\t * @return {RichTextData} The RichTextData instance.\n\t */\n\tstatic fromHTMLElement( htmlElement, options = {} ) {\n\t\tconst { preserveWhiteSpace = false } = options;\n\t\tconst element = preserveWhiteSpace\n\t\t\t? htmlElement\n\t\t\t: collapseWhiteSpace( htmlElement );\n\t\tconst richTextData = new RichTextData( create( { element } ) );\n\t\tObject.defineProperty( richTextData, 'originalHTML', {\n\t\t\tvalue: htmlElement.innerHTML,\n\t\t} );\n\t\treturn richTextData;\n\t}\n\tconstructor( init = createEmptyValue() ) {\n\t\tthis.#value = init;\n\t}\n\ttoPlainText() {\n\t\treturn getTextContent( this.#value );\n\t}\n\t// We could expose `toHTMLElement` at some point as well, but we'd only use\n\t// it internally.\n\t/**\n\t * Convert the rich text value to an HTML string.\n\t *\n\t * @param {{preserveWhiteSpace?: boolean}} options Options.\n\t * @return {string} The HTML string.\n\t */\n\ttoHTMLString( { preserveWhiteSpace } = {} ) {\n\t\treturn (\n\t\t\tthis.originalHTML ||\n\t\t\ttoHTMLString( { value: this.#value, preserveWhiteSpace } )\n\t\t);\n\t}\n\tvalueOf() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoString() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoJSON() {\n\t\treturn this.toHTMLString();\n\t}\n\tget length() {\n\t\treturn this.text.length;\n\t}\n\tget formats() {\n\t\treturn this.#value.formats;\n\t}\n\tget replacements() {\n\t\treturn this.#value.replacements;\n\t}\n\tget text() {\n\t\treturn this.#value.text;\n\t}\n}\n\nfor ( const name of Object.getOwnPropertyNames( String.prototype ) ) {\n\tif ( RichTextData.prototype.hasOwnProperty( name ) ) {\n\t\tcontinue;\n\t}\n\n\tObject.defineProperty( RichTextData.prototype, name, {\n\t\tvalue( ...args ) {\n\t\t\t// Should we convert back to RichTextData?\n\t\t\treturn this.toHTMLString()[ name ]( ...args );\n\t\t},\n\t} );\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. The optional\n * functions can be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {boolean} [$1.__unstableIsEditableTree]\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\t__unstableIsEditableTree: isEditableTree,\n} = {} ) {\n\tif ( html instanceof RichTextData ) {\n\t\treturn {\n\t\t\ttext: html.text,\n\t\t\tformats: html.formats,\n\t\t\treplacements: html.replacements,\n\t\t};\n\t}\n\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\treturn createFromElement( {\n\t\telement,\n\t\trange,\n\t\tisEditableTree,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * We need to strip it from the content because we use white-space: pre-wrap for\n * displaying editable rich text. Without using white-space: pre-wrap, the\n * browser will litter the content with non breaking spaces, among other issues.\n * See packages/rich-text/src/component/use-default-style.js.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse#collapsing_of_white_space\n *\n * @param {HTMLElement} element\n * @param {boolean}     isRoot\n *\n * @return {HTMLElement} New element with collapsed whitespace.\n */\nfunction collapseWhiteSpace( element, isRoot = true ) {\n\tconst clone = element.cloneNode( true );\n\tclone.normalize();\n\tArray.from( clone.childNodes ).forEach( ( node, i, nodes ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet newNodeValue = node.nodeValue;\n\n\t\t\tif ( /[\\n\\t\\r\\f]/.test( newNodeValue ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( /[\\n\\t\\r\\f]+/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( newNodeValue.indexOf( '  ' ) !== -1 ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( / {2,}/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( i === 0 && newNodeValue.startsWith( ' ' ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 1 );\n\t\t\t} else if (\n\t\t\t\tisRoot &&\n\t\t\t\ti === nodes.length - 1 &&\n\t\t\t\tnewNodeValue.endsWith( ' ' )\n\t\t\t) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 0, -1 );\n\t\t\t}\n\n\t\t\tnode.nodeValue = newNodeValue;\n\t\t} else if ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tnode.replaceWith( collapseWhiteSpace( node, false ) );\n\t\t}\n\t} );\n\treturn clone;\n}\n\n/**\n * We need to normalise line breaks to `\\n` so they are consistent across\n * platforms and serialised properly. Not removing \\r would cause it to\n * linger and result in double line breaks when whitespace is preserved.\n */\nconst CARRIAGE_RETURN = '\\r';\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces\n * added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR\n\t// reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp(\n\t\t\t`[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }${ CARRIAGE_RETURN }]`,\n\t\t\t'gu'\n\t\t),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                  Named arguments.\n * @param {Element} [$1.element]        Element to create value from.\n * @param {Range}   [$1.range]          Range to create value from.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( { element, range, isEditableTree } ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst tagName = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tconst text = removeReservedCharacters( node.nodeValue );\n\t\t\trange = filterRange( node, range, removeReservedCharacters );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tnode.nodeType === node.COMMENT_NODE ||\n\t\t\t( node.nodeType === node.ELEMENT_NODE &&\n\t\t\t\tnode.tagName === 'SPAN' &&\n\t\t\t\tnode.hasAttribute( 'data-rich-text-comment' ) )\n\t\t) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: '#comment',\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\t\tnode.nodeType === node.COMMENT_NODE\n\t\t\t\t\t\t\t\t\t? node.nodeValue\n\t\t\t\t\t\t\t\t\t: node.getAttribute(\n\t\t\t\t\t\t\t\t\t\t\t'data-rich-text-comment'\n\t\t\t\t\t\t\t\t\t  ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\ttagName === 'br' &&\n\t\t\t! node.getAttribute( 'data-rich-text-line-break' )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tagName,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttagName,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\t// When a format type is declared as not editable, replace it with an\n\t\t// object replacement character and preserve the inner HTML.\n\t\tif ( format?.formatType?.contentEditable === false ) {\n\t\t\tdelete format.formatType;\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...format,\n\t\t\t\t\t\tinnerHTML: node.innerHTML,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( format ) {\n\t\t\tdelete format.formatType;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Ignore any placeholders, but keep their content since the browser\n\t\t// might insert text inside them when the editable element is flex.\n\t\tif (\n\t\t\t! format ||\n\t\t\tnode.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\tnode.getAttribute( 'data-rich-text-bogus' )\n\t\t) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named arguments.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n", "/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\t// Because `createHTMLDocument` is an expensive operation, and with this\n\t// function being internal to `rich-text` (full control in avoiding a risk\n\t// of asynchronous operations on the shared reference), a single document\n\t// is reused and reset for each call to the function.\n\tif ( ! createElement.body ) {\n\t\tcreateElement.body = implementation.createHTMLDocument( '' ).body;\n\t}\n\n\tcreateElement.body.innerHTML = html;\n\n\treturn createElement.body;\n}\n", "/**\n * Object replacement character, used as a placeholder for objects.\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nexport const ZWNBSP = '\\ufeff';\n", "/**\n * WordPress dependencies\n */\n\nimport {\n\tescapeEditableHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value.\n *\n * @param {Object}        $1                      Named arguments.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {boolean}       [$1.preserveWhiteSpace] Preserves newlines if true.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, preserveWhiteSpace } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tpreserveWhiteSpace,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tif ( type === '#comment' ) {\n\t\t// We can't restore the original comment delimiters, because once parsed\n\t\t// into DOM nodes, we don't have the information. But in the future we\n\t\t// could allow comment handlers to specify custom delimiters, for\n\t\t// example `</{comment-content}>` for Bits, where `comment-content`\n\t\t// would be `/{bit-name}` or `__{translatable-string}` (TBD).\n\t\treturn `<!--${ attributes[ 'data-rich-text-comment' ] }-->`;\n\t}\n\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute(\n\t\t\tattributes[ key ]\n\t\t) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML(\n\t\tchildren\n\t) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children\n\t\t.map( ( child ) => {\n\t\t\tif ( child.html !== undefined ) {\n\t\t\t\treturn child.html;\n\t\t\t}\n\n\t\t\treturn child.text === undefined\n\t\t\t\t? createElementHTML( child )\n\t\t\t\t: escapeEditableHTML( child.text );\n\t\t} )\n\t\t.join( '' );\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormatList} RichTextFormatList */\n\n/**\n * Internal dependencies\n */\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats( value, EMPTY_ACTIVE_FORMATS = [] ) {\n\tconst { formats, start, end, activeFormats } = value;\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\t// If there's no formats at the start index, there are not active formats.\n\tif ( ! formats[ start ] ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tconst selectedFormats = formats.slice( start, end );\n\n\t// Clone the formats so we're not mutating the live value.\n\tconst _activeFormats = [ ...selectedFormats[ 0 ] ];\n\tlet i = selectedFormats.length;\n\n\t// For performance reasons, start from the end where it's much quicker to\n\t// realise that there are no active formats.\n\twhile ( i-- ) {\n\t\tconst formatsAtIndex = selectedFormats[ i ];\n\n\t\t// If we run into any index without formats, we're sure that there's no\n\t\t// active formats.\n\t\tif ( ! formatsAtIndex ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\n\t\tlet ii = _activeFormats.length;\n\n\t\t// Loop over the active formats and remove any that are not present at\n\t\t// the current index.\n\t\twhile ( ii-- ) {\n\t\t\tconst format = _activeFormats[ ii ];\n\n\t\t\tif (\n\t\t\t\t! formatsAtIndex.find( ( _format ) =>\n\t\t\t\t\tisFormatEqual( format, _format )\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t_activeFormats.splice( ii, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// If there are no active formats, we can stop.\n\t\tif ( _activeFormats.length === 0 ) {\n\t\t\treturn EMPTY_ACTIVE_FORMATS;\n\t\t}\n\t}\n\n\treturn _activeFormats || EMPTY_ACTIVE_FORMATS;\n}\n", "/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( richTextStore ).getFormatType( name );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( isEditableTree && type === '#comment' ) {\n\t\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\tattributes[ 'data-rich-text-comment' ],\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t\tappend(\n\t\t\t\t\tappend( pointer, { type: 'span' } ),\n\t\t\t\t\tattributes[ 'data-rich-text-comment' ].trim()\n\t\t\t\t);\n\t\t\t} else if ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\tif ( innerHTML || isEditableTree ) {\n\t\t\t\t\tpointer = getParent( pointer );\n\t\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\t\tif ( isEditableTree ) {\n\t\t\t\t\t\tconst attrs = {\n\t\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t\t'data-rich-text-bogus': true,\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif ( start === i && end === i + 1 ) {\n\t\t\t\t\t\t\tattrs[ 'data-rich-text-format-boundary' ] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = append( pointer, {\n\t\t\t\t\t\t\ttype: 'span',\n\t\t\t\t\t\t\tattributes: attrs,\n\t\t\t\t\t\t} );\n\t\t\t\t\t\t// Some browsers like Safari and Firefox have issues placing\n\t\t\t\t\t\t// the caret after a non-editable element when it's at the\n\t\t\t\t\t\t// end of the field, so help them a little by providing a\n\t\t\t\t\t\t// text element. Similar to `insertPadding` above.\n\t\t\t\t\t\tif ( isEditableTree && i + 1 === text.length ) {\n\t\t\t\t\t\t\tappend( getParent( pointer ), ZWNBSP );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpointer = append(\n\t\t\t\t\t\tpointer,\n\t\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\t} )\n\t\t\t\t\t);\n\t\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\t// We CANNOT use CSS to add a placeholder with pseudo elements on\n\t\t\t// the main block wrappers because that could clash with theme CSS.\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n", "/**\n * Internal dependencies\n */\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text.replace( OBJECT_REPLACEMENT_CHARACTER, '' );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nexport function mergePair( a, b ) {\n\ta.formats = a.formats.concat( b.formats );\n\ta.replacements = a.replacements.concat( b.replacements );\n\ta.text += b.text;\n\n\treturn a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( mergePair, create() ) );\n}\n", "/**\n * Internal dependencies\n */\nimport { getActiveFormats } from './get-active-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nexport function getActiveFormat( value, formatType ) {\n\treturn getActiveFormats( value ).find(\n\t\t( { type } ) => type === formatType\n\t);\n}\n", "/**\n * Internal dependencies\n */\n\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nexport function getActiveObject( { start, end, replacements, text } ) {\n\tif ( start + 1 !== end || text[ start ] !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\treturn;\n\t}\n\n\treturn replacements[ start ];\n}\n", "/**\n * Internal dependencies\n */\nimport type { RichTextValue } from './types';\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param props       The rich text value to check.\n * @param props.start\n * @param props.end\n * @return True if the selection is collapsed, false if not, undefined if there is no selection.\n */\nexport function isCollapsed( {\n\tstart,\n\tend,\n}: RichTextValue ): boolean | undefined {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats(\n\t\tvalues.reduce( ( accumulator, { formats, replacements, text } ) => ( {\n\t\t\tformats: accumulator.formats.concat( separator.formats, formats ),\n\t\t\treplacements: accumulator.replacements.concat(\n\t\t\t\tseparator.replacements,\n\t\t\t\treplacements\n\t\t\t),\n\t\t\ttext: accumulator.text + separator.text + text,\n\t\t} ) )\n\t);\n}\n", "/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}        name        A string identifying the format. Must be\n *                                       unique across all registered formats.\n * @property {string}        tagName     The HTML tag this format will wrap the\n *                                       selection with.\n * @property {boolean}       interactive Whether format makes content interactive or not.\n * @property {boolean}       object      Whether the format represents an object (e.g., `img`, `br`),\n *                                       an object cannot contain other format types.\n * @property {string | null} [className] A class to match the format.\n * @property {string}        title       Name of the format.\n * @property {Function}      edit        Should return a component for the user to\n *                                       interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name     Format name.\n * @param {WPFormat} settings Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error( 'Format names must be strings.' );\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( richTextStore ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.tagName !== 'string' || settings.tagName === '' ) {\n\t\twindow.console.error( 'Format tag names must be a string.' );\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' ||\n\t\t\tsettings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9_-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, underscores, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForBareElement( settings.tagName );\n\n\t\tif (\n\t\t\tformatTypeForBareElement &&\n\t\t\tformatTypeForBareElement.name !== 'core/unknown'\n\t\t) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select(\n\t\t\trichTextStore\n\t\t).getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' +\n\t\t\t\tsettings.name +\n\t\t\t\t'\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error( 'Format titles must be strings.' );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).addFormatTypes( settings );\n\n\treturn settings;\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = newFormats[ startIndex ]?.find(\n\t\t\t( { type } ) => type === formatType\n\t\t);\n\n\t\tif ( format ) {\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ]?.find(\n\t\t\t\t\t( newFormat ) => newFormat === format\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats:\n\t\t\tactiveFormats?.filter( ( { type } ) => type !== formatType ) || [],\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n", "/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insert(\n\tvalue,\n\tvalueToInsert,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\treplacements: replacements\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat(\n\t\t\t\tvalueToInsert.replacements,\n\t\t\t\treplacements.slice( endIndex )\n\t\t\t),\n\t\ttext:\n\t\t\ttext.slice( 0, startIndex ) +\n\t\t\tvalueToInsert.text +\n\t\t\ttext.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n", "/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nexport function insertObject( value, formatToInsert, startIndex, endIndex ) {\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements: [ formatToInsert ],\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n", "/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nexport function slice( value, startIndex = value.start, endIndex = value.end ) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { ...value };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\treplacements: replacements.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n", "/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [ before, after ];\n}\n", "/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range|null} a First range object to test.\n * @param {Range|null} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nexport function isRangeEqual( a, b ) {\n\treturn (\n\t\ta === b ||\n\t\t( a &&\n\t\t\tb &&\n\t\t\ta.startContainer === b.startContainer &&\n\t\t\ta.startOffset === b.startOffset &&\n\t\t\ta.endContainer === b.endContainer &&\n\t\t\ta.endOffset === b.endOffset )\n\t);\n}\n", "/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\nimport { isRangeEqual } from './is-range-equal';\n\n/**\n * MathML namespace URI.\n *\n * @see https://www.w3.org/1998/Math/MathML/\n */\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( child.html !== undefined ) {\n\t\treturn ( element.innerHTML += child.html );\n\t}\n\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tif ( type === '#comment' ) {\n\t\t\tchild = element.ownerDocument.createComment(\n\t\t\t\tattributes[ 'data-rich-text-comment' ]\n\t\t\t);\n\t\t} else {\n\t\t\t// Handle namespace-aware element creation\n\t\t\tconst parentNamespace = element.namespaceURI;\n\n\t\t\tif ( type === 'math' ) {\n\t\t\t\t// Root math element always uses MathML namespace\n\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\ttype\n\t\t\t\t);\n\t\t\t} else if ( parentNamespace === MATHML_NAMESPACE ) {\n\t\t\t\tif ( element.tagName === 'MTEXT' ) {\n\t\t\t\t\t// mtext switches back to HTML namespace for phrasing content\n\t\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t\t} else {\n\t\t\t\t\t// All other elements in MathML context use MathML namespace\n\t\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\t\ttype\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Default HTML element creation\n\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t}\n\n\t\t\tfor ( const key in attributes ) {\n\t\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n", "/**\n * WordPress dependencies\n */\n\nimport { speak } from '@wordpress/a11y';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nexport function toggleFormat( value, format ) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\t// For screen readers, will announce if formatting control is disabled.\n\t\tif ( format.title ) {\n\t\t\t// translators: %s: title of the formatting control\n\t\t\tspeak( sprintf( __( '%s removed.' ), format.title ), 'assertive' );\n\t\t}\n\t\treturn removeFormat( value, format.type );\n\t}\n\t// For screen readers, will announce if formatting control is enabled.\n\tif ( format.title ) {\n\t\t// translators: %s: title of the formatting control\n\t\tspeak( sprintf( __( '%s applied.' ), format.title ), 'assertive' );\n\t}\n\treturn applyFormat( value, format );\n}\n", "/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\n\n/** @typedef {import('./register-format-type').WPFormat} WPFormat */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {WPFormat|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( richTextStore ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error( `Format ${ name } is not registered.` );\n\t\treturn;\n\t}\n\n\tdispatch( richTextStore ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useMemo } from '@wordpress/element';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\n\n/**\n * @template T\n * @typedef {import('@wordpress/element').RefObject<T>} RefObject<T>\n */\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or the selection range if no format is active.\n * The returned value is meant to be used for positioning UI, e.g. by passing it\n * to the `Popover` component.\n *\n * @param {Object}                 $1          Named parameters.\n * @param {RefObject<HTMLElement>} $1.ref      React ref of the element\n *                                             containing  the editable content.\n * @param {RichTextValue}          $1.value    Value to check for selection.\n * @param {WPFormat}               $1.settings The format type's settings.\n *\n * @return {Element|Range} The active element or selection range.\n */\nexport function useAnchorRef( { ref, value, settings = {} } ) {\n\tdeprecated( '`useAnchorRef` hook', {\n\t\tsince: '6.1',\n\t\talternative: '`useAnchor` hook',\n\t} );\n\n\tconst { tagName, className, name } = settings;\n\tconst activeFormat = name ? getActiveFormat( value, name ) : undefined;\n\n\treturn useMemo( () => {\n\t\tif ( ! ref.current ) {\n\t\t\treturn;\n\t\t}\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\n\t\tif ( ! selection.rangeCount ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = selection.getRangeAt( 0 );\n\n\t\tif ( ! activeFormat ) {\n\t\t\treturn range;\n\t\t}\n\n\t\tlet element = range.startContainer;\n\n\t\t// If the caret is right before the element, select the next element.\n\t\telement = element.nextElementSibling || element;\n\n\t\twhile ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\t\telement = element.parentNode;\n\t\t}\n\n\t\treturn element.closest(\n\t\t\ttagName + ( className ? '.' + className : '' )\n\t\t);\n\t}, [ activeFormat, value.start, value.end, tagName, className ] );\n}\n", "/**\n * WordPress dependencies\n */\nimport { usePrevious } from '@wordpress/compose';\nimport { useState, useLayoutEffect } from '@wordpress/element';\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement( range, editableContentElement, tagName, className ) {\n\tlet element = range.startContainer;\n\n\t// Even if the active format is defined, the actually DOM range's start\n\t// container may be outside of the format's DOM element:\n\t// `a\u2038<strong>b</strong>` (DOM) while visually it's `a<strong>\u2038b</strong>`.\n\t// So at a given selection index, start with the deepest format DOM element.\n\tif (\n\t\telement.nodeType === element.TEXT_NODE &&\n\t\trange.startOffset === element.length &&\n\t\telement.nextSibling\n\t) {\n\t\telement = element.nextSibling;\n\n\t\twhile ( element.firstChild ) {\n\t\t\telement = element.firstChild;\n\t\t}\n\t}\n\n\tif ( element.nodeType !== element.ELEMENT_NODE ) {\n\t\telement = element.parentElement;\n\t}\n\n\tif ( ! element ) {\n\t\treturn;\n\t}\n\tif ( element === editableContentElement ) {\n\t\treturn;\n\t}\n\tif ( ! editableContentElement.contains( element ) ) {\n\t\treturn;\n\t}\n\n\tconst selector = tagName + ( className ? '.' + className : '' );\n\n\t// .closest( selector ), but with a boundary. Check if the element matches\n\t// the selector. If it doesn't match, try the parent element if it's not the\n\t// editable wrapper. We don't want to try to match ancestors of the editable\n\t// wrapper, which is what .closest( selector ) would do. When the element is\n\t// the editable wrapper (which is most likely the case because most text is\n\t// unformatted), this never runs.\n\twhile ( element !== editableContentElement ) {\n\t\tif ( element.matches( selector ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\telement = element.parentElement;\n\t}\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement( range, editableContentElement ) {\n\treturn {\n\t\tcontextElement: editableContentElement,\n\t\tgetBoundingClientRect() {\n\t\t\treturn editableContentElement.contains( range.startContainer )\n\t\t\t\t? range.getBoundingClientRect()\n\t\t\t\t: editableContentElement.getBoundingClientRect();\n\t\t},\n\t};\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor( editableContentElement, tagName, className ) {\n\tif ( ! editableContentElement ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = editableContentElement;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection ) {\n\t\treturn;\n\t}\n\tif ( ! selection.rangeCount ) {\n\t\treturn;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\n\tif ( ! range || ! range.startContainer ) {\n\t\treturn;\n\t}\n\n\tconst formatElement = getFormatElement(\n\t\trange,\n\t\teditableContentElement,\n\t\ttagName,\n\t\tclassName\n\t);\n\n\tif ( formatElement ) {\n\t\treturn formatElement;\n\t}\n\n\treturn createVirtualAnchorElement( range, editableContentElement );\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nexport function useAnchor( { editableContentElement, settings = {} } ) {\n\tconst { tagName, className, isActive } = settings;\n\tconst [ anchor, setAnchor ] = useState( () =>\n\t\tgetAnchor( editableContentElement, tagName, className )\n\t);\n\tconst wasActive = usePrevious( isActive );\n\n\tuseLayoutEffect( () => {\n\t\tif ( ! editableContentElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction callback() {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t}\n\n\t\tfunction attach() {\n\t\t\townerDocument.addEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tfunction detach() {\n\t\t\townerDocument.removeEventListener( 'selectionchange', callback );\n\t\t}\n\n\t\tconst { ownerDocument } = editableContentElement;\n\n\t\tif (\n\t\t\teditableContentElement === ownerDocument.activeElement ||\n\t\t\t// When a link is created, we need to attach the popover to the newly created anchor.\n\t\t\t( ! wasActive && isActive ) ||\n\t\t\t// Sometimes we're _removing_ an active anchor, such as the inline color popover.\n\t\t\t// When we add the color, it switches from a virtual anchor to a `<mark>` element.\n\t\t\t// When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\n\t\t\t( wasActive && ! isActive )\n\t\t) {\n\t\t\tsetAnchor(\n\t\t\t\tgetAnchor( editableContentElement, tagName, className )\n\t\t\t);\n\t\t\tattach();\n\t\t}\n\n\t\teditableContentElement.addEventListener( 'focusin', attach );\n\t\teditableContentElement.addEventListener( 'focusout', detach );\n\n\t\treturn () => {\n\t\t\tdetach();\n\n\t\t\teditableContentElement.removeEventListener( 'focusin', attach );\n\t\t\teditableContentElement.removeEventListener( 'focusout', detach );\n\t\t};\n\t}, [ editableContentElement, tagName, className, isActive, wasActive ] );\n\n\treturn anchor;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useRef, useLayoutEffect, useReducer } from '@wordpress/element';\nimport { useMergeRefs, useRefEffect } from '@wordpress/compose';\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { create, RichTextData } from '../create';\nimport { apply } from '../to-dom';\nimport { toHTMLString } from '../to-html-string';\nimport { useDefaultStyle } from './use-default-style';\nimport { useBoundaryStyle } from './use-boundary-style';\nimport { useEventListeners } from './event-listeners';\n\nexport function useRichText( {\n\tvalue = '',\n\tselectionStart,\n\tselectionEnd,\n\tplaceholder,\n\tonSelectionChange,\n\tpreserveWhiteSpace,\n\tonChange,\n\t__unstableDisableFormats: disableFormats,\n\t__unstableIsSelected: isSelected,\n\t__unstableDependencies = [],\n\t__unstableAfterParse,\n\t__unstableBeforeSerialize,\n\t__unstableAddInvisibleFormats,\n} ) {\n\tconst registry = useRegistry();\n\tconst [ , forceRender ] = useReducer( () => ( {} ) );\n\tconst ref = useRef();\n\n\tfunction createRecord() {\n\t\tconst {\n\t\t\townerDocument: { defaultView },\n\t\t} = ref.current;\n\t\tconst selection = defaultView.getSelection();\n\t\tconst range =\n\t\t\tselection.rangeCount > 0 ? selection.getRangeAt( 0 ) : null;\n\n\t\treturn create( {\n\t\t\telement: ref.current,\n\t\t\trange,\n\t\t\t__unstableIsEditableTree: true,\n\t\t} );\n\t}\n\n\tfunction applyRecord( newRecord, { domOnly } = {} ) {\n\t\tapply( {\n\t\t\tvalue: newRecord,\n\t\t\tcurrent: ref.current,\n\t\t\tprepareEditableTree: __unstableAddInvisibleFormats,\n\t\t\t__unstableDomOnly: domOnly,\n\t\t\tplaceholder,\n\t\t} );\n\t}\n\n\t// Internal values are updated synchronously, unlike props and state.\n\tconst _valueRef = useRef( value );\n\tconst recordRef = useRef();\n\n\tfunction setRecordFromProps() {\n\t\t_valueRef.current = value;\n\t\trecordRef.current = value;\n\t\tif ( ! ( value instanceof RichTextData ) ) {\n\t\t\trecordRef.current = value\n\t\t\t\t? RichTextData.fromHTMLString( value, { preserveWhiteSpace } )\n\t\t\t\t: RichTextData.empty();\n\t\t}\n\t\t// To do: make rich text internally work with RichTextData.\n\t\trecordRef.current = {\n\t\t\ttext: recordRef.current.text,\n\t\t\tformats: recordRef.current.formats,\n\t\t\treplacements: recordRef.current.replacements,\n\t\t};\n\t\tif ( disableFormats ) {\n\t\t\trecordRef.current.formats = Array( value.length );\n\t\t\trecordRef.current.replacements = Array( value.length );\n\t\t}\n\t\tif ( __unstableAfterParse ) {\n\t\t\trecordRef.current.formats = __unstableAfterParse(\n\t\t\t\trecordRef.current\n\t\t\t);\n\t\t}\n\t\trecordRef.current.start = selectionStart;\n\t\trecordRef.current.end = selectionEnd;\n\t}\n\n\tconst hadSelectionUpdateRef = useRef( false );\n\n\tif ( ! recordRef.current ) {\n\t\thadSelectionUpdateRef.current = isSelected;\n\t\tsetRecordFromProps();\n\t} else if (\n\t\tselectionStart !== recordRef.current.start ||\n\t\tselectionEnd !== recordRef.current.end\n\t) {\n\t\thadSelectionUpdateRef.current = isSelected;\n\t\trecordRef.current = {\n\t\t\t...recordRef.current,\n\t\t\tstart: selectionStart,\n\t\t\tend: selectionEnd,\n\t\t\tactiveFormats: undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Sync the value to global state. The node tree and selection will also be\n\t * updated if differences are found.\n\t *\n\t * @param {Object} newRecord The record to sync and apply.\n\t */\n\tfunction handleChange( newRecord ) {\n\t\trecordRef.current = newRecord;\n\t\tapplyRecord( newRecord );\n\n\t\tif ( disableFormats ) {\n\t\t\t_valueRef.current = newRecord.text;\n\t\t} else {\n\t\t\tconst newFormats = __unstableBeforeSerialize\n\t\t\t\t? __unstableBeforeSerialize( newRecord )\n\t\t\t\t: newRecord.formats;\n\t\t\tnewRecord = { ...newRecord, formats: newFormats };\n\t\t\tif ( typeof value === 'string' ) {\n\t\t\t\t_valueRef.current = toHTMLString( {\n\t\t\t\t\tvalue: newRecord,\n\t\t\t\t\tpreserveWhiteSpace,\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t_valueRef.current = new RichTextData( newRecord );\n\t\t\t}\n\t\t}\n\n\t\tconst { start, end, formats, text } = recordRef.current;\n\n\t\t// Selection must be updated first, so it is recorded in history when\n\t\t// the content change happens.\n\t\t// We batch both calls to only attempt to rerender once.\n\t\tregistry.batch( () => {\n\t\t\tonSelectionChange( start, end );\n\t\t\tonChange( _valueRef.current, {\n\t\t\t\t__unstableFormats: formats,\n\t\t\t\t__unstableText: text,\n\t\t\t} );\n\t\t} );\n\t\tforceRender();\n\t}\n\n\tfunction applyFromProps() {\n\t\t// Get previous value before updating\n\t\tconst previousValue = _valueRef.current;\n\n\t\tsetRecordFromProps();\n\n\t\t// Check if content length changed (text was added/removed, not just formatted)\n\t\tconst contentLengthChanged =\n\t\t\tpreviousValue &&\n\t\t\ttypeof previousValue === 'string' &&\n\t\t\ttypeof value === 'string' &&\n\t\t\tpreviousValue.length !== value.length;\n\n\t\t// Check if focus is on this element\n\t\tconst hasFocus = ref.current?.contains(\n\t\t\tref.current.ownerDocument.activeElement\n\t\t);\n\n\t\t// Skip re-applying the selection state when content changed from external source\n\t\t// (e.g., typing in sidebar input changes canvas text)\n\t\tconst skipSelection = contentLengthChanged && ! hasFocus;\n\n\t\tapplyRecord( recordRef.current, { domOnly: skipSelection } );\n\t}\n\n\tconst didMountRef = useRef( false );\n\n\t// Value updates must happen synchronously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( didMountRef.current && value !== _valueRef.current ) {\n\t\t\tapplyFromProps();\n\t\t\tforceRender();\n\t\t}\n\t}, [ value ] );\n\n\t// Value updates must happen synchronously to avoid overwriting newer values.\n\tuseLayoutEffect( () => {\n\t\tif ( ! hadSelectionUpdateRef.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ref.current.ownerDocument.activeElement !== ref.current ) {\n\t\t\tref.current.focus();\n\t\t}\n\n\t\tapplyRecord( recordRef.current );\n\t\thadSelectionUpdateRef.current = false;\n\t}, [ hadSelectionUpdateRef.current ] );\n\n\tconst mergedRefs = useMergeRefs( [\n\t\tref,\n\t\tuseDefaultStyle(),\n\t\tuseBoundaryStyle( { record: recordRef } ),\n\t\tuseEventListeners( {\n\t\t\trecord: recordRef,\n\t\t\thandleChange,\n\t\t\tapplyRecord,\n\t\t\tcreateRecord,\n\t\t\tisSelected,\n\t\t\tonSelectionChange,\n\t\t\tforceRender,\n\t\t} ),\n\t\tuseRefEffect( () => {\n\t\t\tapplyFromProps();\n\t\t\tdidMountRef.current = true;\n\t\t}, [ placeholder, ...__unstableDependencies ] ),\n\t] );\n\n\treturn {\n\t\tvalue: recordRef.current,\n\t\t// A function to get the most recent value so event handlers in\n\t\t// useRichText implementations have access to it. For example when\n\t\t// listening to input events, we internally update the state, but this\n\t\t// state is not yet available to the input event handler because React\n\t\t// may re-render asynchronously.\n\t\tgetValue: () => recordRef.current,\n\t\tonChange: handleChange,\n\t\tref: mergedRefs,\n\t};\n}\n\nexport default function __experimentalRichText() {}\n", "/**\n * WordPress dependencies\n */\nimport { useCallback } from '@wordpress/element';\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * A minimum width of 1px will prevent the rich text container from collapsing\n * to 0 width and hiding the caret. This is useful for inline containers.\n */\nconst minWidth = '1px';\n\nexport function useDefaultStyle() {\n\treturn useCallback( ( element ) => {\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\t\telement.style.whiteSpace = whiteSpace;\n\t\telement.style.minWidth = minWidth;\n\t}, [] );\n}\n", "var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n", "/**\n * External dependencies\n */\nimport { colord } from 'colord';\n\n/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nexport function useBoundaryStyle( { record } ) {\n\tconst ref = useRef();\n\tconst { activeFormats = [], replacements, start } = record.current;\n\tconst activeReplacement = replacements[ start ];\n\tuseEffect( () => {\n\t\t// There's no need to recalculate the boundary styles if no formats are\n\t\t// active, because no boundary styles will be visible.\n\t\tif (\n\t\t\t( ! activeFormats || ! activeFormats.length ) &&\n\t\t\t! activeReplacement\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundarySelector = '*[data-rich-text-format-boundary]';\n\t\tconst element = ref.current.querySelector( boundarySelector );\n\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst computedStyle = defaultView.getComputedStyle( element );\n\t\tconst newColor = colord( computedStyle.color )\n\t\t\t.alpha( 0.2 )\n\t\t\t.toRgbString();\n\t\tconst selector = `.rich-text:focus ${ boundarySelector }`;\n\t\tconst rule = `background-color: ${ newColor }`;\n\t\tconst style = `${ selector } {${ rule }}`;\n\t\tconst globalStyleId = 'rich-text-boundary-style';\n\n\t\tlet globalStyle = ownerDocument.getElementById( globalStyleId );\n\n\t\tif ( ! globalStyle ) {\n\t\t\tglobalStyle = ownerDocument.createElement( 'style' );\n\t\t\tglobalStyle.id = globalStyleId;\n\t\t\townerDocument.head.appendChild( globalStyle );\n\t\t}\n\n\t\tif ( globalStyle.innerHTML !== style ) {\n\t\t\tglobalStyle.innerHTML = style;\n\t\t}\n\t}, [ activeFormats, activeReplacement ] );\n\treturn ref;\n}\n", "/**\n * WordPress dependencies\n */\nimport { useMemo, useRef, useInsertionEffect } from '@wordpress/element';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport copyHandler from './copy-handler';\nimport selectObject from './select-object';\nimport formatBoundaries from './format-boundaries';\nimport deleteHandler from './delete';\nimport inputAndSelection from './input-and-selection';\nimport selectionChangeCompat from './selection-change-compat';\nimport { preventFocusCapture } from './prevent-focus-capture';\n\nconst allEventListeners = [\n\tcopyHandler,\n\tselectObject,\n\tformatBoundaries,\n\tdeleteHandler,\n\tinputAndSelection,\n\tselectionChangeCompat,\n\tpreventFocusCapture,\n];\n\nexport function useEventListeners( props ) {\n\tconst propsRef = useRef( props );\n\tuseInsertionEffect( () => {\n\t\tpropsRef.current = props;\n\t} );\n\tconst refEffects = useMemo(\n\t\t() => allEventListeners.map( ( refEffect ) => refEffect( propsRef ) ),\n\t\t[ propsRef ]\n\t);\n\n\treturn useRefEffect(\n\t\t( element ) => {\n\t\t\tconst cleanups = refEffects.map( ( effect ) => effect( element ) );\n\t\t\treturn () => {\n\t\t\t\tcleanups.forEach( ( cleanup ) => cleanup() );\n\t\t\t};\n\t\t},\n\t\t[ refEffects ]\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport { toHTMLString } from '../../to-html-string';\nimport { isCollapsed } from '../../is-collapsed';\nimport { slice } from '../../slice';\nimport { getTextContent } from '../../get-text-content';\n\nexport default ( props ) => ( element ) => {\n\tfunction onCopy( event ) {\n\t\tconst { record } = props.current;\n\t\tconst { ownerDocument } = element;\n\t\tif (\n\t\t\tisCollapsed( record.current ) ||\n\t\t\t! element.contains( ownerDocument.activeElement )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedRecord = slice( record.current );\n\t\tconst plainText = getTextContent( selectedRecord );\n\t\tconst html = toHTMLString( { value: selectedRecord } );\n\t\tevent.clipboardData.setData( 'text/plain', plainText );\n\t\tevent.clipboardData.setData( 'text/html', html );\n\t\tevent.clipboardData.setData( 'rich-text', 'true' );\n\t\tevent.preventDefault();\n\n\t\tif ( event.type === 'cut' ) {\n\t\t\townerDocument.execCommand( 'delete' );\n\t\t}\n\t}\n\n\tconst { defaultView } = element.ownerDocument;\n\n\tdefaultView.addEventListener( 'copy', onCopy );\n\tdefaultView.addEventListener( 'cut', onCopy );\n\treturn () => {\n\t\tdefaultView.removeEventListener( 'copy', onCopy );\n\t\tdefaultView.removeEventListener( 'cut', onCopy );\n\t};\n};\n", "export default () => ( element ) => {\n\tfunction onClick( event ) {\n\t\tconst { target } = event;\n\n\t\t// If the child element has no text content, it must be an object.\n\t\tif (\n\t\t\ttarget === element ||\n\t\t\t( target.textContent && target.isContentEditable )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = target;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst selection = defaultView.getSelection();\n\n\t\t// If it's already selected, do nothing and let default behavior happen.\n\t\t// This means it's \"click-through\".\n\t\tif ( selection.containsNode( target ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = ownerDocument.createRange();\n\t\t// If the target is within a non editable element, select the non\n\t\t// editable element.\n\t\tconst nodeToSelect = target.isContentEditable\n\t\t\t? target\n\t\t\t: target.closest( '[contenteditable]' );\n\n\t\trange.selectNode( nodeToSelect );\n\t\tselection.removeAllRanges();\n\t\tselection.addRange( range );\n\n\t\tevent.preventDefault();\n\t}\n\n\tfunction onFocusIn( event ) {\n\t\t// When there is incoming focus from a link, select the object.\n\t\tif (\n\t\t\tevent.relatedTarget &&\n\t\t\t! element.contains( event.relatedTarget ) &&\n\t\t\tevent.relatedTarget.tagName === 'A'\n\t\t) {\n\t\t\tonClick( event );\n\t\t}\n\t}\n\n\telement.addEventListener( 'click', onClick );\n\telement.addEventListener( 'focusin', onFocusIn );\n\treturn () => {\n\t\telement.removeEventListener( 'click', onClick );\n\t\telement.removeEventListener( 'focusin', onFocusIn );\n\t};\n};\n", "/**\n * WordPress dependencies\n */\nimport { LEFT, RIGHT } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { isCollapsed } from '../../is-collapsed';\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nexport default ( props ) => ( element ) => {\n\tfunction onKeyDown( event ) {\n\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\tif (\n\t\t\t// Only override left and right keys without modifiers pressed.\n\t\t\tshiftKey ||\n\t\t\taltKey ||\n\t\t\tmetaKey ||\n\t\t\tctrlKey ||\n\t\t\t( keyCode !== LEFT && keyCode !== RIGHT )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { record, applyRecord, forceRender } = props.current;\n\t\tconst {\n\t\t\ttext,\n\t\t\tformats,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tactiveFormats: currentActiveFormats = [],\n\t\t} = record.current;\n\t\tconst collapsed = isCollapsed( record.current );\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\t// To do: ideally, we should look at visual position instead.\n\t\tconst { direction } = defaultView.getComputedStyle( element );\n\t\tconst reverseKey = direction === 'rtl' ? RIGHT : LEFT;\n\t\tconst isReverse = event.keyCode === reverseKey;\n\n\t\t// If the selection is collapsed and at the very start, do nothing if\n\t\t// navigating backward.\n\t\t// If the selection is collapsed and at the very end, do nothing if\n\t\t// navigating forward.\n\t\tif ( collapsed && currentActiveFormats.length === 0 ) {\n\t\t\tif ( start === 0 && isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( end === text.length && ! isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the selection is not collapsed, let the browser handle collapsing\n\t\t// the selection for now. Later we could expand this logic to set\n\t\t// boundary positions if needed.\n\t\tif ( ! collapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst destination = isReverse ? formatsBefore : formatsAfter;\n\t\tconst isIncreasing = currentActiveFormats.every(\n\t\t\t( format, index ) => format === destination[ index ]\n\t\t);\n\n\t\tlet newActiveFormatsLength = currentActiveFormats.length;\n\n\t\tif ( ! isIncreasing ) {\n\t\t\tnewActiveFormatsLength--;\n\t\t} else if ( newActiveFormatsLength < destination.length ) {\n\t\t\tnewActiveFormatsLength++;\n\t\t}\n\n\t\tif ( newActiveFormatsLength === currentActiveFormats.length ) {\n\t\t\trecord.current._newActiveFormats = destination;\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tconst origin = isReverse ? formatsAfter : formatsBefore;\n\t\tconst source = isIncreasing ? destination : origin;\n\t\tconst newActiveFormats = source.slice( 0, newActiveFormatsLength );\n\t\tconst newValue = {\n\t\t\t...record.current,\n\t\t\tactiveFormats: newActiveFormats,\n\t\t};\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue );\n\t\tforceRender();\n\t}\n\n\telement.addEventListener( 'keydown', onKeyDown );\n\treturn () => {\n\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t};\n};\n", "/**\n * WordPress dependencies\n */\nimport { BACKSPACE, DELETE } from '@wordpress/keycodes';\n\n/**\n * Internal dependencies\n */\nimport { remove } from '../../remove';\n\nexport default ( props ) => ( element ) => {\n\tfunction onKeyDown( event ) {\n\t\tconst { keyCode } = event;\n\t\tconst { createRecord, handleChange } = props.current;\n\n\t\tif ( event.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( keyCode !== DELETE && keyCode !== BACKSPACE ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, end, text } = currentValue;\n\n\t\t// Always handle full content deletion ourselves.\n\t\tif ( start === 0 && end !== 0 && end === text.length ) {\n\t\t\thandleChange( remove( currentValue ) );\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\telement.addEventListener( 'keydown', onKeyDown );\n\treturn () => {\n\t\telement.removeEventListener( 'keydown', onKeyDown );\n\t};\n};\n", "/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param {Object}        $1         Named paramentes.\n * @param {RichTextValue} $1.value   Value te update.\n * @param {number}        $1.start   Index to update from.\n * @param {number}        $1.end     Index to update until.\n * @param {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nexport function updateFormats( { value, start, end, formats } ) {\n\t// Start and end may be switched in case of delete.\n\tconst min = Math.min( start, end );\n\tconst max = Math.max( start, end );\n\tconst formatsBefore = value.formats[ min - 1 ] || [];\n\tconst formatsAfter = value.formats[ max ] || [];\n\n\t// First, fix the references. If any format right before or after are\n\t// equal, the replacement format should use the same reference.\n\tvalue.activeFormats = formats.map( ( format, index ) => {\n\t\tif ( formatsBefore[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsBefore[ index ] ) ) {\n\t\t\t\treturn formatsBefore[ index ];\n\t\t\t}\n\t\t} else if ( formatsAfter[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsAfter[ index ] ) ) {\n\t\t\t\treturn formatsAfter[ index ];\n\t\t\t}\n\t\t}\n\n\t\treturn format;\n\t} );\n\n\twhile ( --end >= start ) {\n\t\tif ( value.activeFormats.length > 0 ) {\n\t\t\tvalue.formats[ end ] = value.activeFormats;\n\t\t} else {\n\t\t\tdelete value.formats[ end ];\n\t\t}\n\t}\n\n\treturn value;\n}\n", "/**\n * Internal dependencies\n */\nimport { getActiveFormats } from '../../get-active-formats';\nimport { updateFormats } from '../../update-formats';\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set( [\n\t'insertParagraph',\n\t'insertOrderedList',\n\t'insertUnorderedList',\n\t'insertHorizontalRule',\n\t'insertLink',\n] );\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nconst PLACEHOLDER_ATTR_NAME = 'data-rich-text-placeholder';\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection( defaultView ) {\n\tconst selection = defaultView.getSelection();\n\tconst { anchorNode, anchorOffset } = selection;\n\n\tif ( anchorNode.nodeType !== anchorNode.ELEMENT_NODE ) {\n\t\treturn;\n\t}\n\n\tconst targetNode = anchorNode.childNodes[ anchorOffset ];\n\n\tif (\n\t\t! targetNode ||\n\t\ttargetNode.nodeType !== targetNode.ELEMENT_NODE ||\n\t\t! targetNode.hasAttribute( PLACEHOLDER_ATTR_NAME )\n\t) {\n\t\treturn;\n\t}\n\n\tselection.collapseToStart();\n}\n\nexport default ( props ) => ( element ) => {\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\n\tlet isComposing = false;\n\n\tfunction onInput( event ) {\n\t\t// Do not trigger a change if characters are being composed. Browsers\n\t\t// will usually emit a final `input` event when the characters are\n\t\t// composed. As of December 2019, Safari doesn't support\n\t\t// nativeEvent.isComposing.\n\t\tif ( isComposing ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet inputType;\n\n\t\tif ( event ) {\n\t\t\tinputType = event.inputType;\n\t\t}\n\n\t\tconst { record, applyRecord, createRecord, handleChange } =\n\t\t\tprops.current;\n\n\t\t// The browser formatted something or tried to insert HTML. Overwrite\n\t\t// it. It will be handled later by the format library if needed.\n\t\tif (\n\t\t\tinputType &&\n\t\t\t( inputType.indexOf( 'format' ) === 0 ||\n\t\t\t\tINSERTION_INPUT_TYPES_TO_IGNORE.has( inputType ) )\n\t\t) {\n\t\t\tapplyRecord( record.current );\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, activeFormats: oldActiveFormats = [] } = record.current;\n\n\t\t// Update the formats between the last and new caret position.\n\t\tconst change = updateFormats( {\n\t\t\tvalue: currentValue,\n\t\t\tstart,\n\t\t\tend: currentValue.start,\n\t\t\tformats: oldActiveFormats,\n\t\t} );\n\n\t\thandleChange( change );\n\t}\n\n\t/**\n\t * Syncs the selection to local state. A callback for the `selectionchange`\n\t * event.\n\t */\n\tfunction handleSelectionChange() {\n\t\tconst { record, applyRecord, createRecord, onSelectionChange } =\n\t\t\tprops.current;\n\n\t\t// Check if the implementor disabled editing. `contentEditable` does\n\t\t// disable input, but not text selection, so we must ignore selection\n\t\t// changes.\n\t\tif ( element.contentEditable !== 'true' ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ensure the active element is the rich text element.\n\t\tif ( ownerDocument.activeElement !== element ) {\n\t\t\t// If it is not, we can stop listening for selection changes. We\n\t\t\t// resume listening when the element is focused.\n\t\t\townerDocument.removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// In case of a keyboard event, ignore selection changes during\n\t\t// composition.\n\t\tif ( isComposing ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { start, end, text } = createRecord();\n\t\tconst oldRecord = record.current;\n\n\t\t// Fallback mechanism for IE11, which doesn't support the input event.\n\t\t// Any input results in a selection change.\n\t\tif ( text !== oldRecord.text ) {\n\t\t\tonInput();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( start === oldRecord.start && end === oldRecord.end ) {\n\t\t\t// Sometimes the browser may set the selection on the placeholder\n\t\t\t// element, in which case the caret is not visible. We need to set\n\t\t\t// the caret before the placeholder if that's the case.\n\t\t\tif ( oldRecord.text.length === 0 && start === 0 ) {\n\t\t\t\tfixPlaceholderSelection( defaultView );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst newValue = {\n\t\t\t...oldRecord,\n\t\t\tstart,\n\t\t\tend,\n\t\t\t// _newActiveFormats may be set on arrow key navigation to control\n\t\t\t// the right boundary position. If undefined, getActiveFormats will\n\t\t\t// give the active formats according to the browser.\n\t\t\tactiveFormats: oldRecord._newActiveFormats,\n\t\t\t_newActiveFormats: undefined,\n\t\t};\n\n\t\tconst newActiveFormats = getActiveFormats(\n\t\t\tnewValue,\n\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t);\n\n\t\t// Update the value with the new active formats.\n\t\tnewValue.activeFormats = newActiveFormats;\n\n\t\t// It is important that the internal value is updated first,\n\t\t// otherwise the value will be wrong on render!\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue, { domOnly: true } );\n\t\tonSelectionChange( start, end );\n\t}\n\n\tfunction onCompositionStart() {\n\t\tisComposing = true;\n\t\t// Do not update the selection when characters are being composed as\n\t\t// this rerenders the component and might destroy internal browser\n\t\t// editing state.\n\t\townerDocument.removeEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t\t// Remove the placeholder. Since the rich text value doesn't update\n\t\t// during composition, the placeholder doesn't get removed. There's no\n\t\t// need to re-add it, when the value is updated on compositionend it\n\t\t// will be re-added when the value is empty.\n\t\telement.querySelector( `[${ PLACEHOLDER_ATTR_NAME }]` )?.remove();\n\t}\n\n\tfunction onCompositionEnd() {\n\t\tisComposing = false;\n\t\t// Ensure the value is up-to-date for browsers that don't emit a final\n\t\t// input event after composition.\n\t\tonInput( { inputType: 'insertText' } );\n\t\t// Tracking selection changes can be resumed.\n\t\townerDocument.addEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\tfunction onFocus() {\n\t\tconst { record, isSelected, onSelectionChange, applyRecord } =\n\t\t\tprops.current;\n\n\t\t// When the whole editor is editable, let writing flow handle\n\t\t// selection.\n\t\tif ( element.parentElement.closest( '[contenteditable=\"true\"]' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! isSelected ) {\n\t\t\t// We know for certain that on focus, the old selection is invalid.\n\t\t\t// It will be recalculated on the next mouseup, keyup, or touchend\n\t\t\t// event.\n\t\t\tconst index = undefined;\n\n\t\t\trecord.current = {\n\t\t\t\t...record.current,\n\t\t\t\tstart: index,\n\t\t\t\tend: index,\n\t\t\t\tactiveFormats: EMPTY_ACTIVE_FORMATS,\n\t\t\t};\n\t\t} else {\n\t\t\tapplyRecord( record.current, { domOnly: true } );\n\t\t}\n\n\t\tonSelectionChange( record.current.start, record.current.end );\n\n\t\t// There is no selection change event when the element is focused, so\n\t\t// we need to manually trigger it. The selection is also not available\n\t\t// yet in this call stack.\n\t\twindow.queueMicrotask( handleSelectionChange );\n\n\t\townerDocument.addEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\telement.addEventListener( 'input', onInput );\n\telement.addEventListener( 'compositionstart', onCompositionStart );\n\telement.addEventListener( 'compositionend', onCompositionEnd );\n\telement.addEventListener( 'focus', onFocus );\n\n\treturn () => {\n\t\telement.removeEventListener( 'input', onInput );\n\t\telement.removeEventListener( 'compositionstart', onCompositionStart );\n\t\telement.removeEventListener( 'compositionend', onCompositionEnd );\n\t\telement.removeEventListener( 'focus', onFocus );\n\t};\n};\n", "/**\n * Internal dependencies\n */\nimport { isRangeEqual } from '../../is-range-equal';\n\n/**\n * Sometimes some browsers are not firing a `selectionchange` event when\n * changing the selection by mouse or keyboard. This hook makes sure that, if we\n * detect no `selectionchange` or `input` event between the up and down events,\n * we fire a `selectionchange` event.\n */\nexport default () => ( element ) => {\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView?.getSelection();\n\n\tlet range;\n\n\tfunction getRange() {\n\t\treturn selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\t}\n\n\tfunction onDown( event ) {\n\t\tconst type = event.type === 'keydown' ? 'keyup' : 'pointerup';\n\n\t\tfunction onCancel() {\n\t\t\townerDocument.removeEventListener( type, onUp );\n\t\t\townerDocument.removeEventListener( 'selectionchange', onCancel );\n\t\t\townerDocument.removeEventListener( 'input', onCancel );\n\t\t}\n\n\t\tfunction onUp() {\n\t\t\tonCancel();\n\t\t\tif ( isRangeEqual( range, getRange() ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\townerDocument.dispatchEvent( new Event( 'selectionchange' ) );\n\t\t}\n\n\t\townerDocument.addEventListener( type, onUp );\n\t\townerDocument.addEventListener( 'selectionchange', onCancel );\n\t\townerDocument.addEventListener( 'input', onCancel );\n\n\t\trange = getRange();\n\t}\n\n\telement.addEventListener( 'pointerdown', onDown );\n\telement.addEventListener( 'keydown', onDown );\n\treturn () => {\n\t\telement.removeEventListener( 'pointerdown', onDown );\n\t\telement.removeEventListener( 'keydown', onDown );\n\t};\n};\n", "/**\n * Prevents focus from being captured by the element when clicking _outside_\n * around the element. This may happen when the parent element is flex.\n * @see https://github.com/WordPress/gutenberg/pull/65857\n * @see https://github.com/WordPress/gutenberg/pull/66402\n */\nexport function preventFocusCapture() {\n\treturn ( element ) => {\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\n\t\tlet value = null;\n\n\t\tfunction onPointerDown( event ) {\n\t\t\t// Abort if the event is default prevented, we will not get a pointer up event.\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( event.target === element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( ! event.target.contains( element ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue = element.getAttribute( 'contenteditable' );\n\t\t\telement.setAttribute( 'contenteditable', 'false' );\n\t\t\tdefaultView.getSelection().removeAllRanges();\n\t\t}\n\n\t\tfunction onPointerUp() {\n\t\t\tif ( value !== null ) {\n\t\t\t\telement.setAttribute( 'contenteditable', value );\n\t\t\t\tvalue = null;\n\t\t\t}\n\t\t}\n\n\t\tdefaultView.addEventListener( 'pointerdown', onPointerDown );\n\t\tdefaultView.addEventListener( 'pointerup', onPointerUp );\n\t\treturn () => {\n\t\t\tdefaultView.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tdefaultView.removeEventListener( 'pointerup', onPointerUp );\n\t\t};\n\t};\n}\n"],
  "mappings": "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",
  "names": ["import_data", "import_data", "formatTypes", "formatTypes", "i", "import_data", "EMPTY_ACTIVE_FORMATS", "i", "import_data", "getFormatType", "getFormatType", "a", "b", "createEmpty", "append", "getLastChild", "getParent", "isText", "getText", "remove", "appendText", "i", "i", "value", "mergeFormats", "a", "b", "import_data", "i", "remove", "replace", "a", "b", "i", "append", "appendText", "getLastChild", "getParent", "isText", "getText", "remove", "createEmpty", "import_data", "deprecated", "import_element", "import_element", "import_compose", "import_data", "import_element", "r", "t", "n", "e", "u", "a", "o", "i", "s", "h", "r", "t", "n", "e", "u", "i", "a", "import_element", "import_element", "import_compose", "import_keycodes", "remove", "EMPTY_ACTIVE_FORMATS"]
}
