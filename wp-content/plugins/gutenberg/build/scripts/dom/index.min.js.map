{
  "version": 3,
  "sources": ["package-external:@wordpress/deprecated", "../../../packages/dom/src/focusable.js", "../../../packages/dom/src/tabbable.js", "../../../packages/dom/src/dom/get-rectangle-from-range.js", "../../../packages/dom/src/dom/compute-caret-rect.js", "../../../packages/dom/src/dom/document-has-text-selection.js", "../../../packages/dom/src/dom/is-html-input-element.js", "../../../packages/dom/src/dom/is-text-field.js", "../../../packages/dom/src/dom/input-field-has-uncollapsed-selection.js", "../../../packages/dom/src/dom/document-has-uncollapsed-selection.js", "../../../packages/dom/src/dom/document-has-selection.js", "../../../packages/dom/src/dom/get-computed-style.js", "../../../packages/dom/src/dom/get-scroll-container.js", "../../../packages/dom/src/dom/get-offset-parent.js", "../../../packages/dom/src/dom/is-input-or-text-area.js", "../../../packages/dom/src/dom/is-entirely-selected.js", "../../../packages/dom/src/dom/is-form-element.js", "../../../packages/dom/src/dom/is-rtl.js", "../../../packages/dom/src/dom/get-range-height.js", "../../../packages/dom/src/dom/is-selection-forward.js", "../../../packages/dom/src/dom/caret-range-from-point.js", "../../../packages/dom/src/dom/hidden-caret-range-from-point.js", "../../../packages/dom/src/dom/scroll-if-no-range.js", "../../../packages/dom/src/dom/is-edge.js", "../../../packages/dom/src/dom/is-horizontal-edge.js", "../../../packages/dom/src/dom/is-number-input.js", "../../../packages/dom/src/dom/is-vertical-edge.js", "../../../packages/dom/src/dom/place-caret-at-edge.js", "../../../packages/dom/src/dom/place-caret-at-horizontal-edge.js", "../../../packages/dom/src/dom/place-caret-at-vertical-edge.js", "../../../packages/dom/src/dom/insert-after.js", "../../../packages/dom/src/dom/remove.js", "../../../packages/dom/src/dom/replace.js", "../../../packages/dom/src/dom/unwrap.js", "../../../packages/dom/src/dom/replace-tag.js", "../../../packages/dom/src/dom/wrap.js", "../../../packages/dom/src/dom/safe-html.js", "../../../packages/dom/src/dom/strip-html.js", "../../../packages/dom/src/dom/is-empty.js", "../../../packages/dom/src/phrasing-content.js", "../../../packages/dom/src/dom/is-element.js", "../../../packages/dom/src/dom/clean-node-list.js", "../../../packages/dom/src/dom/remove-invalid-html.js", "../../../packages/dom/src/data-transfer.js", "../../../packages/dom/src/index.js"],
  "sourcesContent": ["module.exports = window.wp.deprecated;", "/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\n/**\n * Returns a CSS selector used to query for focusable elements.\n *\n * @param {boolean} sequential If set, only query elements that are sequentially\n *                             focusable. Non-interactive elements with a\n *                             negative `tabindex` are focusable but not\n *                             sequentially focusable.\n *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {string} CSS selector.\n */\nfunction buildSelector( sequential ) {\n\treturn [\n\t\tsequential ? '[tabindex]:not([tabindex^=\"-\"])' : '[tabindex]',\n\t\t'a[href]',\n\t\t'button:not([disabled])',\n\t\t'input:not([type=\"hidden\"]):not([disabled])',\n\t\t'select:not([disabled])',\n\t\t'textarea:not([disabled])',\n\t\t'iframe:not([tabindex^=\"-\"])',\n\t\t'object',\n\t\t'embed',\n\t\t'summary',\n\t\t'area[href]',\n\t\t'[contenteditable]:not([contenteditable=false])',\n\t].join( ',' );\n}\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {HTMLElement} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {HTMLAreaElement} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\t/** @type {HTMLMapElement | null} */\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\t/** @type {HTMLImageElement | null} */\n\tconst img = element.ownerDocument.querySelector(\n\t\t'img[usemap=\"#' + map.name + '\"]'\n\t);\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context              Element in which to search.\n * @param {Object}  options\n * @param {boolean} [options.sequential] If set, only return elements that are\n *                                       sequentially focusable.\n *                                       Non-interactive elements with a\n *                                       negative `tabindex` are focusable but\n *                                       not sequentially focusable.\n *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {HTMLElement[]} Focusable elements.\n */\nexport function find( context, { sequential = false } = {} ) {\n\t/** @type {NodeListOf<HTMLElement>} */\n\tconst elements = context.querySelectorAll( buildSelector( sequential ) );\n\n\treturn Array.from( elements ).filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea(\n\t\t\t\t/** @type {HTMLAreaElement} */ ( element )\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n", "/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/** @typedef {HTMLElement & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup(\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\n\t\t/** @type {MaybeHTMLInputElement} */ element\n\t) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = result.filter( ( e ) => e !== hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {HTMLElement} element Element.\n * @param {number}      index   Array index of element.\n *\n * @return {{ element: HTMLElement, index: number }} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {{ element: HTMLElement }} object Mapped object with element.\n *\n * @return {HTMLElement} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {{ element: HTMLElement, index: number }} a First object to compare.\n * @param {{ element: HTMLElement, index: number }} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {HTMLElement[]} focusables Focusable elements to filter.\n *\n * @return {HTMLElement[]} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\n/**\n * @param {Element} context\n * @return {HTMLElement[]} Tabbable elements within the context.\n */\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Preceding tabbable element.\n */\nexport function findPrevious( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) )\n\t\t.reverse()\n\t\t.find(\n\t\t\t( focusable ) =>\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\t\telement.DOCUMENT_POSITION_PRECEDING\n\t\t);\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Next tabbable element.\n */\nexport function findNext( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) ).find(\n\t\t( focusable ) =>\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\telement.DOCUMENT_POSITION_FOLLOWING\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle of a given Range. Returns `null` if no suitable rectangle\n * can be found.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect?} The rectangle.\n */\nexport default function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\tconst rects = Array.from( range.getClientRects() );\n\n\t\t// If there's just a single rect, return it.\n\t\tif ( rects.length === 1 ) {\n\t\t\treturn rects[ 0 ];\n\t\t}\n\n\t\t// Ignore tiny selection at the edge of a range.\n\t\tconst filteredRects = rects.filter( ( { width } ) => width > 1 );\n\n\t\t// If it's full of tiny selections, return browser default.\n\t\tif ( filteredRects.length === 0 ) {\n\t\t\treturn range.getBoundingClientRect();\n\t\t}\n\n\t\tif ( filteredRects.length === 1 ) {\n\t\t\treturn filteredRects[ 0 ];\n\t\t}\n\n\t\tlet {\n\t\t\ttop: furthestTop,\n\t\t\tbottom: furthestBottom,\n\t\t\tleft: furthestLeft,\n\t\t\tright: furthestRight,\n\t\t} = filteredRects[ 0 ];\n\n\t\tfor ( const { top, bottom, left, right } of filteredRects ) {\n\t\t\tif ( top < furthestTop ) {\n\t\t\t\tfurthestTop = top;\n\t\t\t}\n\t\t\tif ( bottom > furthestBottom ) {\n\t\t\t\tfurthestBottom = bottom;\n\t\t\t}\n\t\t\tif ( left < furthestLeft ) {\n\t\t\t\tfurthestLeft = left;\n\t\t\t}\n\t\t\tif ( right > furthestRight ) {\n\t\t\t\tfurthestRight = right;\n\t\t\t}\n\t\t}\n\n\t\treturn new window.DOMRect(\n\t\t\tfurthestLeft,\n\t\t\tfurthestTop,\n\t\t\tfurthestRight - furthestLeft,\n\t\t\tfurthestBottom - furthestTop\n\t\t);\n\t}\n\n\tconst { startContainer } = range;\n\tconst { ownerDocument } = startContainer;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tassertIsDefined( parentNode, 'parentNode' );\n\t\tconst index = /** @type {Node[]} */ (\n\t\t\tArray.from( parentNode.childNodes )\n\t\t).indexOf( startContainer );\n\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\trange = ownerDocument.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tconst rects = range.getClientRects();\n\n\t// If we have multiple rectangles for a collapsed range, there's no way to\n\t// know which it is, so don't return anything.\n\tif ( rects.length > 1 ) {\n\t\treturn null;\n\t}\n\n\tlet rect = rects[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect || rect.height === 0 ) {\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tassertIsDefined( padNode.parentNode, 'padNode.parentNode' );\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n", "/**\n * Internal dependencies\n */\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Window} win The window of the selection.\n *\n * @return {DOMRect | null} The rectangle.\n */\nexport default function computeCaretRect( win ) {\n\tconst selection = win.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn null;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Check whether the current document has selected text. This applies to ranges\n * of text in the document, and not selection inside `<input>` and `<textarea>`\n * elements.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport default function documentHasTextSelection( doc ) {\n\tassertIsDefined( doc.defaultView, 'doc.defaultView' );\n\tconst selection = doc.defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\treturn !! range && ! range.collapsed;\n}\n", "/**\n * @param {Node} node\n * @return {node is HTMLInputElement} Whether the node is an HTMLInputElement.\n */\nexport default function isHTMLInputElement( node ) {\n\treturn node?.nodeName === 'INPUT';\n}\n", "/**\n * Internal dependencies\n */\nimport isHTMLInputElement from './is-html-input-element';\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {Node} node The HTML element.\n * @return {node is HTMLElement} True if the element is an text field, false if not.\n */\nexport default function isTextField( node ) {\n\tconst nonTextInputs = [\n\t\t'button',\n\t\t'checkbox',\n\t\t'hidden',\n\t\t'file',\n\t\t'radio',\n\t\t'image',\n\t\t'range',\n\t\t'reset',\n\t\t'submit',\n\t\t'number',\n\t\t'email',\n\t\t'time',\n\t];\n\treturn (\n\t\t( isHTMLInputElement( node ) &&\n\t\t\tnode.type &&\n\t\t\t! nonTextInputs.includes( node.type ) ) ||\n\t\tnode.nodeName === 'TEXTAREA' ||\n\t\t/** @type {HTMLElement} */ ( node ).contentEditable === 'true'\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport isTextField from './is-text-field';\nimport isHTMLInputElement from './is-html-input-element';\n\n/**\n * Check whether the given input field or textarea contains a (uncollapsed)\n * selection of text.\n *\n * CAVEAT: Only specific text-based HTML inputs support the selection APIs\n * needed to determine whether they have a collapsed or uncollapsed selection.\n * This function defaults to returning `true` when the selection cannot be\n * inspected, such as with `<input type=\"time\">`. The rationale is that this\n * should cause the block editor to defer to the browser's native selection\n * handling (e.g. copying and pasting), thereby reducing friction for the user.\n *\n * See: https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n *\n * @param {Element} element The HTML element.\n *\n * @return {boolean} Whether the input/textarea element has some \"selection\".\n */\nexport default function inputFieldHasUncollapsedSelection( element ) {\n\tif ( ! isHTMLInputElement( element ) && ! isTextField( element ) ) {\n\t\treturn false;\n\t}\n\n\t// Safari throws a type error when trying to get `selectionStart` and\n\t// `selectionEnd` on non-text <input> elements, so a try/catch construct is\n\t// necessary.\n\ttry {\n\t\tconst { selectionStart, selectionEnd } =\n\t\t\t/** @type {HTMLInputElement | HTMLTextAreaElement} */ ( element );\n\t\treturn (\n\t\t\t// `null` means the input type doesn't implement selection, thus we\n\t\t\t// cannot determine whether the selection is collapsed, so we\n\t\t\t// default to true.\n\t\t\tselectionStart === null ||\n\t\t\t// when not null, compare the two points\n\t\t\tselectionStart !== selectionEnd\n\t\t);\n\t} catch ( error ) {\n\t\t// This is Safari's way of saying that the input type doesn't implement\n\t\t// selection, so we default to true.\n\t\treturn true;\n\t}\n}\n", "/**\n * Internal dependencies\n */\nimport documentHasTextSelection from './document-has-text-selection';\nimport inputFieldHasUncollapsedSelection from './input-field-has-uncollapsed-selection';\n\n/**\n * Check whether the current document has any sort of (uncollapsed) selection.\n * This includes ranges of text across elements and any selection inside\n * textual `<input>` and `<textarea>` elements.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} Whether there is any recognizable text selection in the document.\n */\nexport default function documentHasUncollapsedSelection( doc ) {\n\treturn (\n\t\tdocumentHasTextSelection( doc ) ||\n\t\t( !! doc.activeElement &&\n\t\t\tinputFieldHasUncollapsedSelection( doc.activeElement ) )\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport isTextField from './is-text-field';\nimport isHTMLInputElement from './is-html-input-element';\nimport documentHasTextSelection from './document-has-text-selection';\n\n/**\n * Check whether the current document has a selection. This includes focus in\n * input fields, textareas, and general rich-text selection.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport default function documentHasSelection( doc ) {\n\treturn (\n\t\t!! doc.activeElement &&\n\t\t( isHTMLInputElement( doc.activeElement ) ||\n\t\t\tisTextField( doc.activeElement ) ||\n\t\t\tdocumentHasTextSelection( doc ) )\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * @param {Element} element\n * @return {ReturnType<Window['getComputedStyle']>} The computed style for the element.\n */\nexport default function getComputedStyle( element ) {\n\tassertIsDefined(\n\t\telement.ownerDocument.defaultView,\n\t\t'element.ownerDocument.defaultView'\n\t);\n\treturn element.ownerDocument.defaultView.getComputedStyle( element );\n}\n", "/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Given a DOM node, finds the closest scrollable container node or the node\n * itself, if scrollable.\n *\n * @param {Element | null} node      Node from which to start.\n * @param {?string}        direction Direction of scrollable container to search for ('vertical', 'horizontal', 'all').\n *                                   Defaults to 'vertical'.\n * @return {Element | undefined} Scrollable container node, if found.\n */\nexport default function getScrollContainer( node, direction = 'vertical' ) {\n\tif ( ! node ) {\n\t\treturn undefined;\n\t}\n\n\tif ( direction === 'vertical' || direction === 'all' ) {\n\t\t// Scrollable if scrollable height exceeds displayed...\n\t\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t\t// ...except when overflow is defined to be hidden or visible\n\t\t\tconst { overflowY } = getComputedStyle( node );\n\n\t\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( direction === 'horizontal' || direction === 'all' ) {\n\t\t// Scrollable if scrollable width exceeds displayed...\n\t\tif ( node.scrollWidth > node.clientWidth ) {\n\t\t\t// ...except when overflow is defined to be hidden or visible\n\t\t\tconst { overflowX } = getComputedStyle( node );\n\n\t\t\tif ( /(auto|scroll)/.test( overflowX ) ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( node.ownerDocument === node.parentNode ) {\n\t\treturn node;\n\t}\n\n\t// Continue traversing.\n\treturn getScrollContainer(\n\t\t/** @type {Element} */ ( node.parentNode ),\n\t\tdirection\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {Node | null} Offset parent.\n */\nexport default function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = /** @type {Node} */ ( node.parentNode ) ) ) {\n\t\tif ( closestElement.nodeType === closestElement.ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif (\n\t\tgetComputedStyle( /** @type {Element} */ ( closestElement ) )\n\t\t\t.position !== 'static'\n\t) {\n\t\treturn closestElement;\n\t}\n\n\t// offsetParent is undocumented/draft.\n\treturn /** @type {Node & { offsetParent: Node }} */ ( closestElement )\n\t\t.offsetParent;\n}\n", "/**\n * @param {Element} element\n * @return {element is HTMLInputElement | HTMLTextAreaElement} Whether the element is an input or textarea\n */\nexport default function isInputOrTextArea( element ) {\n\treturn element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {HTMLElement} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport default function isEntirelySelected( element ) {\n\tif ( isInputOrTextArea( element ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tassertIsDefined( lastChild, 'lastChild' );\n\tconst endContainerContentLength =\n\t\tendContainer.nodeType === endContainer.TEXT_NODE\n\t\t\t? /** @type {Text} */ ( endContainer ).data.length\n\t\t\t: endContainer.childNodes.length;\n\n\treturn (\n\t\tisDeepChild( startContainer, element, 'firstChild' ) &&\n\t\tisDeepChild( endContainer, element, 'lastChild' ) &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === endContainerContentLength\n\t);\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {HTMLElement|Node}         query     The element to check.\n * @param {HTMLElement}              container The container that we suspect \"query\" may be a first or last child of.\n * @param {\"firstChild\"|\"lastChild\"} propName  \"firstChild\" or \"lastChild\"\n *\n * @return {boolean} True if query is a deep first/last child of container, false otherwise.\n */\nfunction isDeepChild( query, container, propName ) {\n\t/** @type {HTMLElement | ChildNode | null} */\n\tlet candidate = container;\n\tdo {\n\t\tif ( query === candidate ) {\n\t\t\treturn true;\n\t\t}\n\t\tcandidate = candidate[ propName ];\n\t} while ( candidate );\n\treturn false;\n}\n", "/**\n * Internal dependencies\n */\nimport isInputOrTextArea from './is-input-or-text-area';\n\n/**\n *\n * Detects if element is a form element.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if form element and false otherwise.\n */\nexport default function isFormElement( element ) {\n\tif ( ! element ) {\n\t\treturn false;\n\t}\n\n\tconst { tagName } = element;\n\tconst checkForInputTextarea = isInputOrTextArea( element );\n\treturn (\n\t\tcheckForInputTextarea || tagName === 'BUTTON' || tagName === 'SELECT'\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Whether the element's text direction is right-to-left.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if rtl, false if ltr.\n */\nexport default function isRTL( element ) {\n\treturn getComputedStyle( element ).direction === 'rtl';\n}\n", "/**\n * Gets the height of the range without ignoring zero width rectangles, which\n * some browsers ignore when creating a union.\n *\n * @param {Range} range The range to check.\n * @return {number | undefined} Height of the range or undefined if the range has no client rectangles.\n */\nexport default function getRangeHeight( range ) {\n\tconst rects = Array.from( range.getClientRects() );\n\n\tif ( ! rects.length ) {\n\t\treturn;\n\t}\n\n\tconst highestTop = Math.min( ...rects.map( ( { top } ) => top ) );\n\tconst lowestBottom = Math.max( ...rects.map( ( { bottom } ) => bottom ) );\n\n\treturn lowestBottom - highestTop;\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nexport default function isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tassertIsDefined( anchorNode, 'anchorNode' );\n\tassertIsDefined( focusNode, 'focusNode' );\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & anchorNode.DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & anchorNode.DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n", "/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {DocumentMaybeWithCaretPositionFromPoint} doc The document of the range.\n * @param {number}                                  x   Horizontal position within the current viewport.\n * @param {number}                                  y   Vertical position within the current viewport.\n *\n * @return {Range | null} The best range for the given point.\n */\nexport default function caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * @typedef {{caretPositionFromPoint?: (x: number, y: number)=> CaretPosition | null} & Document } DocumentMaybeWithCaretPositionFromPoint\n * @typedef {{ readonly offset: number; readonly offsetNode: Node; getClientRect(): DOMRect | null; }} CaretPosition\n */\n", "/**\n * Internal dependencies\n */\nimport caretRangeFromPoint from './caret-range-from-point';\nimport getComputedStyle from './get-computed-style';\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document}    doc       The document of the range.\n * @param {number}      x         Horizontal position within the current viewport.\n * @param {number}      y         Vertical position within the current viewport.\n * @param {HTMLElement} container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nexport default function hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\tconst { position = 'static' } = getComputedStyle( container );\n\n\t// A z-index only works if the element position is not static.\n\tif ( position === 'static' ) {\n\t\tcontainer.style.position = 'relative';\n\t}\n\n\tcontainer.style.zIndex = '10000';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n", "/**\n * If no range range can be created or it is outside the container, the element\n * may be out of view, so scroll it into view and try again.\n *\n * @param {HTMLElement} container  The container to scroll.\n * @param {boolean}     alignToTop True to align to top, false to bottom.\n * @param {Function}    callback   The callback to create the range.\n *\n * @return {?Range} The range returned by the callback.\n */\nexport function scrollIfNoRange( container, alignToTop, callback ) {\n\tlet range = callback();\n\n\t// If no range range can be created or it is outside the container, the\n\t// element may be out of view.\n\tif (\n\t\t! range ||\n\t\t! range.startContainer ||\n\t\t! container.contains( range.startContainer )\n\t) {\n\t\tcontainer.scrollIntoView( alignToTop );\n\t\trange = callback();\n\n\t\tif (\n\t\t\t! range ||\n\t\t\t! range.startContainer ||\n\t\t\t! container.contains( range.startContainer )\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn range;\n}\n", "/**\n * Internal dependencies\n */\nimport isRTL from './is-rtl';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\nimport { scrollIfNoRange } from './scroll-if-no-range';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {HTMLElement} container            Focusable element.\n * @param {boolean}     isReverse            Set to true to check left, false to check right.\n * @param {boolean}     [onlyVertical=false] Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical = false ) {\n\tif (\n\t\tisInputOrTextArea( container ) &&\n\t\ttypeof container.selectionStart === 'number'\n\t) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection || ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tconst rangeHeight = getRangeHeight( range );\n\tif (\n\t\t! isCollapsed &&\n\t\trangeHeight &&\n\t\trangeHeight > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = scrollIfNoRange( container, isReverse, () =>\n\t\thiddenCaretRangeFromPoint( ownerDocument, x, y, container )\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n", "/**\n * Internal dependencies\n */\nimport isEdge from './is-edge';\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport default function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n", "/**\n * WordPress dependencies\n */\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport isHTMLInputElement from './is-html-input-element';\n\n/**\n * Check whether the given element is an input field of type number.\n *\n * @param {Node} node The HTML node.\n *\n * @return {node is HTMLInputElement} True if the node is number input.\n */\nexport default function isNumberInput( node ) {\n\tdeprecated( 'wp.dom.isNumberInput', {\n\t\tsince: '6.1',\n\t\tversion: '6.5',\n\t} );\n\treturn (\n\t\tisHTMLInputElement( node ) &&\n\t\tnode.type === 'number' &&\n\t\t! isNaN( node.valueAsNumber )\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport isEdge from './is-edge';\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport default function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n", "/**\n * Internal dependencies\n */\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\nimport isRTL from './is-rtl';\nimport { scrollIfNoRange } from './scroll-if-no-range';\n\n/**\n * Gets the range to place.\n *\n * @param {HTMLElement}      container Focusable element.\n * @param {boolean}          isReverse True for end, false for start.\n * @param {number|undefined} x         X coordinate to vertically position.\n *\n * @return {Range|null} The range to place.\n */\nfunction getRange( container, isReverse, x ) {\n\tconst { ownerDocument } = container;\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\t// When placing at the end (isReverse), find the closest range to the bottom\n\t// right corner. When placing at the start, to the top left corner.\n\t// Ensure x is defined and within the container's boundaries. When it's\n\t// exactly at the boundary, it's not considered within the boundaries.\n\tif ( x === undefined ) {\n\t\tx = isReverse ? containerRect.right - 1 : containerRect.left + 1;\n\t} else if ( x <= containerRect.left ) {\n\t\tx = containerRect.left + 1;\n\t} else if ( x >= containerRect.right ) {\n\t\tx = containerRect.right - 1;\n\t}\n\tconst y = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;\n\treturn hiddenCaretRangeFromPoint( ownerDocument, x, y, container );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {HTMLElement}      container Focusable element.\n * @param {boolean}          isReverse True for end, false for start.\n * @param {number|undefined} x         X coordinate to vertically position.\n */\nexport default function placeCaretAtEdge( container, isReverse, x ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( isInputOrTextArea( container ) ) {\n\t\t// The element may not support selection setting.\n\t\tif ( typeof container.selectionStart !== 'number' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\tconst range = scrollIfNoRange( container, isReverse, () =>\n\t\tgetRange( container, isReverse, x )\n\t);\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\tassertIsDefined( selection, 'selection' );\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n", "/**\n * Internal dependencies\n */\nimport placeCaretAtEdge from './place-caret-at-edge';\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse True for end, false for start.\n */\nexport default function placeCaretAtHorizontalEdge( container, isReverse ) {\n\treturn placeCaretAtEdge( container, isReverse, undefined );\n}\n", "/**\n * Internal dependencies\n */\nimport placeCaretAtEdge from './place-caret-at-edge';\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {HTMLElement} container Focusable element.\n * @param {boolean}     isReverse True for bottom, false for top.\n * @param {DOMRect}     [rect]    The rectangle to position the caret with.\n */\nexport default function placeCaretAtVerticalEdge( container, isReverse, rect ) {\n\treturn placeCaretAtEdge( container, isReverse, rect?.left );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Node} newNode       Node to be inserted.\n * @param {Node} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport default function insertAfter( newNode, referenceNode ) {\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Node} node Node to be removed.\n * @return {void}\n */\nexport default function remove( node ) {\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\n\tnode.parentNode.removeChild( node );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport insertAfter from './insert-after';\nimport remove from './remove';\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport default function replace( processedNode, newNode ) {\n\tassertIsDefined( processedNode.parentNode, 'processedNode.parentNode' );\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport default function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\tassertIsDefined( parent, 'node.parentNode' );\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element} node    The node to replace\n * @param {string}  tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport default function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n", "/**\n * Internal dependencies\n */\nimport { assertIsDefined } from '../utils/assert-is-defined';\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport default function wrap( newNode, referenceNode ) {\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n", "/**\n * Internal dependencies\n */\nimport remove from './remove';\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function safeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn body.innerHTML;\n}\n", "/**\n * Internal dependencies\n */\nimport safeHTML from './safe-html';\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport default function stripHTML( html ) {\n\t// Remove any script tags or on* attributes otherwise their *contents* will be left\n\t// in place following removal of HTML tags.\n\thtml = safeHTML( html );\n\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\tdoc.body.innerHTML = html;\n\treturn doc.body.textContent || '';\n}\n", "/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Whether or not the element is empty.\n */\nexport default function isEmpty( element ) {\n\tswitch ( element.nodeType ) {\n\t\tcase element.TEXT_NODE:\n\t\t\t// We cannot use \\s since it includes special spaces which we want\n\t\t\t// to preserve.\n\t\t\treturn /^[ \\f\\n\\r\\t\\v\\u00a0]*$/.test( element.nodeValue || '' );\n\t\tcase element.ELEMENT_NODE:\n\t\t\tif ( element.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t} else if ( ! element.hasChildNodes() ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn /** @type {Element[]} */ (\n\t\t\t\tArray.from( element.childNodes )\n\t\t\t).every( isEmpty );\n\t\tdefault:\n\t\t\treturn true;\n\t}\n}\n", "/**\n * All phrasing content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\n */\n\n/**\n * @typedef {Record<string,SemanticElementDefinition>} ContentSchema\n */\n\n/**\n * @typedef SemanticElementDefinition\n * @property {string[]}          [attributes] Content attributes\n * @property {ContentSchema|'*'} [children]   Content attributes\n */\n\n/**\n * All text-level semantic elements.\n *\n * @see https://html.spec.whatwg.org/multipage/text-level-semantics.html\n *\n * @type {ContentSchema}\n */\nconst textContentSchema = {\n\tstrong: {},\n\tem: {},\n\ts: {},\n\tdel: {},\n\tins: {},\n\ta: { attributes: [ 'href', 'target', 'rel', 'id' ] },\n\tcode: {},\n\tabbr: { attributes: [ 'title' ] },\n\tsub: {},\n\tsup: {},\n\tbr: {},\n\tsmall: {},\n\t// To do: fix blockquote.\n\t// cite: {},\n\tq: { attributes: [ 'cite' ] },\n\tdfn: { attributes: [ 'title' ] },\n\tdata: { attributes: [ 'value' ] },\n\ttime: { attributes: [ 'datetime' ] },\n\tvar: {},\n\tsamp: {},\n\tkbd: {},\n\ti: {},\n\tb: {},\n\tu: {},\n\tmark: {},\n\truby: {},\n\trt: {},\n\trp: {},\n\tbdi: { attributes: [ 'dir' ] },\n\tbdo: { attributes: [ 'dir' ] },\n\twbr: {},\n\t'#text': {},\n};\n\n// Recursion is needed.\n// Possible: strong > em > strong.\n// Impossible: strong > strong.\nconst excludedElements = [ '#text', 'br' ];\nObject.keys( textContentSchema )\n\t.filter( ( element ) => ! excludedElements.includes( element ) )\n\t.forEach( ( tag ) => {\n\t\tconst { [ tag ]: removedTag, ...restSchema } = textContentSchema;\n\t\ttextContentSchema[ tag ].children = restSchema;\n\t} );\n\n/**\n * Embedded content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#embedded-content-0\n *\n * @type {ContentSchema}\n */\nconst embeddedContentSchema = {\n\taudio: {\n\t\tattributes: [\n\t\t\t'src',\n\t\t\t'preload',\n\t\t\t'autoplay',\n\t\t\t'mediagroup',\n\t\t\t'loop',\n\t\t\t'muted',\n\t\t],\n\t},\n\tcanvas: { attributes: [ 'width', 'height' ] },\n\tembed: { attributes: [ 'src', 'type', 'width', 'height' ] },\n\timg: {\n\t\tattributes: [\n\t\t\t'alt',\n\t\t\t'src',\n\t\t\t'srcset',\n\t\t\t'usemap',\n\t\t\t'ismap',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n\tobject: {\n\t\tattributes: [\n\t\t\t'data',\n\t\t\t'type',\n\t\t\t'name',\n\t\t\t'usemap',\n\t\t\t'form',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n\tvideo: {\n\t\tattributes: [\n\t\t\t'src',\n\t\t\t'poster',\n\t\t\t'preload',\n\t\t\t'playsinline',\n\t\t\t'autoplay',\n\t\t\t'mediagroup',\n\t\t\t'loop',\n\t\t\t'muted',\n\t\t\t'controls',\n\t\t\t'width',\n\t\t\t'height',\n\t\t],\n\t},\n\tmath: {\n\t\tattributes: [ 'display', 'xmlns' ],\n\t\tchildren: '*',\n\t},\n};\n\n/**\n * Phrasing content elements.\n *\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\n */\nconst phrasingContentSchema = {\n\t...textContentSchema,\n\t...embeddedContentSchema,\n};\n\n/**\n * Get schema of possible paths for phrasing content.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n *\n * @param {string} [context] Set to \"paste\" to exclude invisible elements and\n *                           sensitive data.\n *\n * @return {Partial<ContentSchema>} Schema.\n */\nexport function getPhrasingContentSchema( context ) {\n\tif ( context !== 'paste' ) {\n\t\treturn phrasingContentSchema;\n\t}\n\n\t/**\n\t * @type {Partial<ContentSchema>}\n\t */\n\tconst {\n\t\tu, // Used to mark misspelling. Shouldn't be pasted.\n\t\tabbr, // Invisible.\n\t\tdata, // Invisible.\n\t\ttime, // Invisible.\n\t\twbr, // Invisible.\n\t\tbdi, // Invisible.\n\t\tbdo, // Invisible.\n\t\t...remainingContentSchema\n\t} = {\n\t\t...phrasingContentSchema,\n\t\t// We shouldn't paste potentially sensitive information which is not\n\t\t// visible to the user when pasted, so strip the attributes.\n\t\tins: { children: phrasingContentSchema.ins.children },\n\t\tdel: { children: phrasingContentSchema.del.children },\n\t};\n\n\treturn remainingContentSchema;\n}\n\n/**\n * Find out whether or not the given node is phrasing content.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n *\n * @param {Node} node The node to test.\n *\n * @return {boolean} True if phrasing content, false if not.\n */\nexport function isPhrasingContent( node ) {\n\tconst tag = node.nodeName.toLowerCase();\n\treturn getPhrasingContentSchema().hasOwnProperty( tag ) || tag === 'span';\n}\n\n/**\n * @param {Node} node\n * @return {boolean} Node is text content\n */\nexport function isTextContent( node ) {\n\tconst tag = node.nodeName.toLowerCase();\n\treturn textContentSchema.hasOwnProperty( tag ) || tag === 'span';\n}\n", "/**\n * @param {Node | null | undefined} node\n * @return {node is Element} True if node is an Element node\n */\nexport default function isElement( node ) {\n\treturn !! node && node.nodeType === node.ELEMENT_NODE;\n}\n", "/**\n * Internal dependencies\n */\nimport isEmpty from './is-empty';\nimport remove from './remove';\nimport unwrap from './unwrap';\nimport { isPhrasingContent } from '../phrasing-content';\nimport insertAfter from './insert-after';\nimport isElement from './is-element';\n\nconst noop = () => {};\n\n/**\n * @typedef SchemaItem\n * @property {string[]}                            [attributes] Attributes.\n * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.\n * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.\n * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.\n * @property {boolean}                             allowEmpty   Whether to allow nodes without children.\n * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.\n */\n\n/** @typedef {{ [tag: string]: SchemaItem }} Schema */\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Schema}   schema   An array of functions that can mutate with the provided node.\n * @param {boolean}  inline   Whether to clean for inline mode.\n */\nexport default function cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach(\n\t\t( /** @type {Node & { nextElementSibling?: unknown }} */ node ) => {\n\t\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t\t// function, or with an isMatch function that matches the node.\n\t\t\tif (\n\t\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch?.( node ) )\n\t\t\t) {\n\t\t\t\tif ( isElement( node ) ) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tattributes = [],\n\t\t\t\t\t\tclasses = [],\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\trequire = [],\n\t\t\t\t\t\tallowEmpty,\n\t\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t\t// remove the node.\n\t\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\t\tremove( node );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t\t! attributes.includes( name )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\t\tif ( item === '*' ) {\n\t\t\t\t\t\t\t\t\t// Keep all classes.\n\t\t\t\t\t\t\t\t\treturn () => true;\n\t\t\t\t\t\t\t\t} else if ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => className === item;\n\t\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => item.test( className );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tnode.parentNode &&\n\t\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t\t( child ) =>\n\t\t\t\t\t\t\t\t\t\t\t! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t\t} else {\n\t\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t\t// are not phrasing content.\n\t\t\t\tif (\n\t\t\t\t\tinline &&\n\t\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\t\tnode.nextElementSibling\n\t\t\t\t) {\n\t\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t\t}\n\n\t\t\t\tunwrap( node );\n\t\t\t}\n\t\t}\n\t);\n}\n", "/**\n * Internal dependencies\n */\nimport cleanNodeList from './clean-node-list';\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string}                             HTML   The HTML to clean up.\n * @param {import('./clean-node-list').Schema} schema Schema for the HTML.\n * @param {boolean}                            inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport default function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n", "/**\n * Gets all files from a DataTransfer object.\n *\n * @param {DataTransfer} dataTransfer DataTransfer object to inspect.\n *\n * @return {File[]} An array containing all files.\n */\nexport function getFilesFromDataTransfer( dataTransfer ) {\n\tconst files = Array.from( dataTransfer.files );\n\n\tArray.from( dataTransfer.items ).forEach( ( item ) => {\n\t\tconst file = item.getAsFile();\n\n\t\tif (\n\t\t\tfile &&\n\t\t\t! files.find(\n\t\t\t\t( { name, type, size } ) =>\n\t\t\t\t\tname === file.name &&\n\t\t\t\t\ttype === file.type &&\n\t\t\t\t\tsize === file.size\n\t\t\t)\n\t\t) {\n\t\t\tfiles.push( file );\n\t\t}\n\t} );\n\n\treturn files;\n}\n", "/**\n * Internal dependencies\n */\nimport * as focusable from './focusable';\nimport * as tabbable from './tabbable';\n\n/**\n * Object grouping `focusable` and `tabbable` utils\n * under the keys with the same name.\n */\nexport const focus = { focusable, tabbable };\n\nexport * from './dom';\nexport * from './phrasing-content';\nexport * from './data-transfer';\n"],
  "mappings": "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",
  "names": ["require_deprecated", "__commonJSMin", "exports", "module", "buildSelector", "sequential", "isVisible", "element", "isValidFocusableArea", "map", "img", "find", "context", "elements", "nodeName", "getTabIndex", "element", "tabIndex", "isTabbableIndex", "createStatefulCollapseRadioGroup", "CHOSEN_RADIO_BY_NAME", "result", "nodeName", "type", "checked", "name", "hasChosen", "hadChosenElement", "e", "mapElementToObjectTabbable", "index", "mapObjectTabbableToElement", "object", "compareObjectTabbables", "a", "b", "aTabIndex", "bTabIndex", "filterTabbable", "focusables", "find", "context", "findPrevious", "focusable", "findNext", "getRectangleFromRange", "range", "rects", "filteredRects", "width", "furthestTop", "furthestBottom", "furthestLeft", "furthestRight", "top", "bottom", "left", "right", "startContainer", "ownerDocument", "parentNode", "index", "rect", "padNode", "computeCaretRect", "win", "selection", "range", "getRectangleFromRange", "documentHasTextSelection", "doc", "selection", "range", "isHTMLInputElement", "node", "isTextField", "node", "nonTextInputs", "isHTMLInputElement", "inputFieldHasUncollapsedSelection", "element", "isHTMLInputElement", "isTextField", "selectionStart", "selectionEnd", "documentHasUncollapsedSelection", "doc", "documentHasTextSelection", "inputFieldHasUncollapsedSelection", "documentHasSelection", "doc", "isHTMLInputElement", "isTextField", "documentHasTextSelection", "getComputedStyle", "element", "getScrollContainer", "node", "direction", "overflowY", "getComputedStyle", "overflowX", "getOffsetParent", "node", "closestElement", "getComputedStyle", "isInputOrTextArea", "element", "isEntirelySelected", "element", "isInputOrTextArea", "ownerDocument", "defaultView", "selection", "range", "startContainer", "endContainer", "startOffset", "endOffset", "lastChild", "endContainerContentLength", "isDeepChild", "query", "container", "propName", "candidate", "isFormElement", "element", "tagName", "isInputOrTextArea", "isRTL", "element", "getComputedStyle", "getRangeHeight", "range", "rects", "highestTop", "top", "bottom", "isSelectionForward", "selection", "anchorNode", "focusNode", "anchorOffset", "focusOffset", "position", "caretRangeFromPoint", "doc", "x", "y", "point", "range", "hiddenCaretRangeFromPoint", "doc", "x", "y", "container", "originalZIndex", "originalPosition", "position", "getComputedStyle", "range", "caretRangeFromPoint", "scrollIfNoRange", "container", "alignToTop", "callback", "range", "isEdge", "container", "isReverse", "onlyVertical", "isInputOrTextArea", "ownerDocument", "defaultView", "selection", "range", "collapsedRange", "isForward", "isSelectionForward", "isCollapsed", "collapsedRangeRect", "getRectangleFromRange", "rangeRect", "rangeHeight", "getRangeHeight", "isReverseDir", "isRTL", "containerRect", "x", "y", "testRange", "scrollIfNoRange", "hiddenCaretRangeFromPoint", "testRect", "verticalSide", "horizontalSide", "verticalDiff", "horizontalDiff", "hasVerticalDiff", "hasHorizontalDiff", "isHorizontalEdge", "container", "isReverse", "isEdge", "import_deprecated", "isNumberInput", "node", "deprecated", "isHTMLInputElement", "isVerticalEdge", "container", "isReverse", "isEdge", "getRange", "container", "isReverse", "x", "ownerDocument", "isReverseDir", "isRTL", "containerRect", "y", "hiddenCaretRangeFromPoint", "placeCaretAtEdge", "isInputOrTextArea", "range", "scrollIfNoRange", "defaultView", "selection", "placeCaretAtHorizontalEdge", "container", "isReverse", "placeCaretAtEdge", "placeCaretAtVerticalEdge", "container", "isReverse", "rect", "placeCaretAtEdge", "insertAfter", "newNode", "referenceNode", "remove", "node", "replace", "processedNode", "newNode", "insertAfter", "remove", "unwrap", "node", "parent", "replaceTag", "node", "tagName", "newNode", "wrap", "newNode", "referenceNode", "safeHTML", "html", "body", "elements", "elementIndex", "element", "remove", "attributeIndex", "key", "stripHTML", "html", "safeHTML", "doc", "isEmpty", "element", "textContentSchema", "excludedElements", "element", "tag", "removedTag", "restSchema", "embeddedContentSchema", "phrasingContentSchema", "getPhrasingContentSchema", "context", "u", "abbr", "data", "time", "wbr", "bdi", "bdo", "remainingContentSchema", "isPhrasingContent", "node", "isTextContent", "isElement", "node", "noop", "cleanNodeList", "nodeList", "doc", "schema", "inline", "node", "tag", "isElement", "attributes", "classes", "children", "require", "allowEmpty", "isEmpty", "remove", "name", "mattchers", "item", "className", "isMatch", "unwrap", "isPhrasingContent", "child", "insertAfter", "removeInvalidHTML", "HTML", "schema", "inline", "doc", "cleanNodeList", "getFilesFromDataTransfer", "dataTransfer", "files", "item", "file", "name", "type", "size", "focus", "focusable_exports", "tabbable_exports"]
}
