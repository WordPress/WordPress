name: Build & Deploy WordPress to ASG (OIDC)

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  S3_BUCKET: amir-app
  S3_PREFIX: builds
  APP_DIR: /var/www/html/wordpress
  INSTANCE_TAG_KEY: Role
  INSTANCE_TAG_VALUE: wp-app

jobs:
  build_upload_deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set build date + tar name
        id: vars
        run: |
          BUILD_DATE=$(date +%F)
          TAR_NAME="app_${BUILD_DATE}.tar.gz"
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "tar_name=$TAR_NAME" >> $GITHUB_OUTPUT

      - name: Create tar.gz package
        run: |
          TAR="${{ steps.vars.outputs.tar_name }}"
          tar -czf "/tmp/${TAR}" .
          mv "/tmp/${TAR}" "${TAR}"

      - name: Configure AWS credentials via OIDC (AssumeRole)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::753675398055:role/amir-github-actions-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload artifact to S3
        run: |
          # tar -tf "${{ steps.vars.outputs.tar_name }}"
          aws s3 cp "${{ steps.vars.outputs.tar_name }}" \
            "s3://${{ env.S3_BUCKET }}/${{ env.S3_PREFIX }}/${{ steps.vars.outputs.tar_name }}"
      
      - name: Ensure S3 lifecycle expiry (7 days)
        run: |
          cat > lifecycle.json << 'EOF'
          {
            "Rules": [
              {
                "ID": "expire-builds-7-days",
                "Status": "Enabled",
                "Filter": { "Prefix": "builds/" },
                "Expiration": { "Days": 7 }
              }
            ]
          }
          EOF

          aws s3api put-bucket-lifecycle-configuration \
            --bucket "${{ env.S3_BUCKET }}" \
            --lifecycle-configuration file://lifecycle.json

      - uses: actions/upload-artifact@v4
        with:
          name: app-artifact
          path: ${{ steps.vars.outputs.tar_name }}
          
      - name: Discover app instance IDs (1 or 2)
        id: discover
        run: |
          IDS=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:${{ env.INSTANCE_TAG_KEY }},Values=${{ env.INSTANCE_TAG_VALUE }}" \
              "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)

          if [ -z "$IDS" ]; then
            echo "No running instances found with tag ${{ env.INSTANCE_TAG_KEY }}=${{ env.INSTANCE_TAG_VALUE }}"
            exit 1
          fi

          echo "Found instance IDs: $IDS"

          # Convert space-separated to comma-separated for SSM --instance-ids
          IDS_CSV=$(echo "$IDS" | tr ' ' ',')
          echo "instance_ids_csv=$IDS_CSV" >> $GITHUB_OUTPUT
          echo "instance_ids_space=$IDS" >> $GITHUB_OUTPUT

      - name: Deploy to discovered instances via SSM (bash script)
        id: deploy
        run: |
          TAR="${{ steps.vars.outputs.tar_name }}"
          S3URI="s3://${{ env.S3_BUCKET }}/${{ env.S3_PREFIX }}/${TAR}"
          TARGETS_CSV="${{ steps.discover.outputs.instance_ids_csv }}"
          APP_DIR="${{ env.APP_DIR }}"
      
          cat > deploy.sh <<'EOS'
          #!/usr/bin/env bash
          set -euxo pipefail
      
          WORK=/tmp/wp_deploy
          EXTRACT=/tmp/wp_deploy/extracted
      
          sudo mkdir -p "$WORK"
          sudo rm -rf "$EXTRACT"
          sudo mkdir -p "$EXTRACT"
      
          aws s3 cp "__S3URI__" "$WORK/__TAR__"
      
          echo "== TAR CONTENTS (first 30) =="
          sudo tar -tzf "$WORK/__TAR__" | head -n 30
      
          echo "== EXTRACTING =="
          sudo tar --no-same-owner --no-same-permissions -xzf "$WORK/__TAR__" -C "$EXTRACT"
      
          SRC="$EXTRACT"
          if [ ! -d "$SRC/wp-admin" ] || [ ! -d "$SRC/wp-includes" ]; then
            CAND="$(find "$EXTRACT" -maxdepth 4 -type d -name wp-admin | head -n 1 || true)"
            if [ -n "$CAND" ]; then SRC="$(dirname "$CAND")"; fi
          fi
      
          echo "Using source directory: $SRC"
      
          sudo mkdir -p "__APP_DIR__"
          sudo rsync -a --delete "$SRC/" "__APP_DIR__/"
      
          sudo chown -R www-data:www-data "__APP_DIR__" || true
          sudo systemctl restart php8.1-fpm || true
          sudo systemctl restart nginx || true
      
          ls -la "__APP_DIR__" | head -n 30
          test -d "__APP_DIR__/wp-admin" && test -d "__APP_DIR__/wp-includes"
          EOS
      
          sed -i "s|__S3URI__|$S3URI|g" deploy.sh
          sed -i "s|__TAR__|$TAR|g" deploy.sh
          sed -i "s|__APP_DIR__|$APP_DIR|g" deploy.sh
      
          # Encode deploy.sh as JSON string
          SCRIPT_JSON=$(python3 - <<'PY'
          import json
          print(json.dumps(open("deploy.sh").read()))
          PY
          )
      
          # SSM: write script to file then run with bash
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "$TARGETS_CSV" \
            --comment "Deploy WordPress build from GitHub Actions" \
            --parameters "{\"commands\":[
              \"cat > /tmp/deploy_wp.sh <<'EOF'\\n\"$SCRIPT_JSON\"\\nEOF\",
              \"chmod +x /tmp/deploy_wp.sh\",
              \"/bin/bash /tmp/deploy_wp.sh\"
            ]}" \
            --query "Command.CommandId" --output text)
      
          echo "ssm_command_id=$CMD_ID" >> $GITHUB_OUTPUT
          echo "SSM CommandId: $CMD_ID"


      - name: Wait for Deploy command to finish
        if: always()
        continue-on-error: true
        run: |
          CMD_ID="${{ steps.deploy.outputs.ssm_command_id }}"
          echo "Waiting for SSM command: $CMD_ID"
          for INSTANCE_ID in ${{ steps.discover.outputs.instance_ids_space }}; do
            aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          done
      
      - name: Show SSM Deploy command logs
        if: always()
        run: |
          CMD_ID="${{ steps.deploy.outputs.ssm_command_id }}"
          for INSTANCE_ID in ${{ steps.discover.outputs.instance_ids_space }}; do
            echo "===== $INSTANCE_ID ====="
            aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          done
      
      - name: Fail if any instance failed
        run: |
          CMD_ID="${{ steps.deploy.outputs.ssm_command_id }}"
          FAIL=0
          for INSTANCE_ID in ${{ steps.discover.outputs.instance_ids_space }}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query Status --output text)
            echo "$INSTANCE_ID => $STATUS"
            [ "$STATUS" = "Success" ] || FAIL=1
          done
          exit $FAIL
